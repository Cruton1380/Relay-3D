/**
 * @fileoverview Globe Boundary Editor - On-Globe Visual Polygon Editor
 * 
 * Renders boundary editing UI directly on the 3D Cesium globe with draggable pinpoints.
 * Users can add, move, and delete vertices to reshape boundaries in real-time.
 * 
 * Features:
 * - Draggable pinpoint vertices on globe surface
 * - Add vertices by clicking on polygon lines
 * - Delete vertices with right-click
 * - Real-time polygon rendering
 * - Before/after comparison
 * - Impact visualization (affected regions)
 * - Save as new boundary proposal
 * 
 * @version 2.0 - On-Globe Editor
 * @date October 8, 2025
 */

import React, { useState, useEffect, useRef, useCallback } from 'react';
import './GlobeBoundaryEditor.css';

const GlobeBoundaryEditor = ({
  cesiumViewer,
  channel,           // Boundary channel
  proposal = null,   // Existing proposal to edit (or null for new)
  regionName,
  regionType,
  regionCode,
  mode: externalMode = 'single', // External mode control from parent
  onSave,
  onCancel,
  onVerticesChange
}) => {
  // CRITICAL: Log component render
  console.log('🎬 [BOUNDARY EDITOR] Component rendered/re-rendered', {
    regionName,
    regionCode,
    hasViewer: !!cesiumViewer,
    hasChannel: !!channel,
    channelId: channel?.id,
    candidateCount: channel?.candidates?.length,
    hasProposal: !!proposal,
    proposalName: proposal?.name
  });

  // Use global Cesium object (loaded via script tag in index.html)
  const Cesium = window.Cesium;
  
  // State
  const [vertices, setVertices] = useState([]); // Array of {lat, lng, entity, index}
  const [mode, setMode] = useState('view'); // Internal mode: 'view', 'edit', 'add', 'multiple'
  const [originalGeometry, setOriginalGeometry] = useState(null);
  const [showDiff, setShowDiff] = useState(false);
  const [affectedRegions, setAffectedRegions] = useState([]);
  const [description, setDescription] = useState('');
  const [proposalName, setProposalName] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [selectedVertices, setSelectedVertices] = useState([]); // For multi-select
  
  // נ¯ Freeform Selection Tool State
  const [freeformMarkers, setFreeformMarkers] = useState([]); // Array of {lat, lng, entity, id}
  const [selectionPolygon, setSelectionPolygon] = useState(null); // Visual polygon connecting markers
  const [isMultiSelectActive, setIsMultiSelectActive] = useState(false);
  
  // Refs
  const entitiesRef = useRef([]);
  const polygonEntityRef = useRef(null);
  const handlerRef = useRef(null);
  const isDraggingRef = useRef(false);
  const draggedVertexRef = useRef(null);
  const dragStartPositionsRef = useRef(null); // Store original positions at drag start
  const selectedVerticesRef = useRef([]); // CRITICAL: Persist selected vertices across renders
  // נ¯ Refs for freeform selection
  const freeformHandlerRef = useRef(null); // Separate handler for multi-select mode
  const freeformEntitiesRef = useRef([]); // Track freeform marker entities separately
  const freeformMarkerCountRef = useRef(0); // Track count for label numbering

  /**
   * Track mode changes for debugging
   */
  useEffect(() => {
    console.log(`🔄 [MODE CHANGE] Mode is now: "${mode}"`);
  }, [mode]);

  /**
   * Initialize - Load proposal or start new boundary
   */
  useEffect(() => {
    if (!cesiumViewer) {
      console.warn('ג ן¸ [BOUNDARY EDITOR] Cesium viewer not available');
      return;
    }

    if (!Cesium) {
      console.error('ג [BOUNDARY EDITOR] Cesium library not loaded!');
      return;
    }

    console.log('נ—÷ן¸ [BOUNDARY EDITOR] Initializing editor for', regionName);

    if (proposal) {
      loadProposal(proposal);
    } else {
      loadOfficialBoundary();
    }

    return () => {
      cleanup();
    };
  }, [cesiumViewer, proposal, channel]);

  /**
   * Sync external mode from parent with internal mode
   */
  useEffect(() => {
    console.log('נ”„ [BOUNDARY EDITOR] External mode from parent:', externalMode);
    if (externalMode === 'multi' || externalMode === 'multiple') {
      console.log('נ¯ [BOUNDARY EDITOR] Parent requested multiple mode - activating');
      setMode('multiple');
    }
  }, [externalMode]);

  /**
   * Change cursor based on mode
   */
  useEffect(() => {
    if (!cesiumViewer?.canvas) return;
    
    const canvas = cesiumViewer.canvas;
    console.log('🖱️ [CURSOR EFFECT] Running - mode:', mode, 'canvas exists:', !!canvas);
    console.log('🖱️ [CURSOR EFFECT] Current canvas cursor:', canvas.style.cursor);
    
    switch (mode) {
      case 'multiple':
        canvas.style.cursor = 'crosshair';
        console.log('ג… [BOUNDARY EDITOR] Cursor changed to CROSSHAIR for multiple mode');
        break;
      case 'edit':
        canvas.style.cursor = 'pointer';
        break;
      default:
        canvas.style.cursor = 'default';
    }
    
    return () => {
      canvas.style.cursor = 'default';
    };
  }, [mode, cesiumViewer]);

  /**
   * נ¯ FREEFORM MULTI-SELECT TOOL - Completely Independent System
   * Place markers anywhere on globe, connect them with polygon, select vertices inside
   */
  useEffect(() => {
    console.log('🔄 [FREEFORM SELECT] Effect running - mode:', mode, 'cesiumViewer:', !!cesiumViewer, 'Cesium:', !!Cesium);
    
    if (!cesiumViewer || !Cesium) {
      console.log('⚠️ [FREEFORM SELECT] Missing dependencies, skipping');
      return;
    }
    
    const isActive = mode === 'multiple';
    setIsMultiSelectActive(isActive);
    console.log(`🎯 [FREEFORM SELECT] isActive=${isActive}, mode='${mode}', will  handler`);
    
    if (isActive) {
      console.log('נ¯ [FREEFORM SELECT] Activating multi-select tool');
      
      // Destroy main boundary handler if it exists
      if (handlerRef.current) {
        handlerRef.current.destroy();
        handlerRef.current = null;
      }
      
      // Create dedicated handler for freeform selection
      const handler = new Cesium.ScreenSpaceEventHandler(cesiumViewer.scene.canvas);
      freeformHandlerRef.current = handler;
      console.log('✅✅✅ [FREEFORM SELECT] Handler CREATED and stored in ref');
      
      // LEFT CLICK: Place freeform marker anywhere on globe
      handler.setInputAction((click) => {
        // Get globe position (NOT restricted to any grid or boundary)
        const ray = cesiumViewer.camera.getPickRay(click.position);
        const cartesian = cesiumViewer.scene.globe.pick(ray, cesiumViewer.scene);
        
        if (!cartesian) return;
        
        const cartographic = Cesium.Cartographic.fromCartesian(cartesian);
        const lat = Cesium.Math.toDegrees(cartographic.latitude);
        const lng = Cesium.Math.toDegrees(cartographic.longitude);
        
        console.log(`נ“ [FREEFORM SELECT] Placing marker ${freeformMarkerCountRef.current + 1} at: ${lat.toFixed(4)}ֲ°, ${lng.toFixed(4)}ֲ°`);
        console.log(`נ“ [FREEFORM SELECT] Current mode: ${mode}, isMultiSelectActive: ${isActive}`);
        
        // Increment marker count
        freeformMarkerCountRef.current += 1;
        const markerNumber = freeformMarkerCountRef.current;
        
        // Create unique marker ID
        const markerId = `freeform-marker-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        
        // Create visual marker entity (independent of boundary vertices)
        const markerEntity = cesiumViewer.entities.add({
          id: markerId,
          position: Cesium.Cartesian3.fromDegrees(lng, lat, 15000), // 15km altitude for visibility
          point: {
            pixelSize: 16,
            color: Cesium.Color.CYAN,
            outlineColor: Cesium.Color.WHITE,
            outlineWidth: 3,
            heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND,
            disableDepthTestDistance: Number.POSITIVE_INFINITY,
            scaleByDistance: new Cesium.NearFarScalar(1.5e2, 1.2, 8.0e6, 0.6)
          },
          label: {
            text: `נ“ ${markerNumber}`,
            font: '14px sans-serif',
            fillColor: Cesium.Color.CYAN,
            outlineColor: Cesium.Color.BLACK,
            outlineWidth: 2,
            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
            pixelOffset: new Cesium.Cartesian2(0, -25),
            heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND,
            disableDepthTestDistance: Number.POSITIVE_INFINITY,
            scaleByDistance: new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.5)
          },
          properties: new Cesium.PropertyBag({
            type: 'freeform-selection-marker',
            lat: lat,
            lng: lng,
            markerId: markerId
          })
        });
        
        // Add to tracking arrays
        freeformEntitiesRef.current.push(markerEntity);
        
        // Use functional setState to get current value
        setFreeformMarkers(prevMarkers => {
          const newMarkers = [...prevMarkers, { lat, lng, entity: markerEntity, id: markerId }];
          console.log(`נ”„ [FREEFORM] Updated markers state: ${newMarkers.length} markers`, newMarkers);
          
          // Update selection polygon if we have 2+ markers
          if (newMarkers.length >= 2) {
            updateSelectionPolygon(newMarkers);
          }
          
          return newMarkers;
        });
        
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
      
      console.log('ג… [FREEFORM SELECT] Multi-select tool activated');
      
    } else {
      // Clean up when mode changes away from multiple
      if (freeformHandlerRef.current) {
        console.log('נ§¹ [FREEFORM SELECT] Deactivating multi-select tool');
        freeformHandlerRef.current.destroy();
        freeformHandlerRef.current = null;
      }
      
      // Clear markers when switching modes
      clearFreeformSelection();
    }
    
    return () => {
      if (freeformHandlerRef.current) {
        freeformHandlerRef.current.destroy();
        freeformHandlerRef.current = null;
      }
      clearFreeformSelection();
    };
    
  }, [mode, cesiumViewer, Cesium]);

  /**
   * Point-in-Polygon test using ray casting algorithm
   */
  const isPointInPolygon = useCallback((point, polygon) => {
    const x = point.lng;
    const y = point.lat;
    let inside = false;

    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      const xi = polygon[i].lng;
      const yi = polygon[i].lat;
      const xj = polygon[j].lng;
      const yj = polygon[j].lat;

      const intersect = ((yi > y) !== (yj > y)) &&
        (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
      
      if (intersect) inside = !inside;
    }

    return inside;
  }, []);

  /**
   * Finalize selection: Find vertices inside polygon and select them
   */
  const finalizeSelection = useCallback((markers = freeformMarkers) => {
    if (markers.length === 0) {
      console.log('ג ן¸ [FREEFORM SELECT] No markers placed');
      return;
    }
    
    if (markers.length < 3) {
      console.log('ג ן¸ [FREEFORM SELECT] Only', markers.length, 'markers - need at least 3 for area selection');
      alert(`Please place at least 3 markers to define a selection area.\nCurrently: ${markers.length} marker${markers.length === 1 ? '' : 's'}`);
      return;
    }
    
    console.log('נ¯ [FREEFORM SELECT] Finalizing selection with', markers.length, 'markers');
    console.log('נ” [FREEFORM SELECT] Polygon vertices:', markers.map(m => `(${m.lat.toFixed(4)}, ${m.lng.toFixed(4)})`).join(', '));
    
    // Use proper point-in-polygon algorithm
    const selectedIndices = [];
    let testedCount = 0;
    let insideCount = 0;
    
    console.log(`נ” [FREEFORM SELECT] Testing ${vertices.length} vertices against polygon...`);
    
    vertices.forEach((vertex, index) => {
      testedCount++;
      
      if (isPointInPolygon(vertex, markers)) {
        insideCount++;
        selectedIndices.push(index);
        
        console.log(`נ  [FREEFORM SELECT] Vertex ${index} INSIDE: (${vertex.lat.toFixed(4)}, ${vertex.lng.toFixed(4)})`);
        
        // Highlight selected vertex (orange with white outline)
        if (vertex.entity?.point) {
          vertex.entity.point.color = Cesium.Color.ORANGE;
          vertex.entity.point.pixelSize = 20;
          vertex.entity.point.outlineWidth = 3;
          vertex.entity.point.outlineColor = Cesium.Color.WHITE;
        }
      }
      
      // Log progress every 100 vertices
      if (testedCount % 100 === 0) {
        console.log(`ג³ [FREEFORM SELECT] Progress: ${testedCount}/${vertices.length} tested, ${insideCount} inside`);
      }
    });
    
    console.log(`ג… [FREEFORM SELECT] Tested ${testedCount} vertices, found ${selectedIndices.length} inside polygon`);
    
    console.log('🎯 [FREEFORM SELECT] Calling setSelectedVertices with', selectedIndices.length, 'indices:', selectedIndices);
    selectedVerticesRef.current = selectedIndices; // CRITICAL: Also store in ref to persist across renders
    setSelectedVertices(selectedIndices);
    
    // Switch to edit mode so vertices become draggable
    if (selectedIndices.length > 0) {
      console.log('נ”„ [FREEFORM SELECT] Switching to edit mode for multi-node dragging');
      
      // Clear markers and polygon after accepting selection
      if (cesiumViewer) {
        // Remove all marker entities
        freeformEntitiesRef.current.forEach(entity => {
          cesiumViewer.entities.remove(entity);
        });
        
        freeformEntitiesRef.current = [];
        freeformMarkerCountRef.current = 0;
        setFreeformMarkers([]);
        
        // Clear polygon
        if (selectionPolygon) {
          cesiumViewer.entities.remove(selectionPolygon);
          setSelectionPolygon(null);
        }
      }
      
      // Switch to edit mode - main effect will handle handler setup
      setMode('edit');
      console.log('🔄 [FREEFORM SELECT] Switching to edit mode for multi-node dragging');
      
      console.log(`נ‰ [FREEFORM SELECT] ${selectedIndices.length} vertices ready to move together`);
      alert(`ג… Selected ${selectedIndices.length} vertices!\n\nYou can now drag any orange vertex to move all selected vertices together.`);
    } else {
      console.log('ג ן¸ [FREEFORM SELECT] No vertices found in selection area');
      alert('ג ן¸ No vertices found inside the selection area.\n\nTry drawing a larger polygon or positioning it over the boundary vertices.');
    }
  }, [vertices, freeformMarkers, cesiumViewer, Cesium, isPointInPolygon, selectionPolygon]);

  /**
   * Clear freeform selection markers
   */
  const clearFreeformSelection = useCallback(() => {
    console.log('נ§¹ [FREEFORM SELECT] Clearing all freeform markers');
    
    // Remove all marker entities
    freeformEntitiesRef.current.forEach(entity => {
      if (cesiumViewer) {
        cesiumViewer.entities.remove(entity);
      }
    });
    
    freeformEntitiesRef.current = [];
    freeformMarkerCountRef.current = 0;
    setFreeformMarkers([]);
    
    // Clear polygon
    if (selectionPolygon && cesiumViewer) {
      cesiumViewer.entities.remove(selectionPolygon);
      setSelectionPolygon(null);
    }
    
    // Clear selected vertices
    setSelectedVertices([]);
  }, [cesiumViewer, selectionPolygon]);

  /**
   * נ¯ PORTAL: Render floating buttons directly to document.body to avoid CSS issues
   */
  useEffect(() => {
    if (!isMultiSelectActive || freeformMarkers.length < 1) {
      // Remove portal if it exists
      const existingPortal = document.getElementById('freeform-selection-portal');
      if (existingPortal) {
        existingPortal.remove();
      }
      return;
    }

    console.log(`נ”µ [PORTAL] Creating floating button portal with ${freeformMarkers.length} markers`);

    // Create or get portal container
    let portal = document.getElementById('freeform-selection-portal');
    if (!portal) {
      portal = document.createElement('div');
      portal.id = 'freeform-selection-portal';
      portal.style.cssText = `
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 999999;
        pointer-events: auto;
      `;
      document.body.appendChild(portal);
    }

    // Create buttons container
    const container = document.createElement('div');
    container.style.cssText = `
      display: flex;
      gap: 12px;
      padding: 16px 24px;
      background: rgba(0, 0, 0, 0.95);
      border-radius: 12px;
      border: 3px solid cyan;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
    `;

    // Accept button
    const acceptBtn = document.createElement('button');
    acceptBtn.textContent = `ג“ Accept (${freeformMarkers.length}/3)`;
    acceptBtn.disabled = freeformMarkers.length < 3;
    acceptBtn.style.cssText = `
      padding: 12px 24px;
      background: ${freeformMarkers.length >= 3 ? 'linear-gradient(135deg, #10b981, #059669)' : 'linear-gradient(135deg, #6b7280, #4b5563)'};
      color: white;
      border: none;
      border-radius: 8px;
      cursor: ${freeformMarkers.length >= 3 ? 'pointer' : 'not-allowed'};
      font-size: 16px;
      font-weight: 700;
    `;
    acceptBtn.onclick = () => {
      if (freeformMarkers.length >= 3) {
        console.log(`ג… [PORTAL] Accept clicked with ${freeformMarkers.length} markers`);
        finalizeSelection(freeformMarkers);
      }
    };

    // Reject button
    const rejectBtn = document.createElement('button');
    rejectBtn.textContent = 'ג— Reject';
    rejectBtn.style.cssText = `
      padding: 12px 24px;
      background: linear-gradient(135deg, #ef4444, #dc2626);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 700;
    `;
    rejectBtn.onclick = () => {
      console.log(`ג [PORTAL] Reject clicked`);
      clearFreeformSelection();
    };

    container.appendChild(acceptBtn);
    container.appendChild(rejectBtn);
    portal.innerHTML = '';
    portal.appendChild(container);

    // Cleanup
    return () => {
      const existingPortal = document.getElementById('freeform-selection-portal');
      if (existingPortal) {
        existingPortal.remove();
      }
    };
  }, [isMultiSelectActive, freeformMarkers, finalizeSelection, clearFreeformSelection]);

  /**
   * Update selection polygon connecting freeform markers
   */
  const updateSelectionPolygon = (markers) => {
    if (!cesiumViewer || !Cesium || markers.length < 2) return;
    
    console.log(`נ”— [FREEFORM SELECT] Updating selection polygon with ${markers.length} markers`);
    
    // Create closed polygon from markers
    const coords = markers.map(m => [m.lng, m.lat]);
    coords.push([markers[0].lng, markers[0].lat]); // Close the loop
    
    const positions = coords.map(c => Cesium.Cartesian3.fromDegrees(c[0], c[1], 10000));
    
    // Check if polygon exists
    const existingPolygon = cesiumViewer.entities.getById('freeform-selection-polygon');
    
    if (existingPolygon) {
      console.log('נ”„ [FREEFORM SELECT] Updating existing polygon positions');
      
      if (existingPolygon.polyline) {
        existingPolygon.polyline.positions = positions;
      }
      
      if (existingPolygon.polygon) {
        existingPolygon.polygon.hierarchy = new Cesium.PolygonHierarchy(positions);
      }
      
      if (!selectionPolygon) {
        setSelectionPolygon(existingPolygon);
      }
    } else {
      console.log('נ†• [FREEFORM SELECT] Creating initial selection polygon');
      
      const polygon = cesiumViewer.entities.add({
        id: 'freeform-selection-polygon',
        polyline: {
          positions: positions,
          width: 3,
          material: new Cesium.PolylineDashMaterialProperty({
            color: Cesium.Color.CYAN,
            dashLength: 16.0
          }),
          clampToGround: false,
          arcType: Cesium.ArcType.GEODESIC
        },
        polygon: {
          hierarchy: new Cesium.PolygonHierarchy(positions),
          material: Cesium.Color.CYAN.withAlpha(0.2),
          outline: false,
          perPositionHeight: true
        }
      });
      
      setSelectionPolygon(polygon);
    }
    
    console.log('ג… [FREEFORM SELECT] Selection polygon updated');
  };

  /**
   * Clear selection polygon
   */
  const clearSelectionPolygon = () => {
    if (selectionPolygon && cesiumViewer) {
      cesiumViewer.entities.remove(selectionPolygon);
      setSelectionPolygon(null);
    }
  };

  /**
   * Listen for submit event from toolbar
   */
  useEffect(() => {
    console.log('נ§ [BOUNDARY EDITOR] Registering event listener for boundary-editor-submit');
    
    const handleToolbarSubmit = () => {
      console.log('נ“¥ [BOUNDARY EDITOR] Received submit event from toolbar');
      handleSave();
    };

    window.addEventListener('boundary-editor-submit', handleToolbarSubmit);
    console.log('ג… [BOUNDARY EDITOR] Event listener registered');

    return () => {
      console.log('נ” [BOUNDARY EDITOR] Unregistering event listener');
      window.removeEventListener('boundary-editor-submit', handleToolbarSubmit);
    };
  }, [vertices]); // Re-attach when vertices change


  /**
   * Listen for submit event from toolbar
   */
  useEffect(() => {
    console.log('נ§ [BOUNDARY EDITOR] Registering event listener for boundary-editor-submit');
    
    const handleToolbarSubmit = () => {
      console.log('נ“¥ [BOUNDARY EDITOR] Received submit event from toolbar');
      handleSave();
    };

    window.addEventListener('boundary-editor-submit', handleToolbarSubmit);
    console.log('ג… [BOUNDARY EDITOR] Event listener registered');

    return () => {
      console.log('נ” [BOUNDARY EDITOR] Unregistering event listener');
      window.removeEventListener('boundary-editor-submit', handleToolbarSubmit);
    };
  }, [vertices]); // Re-attach when vertices change

  /**
   * Auto-enable edit mode once vertices are loaded
   */
  useEffect(() => {
    // Only auto-enable if vertices are loaded and we're in view mode
    if (vertices.length > 0 && mode === 'view' && cesiumViewer) {
      console.log('נ¯ [BOUNDARY EDITOR] Auto-enabling edit mode after vertices loaded');
      // Small delay to ensure entities are fully rendered
      setTimeout(() => {
        // Double-check mode hasn't changed to 'multiple' during timeout
        setMode(currentMode => {
          if (currentMode === 'view') {
            enableEditMode();
          }
          return currentMode;
        });
      }, 500);
    }
  }, [vertices.length, cesiumViewer]); // Only trigger when vertices first load

  /**
   * Load existing proposal for editing
   */
  const loadProposal = (proposal) => {
    console.log('נ“‚ [BOUNDARY EDITOR] Loading proposal:', proposal.name);
    
    const geometry = proposal.location?.geometry;
    if (!geometry) {
      console.error('ג Proposal has no geometry');
      return;
    }
    
    setOriginalGeometry(geometry);
    setProposalName(proposal.name);
    setDescription(proposal.description || '');
    
    // Extract coordinates from GeoJSON
    if (geometry.type === 'Polygon' && geometry.coordinates && geometry.coordinates[0]) {
      const coords = geometry.coordinates[0];
      loadVertices(coords);
    } else {
      console.error('ג Invalid geometry format');
    }
  };

  /**
   * Load official boundary as starting point
   */
  const loadOfficialBoundary = () => {
    console.log('נ†• [BOUNDARY EDITOR] Loading official boundary for editing');
    
    // Find official boundary candidate
    const officialCandidate = channel?.candidates?.find(c => c.isOfficial || c.isDefault);
    
    if (officialCandidate) {
      loadProposal(officialCandidate);
    } else {
      console.warn('ג ן¸ No official boundary found, starting with empty polygon');
      // Start with empty - user will add vertices
      setMode('add');
    }
  };

  /**
   * Load vertices from GeoJSON coordinates and create pinpoint entities
   */
  const loadVertices = (coordinates) => {
    console.log(`נ“ [BOUNDARY EDITOR] Loading ${coordinates.length} vertices`);
    
    const newVertices = coordinates.map((coord, index) => {
      const [lng, lat] = coord;
      
      // Create pinpoint entity on globe with proper Cesium properties
      const entity = cesiumViewer.entities.add({
        id: `vertex-${index}-${Date.now()}`,
        position: Cesium.Cartesian3.fromDegrees(lng, lat, 10000), // 10km above surface
        point: {
          pixelSize: 18, // Increased from 14 for easier clicking
          color: Cesium.Color.CYAN,
          outlineColor: Cesium.Color.WHITE,
          outlineWidth: 2,
          heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND,
          disableDepthTestDistance: Number.POSITIVE_INFINITY,
          scaleByDistance: new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.5) // Scale with camera distance
        },
        label: {
          text: `V${index + 1}`,
          font: '12px sans-serif',
          fillColor: Cesium.Color.WHITE,
          outlineColor: Cesium.Color.BLACK,
          outlineWidth: 2,
          style: Cesium.LabelStyle.FILL_AND_OUTLINE,
          verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
          pixelOffset: new Cesium.Cartesian2(0, -20),
          heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND,
          disableDepthTestDistance: Number.POSITIVE_INFINITY
        },
        properties: new Cesium.PropertyBag({
          type: 'boundary-vertex',
          index: index,
          editable: true
        })
      });

      entitiesRef.current.push(entity);
      
      // Verify entity was created properly
      if (index < 5) { // Log first 5 vertices only
        console.log(`ג… [BOUNDARY EDITOR] Created vertex ${index}:`, {
          id: entity.id,
          hasProperties: !!entity.properties,
          type: entity.properties?.type?.getValue(),
          index: entity.properties?.index?.getValue()
        });
      }

      return { lat, lng, entity, index };
    });


    setVertices(newVertices);
    
    // CRITICAL: Notify parent of initial vertex count
    if (onVerticesChange) {
      onVerticesChange(newVertices.length);
      console.log('📊 [BOUNDARY EDITOR] Notified parent: initial vertex count =', newVertices.length);
    }
    
    // Draw polygon connecting vertices
    drawPolygon(newVertices);
    
    // Zoom camera to boundary
    zoomToBoundary(newVertices);
    
    console.log('ג… [BOUNDARY EDITOR] Vertices loaded');
  };

  /**
   * Draw polygon on globe
   */
  const drawPolygon = (vertexArray) => {
    // Remove old polygon
    if (polygonEntityRef.current) {
      cesiumViewer.entities.remove(polygonEntityRef.current);
      polygonEntityRef.current = null;
    }

    if (vertexArray.length < 3) {
      console.log('נ–³ [BOUNDARY EDITOR] Need at least 3 vertices for polygon');
      return;
    }

    // Create polygon hierarchy
    const positions = vertexArray.map(v =>
      Cesium.Cartesian3.fromDegrees(v.lng, v.lat, 5000) // 5km above surface
    );

    const polygonEntity = cesiumViewer.entities.add({
      id: 'boundary-polygon-editor',
      polygon: {
        hierarchy: new Cesium.PolygonHierarchy(positions),
        material: Cesium.Color.CYAN.withAlpha(0.4),
        outline: true,
        outlineColor: Cesium.Color.CYAN,
        outlineWidth: 3,
        heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND,
        closeTop: false,
        closeBottom: false
      },
      polyline: {
        positions: [...positions, positions[0]], // Close the loop
        width: 4,
        material: Cesium.Color.CYAN,
        clampToGround: false
      },
      properties: new Cesium.PropertyBag({
        type: 'boundary-polygon',
        editable: true
      })
    });

    polygonEntityRef.current = polygonEntity;
    entitiesRef.current.push(polygonEntity);
  };

  /**
   * Zoom camera to boundary
   */
  const zoomToBoundary = (vertexArray) => {
    if (vertexArray.length === 0) {
      console.warn('⚠️ [BOUNDARY EDITOR] Cannot zoom: no vertices');
      return;
    }

    console.log(`📷 [BOUNDARY EDITOR] Zooming to boundary with ${vertexArray.length} vertices`);

    // Calculate bounding box from vertices
    let minLng = Infinity, maxLng = -Infinity;
    let minLat = Infinity, maxLat = -Infinity;

    vertexArray.forEach(v => {
      minLng = Math.min(minLng, v.lng);
      maxLng = Math.max(maxLng, v.lng);
      minLat = Math.min(minLat, v.lat);
      maxLat = Math.max(maxLat, v.lat);
    });

    // Calculate center
    const centerLng = (minLng + maxLng) / 2;
    const centerLat = (minLat + maxLat) / 2;

    // Calculate appropriate height based on bounding box size
    const lngRange = maxLng - minLng;
    const latRange = maxLat - minLat;
    const maxRange = Math.max(lngRange, latRange);
    
    // Scale factor: larger range needs higher camera
    const height = Math.max(
      maxRange * 150000,  // Scale factor for good view
      100000              // Minimum 100km height
    );

    console.log(`📷 [BOUNDARY EDITOR] Zoom details:`, {
      center: `${centerLng.toFixed(4)}°, ${centerLat.toFixed(4)}°`,
      bounds: {
        west: minLng.toFixed(4),
        east: maxLng.toFixed(4),
        south: minLat.toFixed(4),
        north: maxLat.toFixed(4)
      },
      ranges: {
        lng: lngRange.toFixed(4),
        lat: latRange.toFixed(4),
        max: maxRange.toFixed(4)
      },
      height: `${(height / 1000).toFixed(0)} km`
    });

    // Fly to center with calculated height
    cesiumViewer.camera.flyTo({
      destination: Cesium.Cartesian3.fromDegrees(centerLng, centerLat, height),
      duration: 2.0,
      orientation: {
        heading: Cesium.Math.toRadians(0),
        pitch: Cesium.Math.toRadians(-45), // 45° downward angle
        roll: 0.0
      }
    });

    console.log('✅ [BOUNDARY EDITOR] Camera zoom initiated');
  };

  /**
   * Enable multiple (freeform) selection mode
   */
  const enableMultipleMode = useCallback(() => {
    console.log('נ“ [BOUNDARY EDITOR] Enabling multiple selection mode');
    
    // Cleanup main boundary editing handler if exists
    if (handlerRef.current) {
      console.log('נ§¹ [BOUNDARY EDITOR] Destroying main handler for multiple mode');
      handlerRef.current.destroy();
      handlerRef.current = null;
    }
    
    // Set mode to multiple (freeform handler will be created by useEffect)
    setMode('multiple');
    console.log('✅ [BOUNDARY EDITOR] setMode("multiple") called - mode will change');
    
    // Force cursor change immediately
    if (cesiumViewer?.canvas) {
      cesiumViewer.canvas.style.cursor = 'crosshair';
      console.log('🎯 [BOUNDARY EDITOR] ✅ FORCED cursor to crosshair immediately');
    }
  }, []);

  /**
   * Enable edit mode - make vertices draggable
   */
  const enableEditMode = useCallback(() => {
    console.log('גן¸ [BOUNDARY EDITOR] Enabling edit mode');
    console.log('נ“ [BOUNDARY EDITOR] Current vertices count:', vertices.length);
    console.log('נ“ [BOUNDARY EDITOR] Cesium viewer available:', !!cesiumViewer);
    console.log('נ“ [BOUNDARY EDITOR] Scene canvas available:', !!cesiumViewer?.scene?.canvas);
    
    // נ”¥ CRITICAL: Disable RegionManager handlers AND boundary highlighting to prevent interference
    if (window.earthGlobeControls?.regionManager) {
      console.log('נ›‘ [BOUNDARY EDITOR] Temporarily disabling RegionManager handlers');
      try {
        const regionManager = window.earthGlobeControls.regionManager;
        
        // Remove LEFT_CLICK and MOUSE_MOVE handlers from cesiumWidget.screenSpaceEventHandler
        if (cesiumViewer.cesiumWidget?.screenSpaceEventHandler) {
          cesiumViewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
          cesiumViewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
          console.log('ג… [BOUNDARY EDITOR] RegionManager handlers disabled');
        }

        // נ”¥ CRITICAL: Hide/disable country/boundary highlighting during edit mode
        if (regionManager.adminHierarchy) {
          const adminHierarchy = regionManager.adminHierarchy;
          
          // Dim all country boundaries (make them less visible)
          if (adminHierarchy.entities?.country) {
            console.log('נ¨ [BOUNDARY EDITOR] Dimming country boundaries');
            adminHierarchy.entities.country.forEach((entity) => {
              if (entity.polygon) {
                // Store original settings
                if (!entity._originalSettings) {
                  entity._originalSettings = {
                    outlineWidth: entity.polygon.outlineWidth?.getValue(),
                    outlineColor: entity.polygon.outlineColor?.getValue(),
                    material: entity.polygon.material?.getValue()
                  };
                }
                // Dim the boundaries
                entity.polygon.outlineWidth = 0.5; // Very thin
                entity.polygon.outlineColor = Cesium.Color.GRAY.withAlpha(0.2); // Barely visible
                if (entity.polygon.material) {
                  entity.polygon.material = Cesium.Color.TRANSPARENT; // No fill
                }
              }
            });
          }

          // Dim province boundaries too
          if (adminHierarchy.entities?.province) {
            console.log('נ¨ [BOUNDARY EDITOR] Dimming province boundaries');
            adminHierarchy.entities.province.forEach((entity) => {
              if (entity.polygon) {
                if (!entity._originalSettings) {
                  entity._originalSettings = {
                    outlineWidth: entity.polygon.outlineWidth?.getValue(),
                    outlineColor: entity.polygon.outlineColor?.getValue(),
                    material: entity.polygon.material?.getValue()
                  };
                }
                entity.polygon.outlineWidth = 0.5;
                entity.polygon.outlineColor = Cesium.Color.GRAY.withAlpha(0.1);
                if (entity.polygon.material) {
                  entity.polygon.material = Cesium.Color.TRANSPARENT;
                }
              }
            });
          }

          console.log('ג… [BOUNDARY EDITOR] Country/province boundaries dimmed for editing');
        }
      } catch (error) {
        console.warn('ג ן¸ [BOUNDARY EDITOR] Error disabling RegionManager handlers:', error);
      }
    }
    
    setMode('edit');
    console.log('✅ [EDIT] Edit mode activated - handlers will be created by useEffect');
  }, [vertices, cesiumViewer, Cesium]);

  /**
   * Create drag handlers when mode is 'edit'
   */
  useEffect(() => {
    if (!cesiumViewer || !Cesium || mode !== 'edit') {
      return;
    }

    console.log('🎮 [HANDLER SETUP] Creating edit mode handlers');
    console.log('🎯 [HANDLER SETUP] selectedVertices STATE:', selectedVertices);
    console.log('🎯 [HANDLER SETUP] selectedVertices REF:', selectedVerticesRef.current);
    console.log('🎯 [HANDLER SETUP] Using REF with length:', selectedVerticesRef.current.length);
    // Update vertex colors to yellow
    // Vertex colors already set by finalizeSelection (orange) or enableEditMode (yellow)
    // Cleanup old handler if exists
    if (handlerRef.current) {
      console.log('נ§¹ [BOUNDARY EDITOR] Cleaning up old event handler');
      handlerRef.current.destroy();
      handlerRef.current = null;
    }

    // נ« CRITICAL: Do NOT create main handler in multiple mode (freeform handler handles it)
    if (mode === 'multiple') {
      console.log('ג­ן¸ [BOUNDARY EDITOR] Skipping main handler creation - multiple mode uses freeform handler');
      return;
    }

    // Create input handler
    const handler = new Cesium.ScreenSpaceEventHandler(cesiumViewer.scene.canvas);
    handlerRef.current = handler;
    console.log('🎮 [BOUNDARY EDITOR] ✅ Event handler created successfully for mode:', mode);
    console.log('🎮 [BOUNDARY EDITOR] ✅ selectedVertices count:', selectedVertices.length);
    console.log('🎮 [BOUNDARY EDITOR] ✅ selectedVertices count (REF):', selectedVerticesRef.current.length);
    // Mouse down - start drag (ENHANCED: Individual node selection with drillPick)
    handler.setInputAction((click) => {
      console.log('נ–±ן¸ [BOUNDARY EDITOR] LEFT_DOWN detected at position:', click.position, 'mode:', mode);
      
      // נ« CRITICAL: Skip if in multiple mode (freeform handler processes clicks)
      if (mode === 'multiple') {
        console.log('ג™ן¸ [BOUNDARY EDITOR] Multiple mode - handled by freeform tool');
        return;
      }
      
      // נ”¥ Use drillPick to get ALL entities at this position (not just topmost)
      const allPicked = cesiumViewer.scene.drillPick(click.position, 10); // Get up to 10 entities
      console.log('נ¯ [BOUNDARY EDITOR] DrillPick found', allPicked.length, 'entities');
      
      // Find the first boundary vertex in the list
      let vertexPick = null;
      for (const picked of allPicked) {
        console.log('נ” [BOUNDARY EDITOR] Examining entity:', picked.id?.id, 'type:', picked.id?.properties?.type?.getValue());
        
        if (picked.id?.properties?.type?.getValue() === 'boundary-vertex') {
          vertexPick = picked;
          console.log('ג… [BOUNDARY EDITOR] Found boundary vertex!');
          break;
        }
      }
      
      if (vertexPick) {
        console.log('ג… [BOUNDARY EDITOR] Vertex picked successfully!');
        
        // נ”¥ CRITICAL: Disable camera controls during drag to prevent globe panning
        cesiumViewer.scene.screenSpaceCameraController.enableRotate = false;
        cesiumViewer.scene.screenSpaceCameraController.enableTranslate = false;
        cesiumViewer.scene.screenSpaceCameraController.enableZoom = false;
        cesiumViewer.scene.screenSpaceCameraController.enableTilt = false;
        cesiumViewer.scene.screenSpaceCameraController.enableLook = false;
        console.log('נ”’ [BOUNDARY EDITOR] Camera controls disabled for dragging');
        
        // Deselect previous vertex
        if (draggedVertexRef.current && draggedVertexRef.current !== vertexPick.id) {
          draggedVertexRef.current.point.pixelSize = 16;
          draggedVertexRef.current.point.color = Cesium.Color.YELLOW;
          draggedVertexRef.current.point.outlineWidth = 0;
        }
        
        draggedVertexRef.current = vertexPick.id;
        isDraggingRef.current = true;
        
        // Store original positions of ALL selected vertices at drag start
        console.log(`[BOUNDARY EDITOR] Selected vertices count: ${selectedVerticesRef.current.length}`);
        if (selectedVerticesRef.current.length > 0) {
          const originalPositions = new Map();
          selectedVerticesRef.current.forEach(idx => {
            if (vertices[idx]) {
              originalPositions.set(idx, { lat: vertices[idx].lat, lng: vertices[idx].lng });
            }
          });
          dragStartPositionsRef.current = originalPositions;
          console.log(`✅ [MULTI-SELECT] Stored ${originalPositions.size} vertex start positions for dragging`);
        } else {
          console.log(`⚠️ [SINGLE-SELECT] No multi-selection active`);
        }
        
        const vertexIndex = vertexPick.id.properties.index.getValue();
        console.log(`נ“ [BOUNDARY EDITOR] Selected vertex #${vertexIndex} - Ready to drag`);
        
        // Enhanced visual feedback for selected vertex
        draggedVertexRef.current.point.pixelSize = 24; // Larger for better visibility
        draggedVertexRef.current.point.color = Cesium.Color.ORANGE;
        draggedVertexRef.current.point.outlineWidth = 3;
        draggedVertexRef.current.point.outlineColor = Cesium.Color.WHITE;
      } else {
        console.log('ג [BOUNDARY EDITOR] No boundary vertex found in picked entities');
        
        // Debug: Show what was picked
        if (allPicked.length > 0) {
          console.log('נ“‹ [BOUNDARY EDITOR] Picked entities:', allPicked.map(p => ({
            id: p.id?.id,
            type: p.id?.properties?.type?.getValue()
          })));
        }
      }
    }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

    // Mouse move - update vertex position (MULTI-NODE SUPPORT)
    handler.setInputAction((movement) => {
      if (!isDraggingRef.current || !draggedVertexRef.current) return;

      // Get 3D position on globe
      const ray = cesiumViewer.camera.getPickRay(movement.endPosition);
      const cartesian = cesiumViewer.scene.globe.pick(ray, cesiumViewer.scene);

      if (cartesian) {
        const heightOffset = 10000; // 10km above surface
        const cartographic = Cesium.Cartographic.fromCartesian(cartesian);
        
        // Get new lat/lng for dragged vertex
        const newLat = Cesium.Math.toDegrees(cartographic.latitude);
        const newLng = Cesium.Math.toDegrees(cartographic.longitude);

        // Get dragged vertex index
        const draggedIndex = draggedVertexRef.current.properties.index.getValue();
        
        // Update vertices array (MULTI-NODE: Move all selected vertices together)
        setVertices(prev => {
          const updated = [...prev];
          
          // Calculate offset from ORIGINAL drag start position (not current position)
          const dragStartPos = dragStartPositionsRef.current?.get(draggedIndex);
          if (!dragStartPos) {
            console.warn('נ [BOUNDARY EDITOR] No stored start position - falling back');
            return prev; // Skip this frame if no start position stored
          }
          
          const latOffset = newLat - dragStartPos.lat; // Total offset from start
          const lngOffset = newLng - dragStartPos.lng; // Not incremental!
          
          // Check if this vertex is part of a multi-selection
          const isMultiSelect = selectedVertices.length > 1 && selectedVertices.includes(draggedIndex);
          
          if (isMultiSelect) {
            console.log(`🔄 [MULTI-DRAG] Moving ${selectedVerticesRef.current.length} vertices with offset: lat=${latOffset.toFixed(4)}, lng=${lngOffset.toFixed(4)}`);
            // Move ALL selected vertices by the same offset from THEIR original positions
            selectedVerticesRef.current.forEach(selectedIndex => {
              const startPos = dragStartPositionsRef.current?.get(selectedIndex);
              if (startPos && updated[selectedIndex]) {
                const vertex = updated[selectedIndex];
                const movedLat = startPos.lat + latOffset; // From original, not current
                const movedLng = startPos.lng + lngOffset;
                
                // Update entity position
                if (vertex.entity) {
                  const movedPosition = Cesium.Cartesian3.fromDegrees(movedLng, movedLat, heightOffset);
                  vertex.entity.position = movedPosition;
                }
                
                // Update vertex data
                updated[selectedIndex] = {
                  ...vertex,
                  lat: movedLat,
                  lng: movedLng
                };
              }
            });
          } else {
            // Single vertex drag
            const newPosition = Cesium.Cartesian3.fromRadians(
              cartographic.longitude,
              cartographic.latitude,
              heightOffset
            );
            
            draggedVertexRef.current.position = newPosition;
            updated[draggedIndex] = { 
              lat: newLat, 
              lng: newLng, 
              entity: draggedVertexRef.current, 
              index: draggedIndex 
            };
          }
          
          // Redraw polygon
          drawPolygon(updated);
          
          return updated;
        });
      }
    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

    // Mouse up - end drag (Keep selection visible)
    handler.setInputAction(() => {
      if (draggedVertexRef.current) {
        // Keep vertex selected but reduce highlight intensity
        draggedVertexRef.current.point.pixelSize = 18;
        draggedVertexRef.current.point.color = Cesium.Color.YELLOW;
        draggedVertexRef.current.point.outlineWidth = 2;
        console.log('ג… [BOUNDARY EDITOR] Vertex drag complete - Node remains selected');
      }
      
      // נ”¥ CRITICAL: Re-enable camera controls after drag
      if (isDraggingRef.current) {
        cesiumViewer.scene.screenSpaceCameraController.enableRotate = true;
        cesiumViewer.scene.screenSpaceCameraController.enableTranslate = true;
        cesiumViewer.scene.screenSpaceCameraController.enableZoom = true;
        cesiumViewer.scene.screenSpaceCameraController.enableTilt = true;
        cesiumViewer.scene.screenSpaceCameraController.enableLook = true;
        console.log('נ”“ [BOUNDARY EDITOR] Camera controls re-enabled');
      }
      
      isDraggingRef.current = false;
      dragStartPositionsRef.current = null; // Clear stored positions after drag ends
      // Keep draggedVertexRef to maintain selection
      
      // נ¯ CRITICAL: Notify parent of vertex count update after drag
      if (onVerticesChange) {
        onVerticesChange(vertices.length);
        console.log('📊 [BOUNDARY EDITOR] Notified parent: vertex count =', vertices.length);
      }
    }, Cesium.ScreenSpaceEventType.LEFT_UP);

    // Right-click on vertex - delete
    handler.setInputAction((click) => {
      const pickedObject = cesiumViewer.scene.pick(click.position);
      
      if (pickedObject && pickedObject.id && 
          pickedObject.id.properties?.type?.getValue() === 'boundary-vertex') {
        deleteVertex(pickedObject.id);
      }
    }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);

    // Click on polygon line - add new vertex
    handler.setInputAction((click) => {
      if (isDraggingRef.current) return; // Don't add if dragging
      
      const pickedObject = cesiumViewer.scene.pick(click.position);
      
      if (pickedObject && pickedObject.id && 
          pickedObject.id.properties?.type?.getValue() === 'boundary-polygon') {
        
        const ray = cesiumViewer.camera.getPickRay(click.position);
        const cartesian = cesiumViewer.scene.globe.pick(ray, cesiumViewer.scene);

        if (cartesian) {
          addVertexAtPosition(cartesian);
        }
      }
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

    console.log('ג… Edit mode enabled - vertices are now draggable');
    }, [mode, cesiumViewer, Cesium]); // Recreate handlers when mode changes (selectedVertices in ref)

  /**
   * Add new vertex at clicked position
   */
  const addVertexAtPosition = (cartesian) => {
    const cartographic = Cesium.Cartographic.fromCartesian(cartesian);
    const lat = Cesium.Math.toDegrees(cartographic.latitude);
    const lng = Cesium.Math.toDegrees(cartographic.longitude);

    console.log(`ג• Adding vertex at: ${lat.toFixed(4)}, ${lng.toFixed(4)}`);

    // Find closest line segment to insert vertex
    const insertIndex = findClosestLineSegment(lat, lng);

    // Create new vertex entity
    const heightOffset = 10000;
    const position = Cesium.Cartesian3.fromDegrees(lng, lat, heightOffset);
    
    const entity = cesiumViewer.entities.add({
      id: `vertex-${Date.now()}`,
      position: position,
      point: {
        pixelSize: 16,
        color: Cesium.Color.YELLOW,
        outlineColor: Cesium.Color.WHITE,
        outlineWidth: 2,
        heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND,
        disableDepthTestDistance: Number.POSITIVE_INFINITY
      },
      label: {
        text: `V${insertIndex + 1}`,
        font: '12px sans-serif',
        fillColor: Cesium.Color.WHITE,
        outlineColor: Cesium.Color.BLACK,
        outlineWidth: 2,
        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
        pixelOffset: new Cesium.Cartesian2(0, -20),
        heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND,
        disableDepthTestDistance: Number.POSITIVE_INFINITY
      },
      properties: {
        type: 'boundary-vertex',
        index: insertIndex,
        editable: true
      }
    });

    entitiesRef.current.push(entity);

    // Insert into vertices array
    setVertices(prev => {
      const updated = [...prev];
      updated.splice(insertIndex, 0, { lat, lng, entity, index: insertIndex });
      
      // Update all indices and labels
      updated.forEach((v, i) => {
        v.index = i;
        v.entity.properties.index = i;
        if (v.entity.label) {
          v.entity.label.text = `V${i + 1}`;
        }
      });
      
      drawPolygon(updated);
      return updated;
    });

    console.log('ג… Vertex added');
  };

  /**
   * Delete vertex
   */
  const deleteVertex = (vertexEntity) => {
    if (vertices.length <= 3) {
      alert('ג ן¸ Cannot delete - polygon must have at least 3 vertices');
      return;
    }

    const index = vertexEntity.properties.index.getValue();
    console.log(`נ—‘ן¸ Deleting vertex ${index + 1}`);

    // Remove entity
    cesiumViewer.entities.remove(vertexEntity);
    entitiesRef.current = entitiesRef.current.filter(e => e !== vertexEntity);

    // Remove from vertices array
    setVertices(prev => {
      const updated = prev.filter(v => v.index !== index);
      
      // Update indices and labels
      updated.forEach((v, i) => {
        v.index = i;
        v.entity.properties.index = i;
        if (v.entity.label) {
          v.entity.label.text = `V${i + 1}`;
        }
      });
      
      drawPolygon(updated);
      return updated;
    });

    console.log('ג… Vertex deleted');
  };

  /**
   * Find closest line segment for new vertex insertion
   */
  const findClosestLineSegment = (lat, lng) => {
    let minDistance = Infinity;
    let insertIndex = 0;

    for (let i = 0; i < vertices.length; i++) {
      const v1 = vertices[i];
      const v2 = vertices[(i + 1) % vertices.length];

      const distance = distanceToLineSegment(lat, lng, v1.lat, v1.lng, v2.lat, v2.lng);

      if (distance < minDistance) {
        minDistance = distance;
        insertIndex = i + 1;
      }
    }

    return insertIndex;
  };

  /**
   * Calculate distance from point to line segment
   */
  const distanceToLineSegment = (px, py, x1, y1, x2, y2) => {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;

    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;

    if (lenSq !== 0) {
      param = dot / lenSq;
    }

    let xx, yy;

    if (param < 0) {
      xx = x1;
      yy = y1;
    } else if (param > 1) {
      xx = x2;
      yy = y2;
    } else {
      xx = x1 + param * C;
      yy = y1 + param * D;
    }

    const dx = px - xx;
    const dy = py - yy;

    return Math.sqrt(dx * dx + dy * dy);
  };

  /**
   * Preview impact of boundary change
   */
  const previewImpact = async () => {
    if (vertices.length < 3) {
      alert('ג ן¸ Need at least 3 vertices to preview impact');
      return;
    }

    console.log('נ” [BOUNDARY EDITOR] Previewing impact...');
    setIsLoading(true);

    try {
      // Convert vertices to GeoJSON
      const newGeometry = {
        type: 'Polygon',
        coordinates: [vertices.map(v => [v.lng, v.lat])]
      };

      // TODO: Call API to calculate affected regions
      // For now, show mock data
      const mockAffectedRegions = [
        { code: 'PAK', name: 'Pakistan', overlapPercentage: 15 },
        { code: 'BGD', name: 'Bangladesh', overlapPercentage: 8 },
        { code: 'NPL', name: 'Nepal', overlapPercentage: 12 }
      ];

      setAffectedRegions(mockAffectedRegions);
      
      alert(`ג ן¸ This boundary change affects ${mockAffectedRegions.length} regions:\n\n` +
            mockAffectedRegions.map(r => `ג€¢ ${r.name} (${r.overlapPercentage}% overlap)`).join('\n') +
            '\n\nThese regions will be notified and can participate in discussions.');

    } catch (error) {
      console.error('ג Error previewing impact:', error);
      alert('Error calculating impact: ' + error.message);
    } finally {
      setIsLoading(false);
    }
  };

  /**
   * Save boundary proposal (SIMPLIFIED - Auto-generates name)
   */
  const handleSave = async () => {
    if (vertices.length < 3) {
      alert('ג ן¸ Boundary must have at least 3 vertices');
      return;
    }

    console.log('נ’¾ [BOUNDARY EDITOR] Saving proposal...');
    console.log('נ“‹ [BOUNDARY EDITOR] Channel data:', {
      id: channel?.id,
      regionName: channel?.regionName,
      hasChannel: !!channel
    });
    
    if (!channel || !channel.id) {
      console.error('ג [BOUNDARY EDITOR] No channel ID available!');
      alert('ג Error: Channel information missing. Please reload and try again.');
      return;
    }
    
    setIsLoading(true);

    try {
      // Auto-generate proposal name with timestamp
      const timestamp = new Date().toLocaleString('en-US', { 
        month: 'short', 
        day: 'numeric', 
        hour: '2-digit', 
        minute: '2-digit' 
      });
      const autoName = proposalName.trim() || `${regionName} Boundary Proposal - ${timestamp}`;
      
      // Convert to GeoJSON
      const geometry = {
        type: 'Polygon',
        coordinates: [vertices.map(v => [v.lng, v.lat])]
      };

      // Calculate area changes if we have an official boundary
      let areaChangeData = null;
      if (originalGeometry && originalGeometry.coordinates && originalGeometry.coordinates[0]) {
        const { calculateAreaChange } = await import('../../../../utils/BoundaryPreviewGenerator.js');
        areaChangeData = calculateAreaChange(originalGeometry.coordinates[0], geometry.coordinates[0]);
        console.log('📊 [BOUNDARY EDITOR] Area change calculated:', {
          official: areaChangeData.officialArea.toLocaleString() + ' km²',
          proposed: areaChangeData.proposedArea.toLocaleString() + ' km²',
          delta: (areaChangeData.deltaArea >= 0 ? '+' : '') + areaChangeData.deltaArea.toLocaleString() + ' km²',
          percent: (areaChangeData.deltaPercent >= 0 ? '+' : '') + areaChangeData.deltaPercent.toFixed(2) + '%'
        });
      }
      
      console.log('נ“₪ [BOUNDARY EDITOR] Submitting to API:', {
        url: `/api/channels/boundary/${channel.id}/proposal`,
        name: autoName,
        geometryType: geometry.type,
        vertices: geometry.coordinates[0].length
      });

      // Call API to save proposal (with auto-generated name)
      const response = await fetch(`/api/channels/boundary/${channel.id}/proposal`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          name: autoName,
          description: description || `Proposed boundary modification for ${regionName}`,
          geometry: geometry,
          areaChange: areaChangeData
        })
      });

      console.log('נ“¥ [BOUNDARY EDITOR] Response status:', response.status);
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('ג [BOUNDARY EDITOR] API error response:', errorText);
        throw new Error(`API returned ${response.status}: ${errorText}`);
      }
      
      const data = await response.json();
      console.log('נ“¦ [BOUNDARY EDITOR] Response data:', data);

      if (data.success) {
        console.log('ג… [BOUNDARY EDITOR] Proposal saved:', data.proposal);
        alert(`ג… Boundary proposal saved!\n\nYour proposal "${autoName}" now appears as a candidate in the ${regionName} Boundaries channel panel.\n\nנ‘‰ Add a description and campaign for votes there!`);
        
        if (onSave) {
          onSave(data.proposal);
        }
      } else {
        throw new Error(data.error || 'Failed to save proposal');
      }

    } catch (error) {
      console.error('ג [BOUNDARY EDITOR] Error saving proposal:', error);
      console.error('ג [BOUNDARY EDITOR] Error stack:', error.stack);
      alert('Error saving proposal: ' + error.message);
    } finally {
      setIsLoading(false);
    }
  };

  /**
   * Cleanup entities
   */
  const cleanup = () => {
    console.log('נ§¹ [BOUNDARY EDITOR] Cleaning up...');

    entitiesRef.current.forEach(entity => {
      try {
        cesiumViewer.entities.remove(entity);
      } catch (e) {
        // Entity may already be removed
      }
    });
    entitiesRef.current = [];
    polygonEntityRef.current = null;

    if (handlerRef.current) {
      handlerRef.current.destroy();
      handlerRef.current = null;
    }

    // נ”¥ CRITICAL: Re-enable RegionManager handlers AND restore boundary highlighting
    if (window.earthGlobeControls?.regionManager && cesiumViewer) {
      console.log('ג… [BOUNDARY EDITOR] Re-enabling RegionManager handlers');
      try {
        const regionManager = window.earthGlobeControls.regionManager;
        
        // Re-register RegionManager handlers
        if (regionManager.mouseHandlers && cesiumViewer.cesiumWidget?.screenSpaceEventHandler) {
          cesiumViewer.cesiumWidget.screenSpaceEventHandler.setInputAction(
            regionManager.mouseHandlers.move, 
            window.Cesium.ScreenSpaceEventType.MOUSE_MOVE
          );
          cesiumViewer.cesiumWidget.screenSpaceEventHandler.setInputAction(
            regionManager.mouseHandlers.click, 
            window.Cesium.ScreenSpaceEventType.LEFT_CLICK
          );
          console.log('ג… [BOUNDARY EDITOR] RegionManager handlers re-enabled');
        }

        // נ”¥ CRITICAL: Restore country/boundary highlighting
        if (regionManager.adminHierarchy) {
          const adminHierarchy = regionManager.adminHierarchy;
          
          // Restore country boundaries
          if (adminHierarchy.entities?.country) {
            console.log('נ¨ [BOUNDARY EDITOR] Restoring country boundaries');
            adminHierarchy.entities.country.forEach((entity) => {
              if (entity.polygon && entity._originalSettings) {
                entity.polygon.outlineWidth = entity._originalSettings.outlineWidth || 2;
                entity.polygon.outlineColor = entity._originalSettings.outlineColor || window.Cesium.Color.BLACK;
                if (entity._originalSettings.material) {
                  entity.polygon.material = entity._originalSettings.material;
                }
                delete entity._originalSettings;
              }
            });
          }

          // Restore province boundaries
          if (adminHierarchy.entities?.province) {
            console.log('נ¨ [BOUNDARY EDITOR] Restoring province boundaries');
            adminHierarchy.entities.province.forEach((entity) => {
              if (entity.polygon && entity._originalSettings) {
                entity.polygon.outlineWidth = entity._originalSettings.outlineWidth || 1;
                entity.polygon.outlineColor = entity._originalSettings.outlineColor || window.Cesium.Color.BLACK;
                if (entity._originalSettings.material) {
                  entity.polygon.material = entity._originalSettings.material;
                }
                delete entity._originalSettings;
              }
            });
          }

          console.log('ג… [BOUNDARY EDITOR] Country/province boundaries restored');
        }
      } catch (error) {
        console.warn('ג ן¸ [BOUNDARY EDITOR] Error re-enabling RegionManager handlers:', error);
      }
    }
  };

  // Render controls overlay
  console.log('🎨 [BOUNDARY EDITOR] ==== RENDERING COMPONENT ====', 'mode:', mode);
  return (
    <div className="globe-boundary-editor-overlay">
      {/* Editor Controls Panel */}
      <div className="editor-controls-panel">
        <div className="editor-header">
          <h3>גן¸ Boundary Editor</h3>
          <h4>{regionName}</h4>
          
          {/* Category Badge */}
          {channel?.category && (
            <div style={{
              marginTop: '8px',
              padding: '6px 12px',
              background: 'rgba(33, 150, 243, 0.2)',
              border: '1px solid rgba(33, 150, 243, 0.4)',
              borderRadius: '8px',
              display: 'flex',
              alignItems: 'center',
              gap: '8px'
            }}>
              <span style={{ fontSize: '14px' }}>נ·ן¸</span>
              <div style={{ flex: 1 }}>
                <div style={{ 
                  fontSize: '10px', 
                  color: '#94a3b8',
                  textTransform: 'uppercase',
                  letterSpacing: '0.5px',
                  fontWeight: 600
                }}>
                  Category
                </div>
                <div style={{ 
                  fontSize: '13px', 
                  color: '#60a5fa',
                  fontWeight: 600
                }}>
                  {channel.category}
                </div>
              </div>
            </div>
          )}
          
          {/* Voting Scope Info */}
          {channel?.votingScope && (
            <div style={{
              marginTop: '8px',
              padding: '8px 12px',
              background: 'rgba(16, 185, 129, 0.15)',
              border: '1px solid rgba(16, 185, 129, 0.3)',
              borderRadius: '8px'
            }}>
              <div style={{ 
                fontSize: '10px', 
                color: '#94a3b8',
                textTransform: 'uppercase',
                letterSpacing: '0.5px',
                fontWeight: 600,
                marginBottom: '4px'
              }}>
                נ Voting Scope
              </div>
              <div style={{ 
                fontSize: '12px', 
                color: '#6ee7b7',
                lineHeight: '1.4'
              }}>
                {channel.votingDescription || `Voting open to ${channel.votingScope} level`}
              </div>
            </div>
          )}
        </div>

        {/* MINIMIZED EDITOR - Essential editing tools only */}
        {/* Mode Buttons */}
        <div className="editor-section">
          <label>Mode:</label>
          <div className="mode-buttons">
            <button 
              onClick={() => setMode('view')}
              className={`mode-btn ${mode === 'view' ? 'active' : ''}`}
              disabled={mode === 'view'}
            >
              נ‘ן¸ View
            </button>
            <button 
              onClick={enableEditMode}
              className={`mode-btn ${mode === 'edit' ? 'active' : ''}`}
              disabled={mode === 'edit'}
            >
              גן¸ Edit
            </button>
            <button 
              onClick={enableMultipleMode}
              className={`mode-btn ${mode === 'multiple' ? 'active' : ''}`}
              disabled={mode === 'multiple'}
              title="Freeform multi-select tool - click anywhere to place markers"
            >
              נ“ Multiple
            </button>
          </div>
        </div>

        {/* Freeform Selection Controls */}
        {console.log(`נ¨ [RENDER] isMultiSelectActive: ${isMultiSelectActive}, freeformMarkers.length: ${freeformMarkers.length}`)}
        {isMultiSelectActive && (
          <div className="editor-section" style={{
            background: 'rgba(0, 255, 255, 0.3)',
            border: '3px solid cyan',
            borderRadius: '8px',
            padding: '12px',
            marginTop: '8px',
            marginBottom: '20px',
            maxHeight: 'none',
            overflow: 'visible',
            boxShadow: '0 0 20px rgba(0, 255, 255, 0.5)'
          }}>
            <div style={{
              fontSize: '16px',
              fontWeight: 'bold',
              color: 'cyan',
              textAlign: 'center',
              marginBottom: '12px',
              padding: '8px',
              background: 'rgba(0, 0, 0, 0.5)',
              borderRadius: '4px'
            }}>
              נ¯ FREEFORM SELECTION ACTIVE
            </div>
            <div style={{ 
              display: 'flex', 
              alignItems: 'center', 
              justifyContent: 'space-between',
              marginBottom: '10px'
            }}>
              <div style={{
                fontSize: '12px',
                color: '#06b6d4',
                fontWeight: 600
              }}>
                נ“ Markers: {freeformMarkers.length}
                {freeformMarkers.length >= 2 && ' | ג“ Polygon Active'}
              </div>
            </div>

            <div style={{
              fontSize: '11px',
              color: 'rgba(255, 255, 255, 0.7)',
              marginBottom: '10px',
              lineHeight: '1.4'
            }}>
              <div>ג€¢ <strong>Left-click</strong> to place markers</div>
              {freeformMarkers.length === 0 ? (
                <div style={{ color: '#fbbf24', marginTop: '4px' }}>
                  ג€¢ Click anywhere to start selection
                </div>
              ) : freeformMarkers.length < 3 ? (
                <div style={{ 
                  color: '#06b6d4', 
                  marginTop: '4px', 
                  fontWeight: 600,
                  background: 'rgba(6, 182, 212, 0.1)',
                  padding: '6px 8px',
                  borderRadius: '4px',
                  border: '1px solid rgba(6, 182, 212, 0.3)'
                }}>
                  נ“ Place {3 - freeformMarkers.length} more marker{3 - freeformMarkers.length === 1 ? '' : 's'} (min 3 for selection)
                </div>
              ) : (
                <div style={{ 
                  color: '#10b981', 
                  marginTop: '4px', 
                  fontWeight: 600,
                  background: 'rgba(16, 185, 129, 0.2)',
                  padding: '6px 8px',
                  borderRadius: '4px',
                  border: '1px solid rgba(16, 185, 129, 0.5)'
                }}>
                  ג… Ready! Click "Accept" button below to select nodes
                </div>
              )}
            </div>

            {freeformMarkers.length >= 1 && (
              <div style={{ 
                display: 'flex', 
                gap: '8px',
                marginTop: '12px',
                marginBottom: '20px',
                padding: '12px',
                background: 'rgba(0, 255, 255, 0.2)',
                borderRadius: '8px',
                border: '2px solid rgba(0, 255, 255, 0.5)',
                zIndex: 10000,
                position: 'relative'
              }}>
                <button
                  onClick={() => {
                    console.log(`ג… [FREEFORM] Accept button clicked with ${freeformMarkers.length} markers`);
                    if (freeformMarkers.length >= 3) {
                      finalizeSelection(freeformMarkers);
                    }
                  }}
                  disabled={freeformMarkers.length < 3}
                  style={{
                    flex: 1,
                    padding: '10px 16px',
                    background: freeformMarkers.length >= 3 
                      ? 'linear-gradient(135deg, #10b981, #059669)'
                      : 'linear-gradient(135deg, #6b7280, #4b5563)',
                    color: 'white',
                    border: 'none',
                    borderRadius: '8px',
                    cursor: freeformMarkers.length >= 3 ? 'pointer' : 'not-allowed',
                    fontSize: '13px',
                    fontWeight: 600,
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    gap: '6px',
                    transition: 'all 0.2s',
                    boxShadow: freeformMarkers.length >= 3 
                      ? '0 2px 4px rgba(16, 185, 129, 0.3)'
                      : '0 2px 4px rgba(0, 0, 0, 0.2)',
                    opacity: freeformMarkers.length >= 3 ? 1 : 0.6
                  }}
                  title={freeformMarkers.length >= 3 
                    ? "Accept selection and enable multi-node editing"
                    : `Place ${3 - freeformMarkers.length} more marker${3 - freeformMarkers.length === 1 ? '' : 's'} to enable selection`
                  }
                >
                  <span style={{ fontSize: '16px' }}>ג“</span>
                  <span>Accept {freeformMarkers.length < 3 && `(${freeformMarkers.length}/3)`}</span>
                </button>
                
                <button
                  onClick={clearFreeformSelection}
                  style={{
                    flex: 1,
                    padding: '10px 16px',
                    background: 'linear-gradient(135deg, #ef4444, #dc2626)',
                    color: 'white',
                    border: 'none',
                    borderRadius: '8px',
                    cursor: 'pointer',
                    fontSize: '13px',
                    fontWeight: 600,
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    gap: '6px',
                    transition: 'all 0.2s',
                    boxShadow: '0 2px 4px rgba(239, 68, 68, 0.3)'
                  }}
                  title="Reject selection and clear markers"
                >
                  <span style={{ fontSize: '16px' }}>ג—</span>
                  <span>Reject</span>
                </button>
              </div>
            )}
          </div>
        )}

        {/* Compact Stats */}
        <div className="editor-section stats">
          <div className="stat-item">
            <span className="stat-label">נ“ Nodes:</span>
            <span className="stat-value">{vertices.length}</span>
          </div>
        </div>

        {/* Compact Instructions */}
        <div className="editor-section instructions" style={{ 
          fontSize: '11px', 
          background: 'rgba(255, 255, 255, 0.05)',
          padding: '8px',
          borderRadius: '6px'
        }}>
          <div style={{ marginBottom: '4px', fontWeight: 600 }}>נ–±ן¸ Controls:</div>
          <div>ג€¢ <strong>Click</strong> node to select</div>
          <div>ג€¢ <strong>Drag</strong> to move</div>
          <div>ג€¢ <strong>Click line</strong> to add node</div>
          <div>ג€¢ <strong>Right-click</strong> to delete</div>
        </div>

        {/* Simplified Action Buttons */}
        <div className="editor-actions">
          <button 
            onClick={handleSave}
            className="btn btn-primary"
            disabled={isLoading || vertices.length < 3}
            style={{ flex: 1 }}
          >
            {isLoading ? 'ג³ Saving...' : 'ג“ Confirm'}
          </button>
          <button 
            onClick={onCancel}
            className="btn btn-cancel"
            disabled={isLoading}
            style={{ flex: 1 }}
          >
            ג— Cancel
          </button>
        </div>

        {/* Note about channel panel */}
        <div style={{
          marginTop: '12px',
          padding: '8px',
          background: 'rgba(33, 150, 243, 0.1)',
          border: '1px solid rgba(33, 150, 243, 0.3)',
          borderRadius: '6px',
          fontSize: '11px',
          color: '#60a5fa',
          lineHeight: '1.4'
        }}>
          נ’¡ <strong>Note:</strong> Your boundary will appear as a candidate in the channel panel where you can add details and campaign for votes.
        </div>
      </div>
    </div>
  );
};

export default GlobeBoundaryEditor;




























