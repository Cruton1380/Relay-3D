<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåç Relay Cesium World - Unified Application (Modular)</title>
    
    <!-- Cesium CSS (CDN - requires internet once to cache) -->
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.113/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    
    <!-- XLSX for Excel import (local) -->
    <script src="./libs/xlsx.full.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            overflow: hidden;
        }
        
        #cesiumContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        /* Drop zone overlay */
        #dropZone {
            position: absolute;
            top: 20px;
            right: 20px;
            left: auto;
            transform: none;
            padding: 16px 20px;
            background: rgba(20, 20, 30, 0.95);
            border: 2px dashed #00ddff;
            border-radius: 12px;
            text-align: center;
            pointer-events: all;
            z-index: 1000;
            transition: all 0.3s ease;
        }
        
        #dropZone.hidden {
            display: none;
            pointer-events: none;
        }
        
        #dropZone h2 {
            margin-bottom: 10px;
            color: #00ddff;
        }
        
        #dropZone p {
            color: #aaa;
        }
        
        /* Loading indicator */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px;
            background: rgba(20, 20, 30, 0.95);
            border-radius: 12px;
            text-align: center;
            z-index: 999;
        }
        
        #loading.hidden {
            display: none;
            pointer-events: none;
        }
        
        /* HUD (Heads-Up Display) */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.6;
            z-index: 500;
        }
        
        #hud div {
            margin: 2px 0;
        }

        /* Spreadsheet overlay (MVP) */
        #sheetOverlay {
            position: absolute;
            left: 20px;
            right: 20px;
            bottom: 20px;
            height: 140px;
            background: rgba(10, 10, 16, 0.9);
            border: 1px solid #2b2b35;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            color: #dcdcdc;
            z-index: 550;
            display: none;
            pointer-events: auto;
        }

        #sheetOverlay .bar {
            display: flex;
            gap: 10px;
            padding: 8px 10px;
            border-bottom: 1px solid #2b2b35;
            align-items: center;
        }

        #sheetOverlay .bar label {
            color: #aaa;
            font-size: 11px;
        }

        #sheetOverlay .bar .cell {
            color: #7fd3ff;
            font-weight: 600;
        }

        #sheetOverlay .body {
            padding: 10px;
            font-size: 12px;
            max-height: 70px;
            overflow: auto;
        }

        #sheetOverlay .value,
        #sheetOverlay .formula {
            margin-top: 6px;
            color: #cfcfcf;
            word-break: break-word;
        }

        #sheetOverlay .edit {
            margin-top: 8px;
        }

        #sheetOverlay input {
            width: 100%;
            padding: 6px 8px;
            background: #0f0f18;
            border: 1px solid #2b2b35;
            border-radius: 6px;
            color: #e6e6e6;
            font-family: inherit;
            font-size: 12px;
        }

        #sheetOverlay .hint {
            margin-top: 8px;
            color: #777;
            font-size: 11px;
        }
        
        /* Info panel */
        #infoPanel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            max-height: 50vh;
            padding: 15px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            overflow-y: auto;
            z-index: 500;
            display: none;
        }
        
        #infoPanel h3 {
            margin: 0 0 10px 0;
            color: #00ddff;
        }
        
        /* Log console */
        #logConsole {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 500px;
            max-height: 200px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            overflow-y: auto;
            z-index: 500;
        }
        
        #logConsole div {
            margin: 2px 0;
            padding: 2px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .log-error { color: #ff4444; }
        .log-warn { color: #ffaa00; }
        .log-info { color: #00ddff; }

        body.edit-sheet-mode #cesiumContainer {
            opacity: 0;
            pointer-events: none;
        }

        #sheetGridOverlay {
            position: absolute;
            inset: 0;
            z-index: 540;
            display: none;
            background: #0b1220;
        }

        body.edit-sheet-mode #sheetGridOverlay {
            display: block;
        }

        #sheetGridCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
</head>
<body>
    <div id="cesiumContainer"></div>
    <div id="sheetGridOverlay">
        <canvas id="sheetGridCanvas"></canvas>
    </div>
    
    <div id="dropZone">
        <h2>üìÇ Drop Excel File</h2>
        <p>Drop an .xlsx or .xls file to visualize</p>
    </div>
    
    <div id="loading">
        <h3>üåç Loading Relay...</h3>
        <p>Initializing Cesium viewer...</p>
    </div>
    
    <div id="hud"></div>
    <div id="infoPanel"></div>
    <div id="sheetOverlay">
        <div class="bar">
            <label>Sheet</label><span id="sheetOverlaySheet" class="cell">‚Äî</span>
            <label>Cell</label><span id="sheetOverlayCell" class="cell">‚Äî</span>
        </div>
        <div class="body">
            <div class="value" id="sheetOverlayValue">Value: ‚Äî</div>
            <div class="formula" id="sheetOverlayFormula">Formula: ‚Äî</div>
            <div class="edit"><input id="sheetOverlayInput" type="text" placeholder="Press F2 or double click to edit" disabled></div>
            <div class="hint">Enter to commit, Esc to cancel. Drag to select a range. Ctrl+C / Ctrl+V for range copy/paste.</div>
        </div>
    </div>
    <div id="logConsole"></div>
    
    <!-- Cesium JS (CDN - requires internet once to cache) -->
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.113/Build/Cesium/Cesium.js"></script>
    
    <!-- Relay Core Modules (Lock B: Modular Architecture, Lock F: Core cannot import Cesium) -->
    <script type="module">
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // RELAY CESIUM WORLD - MODULAR VERSION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // Lock B: Thin entrypoint, implementation in modules
        // Lock F: core/** cannot import Cesium
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Import core utilities and services (renderer-agnostic)
        import { RelayLog } from './core/utils/relay-log.js';
        import { relayState, getTreeStats } from './core/models/relay-state.js';
        import { RelayLODGovernor } from './core/services/lod-governor.js';
        
        // Import Cesium-specific modules
        import { initializeCesiumViewer, getCameraHeightAboveGround } from './app/cesium/viewer-init.js';
        import { CesiumFilamentRenderer } from './app/renderers/filament-renderer.js';
        import { RelationshipRenderer } from './app/renderers/relationship-renderer.js';
        import { BoundaryRenderer } from './app/renderers/boundary-renderer.js';
        import { HUDManager } from './app/ui/hud-manager.js';
        import { ExcelImporter } from './app/excel-importer.js';
        
        // Make key objects globally accessible for debugging
        window.RelayLog = RelayLog;
        window.relayState = relayState;
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // INITIALIZATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let viewer = null;
        let lodGovernor = null;
        let filamentRenderer = null;
        let relationshipRenderer = null;
        let boundaryRenderer = null;
        let hudManager = null;
        let excelImporter = null;
        let flightControls = null;
        let sheetOverlay = null;
        let sheetOverlaySheet = null;
        let sheetOverlayCell = null;
        let sheetOverlayValue = null;
        let sheetOverlayFormula = null;
        let sheetOverlayInput = null;
        let sheetOverlayBody = null;
        let editSheetWheelHandler = null;
        let editSheetKeyHandler = null;
        let editSheetInputLogged = false;
        let suppressPointerLock = false;
        let editSheetAutoCooldownUntil = 0;
        window.AUTO_EDIT_SHEET = true;
        let sheetGridOverlay = null;
        let sheetGridCanvas = null;
        let sheetGridCtx = null;
        let editSheetTargetSheet = null;
        let sheetRange = null;
        let rangeDragAnchor = null;
        let rangeDragLast = null;
        let isRangeDragging = false;
        let isEditSheetMode = false;
        let hoveredCellEntity = null;
        let copyBuffer = null;
        let cellEntityIndex = new Map();
        let sheetSelection = null;

        const canEnterEditSheet = (sheet) => {
            if (!viewer || !sheet?._center) return false;
            const camPos = viewer.camera.position;
            const distance = Cesium.Cartesian3.distance(camPos, sheet._center);
            const renderNormal = sheet._renderNormal || sheet._normal || Cesium.Cartesian3.UNIT_Z;
            const toCam = Cesium.Cartesian3.normalize(
                Cesium.Cartesian3.subtract(camPos, sheet._center, new Cesium.Cartesian3()),
                new Cesium.Cartesian3()
            );
            const alignDot = Cesium.Cartesian3.dot(
                Cesium.Cartesian3.normalize(renderNormal, new Cesium.Cartesian3()),
                toCam
            );
            const closeEnough = distance <= 650;
            const alignedEnough = alignDot >= 0.96;
            return closeEnough && alignedEnough;
        };
        let isEditingCell = false;
        const CAMERA_STORAGE_KEY = 'relay.camera.v1';
        const DEBUG_RANGE_STORAGE_KEY = 'relay.debugRangeOps.v1';
        const DEBUG_SPINE_STORAGE_KEY = 'relay.debugSpineGuide.v1';
        const COMPANY_MARKERS_STORAGE_KEY = 'relay.showCompanyMarkers.v1';
        const ACTIVE_MARKERS_STORAGE_KEY = 'relay.showActiveMarkers.v1';
        const ACTIVE_MARKER_MODE_STORAGE_KEY = 'relay.activeMarkerMode.v1';
        const CAMERA_SAVE_THROTTLE_MS = 250;
        let lastCameraSave = 0;
        
        // LOD lock state (top-level scope for render loop access)
        let lodLocked = false;
        let lodLockedLevel = null;
        
        async function initialize() {
            try {
                // SAFE GUARD: ignore InvalidStateError from pointer capture
                if (!window.__relayPointerCaptureShim) {
                    const _spc = Element.prototype.setPointerCapture;
                    Element.prototype.setPointerCapture = function(id) {
                        try {
                            return _spc.call(this, id);
                        } catch (e) {
                            if (e && e.name === 'InvalidStateError') return;
                            throw e;
                        }
                    };
                    window.__relayPointerCaptureShim = true;
                }

                // Set up logging UI
                RelayLog.setLevel(3); // info
                RelayLog.setUIElement(document.getElementById('logConsole'));
                
                RelayLog.info('üöÄ Relay Cesium World starting...');
                
                // Initialize Cesium viewer (no Ion token - using free providers)
                viewer = await initializeCesiumViewer('cesiumContainer', {
                    buildings: true,
                    lighting: true,
                    fog: true,
                    skyAtmosphere: true,  // Enable atmosphere for surface reference
                    initialPosition: {
                        lon: 34.7818,
                        lat: 32.0853,
                        height: 15000,
                        heading: 0,
                        pitch: -45,
                        roll: 0
                    }
                });
                
                // Add visual surface reference (horizon/limb line)
                viewer.scene.globe.enableLighting = true;
                viewer.scene.globe.showGroundAtmosphere = true;
                viewer.scene.skyAtmosphere.show = true;
                window.viewer = viewer; // Global for debugging

                // Restore last camera POV if present
                window.__relayCameraRestored = restoreCameraState(viewer) === true;
                viewer.camera.changed.addEventListener(() => saveCameraState(viewer));
                window.addEventListener('beforeunload', () => saveCameraState(viewer, true));
                
                // Restore free-fly camera controls (Three.js-like)
                flightControls = setupFlightControls(viewer);
                
                // Initialize LOD Governor
                lodGovernor = new RelayLODGovernor();
                lodGovernor.startMonitoring();
                
                lodGovernor.subscribe((newLevel, oldLevel) => {
                    RelayLog.info(`üîÑ LOD: ${oldLevel || 'NONE'} ‚Üí ${newLevel}`);
                    if (filamentRenderer) {
                        filamentRenderer.setLOD(newLevel);
                        if (relayState.tree.nodes.length > 0) {
                            filamentRenderer.renderTree();
                        }
                    }
                });
                
                // Initialize Filament Renderer
                filamentRenderer = new CesiumFilamentRenderer(viewer);
                window.filamentRenderer = filamentRenderer; // Global for debugging
                
                // Initialize Relationship Renderer (for global connections)
                relationshipRenderer = new RelationshipRenderer(viewer, relayState);
                window.relationshipRenderer = relationshipRenderer; // Global for debugging
                
                // Clear any proof mode remnants from previous sessions
                relationshipRenderer.clear();
                filamentRenderer.clear();
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // BOUNDARIES: TEMPORARILY DISABLED DUE TO CESIUM RENDER CRASH
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const ENABLE_BOUNDARIES = false;  // Set to true after debugging
                
                let boundaryStatus = 'DISABLED';
                
                if (ENABLE_BOUNDARIES) {
                    // Initialize Boundary Renderer (v93 boundaries restored)
                    // FAIL-SOFT: Boundary failures must not crash tree rendering
                    boundaryRenderer = new BoundaryRenderer(viewer, relayState);
                    window.boundaryRenderer = boundaryRenderer; // Global for debugging
                    
                    // Load boundaries asynchronously (non-blocking, fail-soft)
                    RelayLog.info('üåç Loading boundaries (fail-soft)...');
                    boundaryStatus = 'LOADING';
                    
                    Promise.all([
                        boundaryRenderer.loadIsrael(),
                        boundaryRenderer.loadUSA()
                    ]).then(([israelCount, usaCount]) => {
                        const totalLoaded = israelCount + usaCount;
                        if (totalLoaded > 0) {
                            boundaryStatus = 'ACTIVE';
                            RelayLog.info(`‚úÖ Boundaries loaded: ISR=${israelCount}, USA=${usaCount}`);
                        } else {
                            boundaryStatus = 'DEGRADED';
                            RelayLog.warn('‚ö†Ô∏è Boundaries DEGRADED: No features loaded (continuing without)');
                        }
                    }).catch(error => {
                        boundaryStatus = 'DEGRADED';
                        RelayLog.warn('‚ö†Ô∏è Boundaries DEGRADED: Load failed (continuing without):', error.message);
                    });
                } else {
                    RelayLog.warn('‚ö†Ô∏è Boundaries DISABLED (ENABLE_BOUNDARIES = false)');
                }
                
                // Expose capability status for HUD
                window.getBoundaryStatus = () => boundaryStatus;
                let buildingsStatus = 'UNKNOWN';
                window.getBuildingsStatus = () => buildingsStatus;
                window.setBuildingsStatus = (status) => { buildingsStatus = status; };
                window.getFilamentMode = () => 'PRIMITIVE';  // Phase 2.1: Now using primitives
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // SINGLE BRANCH PROOF MODE (Step 1)
                // Phase 2.1 PASSED - Now restoring full tree (Phase 2.2)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                window.SINGLE_BRANCH_PROOF = false;  // Full tree by default
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // DEMO TREE: Show filament system working immediately
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                RelayLog.info('üå≤ Loading demo tree...');
                
                // Create sample company tree at Tel Aviv
                // CANONICAL PHASE 2.1: ENU-BASED TREE TOPOLOGY
                // 
                // All geometry is now defined in ENU meters (not degree offsets).
                // The lat/lon values below are ONLY for the trunk anchor point.
                // All branches, sheets, and filaments are positioned using ENU offsets
                // in meters via the FilamentRenderer and CANONICAL_LAYOUT constants.
                // 
                // CANONICAL TREE TOPOLOGY:
                // - Trunk: Vertical along ENU Up (local +Z, not world Z)
                // - Branches: Parallel ribs along ENU East (+X), tight spacing in ENU North (+Y)
                // - Sheets: Horizontal planes (ENU Up normal), above branch endpoints
                // - Filaments: Staged (Cell ‚Üí Spine ‚Üí Branch conduit)
                // - Timeboxes: Dynamic spacing (length-derived or commit-window-derived)
                
                const trunkLat = 32.0853;  // Trunk anchor only
                const trunkLon = 34.7818;  // Trunk anchor only
                
                // NOTE: branchSpacing and branchLength below are DEPRECATED
                // All geometry is now computed in ENU meters via CANONICAL_LAYOUT
                // These values are kept for backwards compatibility with sheet lat/lon
                // but are NOT used by the primitive renderer
                const branchSpacing = 0.0002;  // DEPRECATED: Use CANONICAL_LAYOUT.branch.separation (35m)
                const branchLength = 0.005;    // DEPRECATED: Use CANONICAL_LAYOUT.branch.length (800m)
                
                const demoTree = {
                    nodes: [
                        {
                            id: "trunk.avgol",
                            type: "trunk",
                            name: "Avgol",
                            lat: trunkLat,
                            lon: trunkLon,
                            height: 0,        // Ground
                            alt: 2000,        // Top at 2000m
                            // More granular timeboxes
                            commits: [
                                { timeboxId: 'T1', commitCount: 25, openDrifts: 1, eriAvg: 82, scarCount: 0 },
                                { timeboxId: 'T2', commitCount: 22, openDrifts: 0, eriAvg: 85, scarCount: 0 },
                                { timeboxId: 'T3', commitCount: 28, openDrifts: 2, eriAvg: 78, scarCount: 1 },
                                { timeboxId: 'T4', commitCount: 30, openDrifts: 0, eriAvg: 88, scarCount: 0 },
                                { timeboxId: 'T5', commitCount: 26, openDrifts: 1, eriAvg: 84, scarCount: 0 },
                                { timeboxId: 'T6', commitCount: 32, openDrifts: 3, eriAvg: 76, scarCount: 2 }
                            ]
                        },
                        {
                            id: "branch.operations",
                            type: "branch",
                            name: "Operations",
                            parent: "trunk.avgol",
                            // PARALLEL: Along +X axis from trunk top
                            lat: trunkLat,                    // SAME latitude (tight)
                            lon: trunkLon + branchLength,     // +X direction
                            alt: 2000,                        // AT trunk top (not above)
                            // More granular timeboxes
                            commits: [
                                { timeboxId: 'B1-T1', commitCount: 12, openDrifts: 0, eriAvg: 80, scarCount: 0 },
                                { timeboxId: 'B1-T2', commitCount: 15, openDrifts: 1, eriAvg: 78, scarCount: 0 },
                                { timeboxId: 'B1-T3', commitCount: 18, openDrifts: 0, eriAvg: 82, scarCount: 0 },
                                { timeboxId: 'B1-T4', commitCount: 14, openDrifts: 2, eriAvg: 74, scarCount: 1 }
                            ]
                        },
                        {
                            id: "sheet.packaging",
                            type: "sheet",
                            name: "Packaging Division",
                            parent: "branch.operations",
                            // VERTICAL: Perpendicular to branch, facing BACK down branch (toward trunk)
                            // Position computed by renderer: branch endpoint + 300m along branch tangent
                            // Sheet normal = -T (branch tangent), NOT world Up
                            // (lat/lon/alt below are IGNORED by renderer - kept for legacy compatibility only)
                            lat: trunkLat,
                            lon: trunkLon + branchLength,
                            alt: 2300,
                            eri: 85,
                            rows: 8,
                            cols: 6,
                            // Cell-level timebox data (Phase 3)
                            cellData: [
                                // Row 0
                                { row: 0, col: 0, timeboxCount: 8, hasFormula: true, formula: '=SUM(A2:A10)' },
                                { row: 0, col: 1, timeboxCount: 5, hasFormula: false },
                                { row: 0, col: 2, timeboxCount: 12, hasFormula: true, formula: '=VLOOKUP(A1)' },
                                { row: 0, col: 3, timeboxCount: 3, hasFormula: false },
                                { row: 0, col: 4, timeboxCount: 10, hasFormula: true, formula: '=IF(B1>100)' },
                                { row: 0, col: 5, timeboxCount: 6, hasFormula: false },
                                // Row 1
                                { row: 1, col: 0, timeboxCount: 15, hasFormula: true, formula: '=A1*1.15' },
                                { row: 1, col: 1, timeboxCount: 4, hasFormula: false },
                                { row: 1, col: 2, timeboxCount: 9, hasFormula: true, formula: '=INDEX()' },
                                { row: 1, col: 3, timeboxCount: 7, hasFormula: false },
                                { row: 1, col: 4, timeboxCount: 11, hasFormula: true, formula: '=SUMIFS()' },
                                { row: 1, col: 5, timeboxCount: 2, hasFormula: false },
                                // Row 2
                                { row: 2, col: 0, timeboxCount: 6, hasFormula: false },
                                { row: 2, col: 1, timeboxCount: 13, hasFormula: true, formula: '=AVERAGE()' },
                                { row: 2, col: 2, timeboxCount: 8, hasFormula: false },
                                { row: 2, col: 3, timeboxCount: 10, hasFormula: true, formula: '=COUNTIF()' },
                                { row: 2, col: 4, timeboxCount: 5, hasFormula: false },
                                { row: 2, col: 5, timeboxCount: 14, hasFormula: true, formula: '=CONCAT()' },
                                // Row 3
                                { row: 3, col: 0, timeboxCount: 4, hasFormula: false },
                                { row: 3, col: 1, timeboxCount: 7, hasFormula: true, formula: '=MATCH()' },
                                { row: 3, col: 2, timeboxCount: 3, hasFormula: false },
                                { row: 3, col: 3, timeboxCount: 12, hasFormula: true, formula: '=PMT()' },
                                { row: 3, col: 4, timeboxCount: 6, hasFormula: false },
                                { row: 3, col: 5, timeboxCount: 9, hasFormula: true, formula: '=NPV()' },
                                // Row 4
                                { row: 4, col: 0, timeboxCount: 11, hasFormula: true, formula: '=TREND()' },
                                { row: 4, col: 1, timeboxCount: 5, hasFormula: false },
                                { row: 4, col: 2, timeboxCount: 8, hasFormula: true, formula: '=FORECAST()' },
                                { row: 4, col: 3, timeboxCount: 4, hasFormula: false },
                                { row: 4, col: 4, timeboxCount: 10, hasFormula: true, formula: '=RATE()' },
                                { row: 4, col: 5, timeboxCount: 7, hasFormula: false },
                                // Row 5
                                { row: 5, col: 0, timeboxCount: 6, hasFormula: false },
                                { row: 5, col: 1, timeboxCount: 14, hasFormula: true, formula: '=IRR()' },
                                { row: 5, col: 2, timeboxCount: 3, hasFormula: false },
                                { row: 5, col: 3, timeboxCount: 9, hasFormula: true, formula: '=FV()' },
                                { row: 5, col: 4, timeboxCount: 5, hasFormula: false },
                                { row: 5, col: 5, timeboxCount: 12, hasFormula: true, formula: '=PV()' },
                                // Row 6
                                { row: 6, col: 0, timeboxCount: 8, hasFormula: true, formula: '=XNPV()' },
                                { row: 6, col: 1, timeboxCount: 4, hasFormula: false },
                                { row: 6, col: 2, timeboxCount: 11, hasFormula: true, formula: '=XIRR()' },
                                { row: 6, col: 3, timeboxCount: 6, hasFormula: false },
                                { row: 6, col: 4, timeboxCount: 13, hasFormula: true, formula: '=MIRR()' },
                                { row: 6, col: 5, timeboxCount: 7, hasFormula: false },
                                // Row 7
                                { row: 7, col: 0, timeboxCount: 5, hasFormula: false },
                                { row: 7, col: 1, timeboxCount: 10, hasFormula: true, formula: '=NPER()' },
                                { row: 7, col: 2, timeboxCount: 4, hasFormula: false },
                                { row: 7, col: 3, timeboxCount: 8, hasFormula: true, formula: '=SLN()' },
                                { row: 7, col: 4, timeboxCount: 6, hasFormula: false },
                                { row: 7, col: 5, timeboxCount: 15, hasFormula: true, formula: '=DDB()' }
                            ]
                        },
                        // NOTE: Demo tree intentionally uses a single branch + sheet
                    ],
                    edges: [
                        { source: "trunk.avgol", target: "branch.operations" },
                        { source: "branch.operations", target: "sheet.packaging" }
                    ]
                };
                
                // Load demo tree into relayState
                relayState.tree.nodes = demoTree.nodes;
                relayState.tree.edges = demoTree.edges;
                
                // Render demo tree
                filamentRenderer.renderTree();
                
                RelayLog.info(`‚úÖ Demo tree rendered: Avgol @ Tel Aviv`);
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // CANONICAL CAMERA PRESETS (Phase 2.1)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                window.setTopDownView = () => {
                    const sheets = relayState.tree.nodes.filter(n => n.type === 'sheet');
                    const sheet = sheets.find(s => s._center && s._normal) || sheets[0];
                    if (!sheet || !sheet._center || !sheet._normal) {
                        RelayLog.warn('‚ö†Ô∏è Sheet top-down view unavailable (sheet not ready)');
                        return;
                    }
                    RelayLog.info('[CAM] SheetTopDown: grid readability mode');
                    const normal = Cesium.Cartesian3.normalize(sheet._normal, new Cesium.Cartesian3());
                    const offset = Cesium.Cartesian3.multiplyByScalar(normal, 1200, new Cesium.Cartesian3());
                    const cameraPos = Cesium.Cartesian3.add(sheet._center, offset, new Cesium.Cartesian3());
                    const direction = Cesium.Cartesian3.normalize(
                        Cesium.Cartesian3.subtract(sheet._center, cameraPos, new Cesium.Cartesian3()),
                        new Cesium.Cartesian3()
                    );
                    viewer.camera.setView({
                        destination: cameraPos,
                        orientation: {
                            direction,
                            up: sheet._xAxis || Cesium.Cartesian3.UNIT_Z
                        }
                    });
                };
                
                window.setSideProfileView = () => {
                    RelayLog.info('üì∑ Camera: Side Profile View');
                    viewer.camera.setView({
                        destination: Cesium.Cartesian3.fromDegrees(trunkLon - 0.02, trunkLat, 2500),
                        orientation: {
                            heading: Cesium.Math.toRadians(90),  // Looking at tree from side
                            pitch: 0,
                            roll: 0
                        }
                    });
                };
                
                // LookDownBranch: Camera positioned behind trunk, looking along branch tangent toward sheet
                // This is the "page in a book" view - sheet should appear face-on
                window.setLookDownBranchView = () => {
                    RelayLog.info('[CAM] SheetFaceOn: look down branch');
                    
                    // Find first branch with frames
                    const tree = relayState.tree;
                    const branch = tree.nodes.find(n => n.type === 'branch' && n._branchFrames);
                    
                    if (!branch) {
                        RelayLog.warn('‚ö†Ô∏è No branch with frames found');
                        return;
                    }
                    
                    // Get branch frame at endpoint
                    const frame = branch._branchFrames[branch._branchFrames.length - 1];
                    const branchEndWorld = branch._worldEndpoint;
                    const enuFrame = branch._enuFrame;
                    
                    // Convert frame vectors to world directions
                    const enuOrigin = new Cesium.Cartesian3();
                    Cesium.Matrix4.multiplyByPoint(enuFrame, new Cesium.Cartesian3(0, 0, 0), enuOrigin);
                    
                    const enuT = new Cesium.Cartesian3(frame.T.east, frame.T.north, frame.T.up);
                    const enuN = new Cesium.Cartesian3(frame.N.east, frame.N.north, frame.N.up);
                    Cesium.Matrix4.multiplyByPointAsVector(enuFrame, enuT, enuT);
                    Cesium.Matrix4.multiplyByPointAsVector(enuFrame, enuN, enuN);
                    Cesium.Cartesian3.normalize(enuT, enuT);
                    Cesium.Cartesian3.normalize(enuN, enuN);
                    
                    // Position camera 450m back from branch endpoint along -T, 120m up along +N
                    const back = Cesium.Cartesian3.multiplyByScalar(enuT, -450, new Cesium.Cartesian3());
                    const up = Cesium.Cartesian3.multiplyByScalar(enuN, 120, new Cesium.Cartesian3());
                    
                    const cameraPos = Cesium.Cartesian3.add(branchEndWorld, back, new Cesium.Cartesian3());
                    Cesium.Cartesian3.add(cameraPos, up, cameraPos);
                    
                    // Look toward branch endpoint (along +T)
                    const direction = Cesium.Cartesian3.subtract(branchEndWorld, cameraPos, new Cesium.Cartesian3());
                    Cesium.Cartesian3.normalize(direction, direction);
                    
                    viewer.camera.setView({
                        destination: cameraPos,
                        orientation: {
                            direction: direction,
                            up: enuN
                        }
                    });
                };

                window.setSpineInspectionView = () => {
                    const sheets = relayState.tree.nodes.filter(n => n.type === 'sheet');
                    const sheet = sheets.find(s => s._center && s._normal) || sheets[0];
                    if (!sheet || !sheet._center || !sheet._normal) {
                        RelayLog.warn('‚ö†Ô∏è Spine inspection unavailable (sheet not ready)');
                        return;
                    }
                    const spine = window.cellAnchors?.[sheet.id]?.spine;
                    if (!spine) {
                        RelayLog.warn('‚ö†Ô∏è Spine inspection unavailable (spine not ready)');
                        return;
                    }
                    RelayLog.info('[CAM] SpineInspection: comb readability mode');
                    const right = sheet._yAxis || Cesium.Cartesian3.UNIT_X;
                    const up = sheet._xAxis || Cesium.Cartesian3.UNIT_Z;
                    const offset = Cesium.Cartesian3.add(
                        Cesium.Cartesian3.multiplyByScalar(right, 220, new Cesium.Cartesian3()),
                        Cesium.Cartesian3.multiplyByScalar(up, 140, new Cesium.Cartesian3()),
                        new Cesium.Cartesian3()
                    );
                    const cameraPos = Cesium.Cartesian3.add(spine, offset, new Cesium.Cartesian3());
                    const direction = Cesium.Cartesian3.normalize(
                        Cesium.Cartesian3.subtract(spine, cameraPos, new Cesium.Cartesian3()),
                        new Cesium.Cartesian3()
                    );
                    viewer.camera.setView({
                        destination: cameraPos,
                        orientation: {
                            direction,
                            up
                        }
                    });
                };
                
                // LOD Lock feature (for debugging tree at SHEET level)
                // Note: lodLocked and lodLockedLevel are declared at top-level scope
                window.toggleLODLock = () => {
                    if (!lodLocked) {
                        // Lock LOD at current level
                        lodLockedLevel = lodGovernor.getCurrentLevel();
                        lodLocked = true;
                        RelayLog.info(`üîí LOD locked at: ${lodLockedLevel}`);
                    } else {
                        // Unlock LOD
                        lodLocked = false;
                        lodLockedLevel = null;
                        RelayLog.info(`üîì LOD unlocked (governor active)`);
                    }
                };
                
                const getAggregateCFStatus = (tree) => {
                    const sheets = tree?.nodes?.filter(n => n.type === 'sheet') || [];
                    if (sheets.length === 0) return 'INDETERMINATE';
                    const statuses = sheets.map(s => s?.metadata?.cfStatus).filter(Boolean);
                    if (statuses.length === 0) return 'INDETERMINATE';
                    if (statuses.every(s => s === 'VERIFIED')) return 'VERIFIED';
                    if (statuses.every(s => s === 'INDETERMINATE')) return 'INDETERMINATE';
                    return 'MIXED';
                };

                window.setSpreadsheetProofView = () => {
                    const sheets = relayState.tree.nodes.filter(n => n.type === 'sheet');
                    const sheet = sheets.find(s => s._center && s._normal) || sheets[0];
                    if (!sheet || !sheet._center || !sheet._normal) {
                        RelayLog.warn('‚ö†Ô∏è Spreadsheet proof view unavailable (sheet not ready)');
                        return;
                    }
                    const normal = Cesium.Cartesian3.normalize(sheet._normal, new Cesium.Cartesian3());
                    const up = sheet._xAxis ? Cesium.Cartesian3.normalize(sheet._xAxis, new Cesium.Cartesian3()) : Cesium.Cartesian3.UNIT_Z;
                    const offset = Cesium.Cartesian3.add(
                        Cesium.Cartesian3.multiplyByScalar(normal, 900, new Cesium.Cartesian3()),
                        Cesium.Cartesian3.multiplyByScalar(up, 220, new Cesium.Cartesian3()),
                        new Cesium.Cartesian3()
                    );
                    const cameraPos = Cesium.Cartesian3.add(sheet._center, offset, new Cesium.Cartesian3());
                    const direction = Cesium.Cartesian3.normalize(
                        Cesium.Cartesian3.subtract(sheet._center, cameraPos, new Cesium.Cartesian3()),
                        new Cesium.Cartesian3()
                    );
                    viewer.camera.setView({
                        destination: cameraPos,
                        orientation: {
                            direction,
                            up
                        }
                    });
                };

                window.enterEditSheetMode = (sheet) => {
                    if (isEditSheetMode) return;
                    isEditSheetMode = true;
                    suppressPointerLock = true;
                    if (document.pointerLockElement) {
                        document.exitPointerLock();
                    }
                    if (viewer?.scene?.screenSpaceCameraController) {
                        viewer.scene.screenSpaceCameraController.enableInputs = false;
                    }
                    lodLocked = true;
                    lodLockedLevel = 'SHEET';
                    RelayLog.info('[MODE] enter EDIT_SHEET');
                    RelayLog.info('[LOD] editSheet override=ON level=SHEET');
                    window.setCompanyTopDownView(sheet || editSheetTargetSheet);
                    hudManager.update({ editSheetMode: true });
                    document.body.classList.add('edit-sheet-mode');
                    if (sheetOverlay) {
                        sheetOverlay.style.pointerEvents = 'auto';
                    }
                    if (sheetGridOverlay) {
                        sheetGridOverlay.style.pointerEvents = 'auto';
                    }
                    renderGridOverlay();
                    if (!editSheetWheelHandler) {
                        editSheetWheelHandler = (event) => {
                            if (!isEditSheetMode) return;
                            event.preventDefault();
                            event.stopPropagation();
                            if (sheetOverlayBody) {
                                sheetOverlayBody.scrollTop += event.deltaY;
                            }
                        };
                    }
                    if (!editSheetKeyHandler) {
                        editSheetKeyHandler = (event) => {
                            if (!isEditSheetMode || isEditingCell) return;
                            const key = event.key;
                            const isPrintable = key.length === 1 && !event.ctrlKey && !event.metaKey && !event.altKey;
                            const isNavKey = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Tab', 'Enter', 'Backspace'].includes(key);
                            if (!isPrintable && !isNavKey) return;
                            event.preventDefault();
                            event.stopPropagation();
                            if (key === 'ArrowUp') moveSelectionBy(-1, 0);
                            else if (key === 'ArrowDown') moveSelectionBy(1, 0);
                            else if (key === 'ArrowLeft') moveSelectionBy(0, -1);
                            else if (key === 'ArrowRight') moveSelectionBy(0, 1);
                            else if (key === 'Enter') beginEdit();
                            else if (isPrintable) {
                                beginEdit();
                                if (!sheetOverlayInput?.disabled) {
                                    sheetOverlayInput.value = key;
                                    sheetOverlayInput.setSelectionRange(1, 1);
                                }
                            }
                        };
                    }
                    const wheelTarget = sheetGridOverlay || sheetOverlay;
                    if (wheelTarget) {
                        wheelTarget.addEventListener('wheel', editSheetWheelHandler, { passive: false });
                    }
                    document.addEventListener('keydown', editSheetKeyHandler, true);
                    if (!editSheetInputLogged) {
                        RelayLog.info('[MODE] EDIT_SHEET inputOwner=GRID wheelCaptured=true keyCaptured=true');
                        editSheetInputLogged = true;
                    }
                };

                window.exitEditSheetMode = () => {
                    if (!isEditSheetMode) return;
                    isEditSheetMode = false;
                    suppressPointerLock = false;
                    lodLocked = false;
                    lodLockedLevel = null;
                    RelayLog.info('[MODE] exit EDIT_SHEET');
                    hudManager.update({ editSheetMode: false });
                    document.body.classList.remove('edit-sheet-mode');
                    if (viewer?.scene?.screenSpaceCameraController) {
                        viewer.scene.screenSpaceCameraController.enableInputs = true;
                    }
                    const wheelTarget = sheetGridOverlay || sheetOverlay;
                    if (wheelTarget && editSheetWheelHandler) {
                        wheelTarget.removeEventListener('wheel', editSheetWheelHandler);
                    }
                    if (editSheetKeyHandler) {
                        document.removeEventListener('keydown', editSheetKeyHandler, true);
                    }
                };

                // Keyboard shortcuts for camera presets + LOD lock
                document.addEventListener('keydown', (event) => {
                    if (event.key === 'Escape' && isEditSheetMode && !isEditingCell) {
                        event.preventDefault();
                        window.exitEditSheetMode();
                        return;
                    }
                    if (event.key === '1') {
                        window.setTopDownView();
                    } else if (event.key === '2') {
                        window.setSideProfileView();
                    } else if (event.key === '3') {
                        window.setLookDownBranchView();
                    } else if (event.key === '4') {
                        window.setSpreadsheetProofView();
                    } else if (event.key === '5') {
                        window.setSpineInspectionView();
                    } else if (event.key === 'P' || event.key === 'p') {
                        // Proof capture: force LOD, enable formula lens, emit consolidated logs
                        if (!lodLocked) {
                            lodLocked = true;
                            lodLockedLevel = 'SHEET';
                            RelayLog.info('üîí LOD locked at: SHEET (proof capture)');
                        }
                        if (filamentRenderer) {
                            filamentRenderer.setLOD('SHEET');
                            filamentRenderer.renderTree();
                        }
                        
                        if (hudManager) {
                            const proofLensState = { value: false, formula: true, cf: false, history: true };
                            hudManager.setLensState(proofLensState);
                        }
                        
                        let formulaStats = { edgesRendered: 0, cyclesDetected: 0, scarsRendered: 0 };
                        if (filamentRenderer) {
                            formulaStats = filamentRenderer.renderFormulaDependencies() || formulaStats;
                        }
                        const p3a = filamentRenderer?.lastP3A || {};
                        RelayLog.info('[PROOF] P3-A exitDotToBranchMax=' + (Number.isFinite(p3a.exitDotToBranchMax) ? p3a.exitDotToBranchMax.toFixed(3) : 'n/a'));
                        RelayLog.info('[PROOF] P3-A slabAngleDeltaMaxDeg=' + (Number.isFinite(p3a.slabAngleDeltaMaxDeg) ? p3a.slabAngleDeltaMaxDeg.toFixed(3) : 'n/a'));
                        RelayLog.info('[PROOF] P3-A stage2ConduitsPerSheet=' + (Number.isFinite(p3a.stage2ConduitsPerSheet) ? p3a.stage2ConduitsPerSheet : 'n/a'));
                        RelayLog.info('[PROOF] F2 formulaEdgesRendered=' + formulaStats.edgesRendered);
                        RelayLog.info('[PROOF] F2 cyclesDetected=' + formulaStats.cyclesDetected);
                        RelayLog.info('[PROOF] F2 scarsRendered=' + formulaStats.scarsRendered);
                    } else if (event.key === 'L' || event.key === 'l') {
                        window.toggleLODLock();
                    }
                });
                
                RelayLog.info('üì∑ Camera presets: Press 1=SheetTopDown, 2=SideProfile, 3=SheetFaceOn, 4=SpreadsheetProof, 5=SpineInspection');
                RelayLog.info('üîí LOD Lock: Press L to lock/unlock LOD at current level');
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                
                // Initialize HUD Manager
                hudManager = new HUDManager('hud');
                const lensState = { value: false, formula: false, cf: false, history: true };
                hudManager.setLensState(lensState);
                hudManager.setLensToggleHandler((lens, enabled) => {
                    lensState[lens] = enabled;
                    hudManager.setLensState(lensState);
                    
                    if (lens === 'formula') {
                        if (enabled) {
                            const stats = filamentRenderer.renderFormulaDependencies();
                            hudManager.update({
                                formulaCycles: stats.cyclesDetected,
                                formulaScars: stats.scarsRendered
                            });
                        } else {
                            filamentRenderer.clearFormulaDependencies();
                            hudManager.update({ formulaCycles: 0, formulaScars: 0 });
                        }
                    } else if (lens === 'cf') {
                        const cfStatus = getAggregateCFStatus(relayState.tree);
                        hudManager.update({ cfStatus });
                        RelayLog.info(`[CF] lens=${enabled ? 'ON' : 'OFF'} status=${cfStatus}`);
                    }
                });
                const storedDebugRange = localStorage.getItem(DEBUG_RANGE_STORAGE_KEY);
                window.DEBUG_RANGE_OPS = storedDebugRange === 'true';
                const storedDebugSpine = localStorage.getItem(DEBUG_SPINE_STORAGE_KEY);
                window.DEBUG_SPINE_GUIDE = storedDebugSpine === 'true';
                window.IMPORT_MODE = 'ATTACH_TO_TEMPLATE';
                const storedCompanyMarkers = localStorage.getItem(COMPANY_MARKERS_STORAGE_KEY);
                window.SHOW_CELL_MARKERS_AT_COMPANY = storedCompanyMarkers === 'true';
                const storedActiveMarkers = localStorage.getItem(ACTIVE_MARKERS_STORAGE_KEY);
                window.SHOW_ACTIVE_MARKERS = storedActiveMarkers !== 'false';
                const storedActiveMode = localStorage.getItem(ACTIVE_MARKER_MODE_STORAGE_KEY);
                window.ACTIVE_MARKER_MODE = storedActiveMode || 'auto';
                hudManager.update({
                    debugRangeOps: window.DEBUG_RANGE_OPS,
                    debugSpineGuide: window.DEBUG_SPINE_GUIDE,
                    showCellMarkersAtCompany: window.SHOW_CELL_MARKERS_AT_COMPANY,
                    showActiveMarkers: window.SHOW_ACTIVE_MARKERS,
                    activeMarkerMode: window.ACTIVE_MARKER_MODE
                });
                hudManager.setDebugRangeToggleHandler((enabled) => {
                    window.DEBUG_RANGE_OPS = !!enabled;
                    localStorage.setItem(DEBUG_RANGE_STORAGE_KEY, window.DEBUG_RANGE_OPS ? 'true' : 'false');
                    hudManager.update({ debugRangeOps: window.DEBUG_RANGE_OPS });
                    RelayLog.info(`[UI] debugRangeOps enabled=${window.DEBUG_RANGE_OPS}`);
                });
                hudManager.setDebugSpineGuideToggleHandler((enabled) => {
                    window.DEBUG_SPINE_GUIDE = !!enabled;
                    localStorage.setItem(DEBUG_SPINE_STORAGE_KEY, window.DEBUG_SPINE_GUIDE ? 'true' : 'false');
                    hudManager.update({ debugSpineGuide: window.DEBUG_SPINE_GUIDE });
                    RelayLog.info(`[UI] debugSpineGuide enabled=${window.DEBUG_SPINE_GUIDE}`);
                });
                hudManager.setCompanyMarkersToggleHandler((enabled) => {
                    window.SHOW_CELL_MARKERS_AT_COMPANY = !!enabled;
                    localStorage.setItem(COMPANY_MARKERS_STORAGE_KEY, window.SHOW_CELL_MARKERS_AT_COMPANY ? 'true' : 'false');
                    hudManager.update({ showCellMarkersAtCompany: window.SHOW_CELL_MARKERS_AT_COMPANY });
                    RelayLog.info(`[HUD] showCellMarkersAtCompany enabled=${window.SHOW_CELL_MARKERS_AT_COMPANY}`);
                    filamentRenderer?.renderTree();
                });
                hudManager.setActiveMarkersToggleHandler((enabled) => {
                    window.SHOW_ACTIVE_MARKERS = !!enabled;
                    localStorage.setItem(ACTIVE_MARKERS_STORAGE_KEY, window.SHOW_ACTIVE_MARKERS ? 'true' : 'false');
                    hudManager.update({ showActiveMarkers: window.SHOW_ACTIVE_MARKERS });
                    RelayLog.info(`[HUD] showPresenceMarkers enabled=${window.SHOW_ACTIVE_MARKERS}`);
                    filamentRenderer?.renderTree();
                });
                hudManager.setActiveMarkerModeChangeHandler((mode) => {
                    window.ACTIVE_MARKER_MODE = mode || 'auto';
                    localStorage.setItem(ACTIVE_MARKER_MODE_STORAGE_KEY, window.ACTIVE_MARKER_MODE);
                    hudManager.update({ activeMarkerMode: window.ACTIVE_MARKER_MODE });
                    RelayLog.info(`[HUD] presenceMarkerMode=${window.ACTIVE_MARKER_MODE}`);
                    filamentRenderer?.renderTree();
                });
                hudManager.setEditSheetModeToggleHandler(() => {
                    if (isEditSheetMode) {
                        window.exitEditSheetMode();
                    } else {
                        window.enterEditSheetMode();
                    }
                });
                
                // Initialize Excel Importer
                excelImporter = new ExcelImporter('dropZone');
                excelImporter.setupDragAndDrop();
                excelImporter.onImport((tree) => {
                    RelayLog.info(`‚úÖ Tree imported: ${tree.nodes.length} nodes`);
                    filamentRenderer.renderTree();
                    const markerStats = filamentRenderer?.lastMarkerStats;
                    if (markerStats && markerStats.lod === 'COMPANY' && markerStats.markerCells === 0 && markerStats.anchoredCells > 0) {
                        RelayLog.info(`[HINT] Data loaded (${markerStats.anchoredCells} cells). At COMPANY LOD markers are hidden. Press L to lock SHEET or enable "Show cell markers at COMPANY".`);
                    }
                    hudManager.update({
                        nodeCount: tree.nodes.length,
                        cfStatus: getAggregateCFStatus(tree)
                    });
                });

                // Spreadsheet overlay (MVP: read-only selection + formula bar)
                sheetOverlay = document.getElementById('sheetOverlay');
                sheetOverlaySheet = document.getElementById('sheetOverlaySheet');
                sheetOverlayCell = document.getElementById('sheetOverlayCell');
                sheetOverlayValue = document.getElementById('sheetOverlayValue');
                sheetOverlayFormula = document.getElementById('sheetOverlayFormula');
                sheetOverlayInput = document.getElementById('sheetOverlayInput');
                sheetOverlayBody = sheetOverlay ? sheetOverlay.querySelector('.body') : null;
                sheetGridOverlay = document.getElementById('sheetGridOverlay');
                sheetGridCanvas = document.getElementById('sheetGridCanvas');
                sheetGridCtx = sheetGridCanvas ? sheetGridCanvas.getContext('2d') : null;
                const normalizeInput = (value) => {
                    if (value === null || value === undefined) return '';
                    return String(value).replace(/\r\n/g, '\n').replace(/\s+$/g, '');
                };
                const markRecentCells = (sheet, cellIds) => {
                    if (!sheet || !Array.isArray(cellIds) || cellIds.length === 0) return;
                    if (!sheet._recentCells) {
                        sheet._recentCells = new Map();
                    }
                    const now = Date.now();
                    cellIds.forEach((cellId) => {
                        sheet._recentCells.set(cellId, now);
                    });
                };
                const updateSelectionRange = (sheet, range) => {
                    if (!sheet || !range?.start || !range?.end) return;
                    sheet._selectionRange = {
                        start: { row: range.start.row, col: range.start.col },
                        end: { row: range.end.row, col: range.end.col }
                    };
                };
                const MAX_PASTE_CELLS = 5000;

                const toCellRef = (row, col) => `${String.fromCharCode(65 + col)}${row + 1}`;

                const getCellCoordsFromId = (cellId) => {
                    if (!cellId) return null;
                    const idParts = cellId.split('.');
                    const row = Number.parseInt(idParts[idParts.length - 2], 10);
                    const col = Number.parseInt(idParts[idParts.length - 1], 10);
                    if (!Number.isFinite(row) || !Number.isFinite(col)) return null;
                    return { row, col };
                };

                const ensureCellIndex = (sheet) => {
                    if (!sheet._cellIndex) {
                        sheet._cellIndex = new Map(sheet.cellData.map(c => [`${c.row},${c.col}`, c]));
                    }
                };

                const getOrCreateCellInfo = (sheet, row, col, cellId, cellRef) => {
                    ensureCellIndex(sheet);
                    const key = `${row},${col}`;
                    let cellInfo = sheet._cellIndex.get(key);
                    if (!cellInfo) {
                        cellInfo = { row, col, id: cellId, a1: cellRef };
                        sheet._cellIndex.set(key, cellInfo);
                        sheet.cellData.push(cellInfo);
                    } else if (!cellInfo.id && cellId) {
                        cellInfo.id = cellId;
                    }
                    if (!cellInfo.a1 && cellRef) {
                        cellInfo.a1 = cellRef;
                    }
                    return cellInfo;
                };

                const getCellInfo = (sheet, row, col) => {
                    ensureCellIndex(sheet);
                    return sheet._cellIndex.get(`${row},${col}`) || null;
                };

                const getCellEntity = (sheetId, cellId) => {
                    const key = `${sheetId}|${cellId}`;
                    if (cellEntityIndex.has(key)) return cellEntityIndex.get(key);
                    const match = viewer?.entities?.values?.find(entity => {
                        const props = entity?.properties;
                        const now = Cesium.JulianDate.now();
                        const entitySheetId = props?.sheetId?.getValue ? props.sheetId.getValue(now) : props?.sheetId;
                        const entityCellId = props?.cellId?.getValue ? props.cellId.getValue(now) : props?.cellId;
                        return entitySheetId === sheetId && entityCellId === cellId;
                    }) || null;
                    if (match) {
                        cellEntityIndex.set(key, match);
                    }
                    return match;
                };

                const getRangeBounds = (range) => {
                    if (!range?.start || !range?.end) return null;
                    const minRow = Math.min(range.start.row, range.end.row);
                    const maxRow = Math.max(range.start.row, range.end.row);
                    const minCol = Math.min(range.start.col, range.end.col);
                    const maxCol = Math.max(range.start.col, range.end.col);
                    return {
                        minRow,
                        maxRow,
                        minCol,
                        maxCol,
                        rows: maxRow - minRow + 1,
                        cols: maxCol - minCol + 1
                    };
                };

                const getRangeLabel = (range) => {
                    if (!range?.start || !range?.end) return '‚Äî';
                    const startRef = range.start.cellRef || toCellRef(range.start.row, range.start.col);
                    const endRef = range.end.cellRef || toCellRef(range.end.row, range.end.col);
                    if (startRef === endRef) return startRef;
                    return `${startRef}:${endRef}`;
                };

                const updateOverlayForRange = (range, cellInfo) => {
                    const bounds = getRangeBounds(range);
                    if (!bounds) return;
                    const rangeLabel = getRangeLabel(range);
                    sheetOverlayCell.textContent = rangeLabel;
                    if (bounds.rows * bounds.cols === 1) {
                        const valueText = (cellInfo?.display ?? cellInfo?.value ?? '‚Äî');
                        const formulaText = (cellInfo?.formula ?? '‚Äî');
                        sheetOverlayValue.textContent = `Value: ${valueText}`;
                        sheetOverlayFormula.textContent = `Formula: ${formulaText}`;
                    } else {
                        sheetOverlayValue.textContent = `Value: (range ${bounds.rows}x${bounds.cols})`;
                        sheetOverlayFormula.textContent = `Formula: ‚Äî`;
                    }
                };

                const computeCellUpdate = (normalized) => {
                    const trimmed = typeof normalized === 'string' ? normalized.trim() : '';
                    if (!trimmed) {
                        return {
                            type: 'CELL_CLEAR',
                            value: '',
                            formula: null,
                            hasFormula: false,
                            display: ''
                        };
                    }
                    if (trimmed.startsWith('=')) {
                        return {
                            type: 'CELL_FORMULA_SET',
                            value: null,
                            formula: trimmed,
                            hasFormula: true,
                            display: trimmed
                        };
                    }
                    return {
                        type: 'CELL_SET',
                        value: normalized,
                        formula: null,
                        hasFormula: false,
                        display: normalized
                    };
                };

                const isSameCellState = (cellInfo, update) => {
                    const prevValue = cellInfo?.value ?? '';
                    const prevFormula = cellInfo?.formula ?? null;
                    const prevDisplay = cellInfo?.display ?? '';
                    const prevHasFormula = !!cellInfo?.hasFormula;
                    const nextValue = update.value ?? '';
                    const nextFormula = update.formula ?? null;
                    const nextDisplay = update.display ?? '';
                    return prevValue === nextValue
                        && prevFormula === nextFormula
                        && prevDisplay === nextDisplay
                        && prevHasFormula === update.hasFormula;
                };

                const applyCellValue = (cellInfo, normalized) => {
                    const update = computeCellUpdate(normalized);
                    const changed = !isSameCellState(cellInfo, update);
                    if (changed) {
                        cellInfo.value = update.value;
                        cellInfo.display = update.display;
                        cellInfo.formula = update.formula;
                        cellInfo.hasFormula = update.hasFormula;
                    }
                    return { ...update, changed };
                };

                const commitEdit = (inputValue) => {
                    if (!sheetSelection || !sheetSelection.cellId || !sheetSelection.sheetId) return;
                    const { sheetId, cellId, cellRef, entity } = sheetSelection;
                    const sheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === sheetId);
                    if (!sheet || !Array.isArray(sheet.cellData)) return;
                    const coords = getCellCoordsFromId(cellId);
                    if (!coords) return;
                    const cellInfo = getOrCreateCellInfo(sheet, coords.row, coords.col, cellId, cellRef);
                    const normalized = normalizeInput(inputValue);
                    const commitId = `commit_${Date.now()}`;
                    const applied = applyCellValue(cellInfo, normalized);
                    if (applied.type === 'CELL_FORMULA_SET') {
                        RelayLog.info(`[UI] commit sheet=${sheetId} cell=${cellRef || cellId} type=CELL_FORMULA_SET formula="${cellInfo.formula}" commitId=${commitId}`);
                    } else if (applied.type === 'CELL_CLEAR') {
                        RelayLog.info(`[UI] commit sheet=${sheetId} cell=${cellRef || cellId} type=CELL_CLEAR commitId=${commitId}`);
                    } else {
                        RelayLog.info(`[UI] commit sheet=${sheetId} cell=${cellRef || cellId} type=CELL_SET value="${normalized}" commitId=${commitId}`);
                    }
                    markRecentCells(sheet, [cellId]);

                    if (entity?.label) {
                        const labelText = `${cellRef || cellId}=${cellInfo.display ?? ''}`;
                        entity.label.text = labelText;
                    }

                    updateOverlayForRange(sheetRange || { start: coords, end: coords }, cellInfo);
                    RelayLog.info(`[UI] reflect sheet=${sheetId} cell=${cellRef || cellId} value="${cellInfo.display ?? ''}" formula="${cellInfo.formula ?? ''}" 3DLabel=updated filament=ok`);
                };

                const commitRangeEdit = (sheetId, range, values, source) => {
                    const sheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === sheetId);
                    if (!sheet || !Array.isArray(sheet.cellData)) return;
                    const bounds = getRangeBounds(range);
                    if (!bounds) return;
                    const commitId = `commit_${Date.now()}`;
                    let setCount = 0;
                    let formulaCount = 0;
                    let clearCount = 0;
                    let updatedLabels = 0;
                    let changedCount = 0;
                    let unchangedCount = 0;
                    const debugOps = [];
                    const changedCells = [];

                    for (let r = 0; r < bounds.rows; r++) {
                        for (let c = 0; c < bounds.cols; c++) {
                            const valueRow = values?.[r];
                            const rawValue = valueRow ? valueRow[c] : '';
                            const normalized = normalizeInput(rawValue);
                            const row = bounds.minRow + r;
                            const col = bounds.minCol + c;
                            const cellId = `${sheetId}.cell.${row}.${col}`;
                            const cellRef = toCellRef(row, col);
                            const cellInfo = getOrCreateCellInfo(sheet, row, col, cellId, cellRef);
                            const applied = applyCellValue(cellInfo, normalized);
                            if (applied.changed) {
                                changedCount += 1;
                                changedCells.push(cellId);
                                if (applied.type === 'CELL_FORMULA_SET') {
                                    formulaCount += 1;
                                } else if (applied.type === 'CELL_CLEAR') {
                                    clearCount += 1;
                                } else {
                                    setCount += 1;
                                }
                                const entity = getCellEntity(sheetId, cellId);
                                if (entity?.label) {
                                    entity.label.text = `${cellRef}=${cellInfo.display ?? ''}`;
                                    updatedLabels += 1;
                                }
                                if (window.DEBUG_RANGE_OPS) {
                                    if (applied.type === 'CELL_FORMULA_SET') {
                                        debugOps.push(`${cellRef} FORMULA "${cellInfo.formula}"`);
                                    } else if (applied.type === 'CELL_CLEAR') {
                                        debugOps.push(`${cellRef} CLEAR`);
                                    } else {
                                        debugOps.push(`${cellRef} SET "${cellInfo.display ?? ''}"`);
                                    }
                                }
                            } else {
                                unchangedCount += 1;
                            }
                        }
                    }

                    const rangeLabel = getRangeLabel(range);
                    if (changedCount === 0) {
                        RelayLog.info(`[UI] commitRangeNoop sheet=${sheetId} range=${rangeLabel} changed=0 unchanged=${unchangedCount} ops={SET:0, FORMULA:0, CLEAR:0}`);
                        return;
                    }
                    markRecentCells(sheet, changedCells);
                    RelayLog.info(`[UI] commitRange sheet=${sheetId} range=${rangeLabel} changed=${changedCount} unchanged=${unchangedCount} ops={SET:${setCount}, FORMULA:${formulaCount}, CLEAR:${clearCount}} commitId=${commitId}`);
                    if (window.DEBUG_RANGE_OPS && debugOps.length > 0) {
                        RelayLog.info(`[UI:ops] ${debugOps.join('; ')}`);
                    }
                    RelayLog.info(`[UI] reflectRange sheet=${sheetId} range=${rangeLabel} labelsUpdated=${updatedLabels} filamentsUpdated=${changedCount}`);
                };

                const beginEdit = () => {
                    if (!sheetSelection || !sheetRange) return;
                    const bounds = getRangeBounds(sheetRange);
                    if (bounds && bounds.rows * bounds.cols > 1) return;
                    isEditingCell = true;
                    if (document.pointerLockElement) {
                        document.exitPointerLock();
                    }
                    sheetOverlayInput.disabled = false;
                    const currentValue = sheetOverlayFormula.textContent.replace('Formula: ', '');
                    const currentDisplay = sheetOverlayValue.textContent.replace('Value: ', '');
                    sheetOverlayInput.value = currentValue && currentValue !== '‚Äî' ? currentValue : (currentDisplay !== '‚Äî' ? currentDisplay : '');
                    sheetOverlayInput.focus();
                    sheetOverlayInput.select();
                    RelayLog.info(`[UI] editStart sheet=${sheetSelection.sheetId} cell=${sheetSelection.cellRef || sheetSelection.cellId} cellId=${sheetSelection.cellId}`);
                };

                const endEdit = (commit) => {
                    if (!isEditingCell) return;
                    const inputValue = sheetOverlayInput.value;
                    sheetOverlayInput.blur();
                    sheetOverlayInput.disabled = true;
                    isEditingCell = false;
                    if (commit) {
                        commitEdit(inputValue);
                    }
                };

                sheetOverlayInput.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        endEdit(true);
                    } else if (event.key === 'Escape') {
                        event.preventDefault();
                        endEdit(false);
                    }
                });

                sheetOverlay.addEventListener('dblclick', (event) => {
                    if (event.target === sheetOverlayInput) return;
                    beginEdit();
                });

                document.addEventListener('keydown', (event) => {
                    if (event.key === 'F2') {
                        beginEdit();
                    }
                });
                const picker = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);

                const pickCell = (position) => {
                    const picked = viewer.scene.pick(position);
                    if (!picked || !picked.id) return null;
                    const entity = picked.id;
                    const now = Cesium.JulianDate.now();
                    const sheetId = entity.properties?.sheetId?.getValue ? entity.properties.sheetId.getValue(now) : entity.properties?.sheetId;
                    const cellId = entity.properties?.cellId?.getValue ? entity.properties.cellId.getValue(now) : entity.properties?.cellId;
                    const cellRef = entity.properties?.cellRef?.getValue ? entity.properties.cellRef.getValue(now) : entity.properties?.cellRef;
                    if (!sheetId || !cellId) return null;
                    const coords = getCellCoordsFromId(cellId);
                    if (!coords) return null;
                    return { sheetId, cellId, cellRef, entity, row: coords.row, col: coords.col };
                };

                const applySelection = (selection, range) => {
                    const anchor = range?.start || selection;
                    if (!anchor) return;
                    const sheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === selection.sheetId);
                    let cellInfo = null;
                    if (sheet && Array.isArray(sheet.cellData)) {
                        cellInfo = getCellInfo(sheet, anchor.row, anchor.col);
                    }
                    sheetOverlay.style.display = 'block';
                    sheetOverlaySheet.textContent = selection.sheetId || '‚Äî';
                    updateOverlayForRange(range, cellInfo);
                    sheetOverlayInput.disabled = true;
                    sheetOverlayInput.value = '';
                    updateSelectionRange(sheet, range);
                    const anchorCellId = anchor.cellId || selection.cellId;
                    const anchorCellRef = anchor.cellRef || selection.cellRef;
                    sheetSelection = {
                        sheetId: selection.sheetId,
                        cellId: anchorCellId,
                        cellRef: anchorCellRef,
                        row: anchor.row,
                        col: anchor.col,
                        entity: selection.entity || getCellEntity(selection.sheetId, anchorCellId)
                    };
                    sheetRange = range;
                    renderGridOverlay();
                };

                const getNearestSheetToCamera = () => {
                    if (!viewer) return null;
                    const sheets = relayState.tree.nodes.filter(n => n.type === 'sheet' && n._center);
                    if (sheets.length === 0) return null;
                    let nearest = null;
                    let nearestDist = Infinity;
                    const camPos = viewer.camera.position;
                    sheets.forEach((sheet) => {
                        const dist = Cesium.Cartesian3.distance(camPos, sheet._center);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearest = sheet;
                        }
                    });
                    return nearest;
                };

                const getActiveGridSheet = () => {
                    if (editSheetTargetSheet) return editSheetTargetSheet;
                    if (sheetSelection?.sheetId) {
                        return relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === sheetSelection.sheetId) || null;
                    }
                    const activeName = relayState?.metadata?.activeSheet;
                    if (activeName) {
                        const byName = relayState.tree.nodes.find(n => n.type === 'sheet' && (n.name === activeName || n.metadata?.sheetName === activeName));
                        if (byName) return byName;
                    }
                    return relayState.tree.nodes.find(n => n.type === 'sheet') || null;
                };

                const renderGridOverlay = () => {
                    if (!sheetGridCanvas || !sheetGridCtx || !sheetGridOverlay) return;
                    const sheet = getActiveGridSheet();
                    if (!sheet) return;
                    const rect = sheetGridOverlay.getBoundingClientRect();
                    sheetGridCanvas.width = Math.floor(rect.width);
                    sheetGridCanvas.height = Math.floor(rect.height);
                    const ctx = sheetGridCtx;
                    const rows = sheet.rows || CANONICAL_LAYOUT.sheet.cellRows;
                    const cols = sheet.cols || CANONICAL_LAYOUT.sheet.cellCols;
                    const header = 40;
                    const gridWidth = sheetGridCanvas.width - header;
                    const gridHeight = sheetGridCanvas.height - header;
                    const cellW = gridWidth / cols;
                    const cellH = gridHeight / rows;
                    ctx.clearRect(0, 0, sheetGridCanvas.width, sheetGridCanvas.height);
                    ctx.fillStyle = '#0b1220';
                    ctx.fillRect(0, 0, sheetGridCanvas.width, sheetGridCanvas.height);
                    ctx.strokeStyle = 'rgba(80, 110, 150, 0.35)';
                    ctx.lineWidth = 1;
                    for (let c = 0; c <= cols; c++) {
                        const x = header + c * cellW;
                        ctx.beginPath();
                        ctx.moveTo(x, header);
                        ctx.lineTo(x, header + rows * cellH);
                        ctx.stroke();
                    }
                    for (let r = 0; r <= rows; r++) {
                        const y = header + r * cellH;
                        ctx.beginPath();
                        ctx.moveTo(header, y);
                        ctx.lineTo(header + cols * cellW, y);
                        ctx.stroke();
                    }
                    ctx.fillStyle = 'rgba(200, 220, 255, 0.6)';
                    ctx.font = '12px monospace';
                    for (let c = 0; c < cols; c++) {
                        const label = String.fromCharCode(65 + (c % 26));
                        ctx.fillText(label, header + c * cellW + 6, 24);
                    }
                    for (let r = 0; r < rows; r++) {
                        ctx.fillText(String(r + 1), 10, header + r * cellH + 16);
                    }
                    const cellMap = sheet._cellIndex || new Map(sheet.cellData.map(c => [`${c.row},${c.col}`, c]));
                    sheet._cellIndex = cellMap;
                    ctx.fillStyle = 'rgba(120, 210, 255, 0.85)';
                    for (const cell of cellMap.values()) {
                        if (!Number.isFinite(cell.row) || !Number.isFinite(cell.col)) continue;
                        const hasValue = cell.value !== undefined && cell.value !== null && String(cell.value).trim() !== '';
                        const hasFormula = typeof cell.formula === 'string' && cell.formula.trim() !== '';
                        if (!hasValue && !hasFormula) continue;
                        const x = header + cell.col * cellW + cellW * 0.35;
                        const y = header + cell.row * cellH + cellH * 0.35;
                        ctx.beginPath();
                        ctx.arc(x, y, Math.min(cellW, cellH) * 0.15, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    if (sheetRange && sheetRange.sheetId === sheet.id) {
                        const minRow = Math.min(sheetRange.start.row, sheetRange.end.row);
                        const maxRow = Math.max(sheetRange.start.row, sheetRange.end.row);
                        const minCol = Math.min(sheetRange.start.col, sheetRange.end.col);
                        const maxCol = Math.max(sheetRange.start.col, sheetRange.end.col);
                        const x = header + minCol * cellW;
                        const y = header + minRow * cellH;
                        const w = (maxCol - minCol + 1) * cellW;
                        const h = (maxRow - minRow + 1) * cellH;
                        ctx.strokeStyle = 'rgba(255, 215, 0, 0.9)';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, y, w, h);
                    }
                };

                window.setCompanyTopDownView = (sheet) => {
                    const targetSheet = sheet || getNearestSheetToCamera();
                    if (!targetSheet || !targetSheet._center) {
                        RelayLog.warn('‚ö†Ô∏è Company top-down view unavailable (sheet not ready)');
                        return;
                    }
                    const outward = Cesium.Cartesian3.normalize(
                        Cesium.Cartesian3.clone(targetSheet._center, new Cesium.Cartesian3()),
                        new Cesium.Cartesian3()
                    );
                    const sheetNormal = Cesium.Cartesian3.normalize(
                        Cesium.Cartesian3.clone(targetSheet._renderNormal || targetSheet._normal || Cesium.Cartesian3.UNIT_Z),
                        new Cesium.Cartesian3()
                    );
                    const viewNormal = Cesium.Cartesian3.dot(sheetNormal, outward) >= 0
                        ? sheetNormal
                        : Cesium.Cartesian3.negate(sheetNormal, new Cesium.Cartesian3());
                    const distance = 520;
                    const cameraPos = Cesium.Cartesian3.add(
                        targetSheet._center,
                        Cesium.Cartesian3.multiplyByScalar(viewNormal, distance, new Cesium.Cartesian3()),
                        new Cesium.Cartesian3()
                    );
                    const direction = Cesium.Cartesian3.normalize(
                        Cesium.Cartesian3.subtract(targetSheet._center, cameraPos, new Cesium.Cartesian3()),
                        new Cesium.Cartesian3()
                    );
                    let up = targetSheet._xAxis || Cesium.Cartesian3.UNIT_Z;
                    if (Math.abs(Cesium.Cartesian3.dot(up, direction)) > 0.9) {
                        up = targetSheet._yAxis || Cesium.Cartesian3.UNIT_Y;
                    }
                    RelayLog.info('[CAM] CompanyTopDown: sheet-facing globe-aligned view');
                    viewer.camera.setView({
                        destination: cameraPos,
                        orientation: {
                            direction,
                            up
                        }
                    });
                };

                const moveSelectionBy = (deltaRow, deltaCol) => {
                    if (!sheetSelection) return;
                    const sheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === sheetSelection.sheetId);
                    if (!sheet) return;
                    const rows = sheet.rows || CANONICAL_LAYOUT.sheet.cellRows;
                    const cols = sheet.cols || CANONICAL_LAYOUT.sheet.cellCols;
                    const nextRow = Math.max(0, Math.min(rows - 1, sheetSelection.row + deltaRow));
                    const nextCol = Math.max(0, Math.min(cols - 1, sheetSelection.col + deltaCol));
                    const cellRef = toCellRef(nextRow, nextCol);
                    const cellId = `${sheet.id}.cell.${nextRow}.${nextCol}`;
                    const selection = {
                        sheetId: sheet.id,
                        cellId,
                        cellRef,
                        row: nextRow,
                        col: nextCol,
                        entity: getCellEntity(sheet.id, cellId)
                    };
                    const range = {
                        sheetId: sheet.id,
                        start: { row: nextRow, col: nextCol, cellId, cellRef },
                        end: { row: nextRow, col: nextCol, cellId, cellRef }
                    };
                    applySelection(selection, range);
                    renderGridOverlay();
                };

                if (sheetGridOverlay) {
                    sheetGridOverlay.addEventListener('click', (event) => {
                        if (!isEditSheetMode) return;
                        const sheet = getActiveGridSheet();
                        if (!sheet) return;
                        const rect = sheetGridOverlay.getBoundingClientRect();
                        const header = 40;
                        const x = event.clientX - rect.left;
                        const y = event.clientY - rect.top;
                        if (x < header || y < header) return;
                        const rows = sheet.rows || CANONICAL_LAYOUT.sheet.cellRows;
                        const cols = sheet.cols || CANONICAL_LAYOUT.sheet.cellCols;
                        const cellW = (rect.width - header) / cols;
                        const cellH = (rect.height - header) / rows;
                        const col = Math.max(0, Math.min(cols - 1, Math.floor((x - header) / cellW)));
                        const row = Math.max(0, Math.min(rows - 1, Math.floor((y - header) / cellH)));
                        const cellRef = toCellRef(row, col);
                        const cellId = `${sheet.id}.cell.${row}.${col}`;
                        const selection = {
                            sheetId: sheet.id,
                            cellId,
                            cellRef,
                            row,
                            col,
                            entity: getCellEntity(sheet.id, cellId)
                        };
                        const range = {
                            sheetId: sheet.id,
                            start: { row, col, cellId, cellRef },
                            end: { row, col, cellId, cellRef }
                        };
                        applySelection(selection, range);
                    });
                }

                window.addEventListener('resize', () => {
                    if (isEditSheetMode) {
                        renderGridOverlay();
                    }
                });

                picker.setInputAction((movement) => {
                    const picked = pickCell(movement.position);
                    if (!picked) return;
                    if (!isEditSheetMode) {
                        const targetSheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === picked.sheetId) || null;
                        editSheetTargetSheet = targetSheet;
                        if (canEnterEditSheet(targetSheet)) {
                            window.enterEditSheetMode(targetSheet);
                        } else {
                            RelayLog.info('[MODE] EDIT_SHEET pending (distance/alignment)');
                        }
                    }
                    rangeDragAnchor = picked;
                    rangeDragLast = picked;
                    isRangeDragging = true;
                    const range = {
                        sheetId: picked.sheetId,
                        start: { row: picked.row, col: picked.col, cellId: picked.cellId, cellRef: picked.cellRef },
                        end: { row: picked.row, col: picked.col, cellId: picked.cellId, cellRef: picked.cellRef }
                    };
                    applySelection(picked, range);
                }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

                picker.setInputAction((movement) => {
                    if (!isRangeDragging || !rangeDragAnchor) {
                        if (filamentRenderer) {
                            const picked = viewer.scene.pick(movement.endPosition);
                            const instanceId = typeof picked?.id === 'string' ? picked.id : null;
                            if (instanceId && instanceId.includes('timebox')) {
                                filamentRenderer.setTimeboxHover(instanceId);
                            } else {
                                filamentRenderer.setTimeboxHover(null);
                            }
                        }
                        const hovered = viewer.scene.pick(movement.endPosition);
                        const entity = hovered?.id;
                        const isCell = entity?.properties?.type?.getValue ? entity.properties.type.getValue(Cesium.JulianDate.now()) === 'cell' : entity?.properties?.type === 'cell';
                        if (window.SHOW_CELL_MARKERS_AT_COMPANY && isCell && entity?.label) {
                            if (hoveredCellEntity && hoveredCellEntity !== entity && hoveredCellEntity.label) {
                                hoveredCellEntity.label.show = false;
                            }
                            entity.label.show = true;
                            hoveredCellEntity = entity;
                        } else if (hoveredCellEntity?.label) {
                            hoveredCellEntity.label.show = false;
                            hoveredCellEntity = null;
                        }
                        return;
                    }
                    let picked = pickCell(movement.endPosition);
                    if (!picked) {
                        picked = rangeDragLast;
                    }
                    if (!picked || picked.sheetId !== rangeDragAnchor.sheetId) return;
                    rangeDragLast = picked;
                    const range = {
                        sheetId: rangeDragAnchor.sheetId,
                        start: { row: rangeDragAnchor.row, col: rangeDragAnchor.col, cellId: rangeDragAnchor.cellId, cellRef: rangeDragAnchor.cellRef },
                        end: { row: picked.row, col: picked.col, cellId: picked.cellId, cellRef: picked.cellRef }
                    };
                    applySelection(rangeDragAnchor, range);
                }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

                picker.setInputAction((movement) => {
                    if (!isRangeDragging || !rangeDragAnchor) return;
                    let picked = pickCell(movement.position);
                    isRangeDragging = false;
                    if (!picked) {
                        picked = rangeDragLast;
                    }
                    if (!picked || picked.sheetId !== rangeDragAnchor.sheetId) {
                        rangeDragAnchor = null;
                        rangeDragLast = null;
                        return;
                    }
                    const range = {
                        sheetId: rangeDragAnchor.sheetId,
                        start: { row: rangeDragAnchor.row, col: rangeDragAnchor.col, cellId: rangeDragAnchor.cellId, cellRef: rangeDragAnchor.cellRef },
                        end: { row: picked.row, col: picked.col, cellId: picked.cellId, cellRef: picked.cellRef }
                    };
                    applySelection(rangeDragAnchor, range);
                    const bounds = getRangeBounds(range);
                    const rangeLabel = getRangeLabel(range);
                    RelayLog.info(`[UI] rangeSelect sheet=${range.sheetId} range=${rangeLabel} rows=${bounds?.rows || 1} cols=${bounds?.cols || 1} cells=${bounds?.rows * bounds?.cols || 1}`);
                    rangeDragAnchor = null;
                    rangeDragLast = null;
                }, Cesium.ScreenSpaceEventType.LEFT_UP);

                picker.setInputAction((movement) => {
                    const picked = viewer.scene.pick(movement.position);
                    const id = typeof picked?.id === 'string' ? picked.id : null;
                    if (!id) return;
                    const idBase = id.split('-surface')[0].split('-outline')[0].split('-segment')[0].split('-root')[0].split('-anchor')[0];
                    const isSheet = idBase.startsWith('sheet.');
                    const isBranch = idBase.startsWith('branch.');
                    const isTrunk = idBase.startsWith('trunk.');
                    if (!isSheet && !isBranch && !isTrunk) return;

                    let targetSheet = null;
                    if (isSheet) {
                        targetSheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === idBase);
                    }
                    if (!targetSheet) {
                        targetSheet = getNearestSheetToCamera();
                    }
                    if (targetSheet) {
                        editSheetTargetSheet = targetSheet;
                        if (canEnterEditSheet(targetSheet)) {
                            window.enterEditSheetMode(targetSheet);
                            window.setCompanyTopDownView(targetSheet);
                        } else {
                            RelayLog.info('[MODE] EDIT_SHEET pending (distance/alignment)');
                        }
                    }
                }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

                document.addEventListener('keydown', async (event) => {
                    if (isEditingCell) return;
                    const isCopy = (event.key === 'c' || event.key === 'C') && (event.ctrlKey || event.metaKey);
                    const isPaste = (event.key === 'v' || event.key === 'V') && (event.ctrlKey || event.metaKey);
                    if (!isCopy && !isPaste) return;
                    if (!sheetRange?.sheetId || !sheetSelection?.sheetId) return;
                    event.preventDefault();
                    const bounds = getRangeBounds(sheetRange);
                    if (!bounds) return;
                    const sheetId = sheetRange.sheetId;
                    const sheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === sheetId);
                    if (!sheet || !Array.isArray(sheet.cellData)) return;

                    if (isCopy) {
                        const rows = [];
                        ensureCellIndex(sheet);
                        for (let r = 0; r < bounds.rows; r++) {
                            const rowValues = [];
                            for (let c = 0; c < bounds.cols; c++) {
                                const row = bounds.minRow + r;
                                const col = bounds.minCol + c;
                                const cellInfo = sheet._cellIndex.get(`${row},${col}`);
                                if (cellInfo?.hasFormula && cellInfo.formula) {
                                    rowValues.push(cellInfo.formula);
                                } else if (cellInfo?.value !== undefined && cellInfo?.value !== null) {
                                    rowValues.push(cellInfo.value);
                                } else if (cellInfo?.display !== undefined && cellInfo?.display !== null) {
                                    rowValues.push(cellInfo.display);
                                } else {
                                    rowValues.push('');
                                }
                            }
                            rows.push(rowValues);
                        }
                        copyBuffer = rows;
                        const text = rows.map(row => row.map(v => String(v ?? '')).join('\t')).join('\n');
                        const tsvBytes = window.TextEncoder ? new TextEncoder().encode(text).length : text.length;
                        if (navigator.clipboard?.writeText) {
                            try {
                                await navigator.clipboard.writeText(text);
                            } catch (err) {
                                RelayLog.warn(`[UI] copyRange clipboard write failed: ${err?.message || err}`);
                            }
                        }
                        RelayLog.info(`[UI] copy sheet=${sheetId} range=${getRangeLabel(sheetRange)} tsvBytes=${tsvBytes} rows=${bounds.rows} cols=${bounds.cols}`);
                        return;
                    }

                    let pasteText = null;
                    if (navigator.clipboard?.readText) {
                        try {
                            pasteText = await navigator.clipboard.readText();
                        } catch (err) {
                            RelayLog.warn('[UI] pasteBlocked reason=ClipboardPermission');
                        }
                    }
                    let values = null;
                    if (pasteText && pasteText.length > 0) {
                        const rows = pasteText.replace(/\r\n/g, '\n').split('\n');
                        values = rows.filter((row, idx) => !(idx === rows.length - 1 && row === '')).map(row => row.split('\t'));
                    } else if (copyBuffer) {
                        values = copyBuffer;
                    }
                    if (!values || values.length === 0) return;
                    const srcRows = values.length;
                    const srcCols = Math.max(...values.map(row => row.length));
                    const pasteCells = srcRows * srcCols;
                    if (pasteCells > MAX_PASTE_CELLS) {
                        RelayLog.warn(`[UI] pasteRefused cells=${pasteCells} cap=${MAX_PASTE_CELLS}`);
                        return;
                    }
                    let trimmed = 0;
                    let cleared = 0;
                    let formulas = 0;
                    let literals = 0;
                    for (let r = 0; r < srcRows; r++) {
                        for (let c = 0; c < srcCols; c++) {
                            const rawValue = values?.[r]?.[c] ?? '';
                            const normalized = normalizeInput(rawValue);
                            if (rawValue !== null && rawValue !== undefined && String(rawValue) !== normalized) {
                                trimmed += 1;
                            }
                            if (normalized.trim() === '') {
                                cleared += 1;
                            } else if (normalized.trim().startsWith('=')) {
                                formulas += 1;
                            } else {
                                literals += 1;
                            }
                        }
                    }
                    RelayLog.info(`[UI] pasteNormalize trimmed=${trimmed} cleared=${cleared} formulas=${formulas} literals=${literals}`);
                    const pasteStartRow = bounds.minRow;
                    const pasteStartCol = bounds.minCol;
                    const pasteEndRow = bounds.minRow + values.length - 1;
                    const pasteEndCol = bounds.minCol + srcCols - 1;
                    const pasteRange = {
                        sheetId,
                        start: {
                            row: pasteStartRow,
                            col: pasteStartCol,
                            cellId: `${sheetId}.cell.${pasteStartRow}.${pasteStartCol}`,
                            cellRef: toCellRef(pasteStartRow, pasteStartCol)
                        },
                        end: {
                            row: pasteEndRow,
                            col: pasteEndCol,
                            cellId: `${sheetId}.cell.${pasteEndRow}.${pasteEndCol}`,
                            cellRef: toCellRef(pasteEndRow, pasteEndCol)
                        }
                    };
                    RelayLog.info(`[UI] paste sheet=${sheetId} anchor=${toCellRef(pasteStartRow, pasteStartCol)} srcRows=${srcRows} srcCols=${srcCols} destRange=${getRangeLabel(pasteRange)}`);
                    commitRangeEdit(sheetId, pasteRange, values, 'paste');
                    applySelection(sheetSelection, pasteRange);
                });
                
                // Hide loading screen
                document.getElementById('loading').classList.add('hidden');
                
                // Start render loop
                startRenderLoop();
                
                // Keyboard shortcuts
                setupKeyboardShortcuts();
                
                RelayLog.info('‚úÖ Relay Cesium World initialized');
                
            } catch (error) {
                RelayLog.error(`‚ùå Initialization failed: ${error.message}`);
                console.error(error);
            }
        }

        function saveCameraState(viewer, force = false) {
            try {
                const now = Date.now();
                if (!force && (now - lastCameraSave) < CAMERA_SAVE_THROTTLE_MS) return;
                lastCameraSave = now;

                const pos = viewer.camera.positionWC;
                if (!pos || !Number.isFinite(pos.x) || !Number.isFinite(pos.y) || !Number.isFinite(pos.z)) {
                    return;
                }

                const payload = {
                    x: pos.x,
                    y: pos.y,
                    z: pos.z,
                    heading: viewer.camera.heading,
                    pitch: viewer.camera.pitch,
                    roll: viewer.camera.roll,
                    t: now
                };
                localStorage.setItem(CAMERA_STORAGE_KEY, JSON.stringify(payload));
            } catch (err) {
                RelayLog.warn(`‚ö†Ô∏è Camera state save failed: ${err.message}`);
            }
        }

        function restoreCameraState(viewer) {
            try {
                const raw = localStorage.getItem(CAMERA_STORAGE_KEY);
                if (!raw) return false;
                const state = JSON.parse(raw);
                if (!state || !Number.isFinite(state.x) || !Number.isFinite(state.y) || !Number.isFinite(state.z)) return false;

                viewer.camera.setView({
                    destination: new Cesium.Cartesian3(state.x, state.y, state.z),
                    orientation: {
                        heading: Number.isFinite(state.heading) ? state.heading : viewer.camera.heading,
                        pitch: Number.isFinite(state.pitch) ? state.pitch : viewer.camera.pitch,
                        roll: Number.isFinite(state.roll) ? state.roll : viewer.camera.roll
                    }
                });
                RelayLog.info('üìå Restored last camera POV');
                return true;
            } catch (err) {
                RelayLog.warn(`‚ö†Ô∏è Camera state restore failed: ${err.message}`);
            }
            return false;
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // RENDER LOOP
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let frameCount = 0;
        let lastFPSUpdate = Date.now();
        let fps = 0;
        let lastTickTime = performance.now();
        
        function startRenderLoop() {
            function tick() {
                const nowTime = performance.now();
                const deltaSeconds = Math.min(0.05, (nowTime - lastTickTime) / 1000);
                lastTickTime = nowTime;

                if (flightControls) {
                    flightControls.update(deltaSeconds);
                }

                // Update LOD based on camera height (unless locked)
                if (lodGovernor && viewer) {
                    const height = getCameraHeightAboveGround(viewer);
                    
                    // Only update LOD if not locked
                    if (!lodLocked) {
                        lodGovernor.update(height);
                    } else {
                        // Keep locked LOD active
                        if (lodLockedLevel && lodGovernor.getCurrentLevel() !== lodLockedLevel) {
                            if (filamentRenderer) {
                                filamentRenderer.setLOD(lodLockedLevel);
                                filamentRenderer.renderTree();
                            }
                        }
                    }
                    
                    // Update HUD every frame
                    if (hudManager && frameCount % 5 === 0) {
                        const stats = getTreeStats();
                        const displayLOD = lodLocked ? `${lodGovernor.getCurrentLevel()} üîí` : lodGovernor.getCurrentLevel() || 'UNKNOWN';
                        hudManager.update({
                            lod: displayLOD,
                            altitude: height,
                            nodeCount: stats.nodes,
                            fps: fps,
                            boundaryStatus: window.getBoundaryStatus ? window.getBoundaryStatus() : 'UNKNOWN',
                            buildings: window.getBuildingsStatus ? window.getBuildingsStatus() : 'UNKNOWN',
                            filamentMode: window.getFilamentMode ? window.getFilamentMode() : 'ENTITY',
                            importStatus: relayState.importStatus || 'OK',
                            editSheetMode: isEditSheetMode
                        });
                    }
                }

                        if (viewer && window.AUTO_EDIT_SHEET) {
                            const nowMs = Date.now();
                            if (nowMs >= editSheetAutoCooldownUntil) {
                                const sheets = relayState.tree.nodes.filter(n => n.type === 'sheet' && n._center);
                                if (sheets.length > 0) {
                                    let nearest = null;
                                    let nearestDist = Infinity;
                                    const camPos = viewer.camera.position;
                                    sheets.forEach((sheet) => {
                                        const dist = Cesium.Cartesian3.distance(camPos, sheet._center);
                                        if (dist < nearestDist) {
                                            nearestDist = dist;
                                            nearest = sheet;
                                        }
                                    });
                                    const targetSheet = editSheetTargetSheet || nearest;
                                    if (targetSheet) {
                                        editSheetTargetSheet = targetSheet;
                                        const renderNormal = targetSheet._renderNormal || targetSheet._normal || Cesium.Cartesian3.UNIT_Z;
                                        const toCam = Cesium.Cartesian3.normalize(
                                            Cesium.Cartesian3.subtract(camPos, targetSheet._center, new Cesium.Cartesian3()),
                                            new Cesium.Cartesian3()
                                        );
                                        const alignDot = Cesium.Cartesian3.dot(
                                            Cesium.Cartesian3.normalize(renderNormal, new Cesium.Cartesian3()),
                                            toCam
                                        );
                                        const enterThreshold = 650;
                                        const exitThreshold = 900;
                                        if (!isEditSheetMode && canEnterEditSheet(targetSheet)) {
                                            window.enterEditSheetMode(targetSheet);
                                            window.setCompanyTopDownView(targetSheet);
                                            editSheetAutoCooldownUntil = nowMs + 1500;
                                        } else if (isEditSheetMode && (nearestDist > exitThreshold || alignDot < 0.9) && !isEditingCell) {
                                            window.exitEditSheetMode();
                                            editSheetAutoCooldownUntil = nowMs + 1500;
                                        }
                                    }
                                }
                            }
                        }
                
                // FPS calculation
                frameCount++;
                const now = Date.now();
                if (now - lastFPSUpdate >= 1000) {
                    fps = Math.round((frameCount * 1000) / (now - lastFPSUpdate));
                    frameCount = 0;
                    lastFPSUpdate = now;
                }
                
                requestAnimationFrame(tick);
            }
            tick();
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // KEYBOARD SHORTCUTS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                switch(e.key.toLowerCase()) {
                    case 'l':
                        // Toggle log console
                        const logConsole = document.getElementById('logConsole');
                        logConsole.style.display = logConsole.style.display === 'none' ? 'block' : 'none';
                        break;
                    
                    case 'h':
                        // Toggle HUD
                        if (hudManager) hudManager.toggle();
                        break;
                    
                    case 'i':
                        // Show info
                        const infoPanel = document.getElementById('infoPanel');
                        infoPanel.style.display = infoPanel.style.display === 'none' ? 'block' : 'none';
                        if (infoPanel.style.display === 'block') {
                            const stats = getTreeStats();
                            infoPanel.innerHTML = `
                                <h3>üå≤ Relay Tree Info</h3>
                                <p><strong>Nodes:</strong> ${stats.nodes}</p>
                                <p><strong>Edges:</strong> ${stats.edges}</p>
                                <p><strong>Trunks:</strong> ${stats.trunks}</p>
                                <p><strong>Branches:</strong> ${stats.branches}</p>
                                <p><strong>Sheets:</strong> ${stats.sheets}</p>
                                <p><strong>LOD:</strong> ${lodGovernor ? lodGovernor.getCurrentLevel() : 'N/A'}</p>
                            `;
                        }
                        break;
                }
            });
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FREE-FLY CAMERA CONTROLS (Three.js-style)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function setupFlightControls(viewer) {
            const canvas = viewer.canvas;
            const controller = viewer.scene.screenSpaceCameraController;
            
            let isLocked = false;
            let heading = viewer.camera.heading;
            let pitch = viewer.camera.pitch;
            let speedScale = 1.0;
            
            const moveState = {
                forward: false,
                backward: false,
                left: false,
                right: false,
                up: false,
                down: false,
                fast: false,
                slow: false
            };
            
            const sensitivity = 0.0022;
            const minPitch = -Cesium.Math.PI_OVER_TWO + 0.02;
            const maxPitch = Cesium.Math.PI_OVER_TWO - 0.02;
            
            function setDefaultInputsEnabled(enabled) {
                controller.enableInputs = enabled;
                controller.enableRotate = enabled;
                controller.enableTranslate = enabled;
                controller.enableZoom = enabled;
                controller.enableTilt = enabled;
                controller.enableLook = enabled;
            }
            
            function lockPointer() {
                if (isLocked || isEditSheetMode || suppressPointerLock) return;
                canvas.requestPointerLock();
            }
            
            function unlockPointer() {
                if (!isLocked) return;
                document.exitPointerLock();
            }
            
            function onPointerLockChange() {
                isLocked = (document.pointerLockElement === canvas);
                setDefaultInputsEnabled(!isLocked);
                
                if (isLocked) {
                    heading = viewer.camera.heading;
                    pitch = viewer.camera.pitch;
                    RelayLog.info('üéÆ Free-fly controls active (WASD/QE, mouse look, scroll speed)');
                } else {
                    RelayLog.info('üñ±Ô∏è Free-fly controls released (default Cesium controls)');
                    moveState.forward = false;
                    moveState.backward = false;
                    moveState.left = false;
                    moveState.right = false;
                    moveState.up = false;
                    moveState.down = false;
                    moveState.fast = false;
                    moveState.slow = false;
                }
            }
            
            function onMouseMove(event) {
                if (!isLocked || isEditingCell || isEditSheetMode) return;
                // Invert vertical axis: mouse up = look down
                heading += event.movementX * sensitivity;
                pitch += -event.movementY * sensitivity;
                pitch = Math.max(minPitch, Math.min(maxPitch, pitch));
                
                viewer.camera.setView({
                    destination: Cesium.Cartesian3.clone(viewer.camera.position, new Cesium.Cartesian3()),
                    orientation: {
                        heading: heading,
                        pitch: pitch,
                        roll: 0
                    }
                });
            }
            
            function onKeyDown(e) {
                if (!isLocked || isEditingCell || isEditSheetMode) return;
                switch (e.code) {
                    case 'KeyW': moveState.forward = true; break;
                    case 'KeyS': moveState.backward = true; break;
                    case 'KeyA': moveState.left = true; break;
                    case 'KeyD': moveState.right = true; break;
                    case 'KeyQ': moveState.down = true; break;
                    case 'KeyE':
                    case 'Space': moveState.up = true; break;
                    case 'ShiftLeft':
                    case 'ShiftRight': moveState.fast = true; break;
                    case 'ControlLeft':
                    case 'ControlRight': moveState.slow = true; break;
                }
            }
            
            function onKeyUp(e) {
                if (!isLocked || isEditingCell || isEditSheetMode) return;
                switch (e.code) {
                    case 'KeyW': moveState.forward = false; break;
                    case 'KeyS': moveState.backward = false; break;
                    case 'KeyA': moveState.left = false; break;
                    case 'KeyD': moveState.right = false; break;
                    case 'KeyQ': moveState.down = false; break;
                    case 'KeyE':
                    case 'Space': moveState.up = false; break;
                    case 'ShiftLeft':
                    case 'ShiftRight': moveState.fast = false; break;
                    case 'ControlLeft':
                    case 'ControlRight': moveState.slow = false; break;
                }
            }
            
            function onWheel(e) {
                if (!isLocked || isEditingCell || isEditSheetMode) return;
                e.preventDefault();
                // Wheel up = faster, wheel down = slower
                const delta = Math.sign(e.deltaY);
                speedScale = Math.max(0.2, Math.min(20.0, speedScale - (delta * 0.1)));
                RelayLog.info(`üéöÔ∏è Free-fly speed: √ó${speedScale.toFixed(1)}`);
            }
            
            canvas.addEventListener('click', () => {
                if (!isLocked) lockPointer();
            });
            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            canvas.addEventListener('wheel', onWheel, { passive: false });
            
            return {
                update(deltaSeconds) {
                    if (!isLocked) return;
                    
                    const height = viewer.camera.positionCartographic.height;
                    const baseSpeed = Math.min(1500, Math.max(5, height * 0.02));
                    let speed = baseSpeed * speedScale;
                    if (moveState.fast) speed *= 3.0;
                    if (moveState.slow) speed *= 0.25;
                    const distance = speed * deltaSeconds;
                    
                    const direction = viewer.camera.direction;
                    const right = viewer.camera.right;
                    const up = viewer.camera.up;
                    
                    const move = new Cesium.Cartesian3(0, 0, 0);
                    if (moveState.forward) Cesium.Cartesian3.add(move, direction, move);
                    if (moveState.backward) Cesium.Cartesian3.subtract(move, direction, move);
                    if (moveState.right) Cesium.Cartesian3.add(move, right, move);
                    if (moveState.left) Cesium.Cartesian3.subtract(move, right, move);
                    if (moveState.up) Cesium.Cartesian3.add(move, up, move);
                    if (moveState.down) Cesium.Cartesian3.subtract(move, up, move);
                    
                    if (Cesium.Cartesian3.magnitudeSquared(move) > 0) {
                        Cesium.Cartesian3.normalize(move, move);
                        Cesium.Cartesian3.multiplyByScalar(move, distance, move);
                        viewer.camera.move(move, 1.0);
                    }
                }
            };
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PHASE 2 PROOF MODE HELPERS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        /**
         * Step 3: Render minimal local trees as primitives
         */
        function renderProofTrees(viewer) {
            // Tel Aviv tree trunk (vertical pillar)
            const telAvivPos = Cesium.Cartesian3.fromDegrees(34.7818, 32.0853, 0);
            const telAvivTop = Cesium.Cartesian3.fromDegrees(34.7818, 32.0853, 500000);  // 500 km high
            
            const telAvivGeometry = new Cesium.PolylineGeometry({
                positions: [telAvivPos, telAvivTop],
                width: 5.0,
                vertexFormat: Cesium.PolylineColorAppearance.VERTEX_FORMAT,
                arcType: Cesium.ArcType.NONE  // Straight line (not following ellipsoid)
            });
            
            const telAvivInstance = new Cesium.GeometryInstance({
                geometry: telAvivGeometry,
                id: 'trunk_telaviv',
                attributes: {
                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(
                        new Cesium.Color(0.2, 0.8, 0.3, 1.0)  // Green
                    )
                }
            });
            
            const telAvivPrimitive = new Cesium.Primitive({
                geometryInstances: telAvivInstance,
                appearance: new Cesium.PolylineColorAppearance(),
                asynchronous: false
            });
            
            viewer.scene.primitives.add(telAvivPrimitive);
            
            // NYC tree trunk (vertical pillar)
            const nycPos = Cesium.Cartesian3.fromDegrees(-74.0060, 40.7128, 0);
            const nycTop = Cesium.Cartesian3.fromDegrees(-74.0060, 40.7128, 500000);  // 500 km high
            
            const nycGeometry = new Cesium.PolylineGeometry({
                positions: [nycPos, nycTop],
                width: 5.0,
                vertexFormat: Cesium.PolylineColorAppearance.VERTEX_FORMAT,
                arcType: Cesium.ArcType.NONE  // Straight line (not following ellipsoid)
            });
            
            const nycInstance = new Cesium.GeometryInstance({
                geometry: nycGeometry,
                id: 'trunk_nyc',
                attributes: {
                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(
                        new Cesium.Color(0.2, 0.8, 0.3, 1.0)  // Green
                    )
                }
            });
            
            const nycPrimitive = new Cesium.Primitive({
                geometryInstances: nycInstance,
                appearance: new Cesium.PolylineColorAppearance(),
                asynchronous: false
            });
            
            viewer.scene.primitives.add(nycPrimitive);
            
            RelayLog.info('‚úÖ Phase 2: Local trees rendered as primitives');
        }
        
        /**
         * Step 4: Set camera to proof position
         */
        function setProofCamera(viewer) {
            viewer.camera.setView({
                destination: Cesium.Cartesian3.fromDegrees(0, 0, 28000000),  // 28,000 km altitude
                orientation: {
                    heading: 0.0,
                    pitch: Cesium.Math.toRadians(-45),  // Tilted down 45 degrees
                    roll: 0.0
                }
            });
            
            RelayLog.info('‚úÖ Phase 2: Camera set to proof position (28k km, pitch -45¬∞)');
        }
        
        /**
         * Step 5: Log proof data to console
         */
        function logProofData() {
            setTimeout(() => {
                const height = getCameraHeightAboveGround(viewer);
                const lodLevel = lodGovernor ? lodGovernor.getCurrentLevel() : 'UNKNOWN';
                const primitiveCount = viewer.scene.primitives.length;
                const relStats = relationshipRenderer ? relationshipRenderer.getStats() : {};
                
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('=== Phase 2 Proof - Console Log ===');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log(`Date: ${new Date().toISOString()}`);
                console.log(`Cesium Version: ${Cesium.VERSION}`);
                console.log('');
                console.log(`Current LOD Level: ${lodLevel}`);
                console.log(`Camera Height: ${height.toFixed(0)} m (${(height / 1000).toFixed(0)} km)`);
                console.log('');
                console.log('Primitive Counts:');
                console.log(`- Total primitives in scene: ${primitiveCount}`);
                console.log(`- Trunk Tel Aviv: 1 (PolylineGeometry)`);
                console.log(`- Trunk NYC: 1 (PolylineGeometry)`);
                console.log(`- Relationship legs: ${relStats.legs || 0}`);
                console.log(`- Core marker: ${relStats.coreMarker ? 'Yes' : 'No'}`);
                console.log('');
                console.log('Relationship Renderer:');
                console.log(`- Relationship ID: rel.telaviv_nyc.packaging_film`);
                console.log(`- Leg A: tree.telaviv ‚Üí earth.core`);
                console.log(`- Leg B: earth.core ‚Üí tree.nyc`);
                console.log(`- Route verified: V-shape converges at EARTH_CENTER (0,0,0)`);
                console.log('');
                console.log('ENU Frames:');
                console.log(`- tree.telaviv: Anchored at (32.0853, 34.7818)`);
                console.log(`- tree.nyc: Anchored at (40.7128, -74.0060)`);
                console.log('');
                console.log(`Entity Count: ${viewer.entities.values.length} (labels only, no geometry)`);
                console.log('');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('=== End Log ===');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('');
                console.log('üì∏ NEXT: Capture screenshot ‚Üí Save as archive/proofs/phase2-proof-screenshot.png');
                console.log('üíæ NEXT: Copy this log ‚Üí Save as archive/proofs/phase2-proof-console.log');
            }, 2000);
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // START APPLICATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        initialize();
        
    </script>
</body>
</html>
