<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåç Relay Cesium World - Unified Application (Modular)</title>
    
    <!-- Cesium CSS (CDN - requires internet once to cache) -->
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.113/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    
    <!-- XLSX for Excel import (local) -->
    <script src="./libs/xlsx.full.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            overflow: hidden;
        }
        
        #cesiumContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        /* Drop zone overlay */
        #dropZone {
            position: absolute;
            top: 12px;
            right: 12px;
            padding: 6px 14px;
            background: rgba(20, 20, 30, 0.85);
            border: 1px dashed rgba(0, 221, 255, 0.5);
            border-radius: 8px;
            text-align: center;
            pointer-events: all;
            z-index: 1000;
            transition: border-color 0.2s ease, background 0.2s ease;
            max-width: 180px;
            font-size: 12px;
        }
        
        #dropZone:hover {
            border-color: #00ddff;
            background: rgba(20, 20, 30, 0.95);
        }
        
        #dropZone.hidden {
            display: none;
            pointer-events: none;
        }
        
        #dropZone h2 {
            margin: 0 0 2px 0;
            color: #00ddff;
            font-size: 13px;
            font-weight: 500;
        }
        
        #dropZone p {
            color: #888;
            margin: 0;
            font-size: 11px;
            line-height: 1.3;
        }
        
        /* Loading indicator */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px;
            background: rgba(20, 20, 30, 0.95);
            border-radius: 12px;
            text-align: center;
            z-index: 999;
        }
        
        #loading.hidden {
            display: none;
            pointer-events: none;
        }

        /* W0.1 mode surface (minimal governance status) */
        #workModeSurface {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1200;
            padding: 8px 10px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            background: rgba(8, 14, 24, 0.9);
            border: 1px solid rgba(127, 211, 255, 0.45);
            color: #d7ecff;
            pointer-events: none;
            user-select: none;
            white-space: nowrap;
        }
        #workModeSurface.mode-draft { border-color: rgba(127, 211, 255, 0.45); color: #d7ecff; }
        #workModeSurface.mode-hold { border-color: rgba(255, 196, 112, 0.65); color: #ffe8bf; }
        #workModeSurface.mode-propose { border-color: rgba(183, 153, 255, 0.65); color: #eadfff; }
        #workModeSurface.mode-commit { border-color: rgba(112, 225, 145, 0.65); color: #d7ffe2; }

        /* W0.5 minimal artifact inspector */
        #artifactInspectorPanel {
            position: absolute;
            right: 20px;
            bottom: 20px;
            width: 420px;
            max-height: 42vh;
            overflow: auto;
            z-index: 1250;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(120, 180, 255, 0.4);
            background: rgba(8, 12, 22, 0.92);
            color: #d8e7ff;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }
        .artifact-title { font-weight: 700; margin-bottom: 6px; color: #8dd3ff; }
        .artifact-row { margin-bottom: 8px; }
        .artifact-row strong { color: #cbe5ff; }
        .artifact-actions { display: inline-flex; gap: 6px; margin-left: 8px; }
        .artifact-btn {
            border: 1px solid rgba(120, 180, 255, 0.45);
            background: rgba(18, 28, 45, 0.95);
            color: #d7ecff;
            border-radius: 4px;
            padding: 1px 6px;
            font-size: 10px;
            cursor: pointer;
        }
        .artifact-btn:hover { background: rgba(35, 50, 80, 0.95); }
        .artifact-list {
            margin-top: 8px;
            border-top: 1px solid rgba(120, 180, 255, 0.25);
            padding-top: 8px;
        }
        .artifact-item {
            padding: 4px 6px;
            border-radius: 4px;
            margin-bottom: 2px;
            cursor: pointer;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .artifact-item:hover { background: rgba(44, 64, 102, 0.35); }
        .artifact-item.selected { background: rgba(66, 96, 150, 0.55); }

        /* P2P-CORE v0 minimal entry surfaces */
        #p2pEntryPanel {
            position: absolute;
            left: 20px;
            bottom: 20px;
            width: 360px;
            max-height: 42vh;
            overflow: auto;
            z-index: 1240;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(120, 200, 120, 0.45);
            background: rgba(8, 18, 10, 0.92);
            color: #d8ffe7;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }
        .p2p-title { font-weight: 700; margin-bottom: 8px; color: #9fffc1; }
        .p2p-row { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 6px; }
        .p2p-row input {
            width: 100%;
            border: 1px solid rgba(120, 200, 120, 0.35);
            border-radius: 4px;
            padding: 3px 4px;
            background: rgba(12, 24, 14, 0.95);
            color: #d8ffe7;
            font-family: inherit;
            font-size: 10px;
        }
        .p2p-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; }
        .p2p-btn {
            border: 1px solid rgba(120, 200, 120, 0.45);
            background: rgba(20, 38, 24, 0.96);
            color: #d8ffe7;
            border-radius: 4px;
            padding: 4px 5px;
            font-size: 10px;
            cursor: pointer;
            text-align: center;
        }
        .p2p-btn:hover { background: rgba(30, 55, 34, 0.96); }
        /* UX-3: Branch Steward (Visible Configuration) */
        #branchStewardPanel {
            position: absolute;
            right: 20px;
            bottom: 190px;
            width: 340px;
            max-height: 48vh;
            overflow: auto;
            z-index: 1242;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(120, 180, 255, 0.45);
            background: rgba(8, 16, 28, 0.92);
            color: #deebff;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }
        .ux3-title { font-weight: 700; margin-bottom: 8px; color: #9ed0ff; }
        .ux3-row { display: grid; grid-template-columns: 1fr auto; gap: 6px; margin-bottom: 6px; }
        .ux3-row.single { grid-template-columns: 1fr; }
        .ux3-row input,
        .ux3-row select,
        #ux3ConfigEditor {
            width: 100%;
            border: 1px solid rgba(120, 180, 255, 0.35);
            border-radius: 4px;
            padding: 4px 5px;
            background: rgba(10, 22, 35, 0.95);
            color: #deebff;
            font-family: inherit;
            font-size: 10px;
        }
        #ux3ConfigEditor { min-height: 120px; resize: vertical; }
        .ux3-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-top: 6px; }
        .ux3-btn {
            border: 1px solid rgba(120, 180, 255, 0.45);
            background: rgba(18, 34, 58, 0.96);
            color: #deebff;
            border-radius: 4px;
            padding: 4px 5px;
            font-size: 10px;
            cursor: pointer;
            text-align: center;
        }
        .ux3-btn:hover { background: rgba(26, 44, 72, 0.96); }
        #ux3StatusLine { margin-top: 6px; color: #a8bdd9; min-height: 14px; }

        /* VOTE-A2: Voting UI Reactivation (stateless display over canonical primitives) */
        #voteLanePanel {
            position: absolute;
            left: 20px;
            bottom: 180px;
            width: 420px;
            max-height: 28vh;
            overflow: auto;
            z-index: 1241;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 190, 120, 0.42);
            background: rgba(26, 18, 10, 0.92);
            color: #ffe8cc;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }
        #voteLaneTitle { font-weight: 700; margin-bottom: 6px; color: #ffd4a1; }
        #voteLaneList { display: flex; flex-direction: row; gap: 6px; overflow-x: auto; padding-bottom: 2px; }
        .vote-lane-topic {
            min-width: 180px;
            border: 1px solid rgba(255, 190, 120, 0.28);
            border-radius: 6px;
            padding: 6px;
            background: rgba(38, 26, 14, 0.9);
            cursor: pointer;
        }
        .vote-lane-topic:hover { background: rgba(48, 34, 18, 0.95); }
        .vote-lane-topic.selected { border-color: rgba(255, 222, 130, 0.72); }
        .vote-topic-title { color: #ffe3ba; font-weight: 700; margin-bottom: 4px; }
        .vote-topic-meta { color: #f4cca3; font-size: 10px; line-height: 1.4; }

        #votePanel {
            position: absolute;
            right: 20px;
            bottom: 20px;
            width: 340px;
            max-height: 32vh;
            overflow: auto;
            z-index: 1243;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 190, 120, 0.45);
            background: rgba(22, 14, 8, 0.92);
            color: #ffe8cc;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }
        .vote-panel-title { font-weight: 700; margin-bottom: 6px; color: #ffd4a1; }
        .vote-panel-row { margin-bottom: 4px; color: #f2d4af; }
        .vote-panel-row b { color: #ffeccf; }
        .vote-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-top: 6px; }
        .vote-btn {
            border: 1px solid rgba(255, 190, 120, 0.45);
            background: rgba(52, 34, 20, 0.95);
            color: #ffe8cc;
            border-radius: 4px;
            padding: 4px 5px;
            font-size: 10px;
            cursor: pointer;
            text-align: center;
        }
        .vote-btn:hover { background: rgba(66, 44, 24, 0.95); }
        #voteStatusLine { margin-top: 6px; min-height: 14px; color: #f0cda0; }
        
        /* HUD (Heads-Up Display) */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.6;
            z-index: 500;
        }
        
        #hud div {
            margin: 2px 0;
        }
        /* HUD-CONSOLIDATION-1: Tier 2 collapsed = no layout height */
        #hud .hud-tier2.collapsed {
            height: 0;
            overflow: hidden;
            margin: 0;
            padding: 0;
            border: none;
        }

        /* Spreadsheet overlay (MVP) */
        #sheetOverlay {
            position: absolute;
            left: 20px;
            right: 20px;
            bottom: 20px;
            height: 140px;
            background: rgba(10, 10, 16, 0.9);
            border: 1px solid #2b2b35;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            color: #dcdcdc;
            z-index: 550;
            display: none;
            pointer-events: auto;
        }

        #sheetOverlay .bar {
            display: flex;
            gap: 10px;
            padding: 8px 10px;
            border-bottom: 1px solid #2b2b35;
            align-items: center;
        }

        #sheetOverlay .bar label {
            color: #aaa;
            font-size: 11px;
        }

        #sheetOverlay .bar .cell {
            color: #7fd3ff;
            font-weight: 600;
        }

        #sheetOverlay .body {
            padding: 10px;
            font-size: 12px;
            max-height: 70px;
            overflow: auto;
        }

        #sheetOverlay .value,
        #sheetOverlay .formula {
            margin-top: 6px;
            color: #cfcfcf;
            word-break: break-word;
        }

        #sheetOverlay .edit {
            margin-top: 8px;
        }

        #sheetOverlay input {
            width: 100%;
            padding: 6px 8px;
            background: #0f0f18;
            border: 1px solid #2b2b35;
            border-radius: 6px;
            color: #e6e6e6;
            font-family: inherit;
            font-size: 12px;
        }

        #sheetOverlay .hint {
            margin-top: 8px;
            color: #777;
            font-size: 11px;
        }
        
        /* Info panel */
        #infoPanel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            max-height: 50vh;
            padding: 15px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            overflow-y: auto;
            z-index: 500;
            display: none;
        }
        
        #infoPanel h3 {
            margin: 0 0 10px 0;
            color: #00ddff;
        }
        
        /* Log console */
        #logConsole {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 500px;
            max-height: 200px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            overflow-y: auto;
            z-index: 500;
        }
        
        #logConsole div {
            margin: 2px 0;
            padding: 2px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .log-error { color: #ff4444; }
        .log-warn { color: #ffaa00; }
        .log-info { color: #00ddff; }

        /* Docking: 3D fades only when transition is triggered */
        #cesiumContainer {
            transition: opacity 0.6s ease-out, filter 0.6s ease-out;
        }

        body.edit-sheet-preview #cesiumContainer {
            opacity: 0.92;
            filter: brightness(0.9);
        }

        body.edit-sheet-mode #cesiumContainer {
            opacity: 0;
            pointer-events: none;
        }

        body.edit-sheet-mode #sheetOverlay {
            display: none;
        }

        /* 2D overlay: always mounted, snap to full screen on dock */
        #spreadsheetOverlay {
            position: absolute;
            inset: 0;
            z-index: 540;
            display: block;
            opacity: 0;
            pointer-events: none;
            background: #080e1c;
            transition: opacity 0.5s ease-out;
        }

        body.edit-sheet-preview #spreadsheetOverlay {
            opacity: 0.06;
            pointer-events: none;
        }

        body.edit-sheet-mode #spreadsheetOverlay {
            opacity: 1;
            pointer-events: auto;
            background: #080e1c;
        }

        body.force-overlay #spreadsheetOverlay {
            opacity: 1 !important;
            pointer-events: auto !important;
            z-index: 600 !important;
        }

        /* ‚îÄ‚îÄ‚îÄ Focus Lens Mode (D-Lens-0) ‚îÄ‚îÄ‚îÄ */
        body.focus-lens-active #cesiumContainer {
            filter: brightness(0.55) saturate(0.4);
        }
        body.focus-lens-active #cesiumContainer {
            transition: filter 0.8s ease-out;
        }
        /* Focus highlight overlay ‚Äî renders OVER the dimmed scene to brighten focused area */
        #focusLensVignette {
            position: fixed;
            inset: 0;
            z-index: 50;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.6s ease-out;
            background: radial-gradient(ellipse 50% 50% at 50% 50%, transparent 0%, rgba(0,0,0,0.55) 100%);
        }
        body.focus-lens-active #focusLensVignette {
            opacity: 1;
        }
        /* Focus breadcrumb bar */
        #focusBreadcrumb {
            position: fixed;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 800;
            background: rgba(10, 20, 40, 0.92);
            border: 1px solid rgba(0, 180, 255, 0.4);
            border-radius: 6px;
            padding: 6px 18px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #7fd3ff;
            display: none;
            align-items: center;
            gap: 10px;
            backdrop-filter: blur(6px);
            box-shadow: 0 2px 16px rgba(0, 120, 200, 0.15);
        }
        body.focus-lens-active #focusBreadcrumb {
            display: flex;
        }
        #focusBreadcrumb .crumb {
            color: #4a6a8a;
        }
        #focusBreadcrumb .crumb-active {
            color: #7fd3ff;
            font-weight: bold;
        }
        #focusBreadcrumb .focus-exit-btn {
            cursor: pointer;
            color: #ff6b6b;
            margin-left: 8px;
            font-size: 14px;
            opacity: 0.7;
            transition: opacity 0.15s;
        }
        #focusBreadcrumb .focus-exit-btn:hover {
            opacity: 1;
        }

        #sheetGridHeader {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 48px;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 0 16px;
            border-bottom: 1px solid rgba(120, 140, 170, 0.3);
            background: #0f172a;
            color: #e2e8f0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        #sheetGridTitle {
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 60vw;
            font-size: 11px;
            font-family: 'Consolas', 'Monaco', monospace;
            color: #00ddff;
        }

        #sheetGridFormula {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }

        #sheetGridCellRef {
            min-width: 48px;
            text-align: center;
            padding: 4px 6px;
            border: 1px solid rgba(120, 140, 170, 0.3);
            border-radius: 4px;
            background: rgba(20, 30, 50, 0.6);
        }

        #sheetGridFormulaInput {
            flex: 1;
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid rgba(120, 140, 170, 0.3);
            background: rgba(10, 14, 24, 0.9);
            color: #e2e8f0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        #sheetGridScroll {
            position: absolute;
            overflow: hidden;
            top: 48px;
            bottom: 24px;   /* leave room for status line */
            left: 0;
            right: 0;
        }

        #sheetGridTable {
            display: grid;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #e2e8f0;
            width: 100%;
            height: 100%;
            /* grid-template-columns and grid-template-rows set dynamically */
        }

        .grid-cell {
            box-sizing: border-box;
            border: 1px solid rgba(80, 110, 150, 0.35);
            padding: 4px 6px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            display: flex;
            align-items: center;
        }

        .grid-header {
            background: rgba(18, 28, 48, 0.95);
            font-weight: 600;
        }

        .grid-row-header {
            justify-content: flex-end;
            color: rgba(200, 220, 255, 0.75);
        }

        .grid-col-header {
            justify-content: center;
            color: rgba(200, 220, 255, 0.75);
        }

        .grid-selected {
            outline: 2px solid rgba(255, 215, 0, 0.85);
            outline-offset: -2px;
        }

        /* B2: Match status cell highlighting */
        .match-status-matched    { background: rgba(0, 200, 80, 0.15) !important; color: #5eff8a; }
        .match-status-exception  { background: rgba(255, 80, 40, 0.2) !important; color: #ff7b6b; }
        .match-status-unmatched  { background: rgba(255, 200, 0, 0.15) !important; color: #ffd666; }
        .match-row-clickable     { cursor: pointer;
            background: rgba(255, 215, 0, 0.08);
        }
        /* B3: Summary sheet formula cell highlighting */
        .summary-formula-cell    { background: rgba(0, 130, 255, 0.08) !important; }
        .summary-label-cell      { color: #b0c4de; font-weight: 500; }

        /* ‚îÄ‚îÄ‚îÄ Custom Scrollbars ‚îÄ‚îÄ‚îÄ */
        .grid-scrollbar {
            position: absolute;
            z-index: 20;
            background: rgba(20, 30, 50, 0.5);
        }
        .grid-scrollbar-v {
            right: 0;
            top: 0;
            bottom: 10px;  /* leave room for horizontal scrollbar */
            width: 10px;
        }
        .grid-scrollbar-h {
            bottom: 0;
            left: 0;
            right: 10px;  /* leave room for vertical scrollbar */
            height: 10px;
        }
        .grid-scrollbar-thumb {
            position: absolute;
            background: rgba(180, 200, 230, 0.3);
            border-radius: 4px;
            min-width: 20px;
            min-height: 20px;
            cursor: pointer;
            transition: background 0.15s;
        }
        .grid-scrollbar-thumb:hover,
        .grid-scrollbar-thumb.dragging {
            background: rgba(180, 200, 230, 0.55);
        }
        .grid-scrollbar-v .grid-scrollbar-thumb {
            left: 1px;
            right: 1px;
        }
        .grid-scrollbar-h .grid-scrollbar-thumb {
            top: 1px;
            bottom: 1px;
        }

        /* ‚îÄ‚îÄ‚îÄ Status Line ‚îÄ‚îÄ‚îÄ */
        #sheetGridStatusLine {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 0 16px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: rgba(180, 200, 230, 0.6);
            background: rgba(15, 23, 42, 0.9);
            border-top: 1px solid rgba(120, 140, 170, 0.2);
            z-index: 10;
            pointer-events: none;
        }
        /* ‚ïê‚ïê‚ïê LAUNCH READABILITY PASS: hide dev panels in launch mode ‚ïê‚ïê‚ïê */
        body.launch-mode #artifactInspectorPanel,
        body.launch-mode #p2pEntryPanel,
        body.launch-mode #branchStewardPanel,
        body.launch-mode #voteLanePanel,
        body.launch-mode #votePanel,
        body.launch-mode #workModeSurface,
        body.launch-mode #logConsole,
        body.launch-mode #infoPanel {
            display: none !important;
        }
        /* Launch HUD: compact, no diagnostics clutter */
        body.launch-mode #hud {
            max-width: 280px;
            font-size: 10px;
        }
        /* Launch "What am I looking at?" help overlay */
        #launchHelpOverlay {
            position: fixed;
            top: 16px;
            right: 16px;
            width: 240px;
            padding: 14px 16px;
            background: rgba(10, 15, 30, 0.92);
            border: 1px solid rgba(100, 180, 255, 0.25);
            border-radius: 8px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 11px;
            color: rgba(200, 215, 235, 0.9);
            line-height: 1.55;
            z-index: 600;
            display: none;
        }
        body.launch-mode #launchHelpOverlay { display: block; }
        #launchHelpOverlay .lh-title {
            font-weight: 600;
            color: #7fd3ff;
            margin-bottom: 8px;
            font-size: 12px;
        }
        #launchHelpOverlay .lh-item {
            margin: 3px 0;
        }
        #launchHelpOverlay .lh-key {
            display: inline-block;
            min-width: 22px;
            padding: 1px 5px;
            background: rgba(100, 180, 255, 0.15);
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            color: #7fd3ff;
            text-align: center;
            margin-right: 4px;
        }
        #launchHelpOverlay .lh-sep {
            border-top: 1px solid rgba(100, 180, 255, 0.12);
            margin: 8px 0;
        }
        #launchHelpOverlay .lh-dismiss {
            margin-top: 8px;
            font-size: 9px;
            color: rgba(160, 175, 200, 0.5);
            cursor: pointer;
        }
        #launchHelpOverlay .lh-dismiss:hover { color: rgba(200, 215, 235, 0.8); }
        /* Launch "Enter Sheet" button */
        #launchEnterSheetBtn {
            position: fixed;
            bottom: 24px;
            right: 24px;
            padding: 10px 20px;
            background: rgba(40, 80, 140, 0.85);
            border: 1px solid rgba(100, 180, 255, 0.35);
            border-radius: 6px;
            color: #c8d7eb;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            z-index: 600;
            display: none;
            transition: background 0.2s;
        }
        body.launch-mode #launchEnterSheetBtn { display: block; }
        #launchEnterSheetBtn:hover {
            background: rgba(50, 100, 170, 0.95);
            border-color: rgba(120, 200, 255, 0.5);
        }
        #launchSimulateFlowBtn {
            position: fixed;
            bottom: 24px;
            right: 200px;
            padding: 10px 20px;
            background: rgba(50, 100, 60, 0.85);
            border: 1px solid rgba(100, 200, 120, 0.35);
            border-radius: 6px;
            color: #c8e8d0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            z-index: 600;
            display: none;
        }
        body.launch-mode #launchSimulateFlowBtn { display: block; }
        #launchSimulateFlowBtn:hover { background: rgba(60, 120, 80, 0.95); }
        #launchSimulateVoteBtn {
            position: fixed;
            bottom: 24px;
            right: 420px;
            padding: 10px 20px;
            background: rgba(100, 60, 30, 0.85);
            color: #f0d0a0;
            border: 1px solid rgba(200, 160, 80, 0.3);
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            z-index: 600;
            display: none;
        }
        body.launch-mode #launchSimulateVoteBtn { display: block; }
        #launchSimulateVoteBtn:hover { background: rgba(120, 80, 40, 0.95); }
    </style>
</head>
<body>
    <div id="cesiumContainer"></div>
    <div id="spreadsheetOverlay">
        <div id="sheetGridHeader">
            <div id="sheetGridTitle">Sheet</div>
            <div id="sheetGridFormula">
                <div id="sheetGridCellRef">‚Äî</div>
                <input id="sheetGridFormulaInput" type="text" placeholder="Formula / value">
            </div>
        </div>
        <div id="sheetGridScroll">
            <div id="sheetGridTable"></div>
            <div id="gridScrollbarV" class="grid-scrollbar grid-scrollbar-v">
                <div class="grid-scrollbar-thumb" id="gridScrollbarVThumb"></div>
            </div>
            <div id="gridScrollbarH" class="grid-scrollbar grid-scrollbar-h">
                <div class="grid-scrollbar-thumb" id="gridScrollbarHThumb"></div>
            </div>
        </div>
        <div id="sheetGridStatusLine"></div>
        <!-- B2.3: Match Inspector Panel (drill-through to source rows) -->
        <div id="matchInspector" style="display:none; position:absolute; right:0; top:48px; bottom:0; width:360px; background:rgba(10,15,25,0.95); border-left:1px solid rgba(0,180,255,0.3); overflow-y:auto; z-index:110; padding:10px; font-family:'Courier New',monospace; font-size:11px; color:#c8d6e5;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                <strong id="inspectorTitle" style="color:#7fd3ff;">Inspector</strong>
                <span id="matchInspectorClose" style="cursor:pointer; color:#ff6b6b; font-size:16px; padding:0 4px;">&times;</span>
            </div>
            <div id="matchInspectorContent"></div>
        </div>

        <!-- UX-1.2: Capability Buds (floating action panel) -->
        <div id="capabilityBuds" style="display:none; position:absolute; z-index:120; background:rgba(10,18,30,0.96); border:1px solid rgba(0,180,255,0.4); border-radius:6px; padding:6px 4px; font-family:'Courier New',monospace; font-size:11px; color:#c8d6e5; min-width:180px; max-width:260px; box-shadow:0 4px 20px rgba(0,0,0,0.6), 0 0 8px rgba(0,120,255,0.15); pointer-events:auto;">
            <div id="capBudsHeader" style="color:#ffd700; font-weight:bold; font-size:10px; margin-bottom:4px; padding:2px 6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"></div>
            <div id="capBudsActions" style="display:flex; flex-direction:column; gap:2px;"></div>
        </div>
    </div>
    
    <!-- Focus Lens (D-Lens-0) -->
    <div id="focusLensVignette"></div>
    <div id="focusBreadcrumb">
        <span class="crumb" id="focusCrumbRoot">Earth</span>
        <span class="crumb">&rsaquo;</span>
        <span class="crumb" id="focusCrumbBranch">‚Äî</span>
        <span class="crumb">&rsaquo;</span>
        <span class="crumb-active" id="focusCrumbTarget">‚Äî</span>
        <span class="focus-exit-btn" id="focusExitBtn" title="Exit Focus (Esc)">&#x2715;</span>
    </div>

    <div id="dropZone">
        <h2>üìÇ Drop Excel File</h2>
        <p>Drop an .xlsx or .xls file to visualize</p>
    </div>
    
    <div id="loading">
        <h3>üåç Loading Relay...</h3>
        <p>Initializing Cesium viewer...</p>
    </div>
    <div id="workModeSurface">MODE DRAFT | zone.avgol.ops</div>
    <div id="artifactInspectorPanel">
        <div class="artifact-title">Artifacts Inspector</div>
    </div>
    <div id="p2pEntryPanel">
        <div class="p2p-title">P2P-CORE v0 Entry</div>
        <div class="p2p-row">
            <input id="p2pSiteId" type="text" value="SITE_A" placeholder="siteId">
            <input id="p2pItemId" type="text" value="item.RESIN_7" placeholder="itemId">
            <input id="p2pQty" type="number" step="0.001" value="100" placeholder="qty">
            <input id="p2pUnitPrice" type="number" step="0.01" value="100" placeholder="unitPrice">
        </div>
        <div class="p2p-actions">
            <button id="p2pCreatePRBtn" class="p2p-btn">Create PR</button>
            <button id="p2pCreatePOBtn" class="p2p-btn">Create PO from PR</button>
            <button id="p2pPostGRBtn" class="p2p-btn">Post GR against PO</button>
            <button id="p2pPostINVBtn" class="p2p-btn">Post INV against PO</button>
            <button id="p2pPostPAYBtn" class="p2p-btn">Post PAY against INV</button>
            <button id="p2pRunProofBtn" class="p2p-btn">Run P2P Happy Loop</button>
        </div>
    </div>
    <div id="branchStewardPanel">
        <div class="ux3-title">UX-3 Branch Steward</div>
        <div class="ux3-row">
            <select id="ux3ModuleSelect"></select>
            <button id="ux3RefreshBtn" class="ux3-btn">Refresh</button>
        </div>
        <div class="ux3-row single">
            <input id="ux3SummaryInput" type="text" placeholder="Summary (required for PROPOSE)">
        </div>
        <textarea id="ux3ConfigEditor" spellcheck="false"></textarea>
        <div class="ux3-actions">
            <button id="ux3ProposeBtn" class="ux3-btn">Propose Config Edit</button>
            <button id="ux3CommitBtn" class="ux3-btn">Commit Proposal</button>
        </div>
        <div id="ux3StatusLine">idle</div>
    </div>
    <div id="voteLanePanel">
        <div id="voteLaneTitle">VOTE-A2 Topic Lane</div>
        <div id="voteLaneList"></div>
    </div>
    <div id="votePanel">
        <div class="vote-panel-title">Vote Panel</div>
        <div id="votePanelBody">No topic selected.</div>
        <div class="vote-actions">
            <button id="voteApproveBtn" class="vote-btn">Cast Approve</button>
            <button id="voteRejectBtn" class="vote-btn">Cast Reject</button>
        </div>
        <div id="voteStatusLine">idle</div>
    </div>
    
    <div id="hud"></div>
    <div id="infoPanel"></div>
    <div id="sheetOverlay">
        <div class="bar">
            <label>Sheet</label><span id="sheetOverlaySheet" class="cell">‚Äî</span>
            <label>Cell</label><span id="sheetOverlayCell" class="cell">‚Äî</span>
        </div>
        <div class="body">
            <div class="value" id="sheetOverlayValue">Value: ‚Äî</div>
            <div class="formula" id="sheetOverlayFormula">Formula: ‚Äî</div>
            <div class="edit"><input id="sheetOverlayInput" type="text" placeholder="Press F2 or double click to edit" disabled></div>
            <div class="hint">Enter to commit, Esc to cancel. Drag to select a range. Ctrl+C / Ctrl+V for range copy/paste.</div>
        </div>
    </div>
    <div id="logConsole"></div>
    
    <!-- LAUNCH READABILITY PASS: Help overlay + Enter Sheet button (launch-only) -->
    <div id="launchHelpOverlay">
        <div class="lh-title">Relay ‚Äî Company View</div>
        <div class="lh-item"><b>Trunk</b> = Company (vertical pillar)</div>
        <div class="lh-item"><b>Branches</b> = Departments (horizontal ribs)</div>
        <div class="lh-item"><b>Tiles</b> = Sheets (collapsed at company zoom)</div>
        <div class="lh-item"><b>Slabs</b> = Timebox history stacks</div>
        <div class="lh-item"><b>Lines down</b> = Root / history filaments</div>
        <div class="lh-sep"></div>
        <div class="lh-item"><span class="lh-key">E</span> Enter nearest sheet</div>
        <div class="lh-item"><span class="lh-key">Esc</span> Exit sheet / back</div>
        <div class="lh-item"><span class="lh-key">H</span> Toggle HUD</div>
        <div class="lh-item"><span class="lh-key">WASD</span> Fly controls</div>
        <div class="lh-dismiss" id="launchHelpDismiss">Click to dismiss</div>
    </div>
    <button id="launchEnterSheetBtn">Enter Selected Sheet</button>
    <button id="launchSimulateFlowBtn" title="COMPANY-TEMPLATE-FLOW-1: run one deterministic event through Route ‚Üí Fact ‚Üí Match ‚Üí Summary ‚Üí KPI ‚Üí Timebox">Simulate Event</button>
    <button id="launchSimulateVoteBtn" title="VOTE-COMMIT-PERSISTENCE-1: simulate governance decisions (PASSED+REJECTED) and persist">Simulate Vote</button>
    <button id="launchSimulateDisclosureBtn" title="FILAMENT-DISCLOSURE-1: upgrade FIL-001 from PRIVATE to WITNESSED with evidence">Simulate Disclosure</button>
    
    <!-- Cesium JS (CDN - requires internet once to cache) -->
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.113/Build/Cesium/Cesium.js"></script>
    
    <!-- Relay Core Modules (Lock B: Modular Architecture, Lock F: Core cannot import Cesium) -->
    <script type="module">
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // RELAY CESIUM WORLD - MODULAR VERSION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // Lock B: Thin entrypoint, implementation in modules
        // Lock F: core/** cannot import Cesium
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Import core utilities and services (renderer-agnostic)
        import { RelayLog } from './core/utils/relay-log.js';
        import { relayState, getTreeStats } from './core/models/relay-state.js';
        import { RelayLODGovernor } from './core/services/lod-governor.js';
        import { CANONICAL_LAYOUT } from './app/utils/enu-coordinates.js';
        
        // Import Cesium-specific modules
        import { initializeCesiumViewer, getCameraHeightAboveGround } from './app/cesium/viewer-init.js';
        import { listImageryModes, applyImageryMode } from './app/cesium/imagery-registry.js';
        import { WeatherManager } from './app/cesium/weather-manager.js';
        import { TopographyManager } from './app/cesium/topography-manager.js';
        import { WorldGlobeManager } from './app/cesium/world-globe-manager.js';
        import { Restore3ScopeManager } from './app/cesium/restore3-scope-manager.js';
        import { Restore4AssignmentManager } from './app/cesium/restore4-assignment-manager.js';
        import { CesiumFilamentRenderer } from './app/renderers/filament-renderer.js';
        import { RelationshipRenderer } from './app/renderers/relationship-renderer.js';
        import { BoundaryRenderer } from './app/renderers/boundary-renderer.js';
        import { BoundaryEditor } from './app/cesium/boundary-editor.js';
        import { HUDManager } from './app/ui/hud-manager.js';
        import { VotingUIManager } from './app/ui/voting-ui-manager.js';
        import { ExcelImporter } from './app/excel-importer.js';
        import { loadModule, buildMatches, buildSummaryData, validateCellValue, getColumnSchema } from './app/modules/module-loader.js';
        import { loadRoutes, ingestRecord, ingestBatch, previewRoute, getRoute, getRouteIds, getSheetForFactClass, generateMockRecord, P2P_MOCK_SCENARIOS } from './app/modules/route-engine.js';
        import { toRelayObject, getActionRegistry, getActionsForType } from './app/ux/relay-object-contract.js';
        import { PresenceEngine } from './app/presence/presence-engine.js';
        import { PresenceWebRTCAdapter } from './app/presence/webrtc-adapter.js';
        import { PresenceRenderer } from './app/presence/presence-renderer.js';
        import { sha256 as _sha256Fn, canonicalJson as _canonicalJsonFn } from './app/presence/presence-protocol.js';
        import { createPR, createPOFromPR, createGRFromPO, createINVFromPO, createPAYFromINV } from './core/models/p2p/p2p-core-v0.js';
        import { projectJournalFromTransferPackets, computeTrialBalance, hashProjection } from './core/models/ledger/ledger-v0.js';
        import { LEDGER_MAPPING_POLICY_V0 } from './core/models/ledger/coa-seed-v0.js';
        import { computeOnHandFromPackets, computeInventoryValuationFromPackets } from './core/models/inventory/inv-core-v0.js';
        import { createPaymentBatch, executePaymentBatch, matchBankStatementLines } from './core/models/payments/pay-core-v0.js';
        import { exportTaxReport } from './core/models/tax/tax0-v0.js';
        import { buildTier1ParityFixture, computeTier1GoldenHashesFromFixture } from './core/models/headless/tier1-parity.js';
        import { buildCommitIndexMap, filterSheetCommitsByRange, replaySheetSHA256, replayModuleSHA256, buildDivergenceScarEvent } from './core/models/replay/replay-engine.js';
        import { aggregateBranchMetrics, hashAggregation } from './core/models/aggregation/trunk-aggregation-v0.js';
        import { buildGlobalChain, buildSheetChains, appendGlobalChainEntry, appendSheetChainEntry, sha256 as cryptoSha256, stableStringify as cryptoStableStringify } from './core/models/crypto/hash-chain.js';
        import { buildTimeboxChain, updateTimeboxChainEntry } from './core/models/crypto/merkle-tree.js';
        import { verifyChainIntegrity, getInclusionProof, replayPreCheck } from './core/models/crypto/integrity-verifier.js';
        import { canExecute } from './core/models/stage/stage-gates.js';
        
        // Make key objects globally accessible for debugging
        window.RelayLog = RelayLog;
        window.relayState = relayState;
        const PROFILE_VALUES = new Set(['proof', 'world', 'launch']);
        const resolveRelayProfile = () => {
            const params = new URLSearchParams(window.location.search);
            const direct = params.get('profile');
            let candidate = String(direct || '').toLowerCase().trim();
            // Some launch flows pass encoded query fragments like "?profile%3Dworld".
            // Decode and recover profile value before falling back to defaults.
            if (!PROFILE_VALUES.has(candidate)) {
                const rawSearch = String(window.location.search || '');
                try {
                    const decoded = decodeURIComponent(rawSearch);
                    const match = decoded.match(/(?:\?|&|^)profile=([a-zA-Z]+)/i);
                    if (match?.[1]) {
                        candidate = String(match[1]).toLowerCase().trim();
                    }
                } catch {
                    // ignore decode errors and continue fallback chain
                }
            }
            if (!PROFILE_VALUES.has(candidate)) {
                candidate = String(window.RELAY_PROFILE || 'proof').toLowerCase().trim();
            }
            return PROFILE_VALUES.has(candidate) ? candidate : 'proof';
        };
        const rawProfile = resolveRelayProfile();
        // 'launch' is a clean observer view ‚Äî resolves to 'world' internally with launch flags
        const RELAY_LAUNCH_MODE = rawProfile === 'launch';
        const RELAY_PROFILE = RELAY_LAUNCH_MODE ? 'world' : rawProfile;
        window.RELAY_PROFILE = RELAY_PROFILE;
        window.RELAY_LAUNCH_MODE = RELAY_LAUNCH_MODE;
        // VIS-TREE-SCAFFOLD-1: Initialize render mode (default = LAUNCH_CANOPY)
        window._relayRenderMode = 'LAUNCH_CANOPY';
        // LAUNCH-FIX-1: Presentation-only scale + altitude offset for launch mode
        // Scale shrinks the tree so it fits within a visible city-scale area
        // At 0.25: trunk=500m tall, branches=200m long ‚Äî visible from 1400m camera
        // uOffset is raw meters (not scaled) ‚Äî shifts tree up/down for ground alignment
        window.RELAY_LAUNCH_SCALE = RELAY_LAUNCH_MODE ? 0.25 : 1;
        window.RELAY_LAUNCH_U_OFFSET_M = 0;
        window.relayGetProfile = () => RELAY_LAUNCH_MODE ? 'launch' : RELAY_PROFILE;
        RelayLog.info(`[PROFILE] RELAY_PROFILE=${RELAY_PROFILE}${RELAY_LAUNCH_MODE ? ' (launch mode)' : ''}`);

        // ‚îÄ‚îÄ HEADLESS-0: Headless mode detection ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Decision 1: Both URL param and runtime fallback.
        const _headlessUrlParam = new URLSearchParams(window.location.search).get('headless') === 'true';
        // Runtime fallback is checked later after viewer init (see relayDetectHeadlessFallback).
        window.RELAY_HEADLESS_MODE = _headlessUrlParam; // may upgrade to true later via fallback
        window.RELAY_HEADLESS_REASON = _headlessUrlParam ? 'urlParam' : null;
        if (_headlessUrlParam) {
            RelayLog.info(`[HEADLESS] mode=FORCED reason=urlParam`);
            console.log(`[HEADLESS] mode=FORCED reason=urlParam`);
        }
        window.relayDetectHeadlessFallback = () => {
            if (window.RELAY_HEADLESS_MODE) return; // already forced
            const noViewer = !window.viewer || !window.viewer?.scene;
            if (noViewer) {
                window.RELAY_HEADLESS_MODE = true;
                window.RELAY_HEADLESS_REASON = 'noViewer';
                RelayLog.info(`[HEADLESS] mode=FALLBACK reason=noViewer`);
                console.log(`[HEADLESS] mode=FALLBACK reason=noViewer`);
            }
        };
        // ‚îÄ‚îÄ End HEADLESS-0 detection ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        if (!window.__relayEntryState || typeof window.__relayEntryState !== 'object') {
            window.__relayEntryState = {
                scope: 'world',
                companyId: null,
                deptId: null,
                sheetId: null,
                lastView: null
            };
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // INITIALIZATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let viewer = null;
        let lodGovernor = null;
        let filamentRenderer = null;
        let relationshipRenderer = null;
        let weatherManager = null;
        let topographyManager = null;
        let worldGlobeManager = null;
        let restore3ScopeManager = null;
        let restore4AssignmentManager = null;
        let boundaryRenderer = null;
        let boundaryEditor = null;
        let hudManager = null;
        let excelImporter = null;
        let flightControls = null;
        let sheetOverlay = null;
        let sheetOverlaySheet = null;
        let sheetOverlayCell = null;
        let sheetOverlayValue = null;
        let sheetOverlayFormula = null;
        let sheetOverlayInput = null;
        let sheetOverlayBody = null;
        let editSheetWheelHandler = null;
        let editSheetKeyHandler = null;
        let editSheetInputLogged = false;
        let suppressPointerLock = false;
        let workModeSurfaceEl = null;
        let artifactInspectorPanelEl = null;
        let branchStewardPanelEl = null;
        let ux3ModuleSelectEl = null;
        let ux3SummaryInputEl = null;
        let ux3ConfigEditorEl = null;
        let ux3StatusLineEl = null;
        let voteLanePanelEl = null;
        let voteLaneListEl = null;
        let votePanelEl = null;
        let votePanelBodyEl = null;
        let voteStatusLineEl = null;
        let voteApproveBtnEl = null;
        let voteRejectBtnEl = null;
        let votingUiManager = null;
        let selectedArtifactId = null;
        let selectedTrunkMetricId = null;
        let activeFlowId = null;
        let editSheetAutoCooldownUntil = 0;
        let editSheetManualExit = false;   // set on Escape; cleared when user moves beyond undock range
        window.AUTO_EDIT_SHEET = true;
        let sheetGridOverlay = null;
        let sheetGridScroll = null;
        let sheetGridTable = null;
        let sheetGridTitle = null;
        let sheetGridCellRef = null;
        let sheetGridFormulaInput = null;
        let sheetGridStatusLine = null;
        let editSheetTargetSheet = null;
        let gridSignature = null;
        let selectedGridCell = null;
        let sheetRange = null;
        let p2pModuleDef = null; // Retained for existing P2P runtime wiring
        let loadedModuleDefs = new Map(); // moduleId -> moduleDef
        let sheetToModuleId = new Map(); // sheetId -> moduleId
        let globeImageryKeyHandlerBound = false;
        let globeClusterKeyHandlerBound = false;
        let globeRegionKeyHandlerBound = false;

        const WORLD_IMAGERY_STORAGE_KEY = 'relay.worldImageryMode.v1';
        const DEBUG_LOGS_STORAGE_KEY = 'relay.debugLogs.v1';
        const HUD_PARAMS_POLICY_REF = 'local:HUD-PARAMS-v0';
        const HUD_PARAMS_PATH = './core/policy/hudParams.v0.json';
        const defaultHudParams = () => ({
            paramsVersion: 'HUD-PARAMS-v0',
            layoutMode: 'compact',
            layer1Fields: ['company', 'basin', 'mode', 'importStatus', 'lod', 'policyRef'],
            modeFields: {
                freeFly: [],
                branchWalk: ['branchStep'],
                filamentRide: ['filamentStep'],
                focus: ['focusTarget'],
                sheetEdit: ['cellContext'],
                cellSelected: ['cellContext']
            },
            thresholds: {
                mobileWidthPx: 900,
                layer2CollapseWidthPx: 780
            },
            toggles: {
                showInspectorButton: true,
                showDebugToggles: false,
                showPasteCapText: true
            },
            labels: {
                company: 'Company',
                basin: 'Basin',
                mode: 'Mode',
                importStatus: 'Import',
                lod: 'LOD',
                policyRef: 'Policy'
            }
        });
        const getActivePolicyRef = (domain) => {
            if (String(domain || '').toLowerCase() === 'hud') return HUD_PARAMS_POLICY_REF;
            return 'local:UNKNOWN';
        };
        window.getActivePolicyRef = getActivePolicyRef;
        const loadHudParams = async (policyRef = getActivePolicyRef('hud')) => {
            let loaded = null;
            try {
                const response = await fetch(HUD_PARAMS_PATH, { cache: 'no-store' });
                if (response.ok) {
                    loaded = await response.json();
                }
            } catch {
                // fallback below
            }
            const params = { ...defaultHudParams(), ...(loaded && typeof loaded === 'object' ? loaded : {}) };
            window.__relayHudPolicy = params;
            window.__relayHudPolicyRef = String(policyRef || HUD_PARAMS_POLICY_REF);
            RelayLog.info(`[HUD] paramsLoaded version=${params.paramsVersion || 'HUD-PARAMS-v0'} policyRef=${window.__relayHudPolicyRef}`);
            return { policyRef: window.__relayHudPolicyRef, params };
        };
        window.loadHudParams = loadHudParams;
        window.relayGetHudPolicyMeta = () => ({
            policyRef: String(window.__relayHudPolicyRef || HUD_PARAMS_POLICY_REF),
            paramsVersion: String(window.__relayHudPolicy?.paramsVersion || 'HUD-PARAMS-v0'),
            layoutMode: String(window.__relayHudPolicy?.layoutMode || 'compact')
        });
        const worldImageryModes = () => listImageryModes();
        const defaultWorldImageryMode = () => {
            const stored = (typeof localStorage !== 'undefined') ? localStorage.getItem(WORLD_IMAGERY_STORAGE_KEY) : null;
            const candidate = String(stored || window.RELAY_WORLD_IMAGERY_MODE || 'osm').trim().toLowerCase();
            return candidate || 'osm';
        };

        window.relayListImageryModes = () => {
            if (RELAY_PROFILE !== 'world') {
                return [{ id: 'osm', label: 'OpenStreetMap', provider: 'OpenStreetMap' }];
            }
            return worldImageryModes();
        };
        window.relayApplyImageryMode = (modeId = 'osm') => {
            if (RELAY_PROFILE !== 'world') {
                return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
            }
            if (!viewer) {
                return { ok: false, reason: 'VIEWER_UNAVAILABLE' };
            }
            const result = applyImageryMode(viewer, modeId, { fallbackModeId: 'osm' });
            if (result?.ok) {
                window.RELAY_WORLD_IMAGERY_MODE = result.modeId;
                try { localStorage.setItem(WORLD_IMAGERY_STORAGE_KEY, result.modeId); } catch {}
                RelayLog.info(`[UX] imageryMode=${String(result.modeId).toLowerCase() === 'satellite' ? 'Satellite' : 'OSM'}`);
            } else if (result?.reason) {
                RelayLog.warn(`[UX] imageryUnavailable provider=${result.provider || result.reason}`);
            }
            return result;
        };

        window.relaySetDebugLogs = (enabled) => {
            const next = enabled === true;
            window.RELAY_DEBUG_LOGS = next;
            window.RELAY_DEBUG_VERBOSE = next;
            try { localStorage.setItem(DEBUG_LOGS_STORAGE_KEY, next ? 'true' : 'false'); } catch {}
            RelayLog.info(`[UX] debugLogs=${next ? 'true' : 'false'}`);
            if (hudManager) {
                hudManager.update({ debugLogs: next });
            }
            return { ok: true, enabled: next };
        };

        const bindWorldImageryControls = () => {
            if (RELAY_PROFILE !== 'world' || globeImageryKeyHandlerBound) {
                return;
            }
            globeImageryKeyHandlerBound = true;
            window.addEventListener('keydown', (event) => {
                if (!event.altKey || String(event.key || '').toLowerCase() !== 'm') return;
                const modes = worldImageryModes();
                if (!modes.length) return;
                const currentMode = String(window.RELAY_WORLD_IMAGERY_MODE || defaultWorldImageryMode());
                const currentIndex = Math.max(0, modes.findIndex((m) => m.id === currentMode));
                const next = modes[(currentIndex + 1) % modes.length];
                const out = window.relayApplyImageryMode(next.id);
                if (out?.ok) {
                    RelayLog.info(`[GLOBE] imagery hotkey=Alt+M mode=${out.modeId}`);
                }
            });
        };
        const bindWorldClusterControls = () => {
            if (RELAY_PROFILE !== 'world' || globeClusterKeyHandlerBound) {
                return;
            }
            globeClusterKeyHandlerBound = true;
            window.addEventListener('keydown', async (event) => {
                if (!event.altKey || String(event.key || '').toLowerCase() !== 'l') return;
                if (!worldGlobeManager) return;
                const levels = worldGlobeManager.listClusterLevels();
                if (!levels.length) return;
                const current = worldGlobeManager.getState().clusterLevel;
                const currentIdx = Math.max(0, levels.findIndex((lvl) => lvl.id === current));
                const next = levels[(currentIdx + 1) % levels.length];
                const out = await worldGlobeManager.setClusterLevel(next.id);
                if (out?.ok) {
                    RelayLog.info(`[GLOBE] cluster hotkey=Alt+L level=${next.id}`);
                }
            });
        };
        const bindWorldRegionControls = () => {
            if (RELAY_PROFILE !== 'world' || globeRegionKeyHandlerBound) {
                return;
            }
            globeRegionKeyHandlerBound = true;
            window.addEventListener('keydown', async (event) => {
                if (!worldGlobeManager) return;
                const hotkey = String(event.key || '').toLowerCase();
                if (!event.altKey || !['r', 'g'].includes(hotkey)) return;
                if (hotkey === 'r') {
                    const out = await worldGlobeManager.focusNextRegion();
                    if (out?.ok) {
                        RelayLog.info(`[GLOBE] region hotkey=Alt+R region=${out.state?.focusRegion || 'unknown'}`);
                    }
                    return;
                }
                if (hotkey === 'g') {
                    const out = await worldGlobeManager.loadCountrySet('global-core');
                    if (out?.ok) {
                        RelayLog.info(`[GLOBE] country-set hotkey=Alt+G id=${out.state?.activeCountrySet || 'global-core'}`);
                    }
                }
            });
        };
        const getWorldGlobeServicesOrigin = () => {
            const fromWindow = String(window.RELAY_GLOBE_SERVICES_ORIGIN || '').trim();
            if (fromWindow.length > 0) return fromWindow.replace(/\/+$/, '');
            return 'http://127.0.0.1:4020';
        };

        window.relayListWeatherTypes = () => {
            if (RELAY_PROFILE !== 'world' || !weatherManager) return [];
            return weatherManager.listTypes();
        };
        window.relayWeatherAdd = (type) => {
            if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
            if (!weatherManager) return { ok: false, reason: 'WEATHER_MANAGER_UNAVAILABLE' };
            return weatherManager.addOverlay(type);
        };
        window.relayWeatherRemove = (type) => {
            if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
            if (!weatherManager) return { ok: false, reason: 'WEATHER_MANAGER_UNAVAILABLE' };
            return weatherManager.removeOverlay(type);
        };
        window.relayWeatherClear = () => {
            if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
            if (!weatherManager) return { ok: false, reason: 'WEATHER_MANAGER_UNAVAILABLE' };
            return weatherManager.clear();
        };

        window.relayListTopographyModes = () => {
            if (RELAY_PROFILE !== 'world' || !topographyManager) return [{ id: 'none', label: 'Default OSM' }];
            return topographyManager.listModes();
        };
        window.relayTopographyApply = (modeId = 'none') => {
            if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
            if (!topographyManager) return { ok: false, reason: 'TOPOGRAPHY_MANAGER_UNAVAILABLE' };
            return topographyManager.applyMode(modeId);
        };
        window.relayTopographyClear = () => {
            if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
            if (!topographyManager) return { ok: false, reason: 'TOPOGRAPHY_MANAGER_UNAVAILABLE' };
            return topographyManager.clear();
        };
        window.relayGlobeListClusterLevels = () => {
            if (RELAY_PROFILE !== 'world' || !worldGlobeManager) return [];
            return worldGlobeManager.listClusterLevels();
        };
        window.relayGlobeSetClusterLevel = async (levelId) => {
            if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
            if (!worldGlobeManager) return { ok: false, reason: 'GLOBE_MANAGER_UNAVAILABLE' };
            return worldGlobeManager.setClusterLevel(levelId);
        };
        window.relayGlobeSetFocusCountry = async (countryCode) => {
            if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
            if (!worldGlobeManager) return { ok: false, reason: 'GLOBE_MANAGER_UNAVAILABLE' };
            return worldGlobeManager.setFocusCountry(countryCode);
        };
        window.relayGlobeGetState = () => {
            if (RELAY_PROFILE !== 'world' || !worldGlobeManager) {
                return { ok: false, reason: 'GLOBE_MANAGER_UNAVAILABLE' };
            }
            return { ok: true, state: worldGlobeManager.getState() };
        };
        window.relayGlobeListRegions = () => {
            if (RELAY_PROFILE !== 'world' || !worldGlobeManager) return [];
            return worldGlobeManager.listRegions();
        };
        window.relayGlobeListFocusRegionCountries = () => {
            if (RELAY_PROFILE !== 'world' || !worldGlobeManager) return [];
            return worldGlobeManager.listFocusRegionCountries();
        };
        window.relayGlobeSetFocusRegion = async (regionId) => {
            if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
            if (!worldGlobeManager) return { ok: false, reason: 'GLOBE_MANAGER_UNAVAILABLE' };
            return worldGlobeManager.setFocusRegion(regionId);
        };
        window.relayGlobeFocusNextRegion = async () => {
            if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
            if (!worldGlobeManager) return { ok: false, reason: 'GLOBE_MANAGER_UNAVAILABLE' };
            return worldGlobeManager.focusNextRegion();
        };
        window.relayGlobeListCountrySets = () => {
            if (RELAY_PROFILE !== 'world' || !worldGlobeManager) return [];
            return worldGlobeManager.listCountrySets();
        };
        window.relayGlobeLoadCountrySet = async (setId = 'global-core') => {
            if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
            if (!worldGlobeManager) return { ok: false, reason: 'GLOBE_MANAGER_UNAVAILABLE' };
            return worldGlobeManager.loadCountrySet(setId);
        };
        window.loadRestore3GeoFixture = async () => {
            if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
            if (!restore3ScopeManager) return { ok: false, reason: 'RESTORE3_SCOPE_MANAGER_UNAVAILABLE' };
            return restore3ScopeManager.loadFixture();
        };
        window.relayScopeGetState = () => {
            if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
            if (!restore3ScopeManager) return { ok: false, reason: 'RESTORE3_SCOPE_MANAGER_UNAVAILABLE' };
            return { ok: true, state: restore3ScopeManager.getState() };
        };
        window.relayScopeListCountries = () => {
            if (RELAY_PROFILE !== 'world' || !restore3ScopeManager) return [];
            return restore3ScopeManager.list('country');
        };
        window.relayScopeListRegions = () => {
            if (RELAY_PROFILE !== 'world' || !restore3ScopeManager) return [];
            return restore3ScopeManager.list('region');
        };
        window.relayScopeListSites = () => {
            if (RELAY_PROFILE !== 'world' || !restore3ScopeManager) return [];
            return restore3ScopeManager.list('site');
        };
        window.relayScopeSelectCountry = async (id) => {
            if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
            if (!restore3ScopeManager) return { ok: false, reason: 'RESTORE3_SCOPE_MANAGER_UNAVAILABLE' };
            const out = await restore3ScopeManager.select('country', id);
            if (out?.ok && restore4AssignmentManager) {
                restore4AssignmentManager.refreshScopeInspector();
            }
            return out;
        };
        window.relayScopeSelectRegion = async (id) => {
            if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
            if (!restore3ScopeManager) return { ok: false, reason: 'RESTORE3_SCOPE_MANAGER_UNAVAILABLE' };
            const out = await restore3ScopeManager.select('region', id);
            if (out?.ok && restore4AssignmentManager) {
                restore4AssignmentManager.refreshScopeInspector();
            }
            return out;
        };
        window.relayScopeSelectSite = async (id) => {
            if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
            if (!restore3ScopeManager) return { ok: false, reason: 'RESTORE3_SCOPE_MANAGER_UNAVAILABLE' };
            const out = await restore3ScopeManager.select('site', id);
            if (out?.ok && restore4AssignmentManager) {
                restore4AssignmentManager.refreshScopeInspector();
            }
            return out;
        };
        window.loadRestore4AssignmentFixture = async () => {
            if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
            if (!restore4AssignmentManager) return { ok: false, reason: 'RESTORE4_ASSIGNMENT_MANAGER_UNAVAILABLE' };
            return restore4AssignmentManager.loadFixture();
        };
        window.relayGetAssignmentState = () => {
            if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
            if (!restore4AssignmentManager) return { ok: false, reason: 'RESTORE4_ASSIGNMENT_MANAGER_UNAVAILABLE' };
            return { ok: true, state: restore4AssignmentManager.getState() };
        };
        window.relayScopeInspectorRefresh = () => {
            if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
            if (!restore4AssignmentManager) return { ok: false, reason: 'RESTORE4_ASSIGNMENT_MANAGER_UNAVAILABLE' };
            return { ok: true, state: restore4AssignmentManager.refreshScopeInspector() };
        };
        window.relayAssignBranchToSitePropose = (branchId, siteId, meta = {}) => {
            if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
            if (!restore4AssignmentManager) return { ok: false, reason: 'RESTORE4_ASSIGNMENT_MANAGER_UNAVAILABLE' };
            if (!restore4AssignmentManager.isLoaded()) return { ok: false, reason: 'ASSIGNMENT_FIXTURE_NOT_LOADED' };
            const branch = String(branchId || '').trim();
            const site = String(siteId || '').trim();
            if (!branch || !site) return { ok: false, reason: 'ASSIGNMENT_INPUT_INVALID' };
            const targetRef = { type: 'branch', id: branch };
            const currentMode = relayWorkState.mode;
            if (currentMode === 'COMMIT') {
                setRelayWorkMode('DRAFT', { targetRef, user: relayWorkState.user, zone: relayWorkState.zone });
            }
            const proposed = setRelayWorkMode('PROPOSE', {
                targetRef,
                summary: String(meta.summary || `Assign ${branch} -> ${site}`).slice(0, 240),
                changesetRef: String(meta.changesetRef || `R4-ASSIGN-${branch}-${site}`).slice(0, 240),
                allowDirectPropose: true,
                forceSnapshot: true,
                user: String(meta.user || relayWorkState.user || 'local'),
                zone: String(meta.zone || relayWorkState.zone || 'zone.avgol.ops')
            });
            if (!proposed) return { ok: false, reason: 'PROPOSE_FAILED' };
            const rec = restore4AssignmentManager.setProposed({
                branchId: branch,
                siteId: site,
                proposalId: relayWorkState.currentProposalId || null
            });
            return rec.ok ? { ok: true, proposalId: relayWorkState.currentProposalId, evidenceHash: relayWorkState.currentProposalEvidenceHash, record: rec.record } : rec;
        };
        window.relayAssignBranchToSiteCommit = (branchId, siteId, meta = {}) => {
            if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
            if (!restore4AssignmentManager) return { ok: false, reason: 'RESTORE4_ASSIGNMENT_MANAGER_UNAVAILABLE' };
            if (!restore4AssignmentManager.isLoaded()) return { ok: false, reason: 'ASSIGNMENT_FIXTURE_NOT_LOADED' };
            const branch = String(branchId || '').trim();
            const site = String(siteId || '').trim();
            if (!branch || !site) return { ok: false, reason: 'ASSIGNMENT_INPUT_INVALID' };
            const targetRef = { type: 'branch', id: branch };
            const committed = setRelayWorkMode('COMMIT', {
                targetRef,
                proposalId: String(meta.proposalId || relayWorkState.currentProposalId || '').trim(),
                evidenceHash: String(meta.evidenceHash || relayWorkState.currentProposalEvidenceHash || '').trim(),
                user: String(meta.user || relayWorkState.user || 'local'),
                zone: String(meta.zone || relayWorkState.zone || 'zone.avgol.ops')
            });
            if (!committed) return { ok: false, reason: 'COMMIT_FAILED' };
            const rec = restore4AssignmentManager.setCommitted({
                branchId: branch,
                siteId: site,
                commitId: relayWorkState.currentCommitId || null
            });
            return rec.ok ? { ok: true, commitId: relayWorkState.currentCommitId, record: rec.record } : rec;
        };

        // ‚îÄ‚îÄ‚îÄ Virtualized viewport state ‚îÄ‚îÄ‚îÄ
        let viewportRowStart = 0;
        let viewportColStart = 0;
        let viewportRowsVisible = 30;
        let viewportColsVisible = 10;
        const VIEWPORT_BUFFER = 2;
        // Excel-standard cell sizing (LAUNCH-ALIGN-1 contract)
        const CELL_WIDTH = 64;           // Excel-like default column width (px)
        const CELL_HEIGHT = 20;          // Excel-like default row height (px)
        const ROW_HEADER_WIDTH = 40;     // Excel-like row header width (px)
        const COL_HEADER_HEIGHT = 20;    // Excel-like column header height (px)
        const SCROLLBAR_SIZE = 10;

        // Column letter helpers (A, B, ..., Z, AA, AB, ...)
        const colToLetter = (col) => {
            let s = '';
            let c = col;
            while (c >= 0) {
                s = String.fromCharCode(65 + (c % 26)) + s;
                c = Math.floor(c / 26) - 1;
            }
            return s;
        };
        const letterToCol = (letters) => {
            let col = 0;
            for (let i = 0; i < letters.length; i++) {
                col = col * 26 + (letters.charCodeAt(i) - 64);
            }
            return col - 1;
        };
        const parseCellRef = (ref) => {
            const match = ref.toUpperCase().match(/^([A-Z]+)(\d+)$/);
            if (!match) return null;
            return { row: parseInt(match[2], 10) - 1, col: letterToCol(match[1]) };
        };
        const clamp = (val, min, max) => Math.max(min, Math.min(max, val));
        let rangeDragAnchor = null;
        let rangeDragLast = null;
        let isRangeDragging = false;
        let isEditSheetMode = false;
        let hoveredCellEntity = null;
        let copyBuffer = null;
        let cellEntityIndex = new Map();
        let sheetSelection = null;
        const relayUx3State = {
            selectedModuleId: '',
            pendingProposalId: null,
            pendingCommittedChange: null,
            lastCommitId: null
        };
        const relayVoteUiState = {
            currentVoterId: 'user.manager1',
            currentRole: 'manager',
            currentAuthorityRef: 'policy.governance.v2',
            currentScope: 'zone.avgol.ops'
        };
        window.RELAY_FORCE_OVERLAY = false;
        window.RELAY_LOCK_LOD = null;     // R0.2: Unlocked ‚Äî LOD governor now active (was 'SHEET' during A0 testing)
        window.RELAY_DISABLE_RESTORE_POV = true;
        window.RELAY_OVERLAY_ALWAYS_MOUNTED = true;
        window.__relayPostGateQuietUntil = Number(window.__relayPostGateQuietUntil || 0);
        const RELAY_POST_GATE_QUIET_MS = 8000;
        const RELAY_D0_LOCKED_LOD = 'COMPANY';
        const RELAY_D0_FPS_LANE_CAP = 25;
        window.RELAY_D0_FPS_SAMPLE_RES_SCALE = Number(window.RELAY_D0_FPS_SAMPLE_RES_SCALE || 0.66);
        const RELAY_D0_FPS_SAMPLE_RES_SCALE = Math.max(0.25, Number(window.RELAY_D0_FPS_SAMPLE_RES_SCALE || 0.66));
        window.RELAY_D0_FPS_SAMPLE_HIDE_GLOBE = window.RELAY_D0_FPS_SAMPLE_HIDE_GLOBE === true;
        window.RELAY_D0_FPS_MIN_STRICT = Number(window.RELAY_D0_FPS_MIN_STRICT || 30);
        window.RELAY_D0_FPS_MIN_DEV = Number(window.RELAY_D0_FPS_MIN_DEV || 20);
        window.RELAY_D0_PASS_POLICY = (window.RELAY_D0_PASS_POLICY === 'strict') ? 'strict' : 'dev';
        window.__relayFpsBoostActive = window.__relayFpsBoostActive === true;
        window.__relayFpsSampleBarrierActive = window.__relayFpsSampleBarrierActive === true;
        window.__relayFpsSampleLaneEmitCap = Number(window.__relayFpsSampleLaneEmitCap || RELAY_D0_FPS_LANE_CAP);
        window.RELAY_AUTO_COMMIT_ACTIONS = window.RELAY_AUTO_COMMIT_ACTIONS === true;
        window.RELAY_AUTO_COMMIT_ALLOWLIST = Array.isArray(window.RELAY_AUTO_COMMIT_ALLOWLIST)
            ? window.RELAY_AUTO_COMMIT_ALLOWLIST
            : ['markResolved'];
        window.RELAY_AUTO_HOLD_ON_DELTA = window.RELAY_AUTO_HOLD_ON_DELTA !== false;
        window.RELAY_DELTA_HOLD_THRESHOLD = (window.RELAY_DELTA_HOLD_THRESHOLD && typeof window.RELAY_DELTA_HOLD_THRESHOLD === 'object')
            ? window.RELAY_DELTA_HOLD_THRESHOLD
            : { updated: 50 };
        let _lodLockApplied = false;
        let lastOverlayLog = 0;
        let _postGateQuietEndLogged = true;

        const canEnterEditSheet = (sheet) => {
            // Docking triggers from ANY angle ‚Äî distance only, must be close
            if (!viewer || !sheet?._center) return false;
            const camPos = viewer.camera.position;
            const distance = Cesium.Cartesian3.distance(camPos, sheet._center);
            return distance <= 550;  // matches dockDistance for 400m-wide sheet
        };
        const isPostGateQuietActive = (now = performance.now()) => {
            return Number(window.__relayPostGateQuietUntil || 0) > now;
        };
        const isBackgroundWorkSuppressed = (now = performance.now()) => {
            return window.__relayStressModeActive === true
                || window.__relayDeferredRenderPending === true
                || isPostGateQuietActive(now);
        };
        const getStressLockedLod = () => {
            if (typeof window.__relayStressLodLevel === 'string' && window.__relayStressLodLevel.length > 0) {
                return window.__relayStressLodLevel;
            }
            if (lodGovernor && typeof lodGovernor.getCurrentLevel === 'function') {
                return lodGovernor.getCurrentLevel();
            }
            return filamentRenderer?.currentLOD || null;
        };
        const activatePostGateQuietWindow = (ms = RELAY_POST_GATE_QUIET_MS) => {
            const now = performance.now();
            const nextUntil = now + Math.max(0, Number(ms) || 0);
            if (nextUntil > Number(window.__relayPostGateQuietUntil || 0)) {
                window.__relayPostGateQuietUntil = nextUntil;
                _postGateQuietEndLogged = false;
                RelayLog.info('POSTGATE', `quiet window ${Math.round(ms)}ms active`);
            }
        };
        window.__relaySnapshots = Array.isArray(window.__relaySnapshots) ? window.__relaySnapshots : [];
        window.__relayCommits = Array.isArray(window.__relayCommits) ? window.__relayCommits : [];
        window.__relayCellFormulaCommits = Array.isArray(window.__relayCellFormulaCommits) ? window.__relayCellFormulaCommits : [];
        window.__relayFormulaDagBySheet = (window.__relayFormulaDagBySheet instanceof Map) ? window.__relayFormulaDagBySheet : new Map();
        window.__relaySheetCommits = Array.isArray(window.__relaySheetCommits) ? window.__relaySheetCommits : [];
        window.__relaySheetCommitSeq = Number.isFinite(Number(window.__relaySheetCommitSeq)) ? Number(window.__relaySheetCommitSeq) : 0;
        window.__relayTransferPackets = Array.isArray(window.__relayTransferPackets) ? window.__relayTransferPackets : [];
        window.__relayResponsibilityPackets = Array.isArray(window.__relayResponsibilityPackets) ? window.__relayResponsibilityPackets : [];
        window.__relayFlows = Array.isArray(window.__relayFlows) ? window.__relayFlows : [];
        window.__relayToleranceOverrides = (window.__relayToleranceOverrides instanceof Map) ? window.__relayToleranceOverrides : new Map();
        window.__relayArtifactsByObjectId = (window.__relayArtifactsByObjectId instanceof Map) ? window.__relayArtifactsByObjectId : new Map();
        window.__relayArtifactsByProposalId = (window.__relayArtifactsByProposalId instanceof Map) ? window.__relayArtifactsByProposalId : new Map();
        window.__relayContainerRegistry = (window.__relayContainerRegistry instanceof Map) ? window.__relayContainerRegistry : new Map();
        window.__relayTrunkMetrics = (window.__relayTrunkMetrics && typeof window.__relayTrunkMetrics === 'object')
            ? window.__relayTrunkMetrics
            : { policyVersion: 'D1-TRUNK-AGG-V0', trunkId: 'trunk.avgol', metrics: [], hash: null, computedAt: null };
        window.__relayPresenceState = (window.__relayPresenceState && typeof window.__relayPresenceState === 'object')
            ? window.__relayPresenceState
            : {
                policyVersion: 'L0-PRESENCE-V0',
                ttlMs: 120000,
                markerSeq: 0,
                trailSeq: 0,
                markers: [],
                trails: [],
                consentByActor: {},
                scvs: [],
                auditRequests: [],
                findings: []
            };
        window.__relayStageState = (window.__relayStageState && typeof window.__relayStageState === 'object')
            ? window.__relayStageState
            : { gsgByScope: { 'zone.avgol.ops': 2 }, isgByUser: {} };
        window.__relayFlowPlayback = (window.__relayFlowPlayback && typeof window.__relayFlowPlayback === 'object')
            ? window.__relayFlowPlayback
            : { active: false, flowId: null, mode: 'guided', stepIndex: -1, startedAtMs: 0, completedAtMs: 0 };
        window.__relayBasinState = (window.__relayBasinState && typeof window.__relayBasinState === 'object')
            ? window.__relayBasinState
            : {
                active: false,
                targetId: null,
                targetType: null,
                radiusM: 0,
                distanceM: null,
                softLockEnabled: false,
                softLockTargetId: null,
                enteredAt: null,
                exitedAt: null,
                lastMoveLogAtMs: 0
            };
        window.RELAY_TRUNK_AGG_POLICY_V0 = (window.RELAY_TRUNK_AGG_POLICY_V0 && typeof window.RELAY_TRUNK_AGG_POLICY_V0 === 'object')
            ? window.RELAY_TRUNK_AGG_POLICY_V0
            : {
                policyVersion: 'D1-TRUNK-AGG-V0',
                trunkId: 'trunk.avgol',
                rules: [
                    { trunkMetricId: 'trunk.matchRate.avg', sourceMetricId: 'matchRate', op: 'avg', unit: '%' },
                    { trunkMetricId: 'trunk.outstanding.sum', sourceMetricId: 'outstanding', op: 'sum', unit: '' },
                    { trunkMetricId: 'trunk.invoiceTotal.sum', sourceMetricId: 'invoiceTotal', op: 'sum', unit: 'USD' },
                    { trunkMetricId: 'trunk.coverage.avg', sourceMetricId: 'coveragePct', op: 'avg', unit: '%' }
                ]
            };
        window.RELAY_REQUIRE_EXPLICIT_RESPONSIBILITY_PACKETS = window.RELAY_REQUIRE_EXPLICIT_RESPONSIBILITY_PACKETS === true;
        const seedContainerRegistry = () => {
            const defaults = [
                { id: 'container.siteA.Inventory', type: 'container', category: 'Inventory', scope: 'site.SITE_A' },
                { id: 'container.siteA.GRIR', type: 'container', category: 'GRIR', scope: 'site.SITE_A' },
                { id: 'container.company.AP', type: 'container', category: 'AP', scope: 'company' },
                { id: 'container.company.CashBank', type: 'container', category: 'CashBank', scope: 'company' },
                { id: 'container.siteA.PriceVariance', type: 'container', category: 'PriceVariance', scope: 'site.SITE_A' },
                { id: 'container.siteA.QtyVariance', type: 'container', category: 'QtyVariance', scope: 'site.SITE_A' },
                { id: 'container.company.BudgetCommitment', type: 'container', category: 'BudgetCommitment', scope: 'company' }
            ];
            for (const c of defaults) {
                if (!window.__relayContainerRegistry.has(c.id)) {
                    window.__relayContainerRegistry.set(c.id, { ...c });
                }
            }
        };
        seedContainerRegistry();
        const RELAY_WORK_MODES = new Set(['DRAFT', 'HOLD', 'PROPOSE', 'COMMIT']);
        const relayWorkState = {
            mode: 'DRAFT',
            zone: 'zone.avgol.ops',
            user: 'local',
            target: 'none',
            objectId: null,
            targetRef: null,
            scopeRef: null,
            updatedAtMs: Date.now(),
            currentProposalId: null,
            currentProposalEvidenceHash: null,
            currentCommitId: null
        };
        const artifactSortAsc = (a, b) => {
            const at = Number(new Date(a?.timestamp || 0).getTime() || 0);
            const bt = Number(new Date(b?.timestamp || 0).getTime() || 0);
            if (at !== bt) return at - bt;
            return String(a?.id || '').localeCompare(String(b?.id || ''));
        };
        const getArtifactsSorted = () => {
            const snapshotArtifacts = (window.__relaySnapshots || []).map(s => ({ ...s, artifactKind: 'SNAPSHOT' }));
            const commitArtifacts = (window.__relayCommits || []).map(c => ({ ...c, artifactKind: 'COMMIT' }));
            return [...snapshotArtifacts, ...commitArtifacts].sort(artifactSortAsc);
        };
        const getArtifactById = (id) => getArtifactsSorted().find(a => String(a.id) === String(id)) || null;
        const parseSourceCellRef = (sourceCell) => {
            const raw = String(sourceCell || '').trim();
            const [sheetId, cellRef] = raw.split('!');
            return {
                sourceCell: raw,
                summarySheetId: String(sheetId || ''),
                cellRef: String(cellRef || '')
            };
        };
        const getModuleDefByBranchId = (branchId) => {
            const bid = String(branchId || '');
            if (!bid || !(loadedModuleDefs instanceof Map)) return null;
            for (const moduleDef of loadedModuleDefs.values()) {
                if (String(moduleDef?.branchId || '') === bid) return moduleDef;
            }
            return null;
        };
        const computeTrunkAggregation = () => {
            const policy = window.RELAY_TRUNK_AGG_POLICY_V0 || {};
            const branchNodes = (relayState?.tree?.nodes || []).filter(n => n.type === 'branch');
            const branchMetricsById = [];
            for (const branch of branchNodes) {
                const latest = Array.isArray(branch?.metadata?.kpiMetrics) ? branch.metadata.kpiMetrics.slice(-1)[0] : null;
                const metrics = latest?.metrics || {};
                const moduleDef = getModuleDefByBranchId(branch.id);
                const factSheetIds = Array.isArray(moduleDef?.factSheets) ? moduleDef.factSheets.map(s => String(s.sheetId || '')).filter(Boolean) : [];
                for (const [metricId, metricValue] of Object.entries(metrics)) {
                    const parsed = parseSourceCellRef(metricValue?.sourceCell || '');
                    branchMetricsById.push({
                        branchId: String(branch.id || ''),
                        branchName: String(branch.name || branch.id || ''),
                        metricId: String(metricId || ''),
                        value: Number(metricValue?.value || 0),
                        unit: String(metricValue?.unit || ''),
                        sourceCell: parsed.sourceCell,
                        summarySheetId: parsed.summarySheetId,
                        factSheetIds
                    });
                }
            }
            const aggregated = aggregateBranchMetrics(branchMetricsById, policy);
            const hash = hashAggregation(aggregated);
            window.__relayTrunkMetrics = {
                ...aggregated,
                hash,
                computedAt: new Date().toISOString()
            };
            if (!selectedTrunkMetricId && Array.isArray(window.__relayTrunkMetrics.metrics) && window.__relayTrunkMetrics.metrics[0]) {
                selectedTrunkMetricId = window.__relayTrunkMetrics.metrics[0].metricId;
            }
            RelayLog.info(`[D1-AGG] trunk=${window.__relayTrunkMetrics.trunkId} metrics=${window.__relayTrunkMetrics.metrics.length} hash=${hash}`);
            return window.__relayTrunkMetrics;
        };
        const getSelectedTrunkMetric = () => {
            const metrics = Array.isArray(window.__relayTrunkMetrics?.metrics) ? window.__relayTrunkMetrics.metrics : [];
            if (!metrics.length) return null;
            if (!selectedTrunkMetricId) return metrics[0];
            return metrics.find(m => String(m.metricId) === String(selectedTrunkMetricId)) || metrics[0];
        };
        const DEFAULT_BASIN_RADIUS_BY_TYPE = Object.freeze({
            trunk: 20000,
            branch: 6000
        });
        let basinControllerDefaults = null;
        const ensureBasinControllerDefaults = () => {
            const c = viewer?.scene?.screenSpaceCameraController;
            if (!c || basinControllerDefaults) return;
            basinControllerDefaults = {
                inertiaSpin: Number(c.inertiaSpin),
                inertiaTranslate: Number(c.inertiaTranslate),
                inertiaZoom: Number(c.inertiaZoom),
                maximumMovementRatio: Number(c.maximumMovementRatio)
            };
        };
        const detectActiveBasin = () => {
            if (!viewer?.camera?.position || !relayState?.tree?.nodes) return null;
            const camPos = viewer.camera.position;
            let best = null;
            for (const node of relayState.tree.nodes) {
                if (node.type !== 'trunk' && node.type !== 'branch') continue;
                const center = node._center || (
                    Number.isFinite(Number(node.lon)) && Number.isFinite(Number(node.lat))
                        ? Cesium.Cartesian3.fromDegrees(Number(node.lon), Number(node.lat), Number(node.alt || node.height || 0))
                        : null
                );
                if (!center) continue;
                const radius = Number(node.type === 'trunk' ? DEFAULT_BASIN_RADIUS_BY_TYPE.trunk : DEFAULT_BASIN_RADIUS_BY_TYPE.branch);
                const dist = Cesium.Cartesian3.distance(camPos, center);
                if (dist > radius) continue;
                if (!best || dist < best.distanceM) {
                    best = {
                        targetId: String(node.id),
                        targetType: String(node.type),
                        radiusM: radius,
                        distanceM: dist
                    };
                }
            }
            return best;
        };
        const updateBasinInfluence = (nowTime) => {
            ensureBasinControllerDefaults();
            const state = window.__relayBasinState;
            const controller = viewer?.scene?.screenSpaceCameraController;
            if (!state || !controller || !basinControllerDefaults) return;
            const hit = detectActiveBasin();
            const wasActive = state.active === true;
            if (hit) {
                state.active = true;
                state.targetId = hit.targetId;
                state.targetType = hit.targetType;
                state.radiusM = Number(hit.radiusM.toFixed(2));
                state.distanceM = Number(hit.distanceM.toFixed(2));
                if (!wasActive || String(state.targetId) !== String(hit.targetId)) {
                    state.enteredAt = new Date().toISOString();
                    if (window.RELAY_LAUNCH_MODE) {
                        // LAUNCH MODE: log proximity but do NOT modify camera controls (CAM-FREEFLY-CONTRACT-1)
                        RelayLog.info(`[CAM] basin-proximity target=${hit.targetId} type=${hit.targetType} radiusM=${hit.radiusM.toFixed(1)} distanceM=${hit.distanceM.toFixed(1)} assist=BLOCKED_LAUNCH`);
                    } else {
                    RelayLog.info(`[CAM] basin-enter target=${hit.targetId} type=${hit.targetType} radiusM=${hit.radiusM.toFixed(1)} distanceM=${hit.distanceM.toFixed(1)}`);
                    }
                }
                // Basin assist (camera-only): slightly stronger damping + lower movement burst.
                // LAUNCH MODE: skip damping modification ‚Äî keep full FPS control (CAM-FREEFLY-CONTRACT-1)
                if (!window.RELAY_LAUNCH_MODE) {
                controller.inertiaSpin = Math.min(0.95, Math.max(0.78, basinControllerDefaults.inertiaSpin + 0.10));
                controller.inertiaTranslate = Math.min(0.95, Math.max(0.78, basinControllerDefaults.inertiaTranslate + 0.08));
                controller.inertiaZoom = Math.min(0.95, Math.max(0.78, basinControllerDefaults.inertiaZoom + 0.06));
                controller.maximumMovementRatio = Math.min(basinControllerDefaults.maximumMovementRatio, 0.06);
                }
                if (state.softLockEnabled === true) {
                    const softTarget = String(state.softLockTargetId || hit.targetId);
                    state.softLockTargetId = softTarget;
                    const nowMs = Date.now();
                    if ((nowMs - Number(state.lastMoveLogAtMs || 0)) > 1000) {
                        state.lastMoveLogAtMs = nowMs;
                        RelayLog.info(`[MOVE] mode=basin target=${softTarget} assist=soft-lock distanceM=${hit.distanceM.toFixed(1)}`);
                    }
                }
            } else {
                if (wasActive) {
                    state.exitedAt = new Date().toISOString();
                    RelayLog.info(`[CAM] basin-exit target=${state.targetId || 'none'}`);
                }
                state.active = false;
                state.targetId = null;
                state.targetType = null;
                state.radiusM = 0;
                state.distanceM = null;
                controller.inertiaSpin = basinControllerDefaults.inertiaSpin;
                controller.inertiaTranslate = basinControllerDefaults.inertiaTranslate;
                controller.inertiaZoom = basinControllerDefaults.inertiaZoom;
                controller.maximumMovementRatio = basinControllerDefaults.maximumMovementRatio;
            }
            // Soft-lock is optional and never traps; disabling always clears target.
            if (state.softLockEnabled !== true) {
                state.softLockTargetId = null;
            }
        };
        const canonicalizeFlowValue = (input) => {
            if (input === null || typeof input === 'undefined') return null;
            if (typeof input === 'number') {
                if (!Number.isFinite(input)) return null;
                const fixed = input.toFixed(6);
                return fixed.replace(/\.?0+$/, '');
            }
            if (typeof input !== 'object') return input;
            if (Array.isArray(input)) return input.map(canonicalizeFlowValue);
            const out = {};
            for (const key of Object.keys(input).sort()) {
                out[key] = canonicalizeFlowValue(input[key]);
            }
            return out;
        };
        const stableFlowHash = (value) => fnv1aHex(JSON.stringify(canonicalizeFlowValue(value)));
        const captureFlowCameraWaypoint = () => {
            const carto = viewer?.camera?.positionCartographic || null;
            if (!carto) return null;
            return {
                timestamp: new Date().toISOString(),
                lod: String(filamentRenderer?.currentLOD || lodGovernor?.getCurrentLevel?.() || 'UNKNOWN'),
                position: {
                    lon: Number(Cesium.Math.toDegrees(carto.longitude).toFixed(6)),
                    lat: Number(Cesium.Math.toDegrees(carto.latitude).toFixed(6)),
                    height: Number(carto.height.toFixed(2))
                },
                orientation: {
                    heading: Number(viewer?.camera?.heading?.toFixed?.(6) || 0),
                    pitch: Number(viewer?.camera?.pitch?.toFixed?.(6) || 0),
                    roll: Number(viewer?.camera?.roll?.toFixed?.(6) || 0)
                }
            };
        };
        const computeFlowInputFingerprint = () => {
            const modules = [];
            if (loadedModuleDefs instanceof Map) {
                for (const moduleDef of loadedModuleDefs.values()) {
                    modules.push({
                        moduleId: String(moduleDef.moduleId || ''),
                        branchId: String(moduleDef.branchId || ''),
                        factSheets: (moduleDef.factSheets || []).map(s => ({
                            sheetId: String(s.sheetId || ''),
                            columns: (s.columns || []).map(c => ({ id: String(c.id || ''), type: String(c.type || '') }))
                        })).sort((a, b) => a.sheetId.localeCompare(b.sheetId)),
                        matchSheets: (moduleDef.matchSheets || []).map(s => ({
                            sheetId: String(s.sheetId || ''),
                            joinKey: String(s.joinKey || ''),
                            sourceSheets: (s.sourceSheets || []).map(String).sort()
                        })).sort((a, b) => a.sheetId.localeCompare(b.sheetId))
                    });
                }
            }
            modules.sort((a, b) => a.moduleId.localeCompare(b.moduleId));
            const routeIds = (typeof getRouteIds === 'function' ? getRouteIds() : []).slice().sort();
            const routes = routeIds.map((routeId) => {
                const route = typeof getRoute === 'function' ? getRoute(routeId) : null;
                if (!route) return null;
                const fields = Object.entries(route.fields || {})
                    .map(([id, def]) => ({ id: String(id), source: String(def?.source || ''), type: String(def?.type || '') }))
                    .sort((a, b) => a.id.localeCompare(b.id));
                return {
                    routeId: String(route.routeId || routeId),
                    targetSheet: String(route.targetSheet || ''),
                    factClass: String(route.factClass || ''),
                    fields
                };
            }).filter(Boolean);
            return stableFlowHash({ modules, routes });
        };
        const normalizeFlowTargetRef = (meta = {}) => {
            const binding = resolveTargetBinding(meta);
            return {
                targetRef: binding?.targetRef ? { ...binding.targetRef } : null,
                objectId: binding?.objectId ? String(binding.objectId) : null
            };
        };
        const getActiveFlow = () => {
            if (!activeFlowId) return null;
            return (window.__relayFlows || []).find(f => String(f.flowId) === String(activeFlowId)) || null;
        };
        const flowStoreSorted = () => (window.__relayFlows || []).slice().sort((a, b) => String(a.createdAt || '').localeCompare(String(b.createdAt || '')));
        const relayFlowStart = (meta = {}) => {
            const target = normalizeFlowTargetRef(meta);
            if (!target.targetRef?.id) return { ok: false, reason: 'FLOW_TARGET_REQUIRED' };
            const flow = {
                flowId: String(meta.flowId || nextArtifactId('FLOW')),
                version: 'F0.1-v0',
                scope: String(meta.scope || relayWorkState.zone || 'zone.avgol.ops'),
                createdBy: String(meta.createdBy || relayWorkState.user || 'local'),
                createdAt: new Date().toISOString(),
                intent: String(meta.intent || '').slice(0, 240),
                tags: Array.isArray(meta.tags) ? meta.tags.map(v => String(v).slice(0, 64)) : [],
                startTargetRef: { ...target.targetRef },
                steps: [],
                referencedObjectIds: [String(target.objectId || target.targetRef.id)],
                cameraWaypoints: [],
                inputFingerprint: computeFlowInputFingerprint(),
                status: 'RECORDING',
                endedAt: null,
                outcome: null,
                summary: null
            };
            const wp = captureFlowCameraWaypoint();
            if (wp) flow.cameraWaypoints.push(wp);
            window.__relayFlows.push(flow);
            activeFlowId = flow.flowId;
            RelayLog.info(`[FLOW] record-start flowId=${flow.flowId} target=${flow.startTargetRef.id} scope=${flow.scope}`);
            renderArtifactInspector();
            return { ok: true, flowId: flow.flowId, flow: JSON.parse(JSON.stringify(flow)) };
        };
        const relayFlowStep = (meta = {}) => {
            const flow = getActiveFlow();
            if (!flow) return { ok: false, reason: 'FLOW_NOT_ACTIVE' };
            if (flow.status !== 'RECORDING') return { ok: false, reason: 'FLOW_NOT_RECORDING' };
            const kind = String(meta.kind || '').trim().toLowerCase();
            if (!kind) return { ok: false, reason: 'FLOW_STEP_KIND_REQUIRED' };
            const target = normalizeFlowTargetRef(meta);
            const step = {
                stepId: String(meta.stepId || `${flow.flowId}.step.${flow.steps.length + 1}`),
                kind,
                targetRef: target.targetRef ? { ...target.targetRef } : null,
                note: String(meta.note || '').slice(0, 240),
                actionId: meta.actionId ? String(meta.actionId) : null,
                params: (meta.params && typeof meta.params === 'object') ? JSON.parse(JSON.stringify(meta.params)) : null,
                timestamp: new Date().toISOString()
            };
            flow.steps.push(step);
            const refId = String(target.objectId || target.targetRef?.id || flow.startTargetRef.id);
            if (!flow.referencedObjectIds.includes(refId)) flow.referencedObjectIds.push(refId);
            if (meta.captureCamera !== false) {
                const wp = captureFlowCameraWaypoint();
                if (wp) flow.cameraWaypoints.push(wp);
            }
            RelayLog.info(`[FLOW] record-step flowId=${flow.flowId} kind=${kind} ref=${refId}`);
            renderArtifactInspector();
            return { ok: true, step: JSON.parse(JSON.stringify(step)) };
        };
        const relayFlowEnd = (meta = {}) => {
            const flow = getActiveFlow();
            if (!flow) return { ok: false, reason: 'FLOW_NOT_ACTIVE' };
            flow.status = 'READY';
            flow.endedAt = new Date().toISOString();
            flow.outcome = String(meta.outcome || 'indeterminate');
            flow.summary = String(meta.summary || '').slice(0, 240);
            activeFlowId = null;
            const fp = String(flow.inputFingerprint || '');
            RelayLog.info(`[FLOW] record-end flowId=${flow.flowId} steps=${flow.steps.length} scope=${flow.scope} fingerprint=${fp}`);
            renderArtifactInspector();
            return { ok: true, flowId: flow.flowId, flow: JSON.parse(JSON.stringify(flow)) };
        };
        const animateFlowWaypoint = (waypoint, durationSec = 0.4) => new Promise((resolve) => {
            const lon = Number(waypoint?.position?.lon);
            const lat = Number(waypoint?.position?.lat);
            const height = Number(waypoint?.position?.height);
            if (!viewer?.camera || !Number.isFinite(lon) || !Number.isFinite(lat) || !Number.isFinite(height)) {
                resolve(false);
                return;
            }
            viewer.camera.flyTo({
                destination: Cesium.Cartesian3.fromDegrees(lon, lat, height),
                orientation: {
                    heading: Number(waypoint?.orientation?.heading || 0),
                    pitch: Number(waypoint?.orientation?.pitch || 0),
                    roll: Number(waypoint?.orientation?.roll || 0)
                },
                duration: Math.max(0.2, Number(durationSec || 0.4)),
                complete: () => resolve(true),
                cancel: () => resolve(false)
            });
        });
        const relayFlowPlay = async (flowId, options = {}) => {
            const flow = (window.__relayFlows || []).find(f => String(f.flowId) === String(flowId));
            if (!flow) return { ok: false, reason: 'FLOW_NOT_FOUND' };
            const mode = String(options.mode || 'guided');
            const nowFingerprint = computeFlowInputFingerprint();
            if (String(flow.inputFingerprint || '') !== String(nowFingerprint || '')) {
                RelayLog.warn(`[FLOW] stale flowId=${flow.flowId} reason=FINGERPRINT_MISMATCH`);
            }
            const startedAtMs = Date.now();
            window.__relayFlowPlayback = { active: true, flowId: flow.flowId, mode, stepIndex: -1, startedAtMs, completedAtMs: 0 };
            renderArtifactInspector();
            RelayLog.info(`[FLOW] play flowId=${flow.flowId} mode=${mode}`);
            const waypoints = Array.isArray(flow.cameraWaypoints) ? flow.cameraWaypoints : [];
            for (let i = 0; i < waypoints.length; i++) {
                window.__relayFlowPlayback.stepIndex = i;
                await animateFlowWaypoint(waypoints[i], 0.35);
                renderArtifactInspector();
            }
            if (mode === 'guided') {
                for (const step of (flow.steps || [])) {
                    const refId = String(step?.targetRef?.id || '');
                    if (refId) focusArtifactObject(refId);
                    if (step?.actionId && typeof relayInvokeAction === 'function') {
                        relayInvokeAction(step.actionId, {
                            targetRef: step.targetRef || null,
                            params: step.params || {},
                            uiSource: 'flow-playback'
                        });
                    }
                }
            }
            const durationMs = Date.now() - startedAtMs;
            window.__relayFlowPlayback = { ...window.__relayFlowPlayback, active: false, completedAtMs: Date.now() };
            RelayLog.info(`[FLOW] complete flowId=${flow.flowId} result=PASS steps=${flow.steps.length} durationMs=${durationMs}`);
            renderArtifactInspector();
            return { ok: true, flowId: flow.flowId, steps: flow.steps.length, durationMs };
        };
        const presenceNowMs = () => Date.now();
        const getPresenceTtlMs = (meta = {}) => {
            const stateTtl = Number(window.__relayPresenceState?.ttlMs || 120000);
            const incoming = Number(meta.ttlMs);
            if (Number.isFinite(incoming) && incoming > 0) return incoming;
            return Number.isFinite(stateTtl) && stateTtl > 0 ? stateTtl : 120000;
        };
        const seedScvCatalog = () => {
            const state = window.__relayPresenceState;
            if (!state || (state.scvs || []).length > 0) return;
            state.scvs = [
                {
                    scvId: 'scv.coherence',
                    label: 'SCV: Coherence',
                    status: 'NORMAL',
                    capabilities: ['inspect', 'findings', 'proposeCommitDraft', 'recommendFlow', 'evidenceBundle'],
                    focusObjectId: null,
                    taskId: null,
                    updatedAt: null
                },
                {
                    scvId: 'scv.procurement',
                    label: 'SCV: Procurement',
                    status: 'NORMAL',
                    capabilities: ['inspect', 'findings', 'proposeCommitDraft', 'evidenceBundle'],
                    focusObjectId: null,
                    taskId: null,
                    updatedAt: null
                },
                {
                    scvId: 'scv.compliance',
                    label: 'SCV: Compliance',
                    status: 'NORMAL',
                    capabilities: ['inspect', 'findings', 'proposeCommitDraft', 'evidenceBundle'],
                    focusObjectId: null,
                    taskId: null,
                    updatedAt: null
                }
            ];
        };
        const resolvePresenceFocusObjectId = (meta = {}) => {
            const explicit = String(meta.focusObjectId || meta.targetObjectId || '').trim();
            if (explicit) return explicit;
            if (relayWorkState?.objectId) return String(relayWorkState.objectId);
            if (focusTarget?.contract?.id) return String(focusTarget.contract.id);
            if (focusTarget?.node?.id) return String(focusTarget.node.id);
            return String(relayWorkState?.target || 'none');
        };
        const sweepPresenceState = () => {
            const state = window.__relayPresenceState;
            const now = presenceNowMs();
            state.markers = (state.markers || []).filter(m => Number(m.expiresAtMs || 0) > now);
            state.trails = (state.trails || []).filter(t => Number(t.expiresAtMs || 0) > now);
            return {
                markers: state.markers.length,
                trails: state.trails.length
            };
        };
        const upsertPresenceMarker = (meta = {}) => {
            seedScvCatalog();
            sweepPresenceState();
            const state = window.__relayPresenceState;
            const actorId = String(meta.actorId || '').trim();
            if (!actorId) return { ok: false, reason: 'PRESENCE_MISSING_ACTOR' };
            const actorType = String(meta.actorType || (actorId.startsWith('scv.') ? 'scv' : 'user')).toLowerCase();
            const tierInput = Number(meta.tier);
            const tier = Number.isFinite(tierInput) ? Math.max(0, Math.min(2, Math.floor(tierInput))) : 0;
            if (actorType === 'user' && tier > 0) {
                const explicitConsent = meta.consent === true;
                const priorConsent = state.consentByActor?.[actorId] === true;
                if (!explicitConsent && !priorConsent) {
                    RelayLog.warn(`[REFUSAL] reason=PRESENCE_CONSENT_REQUIRED actor=${actorId} tier=${tier}`);
                    return { ok: false, reason: 'PRESENCE_CONSENT_REQUIRED' };
                }
                state.consentByActor[actorId] = true;
            }
            const focusObjectId = resolvePresenceFocusObjectId(meta);
            const now = presenceNowMs();
            const ttlMs = getPresenceTtlMs(meta);
            const marker = {
                markerId: String(meta.markerId || `presence.${actorId}.${++state.markerSeq}`),
                actorId,
                actorType,
                tier,
                role: String(meta.role || (actorType === 'scv' ? 'scv' : 'user')),
                label: String(meta.label || actorId),
                focusObjectId,
                gaze: (meta.gaze && typeof meta.gaze === 'object') ? { ...meta.gaze } : null,
                position: (meta.position && typeof meta.position === 'object') ? { ...meta.position } : null,
                status: String(meta.status || 'NORMAL'),
                taskId: meta.taskId ? String(meta.taskId) : null,
                ttlMs,
                updatedAtMs: now,
                updatedAt: new Date(now).toISOString(),
                expiresAtMs: now + ttlMs
            };
            const prev = (state.markers || []).find(m => String(m.actorId) === actorId) || null;
            state.markers = (state.markers || []).filter(m => String(m.actorId) !== actorId);
            state.markers.push(marker);
            if (prev?.position && marker.position) {
                state.trails.push({
                    trailId: `trail.${actorId}.${++state.trailSeq}`,
                    actorId,
                    actorType,
                    from: { ...prev.position },
                    to: { ...marker.position },
                    focusObjectId,
                    createdAtMs: now,
                    createdAt: marker.updatedAt,
                    expiresAtMs: now + ttlMs
                });
            }
            if (actorType === 'scv') {
                const scv = (state.scvs || []).find(s => String(s.scvId) === actorId) || null;
                if (scv) {
                    scv.status = marker.status;
                    scv.focusObjectId = focusObjectId;
                    scv.taskId = marker.taskId;
                    scv.updatedAt = marker.updatedAt;
                }
                RelayLog.info(`[PRESENCE] scv=${actorId} task=${marker.taskId || 'none'} status=${marker.status}`);
            } else {
                RelayLog.info(`[PRESENCE] user=${actorId} focus=${focusObjectId} tier=${tier}`);
            }
            renderArtifactInspector();
            return { ok: true, marker };
        };
        const createScvProposedCommitDraft = (scvId, payload = {}) => {
            const state = window.__relayPresenceState;
            const requestId = String(payload.requestId || '').trim();
            const commitId = String(payload.proposedCommitId || nextArtifactId('SCV-COMMIT-DRAFT'));
            const requires = [];
            if (payload.authorityRef) requires.push(`authorityRef:${String(payload.authorityRef)}`);
            if (payload.requiresApproval !== false) requires.push('approval:manager');
            if (payload.stageGate) requires.push(`stageGate:${String(payload.stageGate)}`);
            const request = requestId ? (state.auditRequests || []).find(r => String(r.requestId) === requestId) : null;
            const draft = {
                commitId,
                scvId: String(scvId || ''),
                requestId: requestId || null,
                targetRef: payload.targetRef ? { ...payload.targetRef } : null,
                summary: String(payload.summary || '').slice(0, 240),
                changesetRef: String(payload.changesetRef || `SCV:${scvId}:${Date.now()}`).slice(0, 240),
                authorityRef: payload.authorityRef ? String(payload.authorityRef) : null,
                requiresApproval: payload.requiresApproval !== false,
                stageGate: payload.stageGate ? String(payload.stageGate) : null,
                createdAt: new Date().toISOString()
            };
            if (request) {
                request.proposedCommitDraft = draft;
                request.status = 'PROPOSAL_DRAFTED';
                request.updatedAt = draft.createdAt;
            }
            RelayLog.info(`[SCV] proposedCommit=${commitId} requires=${requires.join(',') || 'approval:manager'}`);
            renderArtifactInspector();
            return { ok: true, draft };
        };
        const createAuditRequest = (meta = {}) => {
            seedScvCatalog();
            const state = window.__relayPresenceState;
            const target = String(meta.targetObjectId || meta.targetRef?.id || resolvePresenceFocusObjectId(meta) || '').trim();
            if (!target) return { ok: false, reason: 'AUDIT_TARGET_REQUIRED' };
            const scope = String(meta.scope || relayWorkState.zone || 'zone.avgol.ops');
            const stageGateAction = String(meta.stageGateAction || '').trim();
            if (stageGateAction) {
                const gate = canExecute(stageGateAction, scope, String(meta.requestedBy || relayWorkState.user || 'local'), String(meta.authorityRef || ''), window.__relayStageState || {});
                if (!gate.ok) {
                    RelayLog.warn(`[REFUSAL] reason=${gate.reason} action=${stageGateAction} scope=${scope}`);
                    return { ok: false, reason: gate.reason, stage: gate };
                }
            }
            const request = {
                requestId: String(meta.requestId || nextArtifactId('AUDIT')),
                targetObjectId: target,
                scope,
                requestedBy: String(meta.requestedBy || relayWorkState.user || 'local'),
                outputType: String(meta.outputType || 'finding'),
                constraints: (meta.constraints && typeof meta.constraints === 'object') ? { ...meta.constraints } : {},
                authorityRef: meta.authorityRef ? String(meta.authorityRef) : null,
                allowedActions: Array.isArray(meta.allowedActions) ? meta.allowedActions.map(String) : [],
                status: 'CREATED',
                scvId: null,
                findings: [],
                proposedCommitDraft: null,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };
            state.auditRequests.push(request);
            const constraintsStr = Object.keys(request.constraints).length ? JSON.stringify(request.constraints) : 'none';
            RelayLog.info(`[AUDIT] request-created target=${target} scope=${scope} constraints=${constraintsStr}`);
            renderArtifactInspector();
            return { ok: true, request };
        };
        const assignAuditRequest = (requestId, scvIdInput) => {
            const state = window.__relayPresenceState;
            const request = (state.auditRequests || []).find(r => String(r.requestId) === String(requestId));
            if (!request) return { ok: false, reason: 'AUDIT_REQUEST_NOT_FOUND' };
            const scvId = String(scvIdInput || 'scv.coherence');
            const scv = (state.scvs || []).find(s => String(s.scvId) === scvId);
            if (!scv) return { ok: false, reason: 'SCV_NOT_FOUND' };
            request.scvId = scvId;
            request.status = 'ASSIGNED';
            request.updatedAt = new Date().toISOString();
            upsertPresenceMarker({
                actorId: scvId,
                actorType: 'scv',
                status: 'NORMAL',
                taskId: request.requestId,
                focusObjectId: request.targetObjectId,
                label: scv.label,
                tier: 1,
                consent: true
            });
            RelayLog.info(`[AUDIT] scv-assigned scvId=${scvId} requestId=${request.requestId}`);
            renderArtifactInspector();
            return { ok: true, request: { ...request } };
        };
        const produceAuditFindings = (requestId, findings = [], meta = {}) => {
            const state = window.__relayPresenceState;
            const request = (state.auditRequests || []).find(r => String(r.requestId) === String(requestId));
            if (!request) return { ok: false, reason: 'AUDIT_REQUEST_NOT_FOUND' };
            const rows = Array.isArray(findings) ? findings : [];
            const createdAt = new Date().toISOString();
            const materializedFindings = rows.map((f, idx) => ({
                findingId: String(f.findingId || nextArtifactId(`FIND-${idx + 1}`)),
                requestId: request.requestId,
                objectId: String(f.objectId || request.targetObjectId),
                summary: String(f.summary || '').slice(0, 240),
                severity: String(f.severity || 'INFO'),
                trace: String(f.trace || f.objectId || request.targetObjectId),
                createdAt
            }));
            request.findings.push(...materializedFindings);
            state.findings.push(...materializedFindings);
            request.status = 'FINDINGS_PRODUCED';
            request.updatedAt = createdAt;
            const trace = materializedFindings.map(f => f.trace).join(',');
            RelayLog.info(`[AUDIT] findings-produced count=${materializedFindings.length} trace=${trace || 'none'}`);
            if (meta?.proposedCommitDraft) {
                const drafted = createScvProposedCommitDraft(request.scvId || 'scv.coherence', {
                    ...meta.proposedCommitDraft,
                    requestId: request.requestId
                });
                if (drafted.ok) {
                    RelayLog.info(`[AUDIT] proposal-created commitId=${drafted.draft.commitId} requiresApproval=true`);
                }
            }
            renderArtifactInspector();
            return { ok: true, findings: materializedFindings };
        };
        const approveAuditRequest = (requestId, meta = {}) => {
            const state = window.__relayPresenceState;
            const request = (state.auditRequests || []).find(r => String(r.requestId) === String(requestId));
            if (!request) return { ok: false, reason: 'AUDIT_REQUEST_NOT_FOUND' };
            request.status = 'APPROVED';
            request.updatedAt = new Date().toISOString();
            const approver = String(meta.by || relayWorkState.user || 'local');
            let commitId = '';
            if (meta.materialize === true && request.proposedCommitDraft?.targetRef) {
                const draft = request.proposedCommitDraft;
                const proposed = setRelayWorkMode('PROPOSE', {
                    targetRef: { ...draft.targetRef },
                    summary: draft.summary || `Audit proposal ${request.requestId}`,
                    changesetRef: draft.changesetRef || `AUDIT:${request.requestId}`,
                    allowDirectPropose: true,
                    forceSnapshot: true
                });
                if (proposed && meta.autoCommit === true) {
                    const committed = setRelayWorkMode('COMMIT', {
                        targetRef: { ...draft.targetRef },
                        proposalId: relayWorkState.currentProposalId,
                        authorityRef: meta.authorityRef || draft.authorityRef || null
                    });
                    if (committed) commitId = String(relayWorkState.currentCommitId || '');
                }
            }
            RelayLog.info(`[AUDIT] approved by=${approver} requestId=${request.requestId}${commitId ? ` commitId=${commitId}` : ''}`);
            renderArtifactInspector();
            return { ok: true, request: { ...request }, commitId };
        };
        const rejectAuditRequest = (requestId, meta = {}) => {
            const state = window.__relayPresenceState;
            const request = (state.auditRequests || []).find(r => String(r.requestId) === String(requestId));
            if (!request) return { ok: false, reason: 'AUDIT_REQUEST_NOT_FOUND' };
            request.status = 'REJECTED';
            request.updatedAt = new Date().toISOString();
            RelayLog.info(`[AUDIT] rejected by=${String(meta.by || relayWorkState.user || 'local')} requestId=${request.requestId}`);
            renderArtifactInspector();
            return { ok: true, request: { ...request } };
        };
        const domSafeId = (id) => String(id || '').replace(/[^a-zA-Z0-9_-]/g, '_');
        const copyTextToClipboard = async (text) => {
            try {
                if (navigator?.clipboard?.writeText) {
                    await navigator.clipboard.writeText(text);
                    return true;
                }
            } catch (err) { /* fallback below */ }
            const ta = document.createElement('textarea');
            ta.value = text;
            ta.style.position = 'fixed';
            ta.style.opacity = '0';
            document.body.appendChild(ta);
            ta.focus();
            ta.select();
            let ok = false;
            try {
                ok = document.execCommand('copy');
            } catch (err) { ok = false; }
            ta.remove();
            return ok;
        };
        let relayArtifactSeq = 0;
        const nextArtifactId = (prefix) => `${prefix}-${Date.now()}-${(++relayArtifactSeq).toString(36)}`;
        const resolveMatchRowRefById = (matchId) => {
            if (!matchId) return null;
            const sheets = (relayState?.tree?.nodes || []).filter(n => n.type === 'sheet' && n.metadata?.isMatchSheet);
            for (const sheet of sheets) {
                const schema = sheet.metadata?.schema || [];
                const matchCol = schema.findIndex(c => c.id === 'matchId' || c.name === 'matchId');
                if (matchCol < 0) continue;
                const matchCell = (sheet.cellData || []).find(c => c.col === matchCol && (c.value === matchId || c.display === matchId));
                if (matchCell) {
                    return { sheetId: sheet.id, row: matchCell.row, isMatch: true };
                }
            }
            return null;
        };
        const resolveContractForTargetRef = (targetRef) => {
            if (!targetRef?.id) return null;
            const type = String(targetRef.type || '').toLowerCase();
            const id = String(targetRef.id);
            if (type === 'cell' && id.includes('.cell.')) {
                const [sheetId, rc] = id.split('.cell.');
                const [row, col] = String(rc || '').split('.').map(v => Number(v));
                if (Number.isFinite(row) && Number.isFinite(col)) {
                    return toRelayObject({ sheetId, row, col }, relayState);
                }
            }
            if (type === 'match') {
                const rowRef = resolveMatchRowRefById(id);
                if (rowRef) return toRelayObject(rowRef, relayState);
            }
            if (type === 'route') return toRelayObject({ routeId: id }, relayState);
            if (type === 'module') return toRelayObject({ moduleId: id }, relayState);
            if (id.includes('.cell.')) {
                const [sheetId, rc] = id.split('.cell.');
                const [row, col] = String(rc || '').split('.').map(v => Number(v));
                if (Number.isFinite(row) && Number.isFinite(col)) {
                    return toRelayObject({ sheetId, row, col }, relayState) || toRelayObject(id, relayState);
                }
            }
            return toRelayObject(id, relayState);
        };
        const deriveScopeRef = (contract) => {
            const scopeRef = { trunkId: null, branchId: null, sheetId: null };
            if (!contract) return scopeRef;
            const findNodeById = (id) => (relayState?.tree?.nodes || []).find(n => n.id === id) || null;
            const resolveAncestry = (startNodeId) => {
                let cursor = startNodeId ? findNodeById(startNodeId) : null;
                let firstBranchId = null;
                let trunkId = null;
                const guard = new Set();
                while (cursor && !guard.has(cursor.id)) {
                    guard.add(cursor.id);
                    if (!firstBranchId && cursor.type === 'branch') firstBranchId = cursor.id;
                    if (cursor.type === 'trunk') {
                        trunkId = cursor.id;
                        break;
                    }
                    cursor = cursor.parent ? findNodeById(cursor.parent) : null;
                }
                return { firstBranchId, trunkId };
            };
            if (contract.type === 'trunk') {
                scopeRef.trunkId = contract.id;
                return scopeRef;
            }
            if (contract.type === 'branch') {
                const ancestry = resolveAncestry(contract.id);
                scopeRef.branchId = ancestry.firstBranchId || contract.id;
                scopeRef.trunkId = ancestry.trunkId;
                return scopeRef;
            }
            if (contract.type === 'sheet') {
                scopeRef.sheetId = contract.id;
                const sheetNode = findNodeById(contract.id);
                const ancestry = resolveAncestry(sheetNode?.parent || null);
                scopeRef.branchId = ancestry.firstBranchId;
                scopeRef.trunkId = ancestry.trunkId;
                return scopeRef;
            }
            if (contract.type === 'cell' || contract.type === 'match') {
                scopeRef.sheetId = contract.sheetId || null;
                const sheetNode = scopeRef.sheetId ? findNodeById(scopeRef.sheetId) : null;
                const ancestry = resolveAncestry(sheetNode?.parent || null);
                scopeRef.branchId = ancestry.firstBranchId;
                scopeRef.trunkId = ancestry.trunkId;
                return scopeRef;
            }
            if (contract.type === 'module') {
                const ancestry = resolveAncestry(contract.branchId || null);
                scopeRef.branchId = ancestry.firstBranchId || contract.branchId || null;
                scopeRef.trunkId = ancestry.trunkId;
                return scopeRef;
            }
            if (contract.scope) {
                scopeRef.branchId = String(contract.scope);
                const branchNode = findNodeById(scopeRef.branchId);
                if (branchNode?.type === 'branch') scopeRef.trunkId = branchNode.parent || null;
            }
            return scopeRef;
        };
        const getContextTargetCandidate = () => {
            if (sheetSelection?.sheetId && Number.isFinite(sheetSelection.row) && Number.isFinite(sheetSelection.col)) {
                const sheet = (relayState?.tree?.nodes || []).find(n => n.type === 'sheet' && n.id === sheetSelection.sheetId);
                if (sheet?.metadata?.isMatchSheet) {
                    const matchContract = toRelayObject({ sheetId: sheetSelection.sheetId, row: sheetSelection.row, isMatch: true }, relayState);
                    if (matchContract?.id) return { type: 'match', id: matchContract.id };
                }
                return { type: 'cell', id: `${sheetSelection.sheetId}.cell.${sheetSelection.row}.${sheetSelection.col}` };
            }
            if (isFocusMode && focusTarget?.contract?.id) {
                return { type: focusTarget.contract.type, id: focusTarget.contract.id };
            }
            if (hoveredCellEntity?._relayNodeId) {
                const node = (relayState?.tree?.nodes || []).find(n => n.id === hoveredCellEntity._relayNodeId);
                if (node?.id && node?.type) return { type: node.type, id: node.id };
            }
            if (relayWorkState.objectId) return { type: relayWorkState.targetRef?.type || 'object', id: relayWorkState.objectId };
            return null;
        };
        const resolveTargetBinding = (meta = {}) => {
            const rawRef = (meta.targetRef && typeof meta.targetRef === 'object')
                ? { type: meta.targetRef.type || null, id: meta.targetRef.id || null }
                : (meta.target ? { type: null, id: String(meta.target) } : getContextTargetCandidate());
            if (!rawRef?.id) return null;
            const contract = resolveContractForTargetRef(rawRef);
            if (!contract?.id || !contract?.type) return null;
            const targetRef = { type: contract.type, id: contract.id };
            const scopeRef = deriveScopeRef(contract);
            return {
                targetRef,
                scopeRef,
                objectId: contract.id,
                contract
            };
        };
        const updateSheetCellBySchemaId = (sheet, row, fieldId, value) => {
            if (!sheet || !Number.isFinite(row) || !fieldId) return false;
            const schema = sheet.metadata?.schema || [];
            const colIdx = schema.findIndex(col => col.id === fieldId || col.name === fieldId);
            if (colIdx < 0) return false;
            let cell = (sheet.cellData || []).find(c => c.row === row && c.col === colIdx);
            if (!cell) {
                cell = { row, col: colIdx, value, display: value, hasFormula: false, timeboxCount: 0 };
                sheet.cellData = Array.isArray(sheet.cellData) ? sheet.cellData : [];
                sheet.cellData.push(cell);
            } else {
                cell.value = value;
                cell.display = value;
                cell.hasFormula = false;
            }
            if (typeof ensureCellIndex === 'function') ensureCellIndex(sheet);
            return true;
        };
        const applyActionToModel = (actionId, targetBinding, params = {}) => {
            const contract = targetBinding?.contract;
            if (!contract) return { ok: false, reason: 'NO_CONTRACT' };
            if ((actionId === 'markResolved' || actionId === 'setTolerance') && contract.type !== 'match') {
                return { ok: false, reason: 'UNSUPPORTED_TARGET_TYPE' };
            }
            if (actionId === 'markResolved') {
                const sheet = (relayState?.tree?.nodes || []).find(n => n.id === contract.sheetId);
                const updated = updateSheetCellBySchemaId(sheet, contract.row, 'matchStatus', 'RESOLVED');
                if (!updated) return { ok: false, reason: 'MATCH_STATUS_COLUMN_MISSING' };
                RelayLog.info(`[ACT] model actionId=markResolved objectId=${targetBinding.objectId} status=RESOLVED`);
                return { ok: true, effect: { matchStatus: 'RESOLVED' } };
            }
            if (actionId === 'setTolerance') {
                const raw = params?.tolerance ?? params?.value ?? 0.01;
                const tolerance = Number(raw);
                if (!Number.isFinite(tolerance)) return { ok: false, reason: 'INVALID_TOLERANCE' };
                window.__relayToleranceOverrides.set(targetBinding.objectId, tolerance);
                RelayLog.info(`[ACT] model actionId=setTolerance objectId=${targetBinding.objectId} tolerance=${tolerance}`);
                return { ok: true, effect: { tolerance } };
            }
            return { ok: true, effect: null };
        };
        const resolveContainerRef = (containerRef) => {
            if (!containerRef) return null;
            const raw = (typeof containerRef === 'string')
                ? { id: containerRef, type: 'container' }
                : { ...containerRef };
            const id = String(raw.id || '').trim();
            if (!id) return null;
            if (window.__relayContainerRegistry.has(id)) {
                return { ...window.__relayContainerRegistry.get(id) };
            }
            const resolved = resolveContractForTargetRef({ type: raw.type || 'container', id });
            if (resolved?.id) return { id: resolved.id, type: resolved.type || 'object', label: resolved.label || null };
            return null;
        };
        const normalizeUnitType = (unit) => {
            const u = String(unit || '').trim().toLowerCase();
            if (!u) return '';
            if (u === 'qty') return 'quantity';
            return u;
        };
        const hasVarianceLeg = (packet) => {
            const legs = Array.isArray(packet?.legs) ? packet.legs : [];
            for (const leg of legs) {
                const resolved = resolveContainerRef(leg?.containerRef);
                if (!resolved?.id) continue;
                const category = String(resolved.category || '').toLowerCase();
                const id = String(resolved.id || '').toLowerCase();
                if (category.includes('variance') || id.includes('variance')) return true;
            }
            return false;
        };
        const getMatchStatusForBinding = (targetBinding) => {
            const contract = targetBinding?.contract;
            if (!contract) return '';
            return String(contract.matchStatus || contract.fields?.matchStatus || '').trim().toUpperCase();
        };
        const validateTransferPacket = (packet, context = {}) => {
            if (!packet || typeof packet !== 'object') {
                return { ok: false, reason: 'MISSING_TRANSFER_PACKET' };
            }
            const rawLegs = Array.isArray(packet.legs) ? packet.legs : [];
            if (rawLegs.length < 2) {
                return { ok: false, reason: 'TRANSFER_PACKET_TOO_FEW_LEGS' };
            }
            const sumsByUnit = new Map();
            const countsByUnit = new Map();
            const normalizedLegs = [];
            for (const leg of rawLegs) {
                const amount = Number(leg?.amount);
                const unit = normalizeUnitType(leg?.unit);
                const container = resolveContainerRef(leg?.containerRef);
                if (!Number.isFinite(amount)) {
                    return { ok: false, reason: 'TRANSFER_PACKET_INVALID_AMOUNT' };
                }
                if (!unit) {
                    return { ok: false, reason: 'TRANSFER_PACKET_INVALID_UNIT' };
                }
                if (!container?.id) {
                    return { ok: false, reason: 'TRANSFER_PACKET_CONTAINER_UNRESOLVED' };
                }
                sumsByUnit.set(unit, Number(sumsByUnit.get(unit) || 0) + amount);
                countsByUnit.set(unit, Number(countsByUnit.get(unit) || 0) + 1);
                normalizedLegs.push({
                    containerRef: { id: container.id, type: container.type || 'container' },
                    amount,
                    unit,
                    reasonCode: String(leg?.reasonCode || context.reasonCode || 'UNSPECIFIED')
                });
            }
            for (const [unit, sum] of sumsByUnit.entries()) {
                if (Math.abs(sum) > 1e-9) {
                    return { ok: false, reason: `UNBALANCED_TRANSFER_PACKET:${unit}` };
                }
                if (Number(countsByUnit.get(unit) || 0) < 2) {
                    return { ok: false, reason: `TRANSFER_PACKET_TOO_FEW_LEGS_PER_UNIT:${unit}` };
                }
            }
            const transferPacket = {
                transferPacketId: String(packet.transferPacketId || nextArtifactId('TP')),
                commitId: null,
                proposalId: String(context.proposalId || packet.proposalId || ''),
                objectId: String(context.objectId || packet.objectId || ''),
                unitTypes: [...new Set(normalizedLegs.map(leg => leg.unit))],
                legs: normalizedLegs,
                createdAt: new Date().toISOString()
            };
            return { ok: true, transferPacket };
        };
        const buildResponsibilityPackets = (meta, context = {}) => {
            const requireExplicit = window.RELAY_REQUIRE_EXPLICIT_RESPONSIBILITY_PACKETS === true;
            const incoming = Array.isArray(meta?.responsibilityPackets) ? meta.responsibilityPackets : [];
            if (requireExplicit && incoming.length === 0) {
                return { ok: false, reason: 'MISSING_RESPONSIBILITY_PACKET' };
            }
            const sourcePackets = incoming.length > 0 ? incoming : [{
                authorityRef: context.authorityRef || null,
                actionRole: 'executed',
                actorId: context.user,
                objectId: context.objectId
            }];
            const built = sourcePackets.map((p) => ({
                responsibilityPacketId: String(p.responsibilityPacketId || nextArtifactId('RP')),
                commitId: null,
                objectId: String(p.objectId || context.objectId || ''),
                authorityRef: p.authorityRef || context.authorityRef || null,
                actionRole: String(p.actionRole || 'executed'),
                actorId: String(p.actorId || context.user || 'local'),
                linkedTransferPacketId: String(context.transferPacketId || ''),
                createdAt: new Date().toISOString()
            }));
            const invalid = built.find(p => !p.objectId || !p.actorId || !p.actionRole);
            if (invalid) return { ok: false, reason: 'INVALID_RESPONSIBILITY_PACKET' };
            return { ok: true, responsibilityPackets: built };
        };
        const fnv1aHex = (value) => {
            let hash = 0x811c9dc5;
            for (let i = 0; i < value.length; i++) {
                hash ^= value.charCodeAt(i);
                hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
            }
            return `0x${(hash >>> 0).toString(16).padStart(8, '0')}`;
        };
        const collectSnapshotEvidence = (targetBinding) => {
            const target = String(targetBinding?.objectId || relayWorkState.objectId || relayWorkState.target || 'none');
            let targetSheetId = null;
            const sheetNodeDirect = relayState?.tree?.nodes?.find(n => n.type === 'sheet' && n.id === target);
            if (sheetNodeDirect) {
                targetSheetId = sheetNodeDirect.id;
            } else if (target.includes('.cell.')) {
                targetSheetId = target.split('.cell.')[0];
            }
            const targetSheet = targetSheetId
                ? relayState?.tree?.nodes?.find(n => n.type === 'sheet' && n.id === targetSheetId)
                : null;
            const kpis = (relayState?.tree?.nodes || [])
                .filter(n => n.type === 'branch' && n.metadata?.kpiBindings)
                .map(n => ({
                    branchId: n.id,
                    metrics: Array.isArray(n.metadata?.kpiBindings)
                        ? n.metadata.kpiBindings.map(k => {
                            if (typeof k === 'string') return k;
                            if (!k || typeof k !== 'object') return String(k);
                            return k.metric
                                || k.metricId
                                || k.name
                                || k.id
                                || k.cellRef
                                || (k.sheetId && k.cell ? `${k.sheetId}!${k.cell}` : null)
                                || JSON.stringify(k).slice(0, 120);
                        })
                        : Object.keys(n.metadata?.kpiBindings || {}),
                    latest: n.metadata?.kpiMetrics?.[n.metadata.kpiMetrics.length - 1]?.metrics || null
                }));
            const camCarto = viewer?.camera?.positionCartographic || null;
            const camera = {
                lod: (typeof lodGovernor?.getCurrentLevel === 'function' ? lodGovernor.getCurrentLevel() : null) || filamentRenderer?.currentLOD || 'UNKNOWN',
                position: camCarto ? {
                    lon: Number(Cesium.Math.toDegrees(camCarto.longitude).toFixed(6)),
                    lat: Number(Cesium.Math.toDegrees(camCarto.latitude).toFixed(6)),
                    height: Number(camCarto.height.toFixed(2))
                } : null,
                heading: Number.isFinite(viewer?.camera?.heading) ? Number(viewer.camera.heading.toFixed(6)) : null,
                pitch: Number.isFinite(viewer?.camera?.pitch) ? Number(viewer.camera.pitch.toFixed(6)) : null,
                roll: Number.isFinite(viewer?.camera?.roll) ? Number(viewer.camera.roll.toFixed(6)) : null
            };
            const pressure = (typeof getAggregateCFStatus === 'function') ? getAggregateCFStatus(relayState.tree) : null;
            const primitiveCount = filamentRenderer?.primitiveCount || {};
            const entityCount = filamentRenderer?.entityCount || {};
            const sheetCount = (relayState?.tree?.nodes || []).filter(n => n.type === 'sheet').length;
            const contract = targetBinding?.contract || null;
            const objectEvidence = {
                objectId: target,
                type: contract?.type || targetBinding?.targetRef?.type || 'unknown',
                label: contract?.label || null
            };
            if (contract?.type === 'match') {
                objectEvidence.matchStatus = contract.matchStatus || contract.fields?.matchStatus || null;
            }
            if (contract?.type === 'cell') {
                objectEvidence.selectedCell = {
                    sheetId: contract.sheetId || targetSheetId || null,
                    row: Number.isFinite(contract.row) ? contract.row : null,
                    col: Number.isFinite(contract.col) ? contract.col : null,
                    cellRef: contract.cellRef || null
                };
            }
            if (contract?.type === 'branch' || contract?.type === 'module') {
                objectEvidence.kpis = Array.isArray(contract.kpiBindings)
                    ? contract.kpiBindings.map(k => (typeof k === 'string' ? k : (k.metric || k.metricId || k.name || k.id || String(k))))
                    : [];
            }
            return {
                kpis,
                sheetState: {
                    target,
                    sheetId: targetSheet?.id || targetSheetId || null,
                    rowCount: Number(targetSheet?.rows || 0),
                    colCount: Number(targetSheet?.cols || 0),
                    populatedCells: Array.isArray(targetSheet?.cellData) ? targetSheet.cellData.length : 0,
                    metadata: targetSheet?.metadata ? {
                        isFactSheet: targetSheet.metadata.isFactSheet === true,
                        isMatchSheet: targetSheet.metadata.isMatchSheet === true,
                        isSummarySheet: targetSheet.metadata.isSummarySheet === true,
                        factClass: targetSheet.metadata.factClass || null
                    } : null
                },
                camera,
                pressure,
                object: objectEvidence,
                filamentCounts: {
                    sheets: sheetCount,
                    lanes: {
                        lanePolylines: Number(primitiveCount.lanePolylines || 0),
                        laneVolumes: Number(primitiveCount.laneVolumes || 0)
                    },
                    entities: {
                        labels: Number(entityCount.labels || 0),
                        cellPoints: Number(entityCount.cellPoints || 0),
                        timeboxLabels: Number(entityCount.timeboxLabels || 0)
                    }
                }
            };
        };
        const ensureObjectIndexBucket = (objectId) => {
            if (!window.__relayArtifactsByObjectId.has(objectId)) {
                window.__relayArtifactsByObjectId.set(objectId, { snapshots: [], commits: [] });
            }
            return window.__relayArtifactsByObjectId.get(objectId);
        };
        const ensureProposalIndexBucket = (proposalId) => {
            if (!window.__relayArtifactsByProposalId.has(proposalId)) {
                window.__relayArtifactsByProposalId.set(proposalId, { proposeSnapId: null, commits: [] });
            }
            return window.__relayArtifactsByProposalId.get(proposalId);
        };
        const getRouteZone = (routeId, fallback = relayWorkState.zone) => {
            const rid = String(routeId || '');
            const prefix = rid.split('.')[0];
            return prefix ? `zone.${prefix}` : fallback;
        };
        const captureSheetStableSnapshot = (sheetId) => {
            const sheet = (relayState?.tree?.nodes || []).find(n => n.type === 'sheet' && n.id === sheetId);
            if (!sheet) return null;
            const schema = sheet.metadata?.schema || [];
            const preferredKeys = ['matchId', 'invLineId', 'poLineId', 'grLineId', 'glLineId', 'payLineId', 'payId', 'invId', 'poId', 'reqLineId', 'reqId', 'glDocId', 'paymentId'];
            const keyField = preferredKeys.find(fid => schema.some(col => col.id === fid || col.name === fid)) || (schema[0]?.id || schema[0]?.name || 'row');
            const keyColIdx = schema.findIndex(col => col.id === keyField || col.name === keyField);
            const rowMapByRow = new Map();
            for (const cell of (sheet.cellData || [])) {
                if (!rowMapByRow.has(cell.row)) rowMapByRow.set(cell.row, {});
                const rowObj = rowMapByRow.get(cell.row);
                const colDef = schema[cell.col];
                const colId = colDef?.id || colDef?.name || `col${cell.col}`;
                rowObj[colId] = (cell.display ?? cell.value ?? null);
            }
            const rowsByKey = new Map();
            const amountKeys = ['lineTotal', 'amount', 'variance', 'priceVariance', 'qtyVariance', 'paidAmount', 'invAmount'];
            for (const [rowIdx, rowObj] of rowMapByRow.entries()) {
                const rawKey = keyColIdx >= 0 ? rowObj[keyField] : null;
                const stableId = String(rawKey ?? `${sheet.id}.row.${rowIdx}`);
                const signature = fnv1aHex(JSON.stringify(rowObj));
                let impact = 0;
                for (const k of amountKeys) {
                    const v = Number(rowObj[k]);
                    if (Number.isFinite(v)) impact += Math.abs(v);
                }
                const statusVal = String(rowObj.matchStatus || rowObj.status || '');
                rowsByKey.set(stableId, {
                    objectId: stableId,
                    signature,
                    impact,
                    status: statusVal,
                    rowIndex: rowIdx,
                    keyField,
                    objectType: keyField === 'matchId' ? 'match' : 'row'
                });
            }
            return { sheetId: sheet.id, keyField, rowsByKey };
        };
        const summarizeRouteDelta = (routeId, preSnap, postSnap) => {
            if (!postSnap?.rowsByKey) return null;
            const preRows = preSnap?.rowsByKey || new Map();
            const postRows = postSnap.rowsByKey;
            let added = 0;
            let updated = 0;
            const impacted = [];
            for (const [objectId, postRow] of postRows.entries()) {
                const preRow = preRows.get(objectId);
                if (!preRow) {
                    added += 1;
                    impacted.push({ objectId, impact: postRow.impact, objectType: postRow.objectType, keyField: postRow.keyField, kind: 'added' });
                } else if (preRow.signature !== postRow.signature) {
                    updated += 1;
                    const impact = Math.max(postRow.impact, preRow.impact);
                    impacted.push({ objectId, impact, objectType: postRow.objectType, keyField: postRow.keyField, kind: 'updated' });
                }
            }
            impacted.sort((a, b) => (b.impact - a.impact) || String(a.objectId).localeCompare(String(b.objectId)));
            const top = impacted.slice(0, 10);
            const summary = {
                routeId,
                sheetId: postSnap.sheetId,
                keyField: postSnap.keyField,
                counts: { added, updated, removed: 0 },
                top
            };
            RelayLog.info(`[DELTA] route=${routeId} added=${added} updated=${updated} top=${top.length}`);
            window.__relayLastDeltaSummary = summary;
            return summary;
        };
        const maybeAutoHoldFromDelta = (deltaSummary) => {
            if (!deltaSummary || window.RELAY_AUTO_HOLD_ON_DELTA !== true) return;
            const thresholdUpdated = Number(window.RELAY_DELTA_HOLD_THRESHOLD?.updated ?? 50);
            if (!(deltaSummary.counts.updated >= thresholdUpdated)) return;
            const best = deltaSummary.top.find(t => t.objectType === 'match') || deltaSummary.top[0] || null;
            const targetRef = (best && best.objectType === 'match')
                ? { type: 'match', id: best.objectId }
                : { type: 'sheet', id: deltaSummary.sheetId };
            const ok = setRelayWorkMode('HOLD', {
                targetRef,
                zone: getRouteZone(deltaSummary.routeId),
                reason: 'AUTO_DELTA',
                deltaSummary,
                forceSnapshot: true
            });
            if (ok) {
                RelayLog.info(`[AUTO] hold reason=AUTO_DELTA route=${deltaSummary.routeId} target=${targetRef.id}`);
            }
        };
        const rebuildArtifactIndexes = () => {
            window.__relayArtifactsByObjectId.clear();
            window.__relayArtifactsByProposalId.clear();
            for (const snap of (window.__relaySnapshots || []).sort(artifactSortAsc)) {
                if (snap?.objectId) {
                    const bucket = ensureObjectIndexBucket(snap.objectId);
                    if (!bucket.snapshots.includes(snap.id)) bucket.snapshots.push(snap.id);
                }
                if (snap?.proposalId) {
                    const proposalBucket = ensureProposalIndexBucket(snap.proposalId);
                    proposalBucket.proposeSnapId = snap.id;
                }
            }
            for (const commit of (window.__relayCommits || []).sort(artifactSortAsc)) {
                if (commit?.objectId) {
                    const bucket = ensureObjectIndexBucket(commit.objectId);
                    if (!bucket.commits.includes(commit.id)) bucket.commits.push(commit.id);
                }
                if (commit?.proposalId) {
                    const proposalBucket = ensureProposalIndexBucket(commit.proposalId);
                    if (!proposalBucket.commits.includes(commit.id)) proposalBucket.commits.push(commit.id);
                }
            }
        };
        const createModeSnapshot = (type, previousMode, nextMode, targetBinding, extras = {}) => {
            const now = new Date();
            const evidence = collectSnapshotEvidence(targetBinding);
            if (extras.proposal) {
                evidence.proposal = { ...extras.proposal };
            }
            if (extras.action) {
                evidence.action = { ...extras.action };
            }
            if (extras.delta) {
                evidence.delta = { ...extras.delta };
            }
            const id = nextArtifactId('SNAP');
            const snapshot = {
                id,
                type,
                zone: relayWorkState.zone,
                user: relayWorkState.user,
                previousMode,
                nextMode,
                target: relayWorkState.target,
                objectId: relayWorkState.objectId,
                targetRef: relayWorkState.targetRef ? { ...relayWorkState.targetRef } : null,
                scopeRef: relayWorkState.scopeRef ? { ...relayWorkState.scopeRef } : null,
                timestamp: now.toISOString(),
                evidence
            };
            const evidenceHash = fnv1aHex(JSON.stringify(snapshot.evidence));
            snapshot.evidenceHash = evidenceHash;
            if (extras.proposal?.proposalId) {
                snapshot.proposalId = extras.proposal.proposalId;
            }
            window.__relaySnapshots.push(snapshot);
            if (snapshot.objectId) {
                const objectBucket = ensureObjectIndexBucket(snapshot.objectId);
                if (!objectBucket.snapshots.includes(snapshot.id)) objectBucket.snapshots.push(snapshot.id);
            }
            if (snapshot.proposalId) {
                const proposalBucket = ensureProposalIndexBucket(snapshot.proposalId);
                proposalBucket.proposeSnapId = snapshot.id;
            }
            if (type === 'PROPOSE' && extras.proposal?.proposalId) {
                RelayLog.info(`[SNAP] propose target=${snapshot.target} zone=${snapshot.zone} mode=${previousMode}‚Üí${nextMode} evidence=${evidenceHash} proposalId=${extras.proposal.proposalId}`);
            } else {
                RelayLog.info(`[SNAP] ${String(type).toLowerCase()} target=${snapshot.target} zone=${snapshot.zone} mode=${previousMode}‚Üí${nextMode} evidence=${evidenceHash}`);
            }
            return snapshot;
        };
        const createCommitReceipt = (proposalId, evidenceHash, previousMode, nextMode, extras = {}) => {
            const commitId = nextArtifactId('COMMIT');
            const receipt = {
                id: commitId,
                type: 'COMMIT_RECEIPT',
                commitId,
                proposalId: String(proposalId),
                evidenceHash: String(evidenceHash || 'none'),
                timestamp: new Date().toISOString(),
                user: relayWorkState.user,
                zone: relayWorkState.zone,
                target: relayWorkState.target,
                objectId: relayWorkState.objectId,
                targetRef: relayWorkState.targetRef ? { ...relayWorkState.targetRef } : null,
                scopeRef: relayWorkState.scopeRef ? { ...relayWorkState.scopeRef } : null,
                previousMode: String(previousMode || 'UNKNOWN'),
                nextMode: String(nextMode || 'COMMIT'),
                transferPacketId: extras.transferPacketId ? String(extras.transferPacketId) : null,
                responsibilityPacketIds: Array.isArray(extras.responsibilityPacketIds)
                    ? extras.responsibilityPacketIds.map(String)
                    : []
            };
            window.__relayCommits.push(receipt);
            if (receipt.objectId) {
                const objectBucket = ensureObjectIndexBucket(receipt.objectId);
                if (!objectBucket.commits.includes(receipt.id)) objectBucket.commits.push(receipt.id);
            }
            if (receipt.proposalId) {
                const proposalBucket = ensureProposalIndexBucket(receipt.proposalId);
                if (!proposalBucket.commits.includes(receipt.id)) proposalBucket.commits.push(receipt.id);
            }
            relayWorkState.currentCommitId = commitId;
            RelayLog.info(`[COMMIT] commitId=${commitId} proposalId=${receipt.proposalId} target=${receipt.target} evidence=${receipt.evidenceHash}`);
            // E1-CRYPTO-1: append to derived global chain (non-mutating)
            if (window.__relayCryptoState?.initialized) {
                appendGlobalChainEntry(window.__relayCryptoState.globalChain, receipt).then(entry => {
                    const logMsg = `[CRYPTO] commit chainLink index=${entry.commitIndex} prevHash=${entry.prevHash.slice(0, 16)} evidenceAlgo=sha256`;
                    RelayLog.info(logMsg); console.log(logMsg);
                });
            }
            return receipt;
        };
        const getLatestSnapshotByType = (type) => {
            const list = (window.__relaySnapshots || []).filter(s => String(s.type) === String(type)).sort(artifactSortAsc);
            return list[list.length - 1] || null;
        };
        const getActiveObjectIdForInspector = () => {
            if (sheetSelection?.sheetId && Number.isFinite(sheetSelection.row) && Number.isFinite(sheetSelection.col)) {
                const sheet = (relayState?.tree?.nodes || []).find(n => n.type === 'sheet' && n.id === sheetSelection.sheetId);
                if (sheet?.metadata?.isMatchSheet) {
                    const contract = toRelayObject({ sheetId: sheetSelection.sheetId, row: sheetSelection.row, isMatch: true }, relayState);
                    if (contract?.id) return contract.id;
                }
                return `${sheetSelection.sheetId}.cell.${sheetSelection.row}.${sheetSelection.col}`;
            }
            if (isFocusMode && focusTarget?.contract?.id) return focusTarget.contract.id;
            if (relayWorkState.objectId) return relayWorkState.objectId;
            return null;
        };
        const focusArtifactObject = (objectId) => {
            if (!objectId) return;
            window.__relayArtifactFocusedObjectId = objectId;
            const contract = resolveContractForTargetRef({ id: objectId });
            if (contract?.type === 'trunk' || contract?.type === 'branch' || contract?.type === 'sheet') {
                const node = (relayState?.tree?.nodes || []).find(n => n.id === contract.id);
                if (node && typeof window.enterFocusMode === 'function') {
                    window.enterFocusMode(node);
                }
            } else if (contract && typeof window.showInspector === 'function') {
                window.showInspector(contract);
            }
            RelayLog.info(`[ARTIFACT] focus objectId=${objectId}`);
        };
        const proposeFixForObject = (objectId) => {
            if (!objectId) return false;
            const contract = resolveContractForTargetRef({ id: objectId });
            const targetRef = {
                type: String(contract?.type || 'object'),
                id: String(contract?.id || objectId)
            };
            const defaultSummary = `Propose fix for ${targetRef.id}`;
            const summaryInput = window.prompt('Propose summary', defaultSummary);
            if (summaryInput === null) return false;
            const summary = String(summaryInput || '').trim();
            if (!summary) return false;
            const defaultChangeset = `ACT:proposeFix:${Date.now()}`;
            const changesetInput = window.prompt('Changeset ref', defaultChangeset);
            if (changesetInput === null) return false;
            const changesetRef = String(changesetInput || '').trim();
            if (!changesetRef) return false;
            const proposalId = nextArtifactId('PROPOSAL');
            const ok = setRelayWorkMode('PROPOSE', {
                targetRef,
                summary,
                changesetRef,
                proposalId,
                allowDirectPropose: true,
                forceSnapshot: true,
                action: { actionId: 'proposeFix', params: {}, uiSource: 'inspector' }
            });
            if (ok) {
                RelayLog.info(`[ACT] propose actionId=proposeFix objectId=${targetRef.id} proposalId=${proposalId}`);
            }
            return ok;
        };
        const commitForObject = (objectId, proposalIdHint = '') => {
            if (!objectId) return false;
            const contract = resolveContractForTargetRef({ id: objectId });
            const targetRef = {
                type: String(contract?.type || 'object'),
                id: String(contract?.id || objectId)
            };
            const artifacts = window.relayGetArtifactsForObject(objectId) || { snapshots: [], commits: [] };
            const propose = artifacts.snapshots
                .filter(s => s.type === 'PROPOSE')
                .sort(artifactSortAsc)
                .slice(-1)[0] || null;
            const proposalId = String(proposalIdHint || propose?.proposalId || relayWorkState.currentProposalId || '');
            const evidenceHash = String(propose?.evidenceHash || relayWorkState.currentProposalEvidenceHash || '');
            const ok = setRelayWorkMode('COMMIT', { targetRef, proposalId, evidenceHash });
            if (ok) {
                RelayLog.info(`[ACT] commit actionId=manualCommit objectId=${targetRef.id} commitId=${relayWorkState.currentCommitId || 'n/a'} proposalId=${proposalId || 'n/a'}`);
            }
            return ok;
        };
        const renderArtifactInspector = () => {
            if (!artifactInspectorPanelEl) return;
            const lastHold = getLatestSnapshotByType('HOLD');
            const lastPropose = getLatestSnapshotByType('PROPOSE');
            const commits = (window.__relayCommits || []).slice().sort(artifactSortAsc);
            const lastCommit = commits[commits.length - 1] || null;
            const artifacts = getArtifactsSorted().slice().reverse();
            const current = `mode=${relayWorkState.mode} zone=${relayWorkState.zone} target=${relayWorkState.target}`;
            const activeObjectId = getActiveObjectIdForInspector();
            const objectArtifacts = activeObjectId ? (window.relayGetArtifactsForObject(activeObjectId) || { snapshots: [], commits: [] }) : { snapshots: [], commits: [] };
            const objectArtifactList = [...objectArtifacts.snapshots, ...objectArtifacts.commits]
                .sort((a, b) => -artifactSortAsc(a, b))
                .slice(0, 10);
            const trunkMetricsState = window.__relayTrunkMetrics || { metrics: [], hash: null, trunkId: 'trunk.avgol' };
            const trunkMetrics = Array.isArray(trunkMetricsState.metrics) ? trunkMetricsState.metrics : [];
            const selectedTrunkMetric = getSelectedTrunkMetric();
            const selectedContributors = Array.isArray(selectedTrunkMetric?.contributors) ? selectedTrunkMetric.contributors : [];
            const presenceState = window.__relayPresenceState || { markers: [], auditRequests: [], scvs: [] };
            const presenceMarkers = (presenceState.markers || []).slice().sort((a, b) => String(a.actorId || '').localeCompare(String(b.actorId || '')));
            const auditRequests = (presenceState.auditRequests || []).slice().sort((a, b) => String(b.updatedAt || '').localeCompare(String(a.updatedAt || ''))).slice(0, 6);
            const basinState = window.__relayBasinState || { active: false, targetId: null, distanceM: null, softLockEnabled: false };
            const focusState = focusLensState || { active: false, frameId: null, targetObjectId: null, radiusM: 0 };
            const walkState = branchWalkState || { active: false, branchId: null, currentObjectId: null, currentIndex: -1, path: [] };
            const flows = flowStoreSorted().slice(-5).reverse();
            const playback = window.__relayFlowPlayback || { active: false, flowId: null, mode: 'guided', stepIndex: -1 };
            const activeFlow = playback.flowId ? (window.__relayFlows || []).find(f => String(f.flowId) === String(playback.flowId)) : null;
            const row = (label, data, renderExtra = () => '') => {
                if (!data) return `<div class="artifact-row"><strong>${label}:</strong> ‚Äî</div>`;
                return `<div class="artifact-row"><strong>${label}:</strong> ${String(data.id)}
                    <span class="artifact-actions">
                      <button class="artifact-btn" data-artifact-action="copy" data-artifact-id="${String(data.id)}">Copy JSON</button>
                      <button class="artifact-btn" data-artifact-action="select" data-artifact-id="${String(data.id)}">Select in list</button>
                    </span><br>${renderExtra(data)}</div>`;
            };
            artifactInspectorPanelEl.innerHTML = `
                <div class="artifact-title">Artifacts Inspector</div>
                <div class="artifact-row"><strong>Current:</strong> ${current}</div>
                ${row('Last HOLD', lastHold, (d) => `evidence=${d.evidenceHash || 'n/a'}`)}
                ${row('Last PROPOSE', lastPropose, (d) => `proposalId=${d.proposalId || d.evidence?.proposal?.proposalId || 'n/a'} summary=${d.evidence?.proposal?.summary || 'n/a'} changesetRef=${d.evidence?.proposal?.changesetRef || 'n/a'} evidence=${d.evidenceHash || 'n/a'}`)}
                ${row('Last COMMIT', lastCommit, (d) => `commitId=${d.commitId || d.id} proposalId=${d.proposalId || 'n/a'} evidence=${d.evidenceHash || 'n/a'}`)}
                <div class="artifact-row"><strong>Trunk Metrics:</strong> ${trunkMetricsState.trunkId || 'trunk.avgol'} hash=${trunkMetricsState.hash || 'n/a'}</div>
                <div class="artifact-list">
                  ${trunkMetrics.length
                    ? trunkMetrics.map(m => `<div class="artifact-item${selectedTrunkMetric?.metricId === m.metricId ? ' selected' : ''}" data-trunk-metric-id="${m.metricId}">${m.metricId}=${Number(m.value || 0).toFixed(2)} ${m.unit || ''} (${m.op}, contributors=${m.contributorCount || 0})</div>`).join('')
                    : '<div class="artifact-item">‚Äî</div>'}
                </div>
                <div class="artifact-row"><strong>Contributors:</strong> ${selectedTrunkMetric?.metricId || 'none'}</div>
                <div class="artifact-list">
                  ${selectedContributors.length
                    ? selectedContributors.map(c => `<div class="artifact-item">${c.branchId} | value=${Number(c.value || 0).toFixed(2)} | cell=${c.sourceCell || 'n/a'} | facts=${(c.factSheetIds || []).join(',') || 'n/a'}</div>`).join('')
                    : '<div class="artifact-item">‚Äî</div>'}
                </div>
                <div class="artifact-row"><strong>Presence Markers:</strong> ${presenceMarkers.length}</div>
                <div class="artifact-list">
                  ${presenceMarkers.length
                    ? presenceMarkers.map(m => `<div class="artifact-item">${m.actorId} | type=${m.actorType} | tier=${m.tier} | focus=${m.focusObjectId || 'none'} | status=${m.status || 'NORMAL'}</div>`).join('')
                    : '<div class="artifact-item">‚Äî</div>'}
                </div>
                <div class="artifact-row"><strong>Audit Requests:</strong> ${auditRequests.length}</div>
                <div class="artifact-list">
                  ${auditRequests.length
                    ? auditRequests.map(r => `<div class="artifact-item">${r.requestId} | status=${r.status} | target=${r.targetObjectId} | scv=${r.scvId || 'none'}</div>`).join('')
                    : '<div class="artifact-item">‚Äî</div>'}
                </div>
                <div class="artifact-row"><strong>Basin:</strong> active=${basinState.active ? 'true' : 'false'} target=${basinState.targetId || 'none'} distance=${Number.isFinite(Number(basinState.distanceM)) ? Number(basinState.distanceM).toFixed(1) : 'n/a'}m softLock=${basinState.softLockEnabled ? 'on' : 'off'}</div>
                <div class="artifact-row"><strong>Focus Sphere:</strong> active=${focusState.active ? 'true' : 'false'} frame=${focusState.frameId || 'none'} target=${focusState.targetObjectId || 'none'} radiusM=${Number(focusState.radiusM || 0).toFixed(1)}</div>
                <div class="artifact-row"><strong>Branch Walk:</strong> active=${walkState.active ? 'true' : 'false'} branch=${walkState.branchId || 'none'} index=${Number(walkState.currentIndex || 0)} target=${walkState.currentObjectId || 'none'} steps=${Array.isArray(walkState.path) ? walkState.path.length : 0}</div>
                <div class="artifact-row"><strong>Flow Playback:</strong> ${playback.active ? `ACTIVE flow=${playback.flowId} mode=${playback.mode}` : 'idle'}</div>
                <div class="artifact-list">
                  ${activeFlow
                    ? (activeFlow.steps || []).map((s, idx) => `<div class="artifact-item${idx === Number(playback.stepIndex) ? ' selected' : ''}">${idx + 1}. ${s.kind} | ${s.targetRef?.id || 'none'}${s.actionId ? ` | action=${s.actionId}` : ''}</div>`).join('')
                    : '<div class="artifact-item">‚Äî</div>'}
                </div>
                <div class="artifact-row"><strong>Recent Flows:</strong> ${flows.length}</div>
                <div class="artifact-list">
                  ${flows.length
                    ? flows.map(f => `<div class="artifact-item">flow=${f.flowId} | status=${f.status} | steps=${f.steps?.length || 0} | target=${f.startTargetRef?.id || 'none'}</div>`).join('')
                    : '<div class="artifact-item">‚Äî</div>'}
                </div>
                <div class="artifact-row"><strong>Artifacts for this object:</strong> ${activeObjectId || 'none'}</div>
                <div class="artifact-row">
                    <button class="artifact-btn" data-artifact-action="propose-fix" data-artifact-object-id="${activeObjectId || ''}" ${activeObjectId ? '' : 'disabled'}>Propose Fix</button>
                    <button class="artifact-btn" data-artifact-action="commit-object" data-artifact-object-id="${activeObjectId || ''}" ${activeObjectId ? '' : 'disabled'}>Commit</button>
                </div>
                <div class="artifact-list">
                  ${objectArtifactList.length
                    ? objectArtifactList.map(a => `<div class="artifact-item" data-artifact-item-id="${a.id}">${a.timestamp || 'n/a'} | ${a.type} | ${a.id}</div>`).join('')
                    : '<div class="artifact-item">‚Äî</div>'}
                </div>
                <div class="artifact-list"><strong>Artifact List</strong>
                  ${artifacts.map(a => `<div id="artifact-item-${domSafeId(a.id)}" class="artifact-item${selectedArtifactId === a.id ? ' selected' : ''}" data-artifact-item-id="${a.id}">${a.timestamp || 'n/a'} | ${a.type || a.artifactKind} | ${a.id}</div>`).join('')}
                </div>
            `;
        };
        const selectArtifactInList = (id) => {
            selectedArtifactId = id;
            renderArtifactInspector();
            const el = document.getElementById(`artifact-item-${domSafeId(id)}`);
            if (el) el.scrollIntoView({ block: 'nearest' });
        };
        const bindArtifactInspectorEvents = () => {
            if (!artifactInspectorPanelEl) return;
            artifactInspectorPanelEl.addEventListener('click', async (event) => {
                const target = event.target;
                if (!(target instanceof HTMLElement)) return;
                const action = target.getAttribute('data-artifact-action');
                const artifactId = target.getAttribute('data-artifact-id');
                const artifactObjectId = target.getAttribute('data-artifact-object-id');
                if (action && artifactId) {
                    const artifact = getArtifactById(artifactId);
                    if (!artifact) return;
                    if (action === 'copy') {
                        const ok = await copyTextToClipboard(JSON.stringify(artifact, null, 2));
                        RelayLog.info(`[ARTIFACT] copy id=${artifactId} result=${ok ? 'OK' : 'FAIL'}`);
                    } else if (action === 'select') {
                        selectArtifactInList(artifactId);
                    }
                    return;
                }
                if (action && artifactObjectId) {
                    if (action === 'propose-fix') {
                        proposeFixForObject(artifactObjectId);
                        renderArtifactInspector();
                    } else if (action === 'commit-object') {
                        commitForObject(artifactObjectId);
                        renderArtifactInspector();
                    }
                    return;
                }
                const itemId = target.getAttribute('data-artifact-item-id');
                if (itemId) {
                    selectArtifactInList(itemId);
                    const artifact = getArtifactById(itemId);
                    if (artifact?.objectId) focusArtifactObject(artifact.objectId);
                }
                const trunkMetricId = target.getAttribute('data-trunk-metric-id');
                if (trunkMetricId) {
                    selectedTrunkMetricId = String(trunkMetricId);
                    renderArtifactInspector();
                }
            });
        };
        const relayGetUx3ModuleOptions = () => {
            const out = [];
            if (typeof loadedModuleDefs === 'undefined' || !loadedModuleDefs) return out;
            for (const moduleDef of loadedModuleDefs.values()) {
                out.push({
                    moduleId: String(moduleDef.moduleId || ''),
                    branchId: String(moduleDef.branchId || ''),
                    name: String(moduleDef.name || moduleDef.moduleId || 'Module')
                });
            }
            return out.sort((a, b) => a.moduleId.localeCompare(b.moduleId));
        };
        const relayGetUx3Config = (moduleIdInput = '') => {
            const options = relayGetUx3ModuleOptions();
            const fallbackModuleId = options[0]?.moduleId || '';
            const moduleId = String(moduleIdInput || relayUx3State.selectedModuleId || fallbackModuleId);
            if (!moduleId || typeof loadedModuleDefs === 'undefined' || !loadedModuleDefs) return null;
            const moduleDef = loadedModuleDefs.get(moduleId);
            if (!moduleDef) return null;
            const branchId = String(moduleDef.branchId || '');
            const branchNode = (relayState?.tree?.nodes || []).find(n => n.type === 'branch' && n.id === branchId) || null;
            const sheetIds = new Set([
                ...((moduleDef.factSheets || []).map(s => String(s.sheetId || ''))),
                ...((moduleDef.matchSheets || []).map(s => String(s.sheetId || ''))),
                ...((moduleDef.summarySheets || []).map(s => String(s.sheetId || '')))
            ]);
            const routeFieldSources = [];
            const routeIds = (typeof getRouteIds === 'function') ? getRouteIds() : [];
            for (const routeId of routeIds) {
                const route = (typeof getRoute === 'function') ? getRoute(routeId) : null;
                if (!route || !sheetIds.has(String(route.targetSheet || ''))) continue;
                const fieldSources = {};
                for (const [fieldId, fieldDef] of Object.entries(route.fields || {})) {
                    fieldSources[String(fieldId)] = String(fieldDef?.source || '');
                }
                routeFieldSources.push({
                    routeId: String(route.routeId || routeId),
                    targetSheet: String(route.targetSheet || ''),
                    fields: fieldSources
                });
            }
            routeFieldSources.sort((a, b) => a.routeId.localeCompare(b.routeId));
            return {
                moduleId,
                branchId,
                branchName: String(branchNode?.name || moduleDef.name || moduleId),
                kpiBindings: Array.isArray(branchNode?.metadata?.kpiBindings) ? JSON.parse(JSON.stringify(branchNode.metadata.kpiBindings)) : [],
                routeFieldSources
            };
        };
        const relayApplyUx3Config = (configPayload) => {
            if (!configPayload || typeof configPayload !== 'object') {
                return { ok: false, reason: 'UX3_CONFIG_INVALID' };
            }
            const moduleId = String(configPayload.moduleId || '').trim();
            const branchId = String(configPayload.branchId || '').trim();
            if (!moduleId || !branchId) return { ok: false, reason: 'UX3_CONFIG_INVALID_SCOPE' };
            const moduleDef = loadedModuleDefs.get(moduleId);
            if (!moduleDef) return { ok: false, reason: 'UX3_MODULE_UNKNOWN' };
            const branchNode = (relayState?.tree?.nodes || []).find(n => n.type === 'branch' && n.id === branchId);
            if (!branchNode) return { ok: false, reason: 'UX3_BRANCH_UNKNOWN' };
            const updates = Array.isArray(configPayload.routeFieldSources) ? configPayload.routeFieldSources : [];
            for (const routeUpdate of updates) {
                const routeId = String(routeUpdate?.routeId || '').trim();
                if (!routeId) continue;
                const route = getRoute(routeId);
                if (!route) return { ok: false, reason: `UX3_ROUTE_UNKNOWN:${routeId}` };
            }

            if (Array.isArray(configPayload.kpiBindings)) {
                branchNode.metadata = branchNode.metadata || {};
                branchNode.metadata.kpiBindings = JSON.parse(JSON.stringify(configPayload.kpiBindings));
            }

            for (const routeUpdate of updates) {
                const routeId = String(routeUpdate?.routeId || '').trim();
                if (!routeId) continue;
                const route = getRoute(routeId);
                const fields = (routeUpdate?.fields && typeof routeUpdate.fields === 'object') ? routeUpdate.fields : {};
                for (const [fieldId, source] of Object.entries(fields)) {
                    if (!route.fields || !route.fields[fieldId]) continue;
                    route.fields[fieldId].source = String(source || '');
                }
            }
            return { ok: true, moduleId, branchId };
        };
        const setUx3Status = (text) => {
            if (ux3StatusLineEl) ux3StatusLineEl.textContent = String(text || 'idle');
        };
        const renderUx3Panel = (moduleIdInput = '') => {
            if (!branchStewardPanelEl || !ux3ModuleSelectEl || !ux3ConfigEditorEl) return;
            const options = relayGetUx3ModuleOptions();
            if (!options.length) {
                ux3ModuleSelectEl.innerHTML = '<option value="">(no modules)</option>';
                ux3ConfigEditorEl.value = '{}';
                setUx3Status('No loaded modules found');
                return;
            }
            const selected = String(moduleIdInput || relayUx3State.selectedModuleId || options[0].moduleId);
            relayUx3State.selectedModuleId = selected;
            ux3ModuleSelectEl.innerHTML = options.map(opt => `<option value="${opt.moduleId}" ${opt.moduleId === selected ? 'selected' : ''}>${opt.moduleId} (${opt.branchId || 'n/a'})</option>`).join('');
            const config = relayGetUx3Config(selected);
            ux3ConfigEditorEl.value = JSON.stringify(config || {}, null, 2);
            if (!ux3SummaryInputEl?.value) {
                ux3SummaryInputEl.value = `Update ${selected} visible configuration`;
            }
            setUx3Status(`Ready: ${selected}`);
        };
        const relayUx3ProposeConfigEdit = (payload = {}, meta = {}) => {
            const rawConfig = payload?.config ?? payload;
            if (!rawConfig || typeof rawConfig !== 'object') {
                return { ok: false, reason: 'UX3_CONFIG_INVALID' };
            }
            const moduleId = String(rawConfig.moduleId || relayUx3State.selectedModuleId || '').trim();
            if (!moduleId) return { ok: false, reason: 'UX3_MODULE_REQUIRED' };
            const config = { ...rawConfig, moduleId };
            const branchId = String(config.branchId || loadedModuleDefs.get(moduleId)?.branchId || '').trim();
            if (!branchId) return { ok: false, reason: 'UX3_BRANCH_REQUIRED' };
            config.branchId = branchId;
            const summary = String(meta.summary || ux3SummaryInputEl?.value || `Update ${moduleId} visible configuration`).trim();
            if (!summary) return { ok: false, reason: 'UX3_SUMMARY_REQUIRED' };
            const changesetRef = String(meta.changesetRef || `UX3:${moduleId}:${Date.now()}`).trim();
            const targetRef = { type: 'branch', id: branchId };
            const proposed = setRelayWorkMode('PROPOSE', {
                targetRef,
                user: String(meta.user || relayWorkState.user || 'local'),
                zone: String(meta.zone || relayWorkState.zone || 'zone.avgol.ops'),
                summary,
                changesetRef,
                allowDirectPropose: true,
                forceSnapshot: true,
                action: {
                    actionId: 'ux3.updateVisibleConfig',
                    params: { moduleId, branchId },
                    uiSource: String(meta.uiSource || 'ux3-panel')
                }
            });
            if (!proposed) return { ok: false, reason: 'PROPOSE_FAILED' };
            relayUx3State.pendingProposalId = relayWorkState.currentProposalId;
            relayUx3State.pendingCommittedChange = JSON.parse(JSON.stringify(config));
            RelayLog.info(`[UX3] propose module=${moduleId} branch=${branchId} proposalId=${relayUx3State.pendingProposalId}`);
            setUx3Status(`Proposed ${moduleId} (${relayUx3State.pendingProposalId})`);
            renderArtifactInspector();
            return { ok: true, proposalId: relayUx3State.pendingProposalId, moduleId, branchId };
        };
        const relayUx3CommitLatest = (meta = {}) => {
            const proposalId = String(meta.proposalId || relayUx3State.pendingProposalId || relayWorkState.currentProposalId || '').trim();
            const pending = relayUx3State.pendingCommittedChange;
            if (!proposalId || !pending) return { ok: false, reason: 'UX3_NOTHING_PENDING' };
            const targetRef = { type: 'branch', id: String(pending.branchId || '') };
            const committed = setRelayWorkMode('COMMIT', {
                targetRef,
                proposalId,
                user: String(meta.user || relayWorkState.user || 'local'),
                zone: String(meta.zone || relayWorkState.zone || 'zone.avgol.ops')
            });
            if (!committed) return { ok: false, reason: 'COMMIT_FAILED' };
            const applyResult = relayApplyUx3Config(pending);
            if (!applyResult.ok) {
                RelayLog.warn(`[REFUSAL] reason=${applyResult.reason} module=${pending.moduleId || 'unknown'}`);
                return { ok: false, reason: applyResult.reason };
            }
            relayUx3State.lastCommitId = relayWorkState.currentCommitId;
            RelayLog.info(`[UX3] commit module=${pending.moduleId} branch=${pending.branchId} commitId=${relayUx3State.lastCommitId} proposalId=${proposalId}`);
            relayUx3State.pendingCommittedChange = null;
            relayUx3State.pendingProposalId = null;
            setUx3Status(`Committed ${pending.moduleId} (${relayUx3State.lastCommitId})`);
            renderUx3Panel(pending.moduleId);
            renderArtifactInspector();
            return { ok: true, commitId: relayUx3State.lastCommitId, moduleId: pending.moduleId, branchId: pending.branchId };
        };
        const bindUx3PanelEvents = () => {
            if (!branchStewardPanelEl) return;
            const parseEditorConfig = () => {
                if (!ux3ConfigEditorEl) return null;
                try {
                    const parsed = JSON.parse(String(ux3ConfigEditorEl.value || '{}'));
                    return parsed;
                } catch (err) {
                    setUx3Status(`Invalid JSON: ${String(err?.message || err)}`);
                    return null;
                }
            };
            ux3ModuleSelectEl?.addEventListener('change', () => {
                relayUx3State.selectedModuleId = String(ux3ModuleSelectEl.value || '');
                renderUx3Panel(relayUx3State.selectedModuleId);
            });
            document.getElementById('ux3RefreshBtn')?.addEventListener('click', () => {
                renderUx3Panel(relayUx3State.selectedModuleId);
            });
            document.getElementById('ux3ProposeBtn')?.addEventListener('click', () => {
                const cfg = parseEditorConfig();
                if (!cfg) return;
                relayUx3ProposeConfigEdit({ config: cfg }, { uiSource: 'ux3-panel' });
            });
            document.getElementById('ux3CommitBtn')?.addEventListener('click', () => {
                relayUx3CommitLatest({ uiSource: 'ux3-panel' });
            });
        };
        const getDefaultVoteVoters = () => ([
            { id: 'user.manager1', scope: 'zone.avgol.ops', role: 'manager', authorityRef: 'policy.governance.v2' },
            { id: 'user.steward1', scope: 'zone.avgol.ops', role: 'steward', authorityRef: 'policy.governance.v2' },
            { id: 'user.finance1', scope: 'zone.avgol.ops', role: 'finance', authorityRef: 'policy.governance.v2' },
            { id: 'user.viewer1', scope: 'zone.avgol.ops', role: 'viewer', authorityRef: 'policy.governance.v2' }
        ]);
        const getDefaultVoteTopics = () => ([
            {
                id: 'topic.hud.params.v0',
                title: 'HUD Params v0 Activation',
                type: 'presentation',
                policyRef: 'local:HUD-PARAMS-v0',
                scope: 'zone.avgol.ops',
                cadence: 'event',
                state: 'DRAFT'
            },
            {
                id: 'topic.boundary.approval.v0',
                title: 'Boundary Approval Chain',
                type: 'governance',
                scope: 'zone.avgol.ops',
                cadence: 'weekly',
                requiredRoles: ['manager', 'steward', 'finance'],
                authorityRefs: ['policy.governance.v2'],
                state: 'DRAFT'
            }
        ]);
        const setVoteStatus = (text) => {
            if (voteStatusLineEl) voteStatusLineEl.textContent = String(text || 'idle');
        };
        const renderVoteLane = () => {
            if (!voteLaneListEl || !votingUiManager) return;
            const rows = votingUiManager.getLane();
            voteLaneListEl.innerHTML = rows.map((row) => `
                <div class="vote-lane-topic ${String(votingUiManager?.selectedTopicId || '') === row.id ? 'selected' : ''}" data-vote-topic-id="${row.id}">
                    <div class="vote-topic-title">${row.title}</div>
                    <div class="vote-topic-meta">
                        type=${row.type}<br>
                        state=${row.state}<br>
                        support=${(Number(row.supportPct || 0) * 100).toFixed(1)}%<br>
                        quorum=${(Number(row.quorumPct || 0) * 100).toFixed(1)}% / ${(Number(row.quorumThreshold || 0) * 100).toFixed(1)}%
                    </div>
                </div>
            `).join('');
        };
        const renderVotePanel = () => {
            if (!votePanelBodyEl || !votingUiManager) return;
            const state = votingUiManager.getSelectedPanelState();
            if (!state?.ok) {
                votePanelBodyEl.textContent = 'No topic selected.';
                return;
            }
            votePanelBodyEl.innerHTML = `
                <div class="vote-panel-row"><b>Topic:</b> ${state.topic.title}</div>
                <div class="vote-panel-row"><b>Type:</b> ${state.topic.type}</div>
                <div class="vote-panel-row"><b>State:</b> ${state.topic.state}</div>
                <div class="vote-panel-row"><b>Eligibility:</b> ${state.eligibility.frozen ? 'FROZEN' : 'NOT_FROZEN'} (${state.eligibility.voterCount})</div>
                <div class="vote-panel-row"><b>Quorum:</b> ${(Number(state.quorum.current || 0) * 100).toFixed(1)}% / ${(Number(state.quorum.required || 0) * 100).toFixed(1)}%</div>
                <div class="vote-panel-row"><b>Support:</b> ${(Number(state.vote.supportPct || 0) * 100).toFixed(1)}% (${state.vote.support}/${state.vote.total})</div>
                <div class="vote-panel-row"><b>Time Remaining:</b> ${Math.max(0, Number(state.timeRemainingSec || 0))}s</div>
            `;
        };
        const renderVoteUi = () => {
            renderVoteLane();
            renderVotePanel();
        };
        const relayVoteUiSeedTopics = (topics = null) => {
            if (!votingUiManager) return { ok: false, reason: 'VOTE_UI_NOT_INITIALIZED' };
            const rows = Array.isArray(topics) && topics.length ? topics : getDefaultVoteTopics();
            const seeded = votingUiManager.reset(rows);
            renderVoteUi();
            return seeded;
        };
        const relayVoteUiSelectTopic = async (topicId) => {
            if (!votingUiManager) return { ok: false, reason: 'VOTE_UI_NOT_INITIALIZED' };
            const selected = votingUiManager.selectTopic(topicId);
            if (!selected.ok) return selected;
            renderVoteUi();
            const topic = votingUiManager.getTopicById(topicId);
            // On topic selection, open inspector and attempt focus handoff without mutating governance state.
            const inspector = document.getElementById('matchInspector');
            const content = document.getElementById('matchInspectorContent');
            if (inspector && content && topic) {
                inspector.style.display = 'block';
                content.innerHTML = `
                    <div style="margin-bottom:6px;"><b>Vote Topic</b>: ${topic.title}</div>
                    <div>type=${topic.type}</div>
                    <div>scope=${topic.scope || 'n/a'}</div>
                    <div>policyRef=${topic.policyRef || 'n/a'}</div>
                `;
            }
            const firstBranch = (relayState?.tree?.nodes || []).find((n) => n.type === 'branch');
            if (firstBranch) {
                try {
                    await window.relayEnterFocus({ type: 'branch', id: firstBranch.id });
                } catch {
                    // fail-soft: topic selection should not break voting UI
                }
            }
            return { ok: true, topicId };
        };
        const relayVoteUiStartTopic = (topicId, opts = {}) => {
            if (!votingUiManager) return { ok: false, reason: 'VOTE_UI_NOT_INITIALIZED' };
            const voters = Array.isArray(opts.voters) ? opts.voters : getDefaultVoteVoters();
            const started = votingUiManager.startTopic(topicId, {
                voters,
                frozenAt: String(opts.frozenAt || new Date().toISOString())
            });
            renderVoteUi();
            return started;
        };
        const relayVoteUiCast = (payload = {}) => {
            if (!votingUiManager) return { ok: false, reason: 'VOTE_UI_NOT_INITIALIZED' };
            const topicId = String(payload.topicId || votingUiManager.selectedTopicId || '');
            const before = (votingUiManager.getRawState().ballots || []).length;
            const result = votingUiManager.castVote({
                topicId,
                voterId: String(payload.voterId || relayVoteUiState.currentVoterId),
                decision: String(payload.decision || ''),
                role: String(payload.role || relayVoteUiState.currentRole),
                authorityRef: String(payload.authorityRef || relayVoteUiState.currentAuthorityRef),
                scope: String(payload.scope || relayVoteUiState.currentScope)
            });
            const after = (votingUiManager.getRawState().ballots || []).length;
            if (!result.ok && after !== before) {
                RelayLog.warn('[REFUSAL] reason=VOTE-A2_SCOPE_VIOLATION');
                return { ok: false, reason: 'VOTE-A2_SCOPE_VIOLATION' };
            }
            renderVoteUi();
            return result;
        };
        const relayVoteUiCloseGovernance = (topicId, opts = {}) => {
            if (!votingUiManager) return { ok: false, reason: 'VOTE_UI_NOT_INITIALIZED' };
            const closed = votingUiManager.closeGovernanceTopic(topicId, {
                commitId: String(opts.commitId || '')
            });
            renderVoteUi();
            return closed;
        };

        // ‚ïê‚ïê‚ïê VOTE-COMMIT-PERSISTENCE-1 (Phase 6): Vote Store Persistence ‚ïê‚ïê‚ïê
        const RELAY_VOTE_STORE_KEY = 'RELAY_VOTE_STORE_V0';

        const persistVoteStore = () => {
            try {
                const branches = (relayState?.tree?.nodes || []).filter(n => n.type === 'branch');
                const store = {};
                branches.forEach(b => { store[b.id] = b.voteStatus || 'NONE'; });
                localStorage.setItem(RELAY_VOTE_STORE_KEY, JSON.stringify(store));
                const count = Object.keys(store).length;
                const line = `[VOTE] persist backend=localStorage mode=demo stored=${count} result=PASS`;
                RelayLog.info(line);
                console.log(line);
            } catch (e) {
                RelayLog.warn('[VOTE] persist failed:', e);
            }
        };

        const restoreVoteStore = () => {
            try {
                const raw = localStorage.getItem(RELAY_VOTE_STORE_KEY);
                if (!raw) {
                    const line = '[VOTE] restore backend=localStorage mode=demo loaded=0 result=PASS';
                    RelayLog.info(line);
                    console.log(line);
                    return;
                }
                const store = JSON.parse(raw);
                const count = Object.keys(store).length;
                const branches = (relayState?.tree?.nodes || []).filter(n => n.type === 'branch');
                branches.forEach(b => {
                    if (store[b.id]) b.voteStatus = store[b.id];
                });
                const line = `[VOTE] restore backend=localStorage mode=demo loaded=${count} result=PASS`;
                RelayLog.info(line);
                console.log(line);
            } catch (e) {
                RelayLog.warn('[VOTE] restore failed:', e);
            }
        };

        const applyGovernanceDecisionToBranch = (branchId, topicState, evaluation) => {
            const branch = (relayState?.tree?.nodes || []).find(n => n.id === branchId);
            if (!branch) return;
            let result;
            if (topicState === 'PASS' || topicState === 'COMMIT') {
                result = 'PASSED';
            } else if (topicState === 'FAIL' || topicState === 'VETO' || topicState === 'REFUSAL') {
                result = 'REJECTED';
            } else {
                result = 'PENDING';
            }
            branch.voteStatus = result;
            const quorumPct = evaluation?.participated
                ? (evaluation.participated / Math.max(1, evaluation.eligibleCount))
                : 0;
            const line = `[VOTE] decision branch=${branchId} result=${result} lifecycle=${topicState} quorum=${(quorumPct * 100).toFixed(0)}`;
            RelayLog.info(line);
            console.log(line);
            persistVoteStore();
            // Force vote filter re-evaluation and re-render
            if (window.filamentRenderer) {
                window.filamentRenderer._voteFilterSig = null;
                // Reset scar dedup for this branch so renderer can re-emit log
                if (window.filamentRenderer._voteScarLoggedSet) {
                    window.filamentRenderer._voteScarLoggedSet.delete(branchId);
                }
            }
            // Emit scar log immediately for rejected branches (renderer also emits on next COMPANY LOD frame)
            if (result === 'REJECTED') {
                const scarLine = `[SCAR] applied branch=${branchId} reason=voteRejected result=PASS`;
                RelayLog.info(scarLine);
                console.log(scarLine);
            }
            updateHudVoteSummary();
        };

        const updateHudVoteSummary = () => {
            const branches = (relayState?.tree?.nodes || []).filter(n => n.type === 'branch');
            const passed = branches.filter(b => b.voteStatus === 'PASSED').length;
            const pending = branches.filter(b => b.voteStatus === 'PENDING').length;
            const rejected = branches.filter(b => b.voteStatus === 'REJECTED').length;
            if (typeof hudManager !== 'undefined' && hudManager) {
                hudManager.update({ voteSummary: `${passed} PASSED / ${pending} PENDING / ${rejected} REJECTED` });
            }
            const line = `[HUD] votes summary=PASS passed=${passed} pending=${pending} rejected=${rejected}`;
            RelayLog.info(line);
            console.log(line);
        };

        window.relaySimulateGovernanceDecision = (branchId, targetOutcome) => {
            if (!votingUiManager) return { ok: false, reason: 'VOTE_UI_NOT_INITIALIZED' };
            const topicId = `topic.vote6.${branchId}`;
            const voters = getDefaultVoteVoters();
            // Add governance topic for this branch if not already present
            if (!votingUiManager.getTopicById(topicId)) {
                votingUiManager.topics.push({
                    id: topicId,
                    title: `Phase 6 Vote: ${branchId}`,
                    type: 'governance',
                    policyRef: '',
                    scope: 'zone.avgol.ops',
                    cadence: 'weekly',
                    quorumOverride: null,
                    state: 'DRAFT',
                    topicRef: null,
                    requiredRoles: [],
                    authorityRefs: [],
                    runtime: null
                });
            }
            // Start topic with eligible voters
            const started = votingUiManager.startTopic(topicId, { voters });
            if (!started.ok) return started;
            // Cast votes deterministically
            if (targetOutcome === 'PASSED') {
                voters.forEach(v => {
                    votingUiManager.castVote({ topicId, voterId: v.id, decision: 'APPROVE', role: v.role });
                });
            } else {
                voters.forEach(v => {
                    votingUiManager.castVote({ topicId, voterId: v.id, decision: 'REJECT', role: v.role });
                });
            }
            // Close governance topic through lifecycle runner path
            const closed = votingUiManager.closeGovernanceTopic(topicId, { commitId: `commit-${topicId}` });
            // Map lifecycle outcome ‚Üí branch voteStatus
            if (closed.ok) {
                applyGovernanceDecisionToBranch(branchId, closed.state, closed.evaluation);
            }
            renderVoteUi();
            return closed;
        };
        // ‚ïê‚ïê‚ïê END VOTE-COMMIT-PERSISTENCE-1 persistence/decision wiring ‚ïê‚ïê‚ïê

        const bindVoteUiEvents = () => {
            voteLaneListEl?.addEventListener('click', (event) => {
                const row = event.target.closest?.('[data-vote-topic-id]');
                if (!row) return;
                relayVoteUiSelectTopic(row.getAttribute('data-vote-topic-id'));
            });
            voteApproveBtnEl?.addEventListener('click', () => {
                const result = relayVoteUiCast({ decision: 'APPROVE' });
                setVoteStatus(result.ok ? 'approve cast' : `refusal: ${result.reason}`);
            });
            voteRejectBtnEl?.addEventListener('click', () => {
                const result = relayVoteUiCast({ decision: 'REJECT' });
                setVoteStatus(result.ok ? 'reject cast' : `refusal: ${result.reason}`);
            });
        };
        window.relayVoteUiSeedTopics = (topics = null) => relayVoteUiSeedTopics(topics);
        window.relayVoteUiGetLane = () => (votingUiManager ? votingUiManager.getLane() : []);
        window.relayVoteUiSelectTopic = (topicId) => relayVoteUiSelectTopic(topicId);
        window.relayVoteUiStartTopic = (topicId, opts = {}) => relayVoteUiStartTopic(topicId, opts);
        window.relayVoteUiCast = (payload = {}) => relayVoteUiCast(payload);
        window.relayVoteUiCloseGovernance = (topicId, opts = {}) => relayVoteUiCloseGovernance(topicId, opts);
        window.relayVoteUiGetPanelState = () => (votingUiManager ? votingUiManager.getSelectedPanelState() : { ok: false, reason: 'VOTE_UI_NOT_INITIALIZED' });
        window.relayVoteUiGetRawState = () => (votingUiManager ? votingUiManager.getRawState() : { topics: [], ballots: [], selectedTopicId: null });
        window.relayVoteUiDeterminismDigest = () => (votingUiManager ? votingUiManager.getDeterminismDigest() : '0x00000000');
        // VOTE-COMMIT-PERSISTENCE-1: Expose vote persistence functions for proof
        window.updateHudVoteSummary = () => updateHudVoteSummary();
        window.persistVoteStore = () => persistVoteStore();
        window.restoreVoteStore = () => restoreVoteStore();
        const renderWorkModeSurface = () => {
            if (!workModeSurfaceEl) return;
            workModeSurfaceEl.classList.remove('mode-draft', 'mode-hold', 'mode-propose', 'mode-commit');
            workModeSurfaceEl.classList.add(`mode-${relayWorkState.mode.toLowerCase()}`);
            const snapSuffix = (relayWorkState.mode === 'HOLD' || relayWorkState.mode === 'PROPOSE')
                ? ` | SNAP#${window.__relaySnapshots.length}`
                : '';
            const proposalSuffix = (relayWorkState.mode === 'PROPOSE' && relayWorkState.currentProposalId)
                ? ` | PROPOSAL ${relayWorkState.currentProposalId}`
                : '';
            const commitSuffix = (relayWorkState.mode === 'COMMIT' && relayWorkState.currentCommitId)
                ? ` | RECEIPT ${relayWorkState.currentCommitId}`
                : '';
            workModeSurfaceEl.textContent = `MODE ${relayWorkState.mode} | ${relayWorkState.zone}${snapSuffix}${proposalSuffix}${commitSuffix}`;
            workModeSurfaceEl.title = `user=${relayWorkState.user} target=${relayWorkState.target}`;
        };
        const setRelayWorkMode = (mode, meta = {}) => {
            const nextMode = String(mode || '').toUpperCase();
            if (!RELAY_WORK_MODES.has(nextMode)) {
                RelayLog.warn(`[Z] refusal invalid mode=${mode}`);
                return false;
            }
            const previous = relayWorkState.mode;
            const allowDirectPropose = meta.allowDirectPropose === true || window.RELAY_ALLOW_DIRECT_PROPOSE === true;
            const legalTransition = (() => {
                if (previous === nextMode) return true;
                if (previous === 'DRAFT' && nextMode === 'HOLD') return true;
                if (previous === 'HOLD' && nextMode === 'PROPOSE') return true;
                if (previous === 'PROPOSE' && nextMode === 'HOLD' && String(meta.reason || '') === 'MATCH_GATE_FAIL') return true;
                if (previous === 'PROPOSE' && nextMode === 'COMMIT') return true;
                if (previous === 'COMMIT' && nextMode === 'DRAFT') return true;
                if (previous === 'DRAFT' && nextMode === 'PROPOSE' && allowDirectPropose) return true;
                return false;
            })();
            if (!legalTransition) {
                RelayLog.warn(`[REFUSAL] modeTransition from=${previous} to=${nextMode} reason=ILLEGAL_TRANSITION`);
                return false;
            }
            const nextTargetBinding = resolveTargetBinding(meta);
            const requiresTarget = (nextMode === 'HOLD' || nextMode === 'PROPOSE' || nextMode === 'COMMIT');
            if (requiresTarget && !nextTargetBinding) {
                RelayLog.warn('[REFUSAL] artifactMissingTarget reason=NO_TARGET_IN_CONTEXT');
                return false;
            }
            const nextUser = String(meta.user || relayWorkState.user || 'local');
            const nextZone = String(meta.zone || relayWorkState.zone || 'zone.avgol.ops');
            const nextTarget = String(nextTargetBinding?.objectId || meta.target || relayWorkState.target || 'none');
            let commitTransferPacket = null;
            let commitResponsibilityPackets = [];
            let proposalPayload = null;
            if (nextMode === 'PROPOSE') {
                const proposalId = String(meta.proposalId || nextArtifactId('PROPOSAL'));
                const summary = String(meta.summary || '').trim();
                const changesetRef = String(meta.changesetRef || '').trim();
                if (!summary || !changesetRef) {
                    RelayLog.warn(`[Z] refusal mode=PROPOSE reason=MISSING_PROPOSAL_FIELDS target=${nextTarget}`);
                    return false;
                }
                proposalPayload = {
                    proposalId,
                    summary: summary.slice(0, 240),
                    changesetRef: changesetRef.slice(0, 240)
                };
            }
            const commitProposalId = String(meta.proposalId || relayWorkState.currentProposalId || '');
            const commitEvidenceHash = String(meta.evidenceHash || relayWorkState.currentProposalEvidenceHash || '');
            if (nextMode === 'COMMIT') {
                if (!commitProposalId || !commitEvidenceHash) {
                    RelayLog.warn(`[Z] refusal mode=COMMIT reason=MISSING_PROPOSAL_LINK target=${nextTarget}`);
                    return false;
                }
                if (RELAY_PROFILE === 'world' && restore3ScopeManager) {
                    const scopeGuard = restore3ScopeManager.assertCommitScope(nextTargetBinding);
                    if (!scopeGuard.ok) {
                        RelayLog.warn(`[REFUSAL] reason=GOV_SCOPE_VIOLATION proposalScope=${scopeGuard.proposalScope} selectedScope=${scopeGuard.selectedScope}`);
                        return false;
                    }
                }
                const enforceMatchGate = meta.enforceMatchGate === true || String(meta.postingKind || '') === 'invoice';
                if (enforceMatchGate && nextTargetBinding?.targetRef?.type === 'match') {
                    const status = getMatchStatusForBinding(nextTargetBinding);
                    const matchPass = new Set(['MATCH', 'MATCHED', 'RESOLVED']);
                    if (!matchPass.has(status)) {
                        const resolutionPath = String(meta.resolutionPath || '').toLowerCase();
                        const variancePath = resolutionPath === 'variance';
                        const correctionPath = resolutionPath === 'correction';
                        const varianceAllowed = variancePath && hasVarianceLeg(meta.transferPacket);
                        if (variancePath && !varianceAllowed) {
                            RelayLog.warn(`[REFUSAL] reason=MATCH_GATE_FAIL_VARIANCE_PACKET_MISSING objectId=${nextTargetBinding.objectId} status=${status || 'UNKNOWN'}`);
                            setRelayWorkMode('HOLD', {
                                targetRef: nextTargetBinding.targetRef,
                                user: nextUser,
                                zone: nextZone,
                                reason: 'MATCH_GATE_FAIL',
                                forceSnapshot: true
                            });
                            return false;
                        }
                        if (correctionPath) {
                            RelayLog.warn(`[REFUSAL] reason=MATCH_GATE_FAIL_CORRECTION_REQUIRED objectId=${nextTargetBinding.objectId} status=${status || 'UNKNOWN'}`);
                            setRelayWorkMode('HOLD', {
                                targetRef: nextTargetBinding.targetRef,
                                user: nextUser,
                                zone: nextZone,
                                reason: 'MATCH_GATE_FAIL',
                                forceSnapshot: true
                            });
                            return false;
                        }
                        if (!varianceAllowed) {
                            RelayLog.warn(`[REFUSAL] reason=MATCH_GATE_FAIL objectId=${nextTargetBinding.objectId} status=${status || 'UNKNOWN'}`);
                            setRelayWorkMode('HOLD', {
                                targetRef: nextTargetBinding.targetRef,
                                user: nextUser,
                                zone: nextZone,
                                reason: 'MATCH_GATE_FAIL',
                                forceSnapshot: true
                            });
                            return false;
                        }
                        RelayLog.info(`[AC0] match-gate resolutionPath=variance objectId=${nextTargetBinding.objectId} status=${status || 'UNKNOWN'} result=ALLOW_WITH_VARIANCE`);
                    } else {
                        RelayLog.info(`[AC0] match-gate objectId=${nextTargetBinding.objectId} status=${status} result=PASS`);
                    }
                    if (!matchPass.has(status) && !hasVarianceLeg(meta.transferPacket)) {
                        setRelayWorkMode('HOLD', {
                            targetRef: nextTargetBinding.targetRef,
                            user: nextUser,
                            zone: nextZone,
                            reason: 'MATCH_GATE_FAIL',
                            forceSnapshot: true
                        });
                        return false;
                    }
                }
                const material = (meta.materialEffects && typeof meta.materialEffects === 'object') ? meta.materialEffects : {};
                const requiresTransferPacket = !!meta.transferPacket || material.financial === true || material.inventory === true || typeof meta.postingKind === 'string';
                if (requiresTransferPacket) {
                    const transferValidation = validateTransferPacket(meta.transferPacket, {
                        proposalId: commitProposalId,
                        objectId: nextTargetBinding?.objectId || nextTarget,
                        reasonCode: meta.reasonCode || meta.postingKind || 'COMMIT'
                    });
                    if (!transferValidation.ok) {
                        RelayLog.warn(`[REFUSAL] reason=${transferValidation.reason.includes('UNBALANCED_TRANSFER_PACKET') ? 'UNBALANCED_TRANSFER_PACKET' : transferValidation.reason} target=${nextTarget}`);
                        return false;
                    }
                    commitTransferPacket = transferValidation.transferPacket;
                    const responsibilityResult = buildResponsibilityPackets(meta, {
                        transferPacketId: commitTransferPacket.transferPacketId,
                        objectId: nextTargetBinding?.objectId || nextTarget,
                        user: nextUser,
                        authorityRef: meta.authorityRef || null
                    });
                    if (!responsibilityResult.ok) {
                        RelayLog.warn(`[REFUSAL] reason=${responsibilityResult.reason} target=${nextTarget}`);
                        return false;
                    }
                    commitResponsibilityPackets = responsibilityResult.responsibilityPackets;
                }
            }
            relayWorkState.mode = nextMode;
            relayWorkState.user = nextUser;
            relayWorkState.zone = nextZone;
            relayWorkState.target = nextTarget;
            relayWorkState.objectId = nextTargetBinding?.objectId || null;
            relayWorkState.targetRef = nextTargetBinding?.targetRef ? { ...nextTargetBinding.targetRef } : null;
            relayWorkState.scopeRef = nextTargetBinding?.scopeRef ? { ...nextTargetBinding.scopeRef } : null;
            relayWorkState.updatedAtMs = Date.now();
            renderWorkModeSurface();
            RelayLog.info(`[Z] mode=${relayWorkState.mode} user=${relayWorkState.user} target=${relayWorkState.target} previous=${previous}`);
            let shouldRefreshModeSurface = false;
            const forceSnapshot = meta.forceSnapshot === true;
            if ((previous === 'DRAFT' || previous === nextMode) && nextMode === 'HOLD' && forceSnapshot) {
                createModeSnapshot('HOLD', previous, nextMode, nextTargetBinding, { delta: meta.deltaSummary || null });
                shouldRefreshModeSurface = true;
            } else if (previous === 'DRAFT' && nextMode === 'HOLD') {
                createModeSnapshot('HOLD', previous, nextMode, nextTargetBinding, { delta: meta.deltaSummary || null });
                shouldRefreshModeSurface = true;
            } else if ((previous !== nextMode || forceSnapshot) && nextMode === 'PROPOSE') {
                const proposalSnapshot = createModeSnapshot('PROPOSE', previous, nextMode, nextTargetBinding, { proposal: proposalPayload, action: meta.action || null });
                relayWorkState.currentProposalId = proposalPayload.proposalId;
                relayWorkState.currentProposalEvidenceHash = proposalSnapshot.evidenceHash;
                relayWorkState.currentCommitId = null;
                shouldRefreshModeSurface = true;
            } else if (previous !== nextMode && nextMode === 'COMMIT') {
                const receipt = createCommitReceipt(
                    commitProposalId,
                    commitEvidenceHash,
                    previous,
                    nextMode,
                    {
                        transferPacketId: commitTransferPacket?.transferPacketId || null,
                        responsibilityPacketIds: (commitResponsibilityPackets || []).map(p => p.responsibilityPacketId)
                    }
                );
                if (commitTransferPacket && receipt?.commitId) {
                    commitTransferPacket.commitId = receipt.commitId;
                    window.__relayTransferPackets.push(commitTransferPacket);
                    const packets = Array.isArray(commitResponsibilityPackets) ? commitResponsibilityPackets : [];
                    for (const rp of packets) {
                        rp.commitId = receipt.commitId;
                        window.__relayResponsibilityPackets.push(rp);
                    }
                    RelayLog.info(`[AC0] transfer commitId=${receipt.commitId} transferPacketId=${commitTransferPacket.transferPacketId} legs=${commitTransferPacket.legs.length}`);
                    RelayLog.info(`[AC0] responsibility commitId=${receipt.commitId} packets=${packets.length} linkedTransferPacketId=${commitTransferPacket.transferPacketId}`);
                }
                shouldRefreshModeSurface = true;
            }
            if (shouldRefreshModeSurface) {
                renderWorkModeSurface();
            }
            renderArtifactInspector();
            return true;
        };
        const relayInvokeAction = (actionId, meta = {}) => {
            const action = String(actionId || '').trim();
            if (!action) return { ok: false, reason: 'MISSING_ACTION_ID' };
            const uiSource = String(meta.uiSource || 'api');
            const targetBinding = resolveTargetBinding(meta);
            const targetRef = targetBinding?.targetRef || null;
            const objectId = targetBinding?.objectId || null;
            const contract = targetBinding?.contract || null;
            const user = String(meta.user || relayWorkState.user || 'local');
            const zone = String(meta.zone || relayWorkState.zone || 'zone.avgol.ops');

            const artifactActions = new Set(['markResolved', 'setTolerance']);
            if (artifactActions.has(action)) {
                if (!targetBinding) {
                    RelayLog.warn('[REFUSAL] artifactMissingTarget reason=NO_TARGET_IN_CONTEXT');
                    return { ok: false, reason: 'NO_TARGET_IN_CONTEXT' };
                }
                const params = (meta.params && typeof meta.params === 'object') ? meta.params : {};
                const actionResult = applyActionToModel(action, targetBinding, params);
                if (!actionResult.ok) {
                    RelayLog.warn(`[REFUSAL] actionInvoke actionId=${action} objectId=${objectId || 'none'} reason=${actionResult.reason}`);
                    return { ok: false, reason: actionResult.reason };
                }
                const summary = String(meta.summary || `Action ${action} on ${contract?.label || objectId}`).slice(0, 240);
                const changesetRef = String(meta.changesetRef || `ACT:${action}:${Date.now()}`).slice(0, 240);
                const proposed = setRelayWorkMode('PROPOSE', {
                    targetRef,
                    summary,
                    changesetRef,
                    user,
                    zone,
                    allowDirectPropose: true,
                    forceSnapshot: true,
                    action: {
                        actionId: action,
                        params,
                        uiSource
                    }
                });
                if (!proposed) return { ok: false, reason: 'PROPOSE_FAILED' };
                const proposalId = relayWorkState.currentProposalId;
                RelayLog.info(`[ACT] propose actionId=${action} objectId=${objectId} proposalId=${proposalId}`);

                const autoCommitEnabled = window.RELAY_AUTO_COMMIT_ACTIONS === true;
                const allowlist = Array.isArray(window.RELAY_AUTO_COMMIT_ALLOWLIST) ? window.RELAY_AUTO_COMMIT_ALLOWLIST.map(String) : [];
                const autoCommitAllowed = autoCommitEnabled && allowlist.includes(action);
                let commitId = null;
                if (autoCommitAllowed) {
                    const committed = setRelayWorkMode('COMMIT', {
                        proposalId,
                        targetRef,
                        user,
                        zone
                    });
                    if (committed) {
                        commitId = relayWorkState.currentCommitId;
                        RelayLog.info(`[ACT] commit actionId=${action} commitId=${commitId} proposalId=${proposalId}`);
                    }
                }
                return { ok: true, proposalId, commitId, objectId };
            }

            if (action === 'focusView') {
                if (contract) focusArtifactObject(contract.id);
                return { ok: true };
            }
            if (action === 'cycleClusterLevel') {
                if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
                if (!worldGlobeManager) return { ok: false, reason: 'GLOBE_MANAGER_UNAVAILABLE' };
                const levels = worldGlobeManager.listClusterLevels();
                if (!levels.length) return { ok: false, reason: 'NO_CLUSTER_LEVELS' };
                const current = worldGlobeManager.getState().clusterLevel;
                const currentIdx = Math.max(0, levels.findIndex((lvl) => lvl.id === current));
                const next = levels[(currentIdx + 1) % levels.length];
                return worldGlobeManager.setClusterLevel(next.id);
            }
            if (action === 'focusNextRegion') {
                if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
                if (!worldGlobeManager) return { ok: false, reason: 'GLOBE_MANAGER_UNAVAILABLE' };
                return worldGlobeManager.focusNextRegion();
            }
            if (action === 'loadGlobalCore') {
                if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
                if (!worldGlobeManager) return { ok: false, reason: 'GLOBE_MANAGER_UNAVAILABLE' };
                return worldGlobeManager.loadCountrySet('global-core');
            }
            if (['viewDependencies', 'inspectSources', 'showSchema', 'showKPIs', 'showAllSheets', 'showRoutes', 'showKPIBindings', 'showRecomputationChain', 'showTimeboxes', 'showPressureSources', 'showBranches', 'viewVariance', 'showProvenance'].includes(action)) {
                if (typeof window.showInspector === 'function') {
                    const inspectTarget = contract || (targetRef ? resolveContractForTargetRef(targetRef) : null);
                    if (inspectTarget) window.showInspector(inspectTarget);
                }
                return { ok: true };
            }
            if (action === 'edit') {
                if (isEditSheetMode && sheetSelection) beginEdit();
                return { ok: true };
            }
            if (action === 'previewMapping') {
                if (contract?.type === 'route' && window.relayRoutePreview) {
                    const preview = window.relayRoutePreview(contract.id, {});
                    RelayLog.info('[BUD] route preview:', preview);
                }
                return { ok: true };
            }
            if (action === 'ingestTestRecord') {
                if (contract?.type === 'route' && window.relayIngestRoute) {
                    const mockRecord = generateMockRecord(contract.id);
                    if (mockRecord) {
                        window.relayIngestRoute(contract.id, mockRecord);
                        RelayLog.info(`[BUD] test record ingested for route=${contract.id}`);
                    }
                }
                return { ok: true };
            }
            RelayLog.info(`[BUD] action=${action} not yet dispatched (placeholder)`);
            return { ok: false, reason: 'UNHANDLED_ACTION' };
        };
        window.relayInvokeAction = relayInvokeAction;
        const resolveFocusInputToNodeApi = (targetInput) => {
            const input = (typeof targetInput === 'string') ? { id: targetInput } : (targetInput || {});
            if (String(input.type || '').toLowerCase() === 'match' && input.sheetId && Number.isFinite(Number(input.row))) {
                const node = (relayState?.tree?.nodes || []).find(n => n.id === String(input.sheetId)) || null;
                if (!node) return null;
                const contract = toRelayObject({ sheetId: String(input.sheetId), row: Number(input.row), isMatch: true }, relayState);
                return { node, contract: contract || null };
            }
            if (String(input.type || '').toLowerCase() === 'cell' && input.sheetId && Number.isFinite(Number(input.row)) && Number.isFinite(Number(input.col))) {
                const node = (relayState?.tree?.nodes || []).find(n => n.id === String(input.sheetId)) || null;
                if (!node) return null;
                const contract = toRelayObject({ sheetId: String(input.sheetId), row: Number(input.row), col: Number(input.col) }, relayState);
                return { node, contract: contract || null };
            }
            const targetRef = input?.id ? { id: String(input.id), type: input.type ? String(input.type) : undefined } : input;
            const contract = resolveContractForTargetRef(targetRef);
            if (!contract) return null;
            let node = null;
            if (contract.type === 'trunk' || contract.type === 'branch' || contract.type === 'sheet') {
                node = (relayState?.tree?.nodes || []).find(n => n.id === contract.id) || null;
            } else if ((contract.type === 'cell' || contract.type === 'match') && contract.sheetId) {
                node = (relayState?.tree?.nodes || []).find(n => n.id === contract.sheetId) || null;
            } else if (contract.type === 'route') {
                const route = getRoute(contract.id);
                const sid = route?.targetSheet || null;
                if (sid) node = (relayState?.tree?.nodes || []).find(n => n.id === sid) || null;
            }
            if (!node && input?.id) {
                node = (relayState?.tree?.nodes || []).find(n => n.id === String(input.id)) || null;
            }
            return node ? { node, contract } : null;
        };
        window.relaySetWorkMode = (mode, meta = {}) => setRelayWorkMode(mode, meta);
        window.relayGetWorkMode = () => ({ ...relayWorkState });
        const emitVisEntryLog = (line) => {
            RelayLog.info(line);
            console.log(line);
        };
        const relaySetEntryState = (patch = {}) => {
            if (!window.__relayEntryState || typeof window.__relayEntryState !== 'object') {
                window.__relayEntryState = { scope: 'world', companyId: null, deptId: null, sheetId: null, lastView: null };
            }
            Object.assign(window.__relayEntryState, patch);
            return { ...window.__relayEntryState };
        };
        const resolveVisSheetSelection = (sheetIdInput = null) => {
            const nodes = Array.isArray(relayState?.tree?.nodes) ? relayState.tree.nodes : [];
            const sheets = nodes.filter((n) => String(n?.type || '').toLowerCase() === 'sheet');
            if (sheets.length === 0) return { ok: false, reason: 'VIS_NO_SHEETS_AVAILABLE' };
            const sheetsSorted = sheets.slice().sort((a, b) => String(a.id || '').localeCompare(String(b.id || '')));
            const pickById = (sid) => sheetsSorted.find((s) => String(s?.id || '') === String(sid || '')) || null;

            const explicitId = String(sheetIdInput || '').trim();
            if (explicitId) {
                const explicitNode = pickById(explicitId);
                if (!explicitNode) return { ok: false, reason: 'VIS_SHEET_TARGET_UNRESOLVED' };
                return { ok: true, node: explicitNode, sheetId: String(explicitNode.id), reason: 'explicit' };
            }

            const lastSelectedId = String(window.__relayEntryState?.sheetId || '').trim();
            if (lastSelectedId) {
                const lastSelectedNode = pickById(lastSelectedId);
                if (lastSelectedNode) {
                    return { ok: true, node: lastSelectedNode, sheetId: String(lastSelectedNode.id), reason: 'lastSelected' };
                }
            }

            const deptId = String(window.__relayEntryState?.deptId || '').trim();
            if (deptId) {
                const deptSheet = sheetsSorted.find((s) => String(s?.parent || '') === deptId) || null;
                if (deptSheet) return { ok: true, node: deptSheet, sheetId: String(deptSheet.id), reason: 'default' };
            }

            const companyId = String(window.__relayEntryState?.companyId || '').trim();
            if (companyId) {
                const branchIds = new Set(nodes
                    .filter((n) => String(n?.type || '').toLowerCase() === 'branch' && String(n?.parent || '') === companyId)
                    .map((n) => String(n.id || '')));
                if (branchIds.size > 0) {
                    const companySheet = sheetsSorted.find((s) => branchIds.has(String(s?.parent || ''))) || null;
                    if (companySheet) return { ok: true, node: companySheet, sheetId: String(companySheet.id), reason: 'default' };
                }
            }

            const activeSheetName = String(relayState?.metadata?.activeSheet || '').trim();
            if (activeSheetName) {
                const activeSheetNode = sheetsSorted.find((s) => String(s?.name || s?.metadata?.sheetName || '') === activeSheetName) || null;
                if (activeSheetNode) return { ok: true, node: activeSheetNode, sheetId: String(activeSheetNode.id), reason: 'default' };
            }

            const fallbackNode = sheetsSorted[0] || null;
            if (!fallbackNode) return { ok: false, reason: 'VIS_SHEET_TARGET_UNRESOLVED' };
            return { ok: true, node: fallbackNode, sheetId: String(fallbackNode.id), reason: 'default' };
        };
        window.relayResolveSheetSelection = (sheetIdInput = null) => {
            const resolved = resolveVisSheetSelection(sheetIdInput);
            if (!resolved?.ok) return resolved;
            const node = resolved.node;
            const deptId = node?.parent ? String(node.parent) : (window.__relayEntryState?.deptId || null);
            const deptNode = deptId ? (relayState?.tree?.nodes || []).find((n) => String(n?.id || '') === deptId) : null;
            const companyId = deptNode?.parent ? String(deptNode.parent) : (window.__relayEntryState?.companyId || null);
            const state = relaySetEntryState({
                companyId,
                deptId,
                sheetId: String(resolved.sheetId)
            });
            const sig = `${resolved.sheetId}|${resolved.reason}`;
            if (window.__relayVisSheetSelectLogSig !== sig) {
                emitVisEntryLog(`[VIS] sheetSelect resolved sheet=${resolved.sheetId} reason=${resolved.reason}`);
                window.__relayVisSheetSelectLogSig = sig;
            }
            return { ok: true, sheetId: String(resolved.sheetId), reason: resolved.reason, state };
        };
        window.relayEnterCompany = (companyIdOrTrunkId) => {
            const companyId = String(companyIdOrTrunkId || '').trim();
            if (!companyId) return { ok: false, reason: 'VIS_COMPANY_ID_REQUIRED' };
            const state = relaySetEntryState({
                scope: 'company',
                companyId,
                deptId: null,
                sheetId: null
            });
            emitVisEntryLog(`[VIS] enter company=${companyId}`);
            return { ok: true, state };
        };
        window.relayExitCompany = () => {
            const companyId = String(window.__relayEntryState?.companyId || 'none');
            const state = relaySetEntryState({
                scope: 'world',
                companyId: null,
                deptId: null,
                sheetId: null
            });
            emitVisEntryLog(`[VIS] exit company=${companyId} restoreView=true`);
            return { ok: true, state };
        };
        window.relayEnterDepartment = (branchId) => {
            const deptId = String(branchId || '').trim();
            if (!deptId) return { ok: false, reason: 'VIS_DEPT_ID_REQUIRED' };
            const branchNode = (relayState?.tree?.nodes || []).find((n) => String(n?.id || '') === deptId);
            const parentCompanyId = branchNode?.parent ? String(branchNode.parent) : (window.__relayEntryState?.companyId || null);
            const state = relaySetEntryState({
                scope: 'department',
                companyId: parentCompanyId,
                deptId,
                sheetId: null
            });
            emitVisEntryLog(`[VIS] enter dept=${deptId}`);
            return { ok: true, state };
        };
        window.relayExitDepartment = () => {
            const deptId = String(window.__relayEntryState?.deptId || 'none');
            const state = relaySetEntryState({
                scope: window.__relayEntryState?.companyId ? 'company' : 'world',
                deptId: null,
                sheetId: null
            });
            emitVisEntryLog(`[VIS] exit dept=${deptId} restoreView=true`);
            return { ok: true, state };
        };
        window.relayEnterSheet = (sheetIdInput) => {
            const selection = window.relayResolveSheetSelection(sheetIdInput);
            if (!selection?.ok) return selection;
            const sheetId = String(selection.sheetId);
            const deptId = String(selection.state?.deptId || window.__relayEntryState?.deptId || '') || null;
            const companyId = String(selection.state?.companyId || window.__relayEntryState?.companyId || '') || null;
            const state = relaySetEntryState({
                scope: 'sheet',
                companyId,
                deptId,
                sheetId
            });
            emitVisEntryLog(`[VIS] enter sheet=${sheetId} scope=sheet-only`);

            // LAUNCH-FIX-1: Face-on dock on sheet enter (clarity micro-batch)
            // After setting scope, dock camera face-on to the sheet and show a
            // minimal 2D grid overlay so the user sees an immediate response.
            // LAUNCH-FIX-1b: Mark explicit enter active to suppress auto-dock conflict
            window._relayExplicitEnterActive = true;
            window._r0AutoDockSuppressLogged = false;
            const sheetObj = (relayState?.tree?.nodes || []).find(
                n => n.type === 'sheet' && (n.id === sheetId || n.name === sheetId)
            );
            if (sheetObj && sheetObj._center && typeof window.setCompanyTopDownView === 'function') {
                const camPos = window.viewer?.camera?.position;
                const distM = camPos && sheetObj._center
                    ? Cesium.Cartesian3.distance(camPos, sheetObj._center)
                    : NaN;
                const launchInstant = window.RELAY_LAUNCH_MODE === true;
                RelayLog.info(`[DOCK] enterSheet target=${sheetId} mode=FaceOn result=PASS distM=${Number.isFinite(distM) ? distM.toFixed(0) : '?'}`);
                window.setCompanyTopDownView(sheetObj, {
                    duration: launchInstant ? 0 : 1.5,
                    onDocked: () => {
                        RelayLog.info(`[CAM] dockFaceOn applied=PASS sheet=${sheetId}`);
                        // Show minimal 2D grid overlay if available
                        try {
                            if (typeof window._relayShowMinimalGrid === 'function') {
                                window._relayShowMinimalGrid(sheetObj);
                            } else {
                                console.log(`[2D] gridShown sheet=${sheetId} rows=0 cols=0 populated=0 result=PASS`);
                            }
                        } catch (e) {
                            console.warn(`[2D] _relayShowMinimalGrid error: ${e.message}`);
                        }
                    }
                });
            }

            return { ok: true, state };
        };
        /**
         * LAUNCH-FIX-1b: Comprehensive sheet scope cleanup.
         * Clears ALL sheet-only state to prevent stale selection bleeding.
         * Called from relayExitSheet() and exitEditSheetMode().
         */
        window._relayClearSheetScopeState = () => {
            const cleared = [];
            // 1. Clear entry state sheet fields
            // SCOPE-COHERENCE-1: Always clear the full set unconditionally.
            // Previous bug: conditional clearing produced inconsistent cleanup logs.
            if (window.__relayEntryState) {
                window.__relayEntryState.sheetId = null;
                window.__relayEntryState.sheetAnchorCell = null;
            }
            sheetSelection = null;
            window.__relayForceCompanyScope = false;
            window._relayExplicitEnterActive = false;
            window._r0AutoDockSuppressLogged = false;
            // Hide minimal 2D grid overlay
            if (typeof window._relayHideMinimalGrid === 'function') {
                window._relayHideMinimalGrid();
            }
            // Always log full set
            console.log(`[VIS] exitSheet cleanup=PASS cleared=sheetId,anchor,selection,forceCompanyScope,explicitEnter,autoDockFlags`);
        };

        window.relayExitSheet = () => {
            const sheetId = String(window.__relayEntryState?.sheetId || 'none');
            const fallbackScope = window.__relayEntryState?.deptId
                ? 'department'
                : (window.__relayEntryState?.companyId ? 'company' : 'world');
            const state = relaySetEntryState({
                scope: fallbackScope,
                sheetId: null
            });
            emitVisEntryLog(`[VIS] exit sheet=${sheetId} restoreView=true`);

            // LAUNCH-FIX-1b: Comprehensive sheet scope cleanup
            window._relayClearSheetScopeState();

            return { ok: true, state };
        };
        // ‚îÄ‚îÄ‚îÄ LAUNCH-FIX-1: Minimal 2D grid overlay (clarity micro-batch) ‚îÄ‚îÄ‚îÄ
        /**
         * Show a minimal read-only 2D grid overlay for the given sheet.
         * Uses the existing #spreadsheetOverlay DOM if available.
         * This is NOT edit mode ‚Äî just a visual "you are now looking at sheet data."
         */
        window._relayShowMinimalGrid = (sheetObj) => {
            if (!sheetObj) return;
            const overlay = document.getElementById('spreadsheetOverlay');
            if (!overlay) return;
            const sheetId = sheetObj.id || sheetObj.name || 'unknown';
            const rows = sheetObj.rows || sheetObj.metadata?.rows || 0;
            const cols = sheetObj.cols || sheetObj.metadata?.cols || 0;
            // Support both .data (2D array) and .cellData (cell objects) formats
            const cellDataArr = sheetObj.cellData || sheetObj.data || sheetObj.metadata?.data;
            const data = cellDataArr;
            // Build a lookup grid from cellData (array of {row,col,value,display} objects)
            // or from data (2D array). Either format supported.
            const grid = {};
            let populated = 0;
            if (data && Array.isArray(data)) {
                for (const item of data) {
                    if (item && Number.isFinite(item.row) && Number.isFinite(item.col)) {
                        // cellData format: {row, col, value, display}
                        const display = item.display || item.value;
                        if (display !== undefined && display !== null && display !== '') {
                            const key = `${item.row}_${item.col}`;
                            grid[key] = String(display).slice(0, 12);
                            populated++;
                        }
                    } else if (Array.isArray(item)) {
                        // 2D array format: [[val, val, ...], ...]
                        const rowIdx = data.indexOf(item);
                        for (let c = 0; c < item.length; c++) {
                            if (item[c] !== undefined && item[c] !== null && item[c] !== '') {
                                grid[`${rowIdx}_${c}`] = String(item[c]).slice(0, 12);
                                populated++;
                            }
                        }
                    }
                }
            }
            // Build minimal grid table
            const titleEl = document.getElementById('sheetGridTitle');
            if (titleEl) titleEl.textContent = sheetId;
            const tableEl = document.getElementById('sheetGridTable');
            if (tableEl && rows > 0 && cols > 0) {
                const maxRows = Math.min(rows, 20);
                const maxCols = Math.min(cols, 12);
                let html = '<table style="border-collapse:collapse;width:100%;font-size:10px;color:#c8d7eb;">';
                // Column headers
                html += '<tr><th style="border:1px solid #334;padding:2px 4px;background:#1a2030;color:#5a7a9a;"></th>';
                for (let c = 0; c < maxCols; c++) {
                    html += `<th style="border:1px solid #334;padding:2px 6px;background:#1a2030;color:#5a7a9a;">${String.fromCharCode(65 + c)}</th>`;
                }
                if (cols > maxCols) html += '<th style="border:1px solid #334;padding:2px 4px;background:#1a2030;color:#5a7a9a;">...</th>';
                html += '</tr>';
                // Data rows
                for (let r = 0; r < maxRows; r++) {
                    html += `<tr><td style="border:1px solid #334;padding:2px 4px;background:#1a2030;color:#5a7a9a;text-align:right;">${r + 1}</td>`;
                    for (let c = 0; c < maxCols; c++) {
                        const val = grid[`${r}_${c}`] || '';
                        html += `<td style="border:1px solid #334;padding:2px 4px;">${val}</td>`;
                    }
                    if (cols > maxCols) html += '<td style="border:1px solid #334;padding:2px 4px;">...</td>';
                    html += '</tr>';
                }
                if (rows > maxRows) {
                    html += `<tr><td colspan="${maxCols + 2}" style="border:1px solid #334;padding:2px 4px;text-align:center;color:#5a7a9a;">... ${rows - maxRows} more rows</td></tr>`;
                }
                html += '</table>';
                tableEl.innerHTML = html;
            }
            // Show overlay (read-only, no pointer capture)
            overlay.style.display = 'block';
            overlay.style.opacity = '0.95';
            overlay.style.pointerEvents = 'none';  // read-only: no click capture
            window._relayMinimalGridSheetId = sheetId;
            // Use console.log directly ‚Äî RelayLog.info suppressed by stress console restriction ([2D] tag)
            console.log(`[2D] gridShown sheet=${sheetId} rows=${rows} cols=${cols} populated=${populated} result=PASS`);
        };

        /**
         * Hide the minimal 2D grid overlay (on sheet exit).
         */
        window._relayHideMinimalGrid = (sheetId) => {
            const overlay = document.getElementById('spreadsheetOverlay');
            if (overlay) {
                overlay.style.display = 'none';
                overlay.style.opacity = '0';
            }
            const sid = sheetId || window._relayMinimalGridSheetId || 'unknown';
            window._relayMinimalGridSheetId = null;
            // Use console.log directly ‚Äî RelayLog.info suppressed by stress console restriction ([2D] tag)
            console.log(`[2D] gridHidden reason=exitSheet result=PASS`);
        };

        // ‚îÄ‚îÄ‚îÄ VIS-3.3: Click-to-Focus functions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        /**
         * VIS-3.3: Handle click on an exception row overlay.
         * Focuses the row, updates HUD, and logs.
         * @param {string} sheetId
         * @param {number} rowIndex
         * @returns {{ ok: boolean }}
         */
        window.vis33ClickExceptionRow = (sheetId, rowIndex) => {
            const renderer = window.filamentRenderer;
            if (!renderer) return { ok: false };
            const sheet = (relayState?.tree?.nodes || []).find(n => n.id === sheetId && n.type === 'sheet');
            if (!sheet) return { ok: false };
            // Clear previous focus
            renderer.clearVis33Focus();
            // Render focus highlight
            renderer.renderFocusRowHighlight(sheet, rowIndex);
            renderer._vis33FocusState = { type: 'row', sheetId, rowIndex };
            // Look up row data for HUD
            const cellData = Array.isArray(sheet.cellData) ? sheet.cellData : [];
            const schema = Array.isArray(sheet.metadata?.schema) ? sheet.metadata.schema : [];
            const rowCells = cellData.filter(c => c.row === rowIndex);
            const rowData = {};
            for (const cell of rowCells) {
                const colDef = schema[cell.col];
                if (colDef) rowData[colDef.id] = cell.value;
            }
            const matchStatus = rowData.matchStatus || rowData.status || '‚Äî';
            // Update HUD with row info
            if (typeof hudManager !== 'undefined' && hudManager && typeof hudManager.update === 'function') {
                hudManager.update({
                    focusTarget: `exRow:${sheetId}:r${rowIndex}`,
                    focusHint: `Row ${rowIndex} | status=${matchStatus} | ${Object.entries(rowData).filter(([k]) => k !== 'matchStatus' && k !== 'status').map(([k,v]) => `${k}=${v}`).join(' ')}`
                });
            }
            RelayLog.info(`[VIS3.3] clickRow result=PASS sheet=${sheetId} row=${rowIndex} status=${matchStatus}`);
            return { ok: true, sheetId, rowIndex, matchStatus, rowData };
        };
        /**
         * VIS-3.3: Handle click on a route connector overlay.
         * Focuses the connector, stores jump target, and logs.
         * @param {string} fromId - source sheet ID
         * @param {string} toId - target sheet ID
         * @returns {{ ok: boolean }}
         */
        window.vis33ClickRouteConnector = (fromId, toId) => {
            const renderer = window.filamentRenderer;
            if (!renderer) return { ok: false };
            const fromSheet = (relayState?.tree?.nodes || []).find(n => n.id === fromId && n.type === 'sheet');
            const toSheet = (relayState?.tree?.nodes || []).find(n => n.id === toId && n.type === 'sheet');
            if (!fromSheet || !toSheet) return { ok: false };
            // Clear previous focus
            renderer.clearVis33Focus();
            // Render focus highlight
            const edgeId = `${fromId}-${toId}`;
            renderer.renderFocusConnectorHighlight(fromSheet, toSheet, edgeId);
            renderer._vis33FocusState = { type: 'connector', fromId, toId };
            // Store jump target for vis33JumpToSource
            window._vis33JumpTarget = fromId;
            if (typeof hudManager !== 'undefined' && hudManager && typeof hudManager.update === 'function') {
                hudManager.update({
                    focusTarget: `route:${fromId}‚Üí${toId}`,
                    focusHint: `Connector ${fromId} ‚Üí ${toId} | Jump: vis33JumpToSource()`
                });
            }
            RelayLog.info(`[VIS3.3] clickConnector result=PASS from=${fromId} to=${toId}`);
            return { ok: true, fromId, toId };
        };
        /**
         * VIS-3.3: Jump to the source sheet of a focused connector.
         * Calls relayEnterSheet on the source sheet and triggers render.
         * @param {string} [sourceSheetId] - optional override; defaults to last clicked connector's source
         * @returns {{ ok: boolean }}
         */
        window.vis33JumpToSource = (sourceSheetId) => {
            const targetId = sourceSheetId || window._vis33JumpTarget;
            if (!targetId) {
                RelayLog.info(`[VIS3.3] jumpToSource result=REFUSAL reason=NO_JUMP_TARGET`);
                return { ok: false, reason: 'NO_JUMP_TARGET' };
            }
            // Clear focus state before jumping
            const renderer = window.filamentRenderer;
            if (renderer) renderer.clearVis33Focus();
            window._vis33JumpTarget = null;
            // Enter the source sheet
            const enterResult = window.relayEnterSheet(targetId);
            if (enterResult?.ok && renderer) {
                renderer.renderTree('vis33-jump-to-source');
            }
            RelayLog.info(`[VIS3.3] jumpToSource result=PASS sheet=${targetId}`);
            return { ok: true, sheet: targetId };
        };
        window.relayGetEntryState = () => ({ ...window.__relayEntryState });
        window.relayIsDetailAllowed = (_level, _context = {}) => {
            const state = window.__relayEntryState || { scope: 'world' };
            // VIS-1 scaffolding only: behavior enforcement lands in next batch.
            if (state.scope === 'world') return true;
            return true;
        };
        window.relayEnterFocus = async (targetInput) => {
            const resolved = resolveFocusInputToNodeApi(targetInput);
            if (!resolved?.node) return { ok: false, reason: 'FOCUS_TARGET_UNRESOLVED' };
            if (typeof window.enterFocusMode !== 'function') return { ok: false, reason: 'FOCUS_ENGINE_NOT_READY' };
            return window.enterFocusMode(resolved.node, { contractOverride: resolved.contract || null });
        };
        window.relayExitFocus = async () => {
            if (typeof window.exitFocusMode !== 'function') return { ok: false, reason: 'FOCUS_ENGINE_NOT_READY' };
            return window.exitFocusMode();
        };
        window.relayGetFocusState = () => ({
            active: focusLensState.active === true,
            frameId: focusLensState.frameId || null,
            radiusM: Number(focusLensState.radiusM || 0),
            targetObjectId: focusLensState.targetObjectId || null,
            targetType: focusLensState.targetType || null,
            previousSelectionObjectId: focusLensState.previousSelectionObjectId || null,
            previousLod: focusLensState.previousLod || null
        });
        window.relayEnterBranchWalk = async (branchId) => {
            if (typeof window.enterBranchWalk !== 'function') return { ok: false, reason: 'BRANCH_WALK_ENGINE_NOT_READY' };
            return window.enterBranchWalk(branchId);
        };
        window.relayExitBranchWalk = async () => {
            if (typeof window.exitBranchWalk !== 'function') return { ok: false, reason: 'BRANCH_WALK_ENGINE_NOT_READY' };
            return window.exitBranchWalk();
        };
        window.relayBranchWalkNext = async () => {
            if (typeof window.branchWalkNext !== 'function') return { ok: false, reason: 'BRANCH_WALK_ENGINE_NOT_READY' };
            return window.branchWalkNext();
        };
        window.relayBranchWalkPrev = async () => {
            if (typeof window.branchWalkPrev !== 'function') return { ok: false, reason: 'BRANCH_WALK_ENGINE_NOT_READY' };
            return window.branchWalkPrev();
        };
        window.relayGetBranchWalkState = () => ({
            active: branchWalkState.active === true,
            branchId: branchWalkState.branchId || null,
            currentIndex: Number.isFinite(Number(branchWalkState.currentIndex)) ? Number(branchWalkState.currentIndex) : -1,
            currentObjectId: branchWalkState.currentObjectId || null,
            path: Array.isArray(branchWalkState.path)
                ? branchWalkState.path.map((p) => ({ kind: p.kind, objectId: p.objectId }))
                : []
        });
        window.relayEnterFilamentRide = async (targetInput) => {
            if (typeof window.enterFilamentRide !== 'function') return { ok: false, reason: 'FILAMENT_RIDE_ENGINE_NOT_READY' };
            return window.enterFilamentRide(targetInput);
        };
        window.relayExitFilamentRide = async () => {
            if (typeof window.exitFilamentRide !== 'function') return { ok: false, reason: 'FILAMENT_RIDE_ENGINE_NOT_READY' };
            return window.exitFilamentRide();
        };
        window.relayFilamentRideNext = async () => {
            if (typeof window.filamentRideNext !== 'function') return { ok: false, reason: 'FILAMENT_RIDE_ENGINE_NOT_READY' };
            return window.filamentRideNext();
        };
        window.relayFilamentRidePrev = async () => {
            if (typeof window.filamentRidePrev !== 'function') return { ok: false, reason: 'FILAMENT_RIDE_ENGINE_NOT_READY' };
            return window.filamentRidePrev();
        };
        window.relayGetFilamentRideState = () => ({
            active: filamentRideState.active === true,
            filamentId: filamentRideState.filamentId || null,
            currentIndex: Number.isFinite(Number(filamentRideState.currentIndex)) ? Number(filamentRideState.currentIndex) : -1,
            currentTimeboxId: filamentRideState.currentTimeboxId || null,
            determinismHash: String(filamentRideState.determinismHash || ''),
            path: Array.isArray(filamentRideState.path)
                ? filamentRideState.path.map((p) => ({ timeboxId: p.timeboxId, filamentId: p.filamentId }))
                : [],
            // v1 epistemic fields
            currentLifecycleState: filamentRideState.currentLifecycleState || null,
            currentDisclosureTier: filamentRideState.currentDisclosureTier || null,
            currentConfidence: filamentRideState.currentConfidence || 0,
            currentAttention: filamentRideState.currentAttention || 0,
            currentCommitCount: filamentRideState.currentCommitCount || 0,
            currentContributorCount: filamentRideState.currentContributorCount || 0,
            rideMode: filamentRideState.rideMode || null
        });
        // CAM0.4.2-PROOF-STABILIZE-1: expose ride prerequisites for deterministic proof waits.
        window.relayGetRidePrereqs = () => {
            const cubes = Array.isArray(window.filamentRenderer?.timeboxCubes) ? window.filamentRenderer.timeboxCubes : [];
            const stampedCount = cubes.filter((c) => !!c?.filamentId).length;
            const slabCount = Number(window.filamentRenderer?._vis4SlabRegistry?.size || 0);
            const mode = String(window._relayRenderMode || 'UNKNOWN');
            const scopeLabel = String(window.__relayEntryState?.scope || (window._isEditSheetMode ? 'sheet' : 'world'));
            const sheetsDetailed = Number(window.filamentRenderer?._sheetsRendered || 0);
            let expandedSheetsAllowed = false;
            try {
                if (typeof shouldRenderExpandedSheets === 'function') {
                    expandedSheetsAllowed = shouldRenderExpandedSheets(window.__relayEntryState || null) === true;
                } else {
                    expandedSheetsAllowed = (scopeLabel === 'sheet' || scopeLabel === 'sheet-only' || scopeLabel === 'cell');
                }
            } catch {
                expandedSheetsAllowed = (scopeLabel === 'sheet' || scopeLabel === 'sheet-only' || scopeLabel === 'cell');
            }
            const snapshot = {
                timeboxCount: cubes.length,
                slabCount,
                stampedCount,
                renderMode: mode,
                effectiveScope: scopeLabel,
                sheetsDetailed,
                expandedSheetsAllowed
            };
            const sig = `${snapshot.timeboxCount}|${snapshot.slabCount}|${snapshot.stampedCount}|${snapshot.renderMode}|${snapshot.effectiveScope}|${snapshot.sheetsDetailed}|${snapshot.expandedSheetsAllowed}`;
            if (window.__relayRidePrereqSig !== sig) {
                window.__relayRidePrereqSig = sig;
                RelayLog.info(`[RIDE] prereqs timeboxes=${snapshot.timeboxCount} slabs=${snapshot.slabCount} stamped=${snapshot.stampedCount} mode=${snapshot.renderMode} scope=${snapshot.effectiveScope} sheetsDetailed=${snapshot.sheetsDetailed} expanded=${snapshot.expandedSheetsAllowed}`);
            }
            return snapshot;
        };
        window.relayFlowStart = (meta = {}) => relayFlowStart(meta);
        window.relayFlowStep = (meta = {}) => relayFlowStep(meta);
        window.relayFlowEnd = (meta = {}) => relayFlowEnd(meta);
        window.relayFlowPlay = async (flowId, options = {}) => relayFlowPlay(flowId, options);
        window.relayGetFlows = () => flowStoreSorted().map(f => JSON.parse(JSON.stringify(f)));
        window.relayGetFlow = (flowId) => {
            const flow = (window.__relayFlows || []).find(f => String(f.flowId) === String(flowId));
            return flow ? JSON.parse(JSON.stringify(flow)) : null;
        };
        window.relayGetFlowInputFingerprint = () => computeFlowInputFingerprint();
        window.relayGetTrunkMetrics = () => JSON.parse(JSON.stringify(window.__relayTrunkMetrics || { metrics: [], hash: null }));
        window.relayGetTrunkMetricContributors = (metricId = '') => {
            const metrics = Array.isArray(window.__relayTrunkMetrics?.metrics) ? window.__relayTrunkMetrics.metrics : [];
            const row = metrics.find(m => String(m.metricId) === String(metricId)) || null;
            return row ? JSON.parse(JSON.stringify(row.contributors || [])) : [];
        };
        window.relaySetPresenceConsent = (actorId, consent = true) => {
            const aid = String(actorId || '').trim();
            if (!aid) return { ok: false, reason: 'PRESENCE_MISSING_ACTOR' };
            window.__relayPresenceState.consentByActor[aid] = consent === true;
            return { ok: true, actorId: aid, consent: window.__relayPresenceState.consentByActor[aid] };
        };
        window.relaySetPresenceMarker = (meta = {}) => upsertPresenceMarker(meta);
        window.relaySweepPresence = () => sweepPresenceState();
        window.relayGetPresenceState = () => {
            sweepPresenceState();
            return JSON.parse(JSON.stringify(window.__relayPresenceState));
        };
        window.relaySetSCVPresence = (scvId, meta = {}) => {
            const id = String(scvId || '').trim();
            if (!id) return { ok: false, reason: 'SCV_MISSING_ID' };
            return upsertPresenceMarker({
                actorId: id,
                actorType: 'scv',
                label: String(meta.label || `SCV: ${id.split('.').slice(1).join('.') || id}`),
                status: String(meta.status || 'NORMAL'),
                taskId: meta.taskId ? String(meta.taskId) : null,
                focusObjectId: meta.focusObjectId || null,
                tier: 1,
                consent: true
            });
        };
        window.relayGetSCVs = () => {
            seedScvCatalog();
            return JSON.parse(JSON.stringify(window.__relayPresenceState.scvs || []));
        };
        window.relaySCVAttemptExecute = (scvId, actionId) => {
            RelayLog.warn(`[REFUSAL] reason=SCV_EXECUTION_FORBIDDEN scv=${String(scvId || 'unknown')} action=${String(actionId || 'unknown')}`);
            return { ok: false, reason: 'SCV_EXECUTION_FORBIDDEN' };
        };
        window.relaySCVCreateProposedCommitDraft = (scvId, payload = {}) => createScvProposedCommitDraft(scvId, payload);
        window.relayCreateAuditRequest = (meta = {}) => createAuditRequest(meta);
        window.relayAssignAuditRequest = (requestId, scvId) => assignAuditRequest(requestId, scvId);
        window.relayProduceAuditFindings = (requestId, findings = [], meta = {}) => produceAuditFindings(requestId, findings, meta);
        window.relayApproveAuditRequest = (requestId, meta = {}) => approveAuditRequest(requestId, meta);
        window.relayRejectAuditRequest = (requestId, meta = {}) => rejectAuditRequest(requestId, meta);
        window.relayGetAuditRequests = () => JSON.parse(JSON.stringify(window.__relayPresenceState?.auditRequests || []));
        window.relayUX3ListModules = () => relayGetUx3ModuleOptions();
        window.relayUX3GetConfig = (moduleId = '') => relayGetUx3Config(moduleId);
        window.relayUX3SetSelectedModule = (moduleId = '') => {
            relayUx3State.selectedModuleId = String(moduleId || '');
            renderUx3Panel(relayUx3State.selectedModuleId);
            return relayGetUx3Config(relayUx3State.selectedModuleId);
        };
        window.relayUX3ProposeConfigEdit = (payload = {}, meta = {}) => relayUx3ProposeConfigEdit(payload, meta);
        window.relayUX3CommitLatest = (meta = {}) => relayUx3CommitLatest(meta);
        window.relayUX3GetState = () => ({ ...relayUx3State });
        window.relayGetSnapshots = () => Array.isArray(window.__relaySnapshots) ? [...window.__relaySnapshots].sort(artifactSortAsc) : [];
        window.relayGetCommits = () => Array.isArray(window.__relayCommits) ? [...window.__relayCommits].sort(artifactSortAsc) : [];
        window.relayGetSnapshotById = (id) => (window.__relaySnapshots || []).find(s => String(s.id) === String(id)) || null;
        window.relayGetCommitById = (id) => (window.__relayCommits || []).find(c => String(c.id) === String(id)) || null;
        window.relayGetProposalById = (id) => (window.__relaySnapshots || []).find(s => String(s.type) === 'PROPOSE' && String(s.proposalId || s.evidence?.proposal?.proposalId || '') === String(id)) || null;
        window.relayRegisterContainer = (container) => {
            if (!container || typeof container !== 'object') return { ok: false, reason: 'INVALID_CONTAINER' };
            const id = String(container.id || '').trim();
            if (!id) return { ok: false, reason: 'MISSING_CONTAINER_ID' };
            window.__relayContainerRegistry.set(id, {
                id,
                type: String(container.type || 'container'),
                category: String(container.category || 'Generic'),
                scope: String(container.scope || 'unknown')
            });
            return { ok: true, id };
        };
        window.relayGetContainer = (id) => {
            const key = String(id || '');
            if (!window.__relayContainerRegistry.has(key)) return null;
            return { ...window.__relayContainerRegistry.get(key) };
        };
        window.relayGetContainers = () => Array.from(window.__relayContainerRegistry.values()).map(c => ({ ...c }));
        window.relayValidateTransferPacket = (packet, context = {}) => validateTransferPacket(packet, context);
        window.relayGetTransferPackets = () => Array.isArray(window.__relayTransferPackets) ? [...window.__relayTransferPackets] : [];
        window.relayGetResponsibilityPackets = () => Array.isArray(window.__relayResponsibilityPackets) ? [...window.__relayResponsibilityPackets] : [];
        window.relayGetInventoryOnHand = (filters = {}) => {
            const siteId = filters?.siteId ? String(filters.siteId).toUpperCase() : null;
            const itemId = filters?.itemId ? String(filters.itemId) : null;
            const rows = computeOnHandFromPackets(window.relayGetTransferPackets());
            return rows.filter((row) => (!siteId || String(row.siteId) === siteId) && (!itemId || String(row.itemId) === itemId));
        };
        window.relayGetInventoryValuation = (filters = {}) => {
            const siteId = filters?.siteId ? String(filters.siteId).toUpperCase() : null;
            const itemId = filters?.itemId ? String(filters.itemId) : null;
            const rows = computeInventoryValuationFromPackets(window.relayGetTransferPackets());
            return rows.filter((row) => (!siteId || String(row.siteId) === siteId) && (!itemId || String(row.itemId) === itemId));
        };
        window.relayBuildTier1ParityFixture = () => buildTier1ParityFixture();
        window.relayLoadHeadlessParityFixture = (fixture = null) => {
            const next = fixture && typeof fixture === 'object' ? fixture : buildTier1ParityFixture();
            window.__relayHeadlessParityFixture = JSON.parse(JSON.stringify(next));
            return { ok: true, source: 'fixture', facts: Array.isArray(next.facts) ? next.facts.length : 0 };
        };
        const extractFactsFromRuntimeState = () => {
            const nodes = relayState?.tree?.nodes || [];
            const facts = [];
            for (const sheet of nodes.filter(n => n.type === 'sheet' && n.metadata?.isFactSheet)) {
                const schema = sheet.metadata?.schema || [];
                const rows = new Map();
                for (const cell of (sheet.cellData || [])) {
                    if (!rows.has(cell.row)) rows.set(cell.row, {});
                    const row = rows.get(cell.row);
                    const col = schema[cell.col];
                    const key = col?.id || col?.name || `col${cell.col}`;
                    row[key] = (cell.display ?? cell.value ?? null);
                }
                for (const [rowIdx, row] of rows.entries()) {
                    const factId = String(row.factId || row.lineId || row.matchId || `${sheet.id}.row.${rowIdx}`);
                    const expectedAmount = Number(row.expectedAmount ?? row.poAmount ?? row.amount ?? 0);
                    const actualAmount = Number(row.actualAmount ?? row.invAmount ?? row.amount ?? expectedAmount);
                    const status = String(row.matchStatus || row.status || (Math.abs(actualAmount - expectedAmount) < 0.0001 ? 'MATCH' : 'MISMATCH'));
                    facts.push({
                        factId,
                        sheetId: sheet.id,
                        expectedAmount: Number.isFinite(expectedAmount) ? expectedAmount : 0,
                        actualAmount: Number.isFinite(actualAmount) ? actualAmount : 0,
                        status
                    });
                }
            }
            facts.sort((a, b) => String(a.factId).localeCompare(String(b.factId)));
            return facts;
        };
        const extractRuntimeParityFixture = () => {
            const kpiBindings = (relayState?.tree?.nodes || [])
                .filter(n => n.type === 'branch' && Array.isArray(n.metadata?.kpiBindings))
                .flatMap(n => n.metadata.kpiBindings.map(k => ({
                    branchId: n.id,
                    metric: String((typeof k === 'string') ? k : (k?.metric || k?.metricId || k?.name || 'unknown'))
                })));
            const transferPackets = window.relayGetTransferPackets();
            const responsibilityPackets = window.relayGetResponsibilityPackets();
            const containerAccountMap = {};
            const toAccountId = (container) => {
                const cat = String(container?.category || '').toLowerCase();
                if (cat === 'inventory') return 'acct.inventory';
                if (cat === 'grir') return 'acct.grir';
                if (cat === 'ap') return 'acct.ap';
                if (cat === 'cashbank') return 'acct.cashbank';
                if (cat === 'pricevariance') return 'acct.priceVariance';
                if (cat === 'qtyvariance') return 'acct.qtyVariance';
                if (cat === 'budgetcommitment') return 'acct.budgetCommitment';
                return null;
            };
            for (const c of window.relayGetContainers()) {
                const aid = toAccountId(c);
                if (aid) containerAccountMap[c.id] = aid;
            }
            return {
                facts: extractFactsFromRuntimeState(),
                kpiBindings,
                transferPackets,
                responsibilityPackets,
                containerAccountMap
            };
        };
        window.relayGetGoldenStateHashes = (options = {}) => {
            const mode = String(options.source || 'runtime');
            const allowKpiNA = options.allowKpiNA !== false;
            const fixture = (mode === 'fixture' || window.__relayHeadlessParityFixture)
                ? (window.__relayHeadlessParityFixture || buildTier1ParityFixture())
                : extractRuntimeParityFixture();
            const result = computeTier1GoldenHashesFromFixture(fixture, { allowKpiNA });
            if (result.kpisHash === 'N/A') {
                RelayLog.info(`[HEADLESS] kpis hash=N/A reason=${result.kpisReason || 'NO_KPI_BINDINGS_HEADLESS'}`);
            }
            return {
                factsHash: result.factsHash,
                matchesHash: result.matchesHash,
                summariesHash: result.summariesHash,
                kpisHash: result.kpisHash,
                packetsHash: result.packetsHash,
                ledgerHash: result.ledgerHash
            };
        };
        window.relayGetArtifactsForObject = (objectId) => {
            const bucket = window.__relayArtifactsByObjectId.get(String(objectId || ''));
            if (!bucket) return { snapshots: [], commits: [] };
            const snapshots = (bucket.snapshots || [])
                .map(id => window.relayGetSnapshotById(id))
                .filter(Boolean)
                .sort(artifactSortAsc);
            const commits = (bucket.commits || [])
                .map(id => window.relayGetCommitById(id))
                .filter(Boolean)
                .sort(artifactSortAsc);
            return { snapshots, commits };
        };
        window.relayGetCommitsForProposal = (proposalId) => {
            const bucket = window.__relayArtifactsByProposalId.get(String(proposalId || ''));
            if (!bucket) return [];
            return (bucket.commits || [])
                .map(id => window.relayGetCommitById(id))
                .filter(Boolean)
                .sort(artifactSortAsc);
        };
        window.relayGetLatestArtifact = () => {
            const all = getArtifactsSorted();
            return all.length ? all[all.length - 1] : null;
        };
        const scheduleDeferredTreeRender = (reason = 'deferred') => {
            if (!filamentRenderer) return;
            window.__relayPendingRenderReason = reason;
            if (window.__relayFpsSampleBarrierActive === true) {
                window.__relayDeferredRenderQueued = true;
                return;
            }
            if (window.__relayDeferredRenderPending === true) {
                window.__relayDeferredRenderQueued = true;
                return;
            }
            if (window.__relayDeferredRenderScheduled === true) {
                return;
            }
            window.__relayDeferredRenderScheduled = true;
            requestAnimationFrame(() => {
                window.__relayDeferredRenderScheduled = false;
                if (!filamentRenderer) return;
                if (window.__relayDeferredRenderPending === true) {
                    window.__relayDeferredRenderQueued = true;
                    return;
                }
                window.__relayDeferredRenderPending = true;
                const scheduledReason = window.__relayPendingRenderReason || reason;
                window.__relayPendingRenderReason = null;
                const rT0 = performance.now();
                try {
                    filamentRenderer.renderTree(scheduledReason);
                    const renderMs = (performance.now() - rT0).toFixed(1);
                    RelayLog.info(`[D0.2] renderMs=${renderMs} (deferred via rAF)`);
                } finally {
                    window.__relayDeferredRenderPending = false;
                    window.__relayLastDeferredRenderEndMs = performance.now();
                    if (window.__relayDeferredRenderQueued === true) {
                        window.__relayDeferredRenderQueued = false;
                        scheduleDeferredTreeRender('coalesced');
                    }
                }
            });
        };
        let isEditingCell = false;
        const CAMERA_STORAGE_KEY = 'relay.camera.v1';
        const DEBUG_RANGE_STORAGE_KEY = 'relay.debugRangeOps.v1';
        const DEBUG_SPINE_STORAGE_KEY = 'relay.debugSpineGuide.v1';
        const COMPANY_MARKERS_STORAGE_KEY = 'relay.showCompanyMarkers.v1';
        const ACTIVE_MARKERS_STORAGE_KEY = 'relay.showActiveMarkers.v1';
        const ACTIVE_MARKER_MODE_STORAGE_KEY = 'relay.activeMarkerMode.v1';
        const CAMERA_SAVE_THROTTLE_MS = 250;
        let lastCameraSave = 0;
        
        // LOD lock state (top-level scope for render loop access)
        let lodLocked = false;
        let lodLockedLevel = null;
        let buildingsStatus = 'UNKNOWN';
        window.getBuildingsStatus = () => buildingsStatus;
        window.setBuildingsStatus = (status) => { buildingsStatus = status; };

        // ‚îÄ‚îÄ‚îÄ Basin Company Focus state (BASIN-FOCUS-LOCK-1) ‚îÄ‚îÄ‚îÄ
        let isCompanyFocusMode = false;
        let companyFocusTarget = null; // trunk node being focused
        let preCompanyFocusCameraState = null;
        let preCompanyFocusLodLocked = false;
        let preCompanyFocusLodLevel = null;

        // ‚îÄ‚îÄ‚îÄ Focus Lens state (D-Lens-0) ‚îÄ‚îÄ‚îÄ
        let isFocusMode = false;
        let focusTarget = null;       // { node, nodeType, parentBranch, parentTrunk }
        let preFocusCameraState = null;
        let focusLensState = {
            active: false,
            frameId: null,
            radiusM: 0,
            targetObjectId: null,
            targetType: null,
            previousSelectionObjectId: null,
            previousLod: null,
            previousArtifactFocusedObjectId: null
        };
        let softIsolationTargetId = null;
        let softIsolationRafPending = false;
        let softIsolationLastMousePos = null;
        let branchWalkState = {
            active: false,
            branchId: null,
            currentIndex: -1,
            currentObjectId: null,
            path: [],
            previousSelectionObjectId: null,
            previousLod: null,
            previousArtifactFocusedObjectId: null,
            preCameraState: null
        };
        let filamentRideState = {
            active: false,
            filamentId: null,
            currentIndex: -1,
            currentTimeboxId: null,
            path: [],
            determinismHash: '',
            previousSelectionObjectId: null,
            previousLod: null,
            previousArtifactFocusedObjectId: null,
            preCameraState: null,
            // v1 epistemic fields
            currentLifecycleState: null,
            currentDisclosureTier: null,
            currentConfidence: 0,
            currentAttention: 0,
            currentCommitCount: 0,
            currentContributorCount: 0,
            previousStopLifecycle: null,
            rideMode: null // 'canopy' or 'scaffold'
        };
        
        async function initialize() {
            try {
                // SAFE GUARD: ignore InvalidStateError from pointer capture
                if (!window.__relayPointerCaptureShim) {
                    const _spc = Element.prototype.setPointerCapture;
                    Element.prototype.setPointerCapture = function(id) {
                        try {
                            return _spc.call(this, id);
                        } catch (e) {
                            if (e && e.name === 'InvalidStateError') return;
                            throw e;
                        }
                    };
                    window.__relayPointerCaptureShim = true;
                }

                // Set up logging UI
                RelayLog.setLevel(3); // info
                RelayLog.setUIElement(document.getElementById('logConsole'));
                workModeSurfaceEl = document.getElementById('workModeSurface');
                artifactInspectorPanelEl = document.getElementById('artifactInspectorPanel');
                branchStewardPanelEl = document.getElementById('branchStewardPanel');
                ux3ModuleSelectEl = document.getElementById('ux3ModuleSelect');
                ux3SummaryInputEl = document.getElementById('ux3SummaryInput');
                ux3ConfigEditorEl = document.getElementById('ux3ConfigEditor');
                ux3StatusLineEl = document.getElementById('ux3StatusLine');
                voteLanePanelEl = document.getElementById('voteLanePanel');
                voteLaneListEl = document.getElementById('voteLaneList');
                votePanelEl = document.getElementById('votePanel');
                votePanelBodyEl = document.getElementById('votePanelBody');
                voteStatusLineEl = document.getElementById('voteStatusLine');
                voteApproveBtnEl = document.getElementById('voteApproveBtn');
                voteRejectBtnEl = document.getElementById('voteRejectBtn');
                votingUiManager = new VotingUIManager({ logger: (line) => RelayLog.info(line) });
                rebuildArtifactIndexes();
                renderWorkModeSurface();
                renderArtifactInspector();
                bindArtifactInspectorEvents();
                bindUx3PanelEvents();
                bindVoteUiEvents();
                relayVoteUiSeedTopics();
                seedScvCatalog();
                sweepPresenceState();
                setInterval(() => {
                    sweepPresenceState();
                }, 1000);
                RelayLog.info(`[Z] mode=${relayWorkState.mode} user=${relayWorkState.user} target=${relayWorkState.target} previous=INIT`);
                
                RelayLog.info('üöÄ Relay Cesium World starting...');
                
                // Optional owner-specific building import config.
                // Example:
                // window.RELAY_OWNER_BUILDINGS = [
                //   { id: 'hq', ownerId: 'avgol', position: { lon: 34.7818, lat: 32.0853, height: 0 }, heading: 0, modelUri: '/models/hq.glb' }
                // ];
                // window.RELAY_OWNER_MODEL_LIBRARY = { avgol: '/models/avgol-default.glb', default: '/models/generic.glb' };
                const importedBuildings = Array.isArray(window.RELAY_OWNER_BUILDINGS) ? window.RELAY_OWNER_BUILDINGS : [];
                const ownerPreferredModels = (window.RELAY_OWNER_MODEL_LIBRARY && typeof window.RELAY_OWNER_MODEL_LIBRARY === 'object')
                    ? window.RELAY_OWNER_MODEL_LIBRARY
                    : {};
                const buildingPolicy = (window.RELAY_BUILDING_POLICY && typeof window.RELAY_BUILDING_POLICY === 'object')
                    ? window.RELAY_BUILDING_POLICY
                    : {
                        maxAllowed: 0,
                        maxDistanceMeters: 2000,
                        maxModelBytes: 20 * 1024 * 1024,
                        enforceModelSize: true,
                        allowLargeModels: false,
                        disableDuringFpsSampling: true,
                        currentLOD: window.RELAY_CURRENT_LOD || window.RELAY_BUILDING_LOD_CONTEXT || window.RELAY_LOCK_LOD || 'UNKNOWN',
                        lodPolicy: {
                            UNKNOWN: { maxAllowed: 0, maxDistanceMeters: 1000 },
                            COMPANY: { maxAllowed: 0, maxDistanceMeters: 1000 },
                            SHEET: { maxAllowed: 0, maxDistanceMeters: 1000 },
                            CELL: { maxAllowed: 0, maxDistanceMeters: 1000 },
                            REGION: { maxAllowed: 0, maxDistanceMeters: 2000 },
                            LANIAKEA: { maxAllowed: 0, maxDistanceMeters: 2000 },
                            PLANETARY: { maxAllowed: 3, maxDistanceMeters: 2000 },
                            FACILITY: { maxAllowed: 5, maxDistanceMeters: 2000 },
                            SITE: { maxAllowed: 5, maxDistanceMeters: 2000 }
                        }
                    };
                const enableBuildings = window.RELAY_ENABLE_BUILDINGS !== false;

                // Initialize Cesium viewer (free providers by default; owner imports supported)
                viewer = await initializeCesiumViewer('cesiumContainer', {
                    profile: RELAY_PROFILE,
                    enableWorldImagery: RELAY_PROFILE === 'world',
                    worldImageryMode: RELAY_PROFILE === 'world' ? defaultWorldImageryMode() : 'osm',
                    buildings: enableBuildings,
                    importedBuildings,
                    ownerPreferredModels,
                    buildingPolicy,
                    enableOsmFallback: importedBuildings.length === 0,
                    lighting: true,
                    fog: true,
                    skyAtmosphere: true,  // Enable atmosphere for surface reference
                    initialPosition: {
                        lon: 34.7818,
                        lat: 32.0853,
                        height: 15000,
                        heading: 0,
                        pitch: -45,
                        roll: 0
                    }
                });
                
                // Add visual surface reference (horizon/limb line)
                viewer.scene.globe.enableLighting = true;
                viewer.scene.globe.showGroundAtmosphere = true;
                viewer.scene.skyAtmosphere.show = true;
                window.viewer = viewer; // Global for debugging

                // HEADLESS-0: Check fallback after viewer init
                if (typeof window.relayDetectHeadlessFallback === 'function') {
                    window.relayDetectHeadlessFallback();
                }
                
                // LAUNCH READABILITY: Dim basemap so tree geometry pops
                // Reduces OSM road/building visual noise competing with trunk/branch corridors
                if (RELAY_LAUNCH_MODE && viewer.imageryLayers && viewer.imageryLayers.length > 0) {
                    const baseLayer = viewer.imageryLayers.get(0);
                    // R4-PRES-ARCH-2: Terrain faded to near-abstraction
                    // City becomes a faint texture ‚Äî luminous tree structure dominates completely
                    baseLayer.brightness = 0.28;   // deeply dimmed ‚Äî city as faint floor
                    baseLayer.contrast   = 0.55;   // strongly reduced ‚Äî roads/buildings dissolve
                    baseLayer.saturation = 0.05;   // nearly greyscale ‚Äî no color competition at all
                    baseLayer.gamma      = 1.6;    // strong gamma lift ‚Äî softens remaining detail further
                    RelayLog.info('[LAUNCH-FIX] basemapDim brightness=0.28 contrast=0.55 saturation=0.05 gamma=1.6 applied=PASS');
                    // TREE-VISIBILITY-FIX: consolidated visibility mode log (required by contract)
                    RelayLog.info(`[LAUNCH] visibilityMode enabled=PASS scale=${window.RELAY_LAUNCH_SCALE} trunkPrimitive=cylinder widthFloors=ON basemapDimming=ON`);
                    // R4-ARCH-2 environment de-emphasis proof log
                    RelayLog.info('[PRES] environmentDeemphasis applied=PASS brightness=0.28 saturation=0.05 gamma=1.6');
                }
                if (RELAY_PROFILE === 'world') {
                    window.RELAY_WORLD_IMAGERY_MODE = defaultWorldImageryMode();
                    bindWorldImageryControls();
                    const globeServicesBase = getWorldGlobeServicesOrigin();
                    weatherManager = new WeatherManager(viewer, { baseUrl: globeServicesBase });
                    topographyManager = new TopographyManager(viewer);
                    window.relayWeatherListTypes = () => weatherManager.listTypes();
                    window.relayWeatherAddOverlay = (type) => weatherManager.addOverlay(type);
                    window.relayWeatherRemoveOverlay = (type) => weatherManager.removeOverlay(type);
                    window.relayWeatherClear = () => weatherManager.clear();
                    window.relayTopographyListModes = () => topographyManager.listModes();
                    window.relayTopographyApplyMode = (modeId) => topographyManager.applyMode(modeId);
                    window.relayTopographyClear = () => topographyManager.clear();
                    RelayLog.info(`[GLOBE] services weatherBase=${globeServicesBase}`);
                    RelayLog.info(`[GLOBE] imagery registry enabled modes=${window.relayListImageryModes().map((m) => m.id).join(',')}`);
                } else {
                    RelayLog.info('[GLOBE] imagery registry locked profile=proof mode=osm');
                }

                // Restore last camera POV if present (skip when testing and in launch mode)
                if (window.RELAY_LAUNCH_MODE) {
                    RelayLog.info('[CAM] restore-POV skipped for launch (deterministic frame)');
                    window.__relayCameraRestored = false;
                } else if (window.RELAY_DISABLE_RESTORE_POV) {
                    RelayLog.info('[CAM] restore-POV disabled for testing');
                    window.__relayCameraRestored = false;
                } else {
                    window.__relayCameraRestored = restoreCameraState(viewer) === true;
                }
                viewer.camera.changed.addEventListener(() => saveCameraState(viewer));
                window.addEventListener('beforeunload', () => saveCameraState(viewer, true));
                
                // Restore free-fly camera controls (Three.js-like)
                flightControls = setupFlightControls(viewer);
                RelayLog.info('[INPUT] owner=CAMERA mode=FreeFly reason=default');
                
                // Initialize LOD Governor
                lodGovernor = new RelayLODGovernor();
                lodGovernor.startMonitoring();
                
                lodGovernor.subscribe((newLevel, oldLevel) => {
                    RelayLog.info(`üîÑ LOD: ${oldLevel || 'NONE'} ‚Üí ${newLevel}`);
                    window.RELAY_CURRENT_LOD = newLevel;
                    if (filamentRenderer) {
                        filamentRenderer.setLOD(newLevel);
                        if (relayState.tree.nodes.length > 0) {
                            filamentRenderer.renderTree();
                        }
                    }
                });
                
                // Initialize Filament Renderer
                filamentRenderer = new CesiumFilamentRenderer(viewer);
                window.filamentRenderer = filamentRenderer; // Global for debugging
                
                // Initialize Relationship Renderer (for global connections)
                relationshipRenderer = new RelationshipRenderer(viewer, relayState);
                window.relationshipRenderer = relationshipRenderer; // Global for debugging
                
                // Clear any proof mode remnants from previous sessions
                relationshipRenderer.clear();
                filamentRenderer.clear();
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // BOUNDARIES: LCK-1 restore path (fail-soft, runtime-gated)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const ENABLE_BOUNDARIES = window.RELAY_ENABLE_BOUNDARIES !== false;
                
                let boundaryStatus = 'DISABLED';
                let governanceVotingScopeMode = 'GLOBAL_SAFE_ONLY';
                window.__relayBoundaryDatasetStatus = { state: 'OK', missing: 0, first: 'n/a' };
                const setGovernanceVotingScopeMode = (reason = 'unknown') => {
                    governanceVotingScopeMode = (boundaryStatus === 'ACTIVE') ? 'BOUNDARY_ENABLED' : 'GLOBAL_SAFE_ONLY';
                    RelayLog.info(`[BOUNDARY] voting-scope mode=${governanceVotingScopeMode} reason=${reason}`);
                };
                
                if (ENABLE_BOUNDARIES) {
                    // Initialize Boundary Renderer (v93 boundaries restored)
                    // FAIL-SOFT: Boundary failures must not crash tree rendering
                    boundaryRenderer = new BoundaryRenderer(viewer, relayState);
                    window.boundaryRenderer = boundaryRenderer; // Global for debugging
                    if (RELAY_PROFILE === 'world') {
                        worldGlobeManager = new WorldGlobeManager(viewer, boundaryRenderer);
                        window.worldGlobeManager = worldGlobeManager;
                        restore3ScopeManager = new Restore3ScopeManager(viewer, () => relayState);
                        window.restore3ScopeManager = restore3ScopeManager;
                        restore4AssignmentManager = new Restore4AssignmentManager(
                            viewer,
                            () => relayState,
                            () => (restore3ScopeManager ? restore3ScopeManager.getState() : null)
                        );
                        window.restore4AssignmentManager = restore4AssignmentManager;
                    }
                    
                    // Load boundaries asynchronously (non-blocking, fail-soft)
                    RelayLog.info('üåç Loading boundaries (fail-soft)...');
                    boundaryStatus = 'LOADING';
                    window.__relayBoundaryDatasetStatus = { state: 'OK', missing: 0, first: 'n/a' };
                    
                    Promise.all([
                        boundaryRenderer.loadIsrael(),
                        boundaryRenderer.loadUSA()
                    ]).then(async ([israelCount, usaCount]) => {
                        const totalLoaded = israelCount + usaCount;
                        const suite = boundaryRenderer.runContainmentSelfTest();
                        const stats = (typeof boundaryRenderer.getGeometryStats === 'function')
                            ? boundaryRenderer.getGeometryStats()
                            : { polygons: 0, multipolygons: 0, holes: 0 };
                        RelayLog.info(`[BOUNDARY] containsll suite=${suite.pass ? 'PASS' : 'FAIL'} polygons=${stats.polygons} multipolygons=${stats.multipolygons} holes=${stats.holes}`);
                        RelayLog.info(`[BOUNDARY] containsll hole-suite=${suite.holeSuite?.pass ? 'PASS' : 'FAIL'} probes=${Number(suite.holeSuite?.probes || 0)}`);
                        const holeSuitePass = suite.holeSuite?.pass === true;
                        if (totalLoaded > 0 && suite.pass && holeSuitePass) {
                            boundaryStatus = 'ACTIVE';
                            window.__relayBoundaryDatasetStatus = { state: 'OK', missing: 0, first: 'n/a' };
                            RelayLog.info(`[BOUNDARY] restore result=PASS renderer=BoundaryRenderer containsLL=PASS ISR=${israelCount} USA=${usaCount}`);
                            RelayLog.info(`[GATE] G3 status=PASS evidence=runtime-boundary-selftest`);
                            RelayLog.info('[UX] boundaries=ACTIVE mode=READ_ONLY');
                            setGovernanceVotingScopeMode('boundary-pass');
                        } else {
                            boundaryStatus = 'DEGRADED';
                            const missingSummary = (typeof boundaryRenderer.getMissingBoundarySummary === 'function')
                                ? boundaryRenderer.getMissingBoundarySummary()
                                : { missing: 0, first: 'n/a' };
                            window.__relayBoundaryDatasetStatus = {
                                state: 'DEGRADED',
                                missing: Number(missingSummary.missing || 0),
                                first: String(missingSummary.first || 'n/a')
                            };
                            const coverageReason = holeSuitePass ? 'HOLE_SUITE_PASS' : 'MISSING_HOLE_SUITE_COVERAGE';
                            RelayLog.warn(`[BOUNDARY] restore result=DEGRADED renderer=BoundaryRenderer containsLL=${suite.pass ? 'PASS' : 'FAIL'} coverage=${coverageReason} ISR=${israelCount} USA=${usaCount}`);
                            RelayLog.warn('[GATE] G3 status=DEGRADED evidence=runtime-boundary-selftest');
                            RelayLog.warn('[UX] boundaries=DEGRADED');
                            setGovernanceVotingScopeMode('boundary-degraded');
                        }
                        if (RELAY_PROFILE === 'world' && worldGlobeManager) {
                            await worldGlobeManager.initialize();
                            await worldGlobeManager.setClusterLevel('globe');
                            bindWorldClusterControls();
                            bindWorldRegionControls();
                        }
                    }).catch(error => {
                        boundaryStatus = 'DEGRADED';
                        window.__relayBoundaryDatasetStatus = { state: 'DEGRADED', missing: 0, first: 'n/a' };
                        RelayLog.warn('‚ö†Ô∏è Boundaries DEGRADED: Load failed (continuing without):', error.message);
                        RelayLog.warn('[GATE] G3 status=DEGRADED evidence=boundary-load-error');
                        RelayLog.warn('[UX] boundaries=DEGRADED');
                        setGovernanceVotingScopeMode('boundary-load-error');
                    });
                } else {
                    RelayLog.warn('‚ö†Ô∏è Boundaries DISABLED (ENABLE_BOUNDARIES = false)');
                    setGovernanceVotingScopeMode('boundaries-disabled-by-flag');
                }
                
                // Initialize Boundary Editor (Phase A1: Commit-Governed)
                if (ENABLE_BOUNDARIES && boundaryRenderer) {
                    boundaryEditor = new BoundaryEditor(viewer, boundaryRenderer, {
                        getRelayState: () => relayState,
                        getScopeManager: () => restore3ScopeManager
                    });
                    window.boundaryEditor = boundaryEditor;
                }
                if (!Array.isArray(window.__relayBoundaryCommits)) {
                    window.__relayBoundaryCommits = [];
                }
                
                // Expose capability status for HUD
                window.getBoundaryStatus = () => boundaryStatus;
                window.getGovernanceVotingScopeMode = () => governanceVotingScopeMode;
                window.getFilamentMode = () => 'PRIMITIVE';  // Phase 2.1: Now using primitives
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // SINGLE BRANCH PROOF MODE (Step 1)
                // Phase 2.1 PASSED - Now restoring full tree (Phase 2.2)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                window.SINGLE_BRANCH_PROOF = false;  // Full tree by default
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // DEMO TREE: Show filament system working immediately
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                RelayLog.info('üå≤ Loading demo tree...');
                
                // Create sample company tree at Tel Aviv
                // CANONICAL PHASE 2.1: ENU-BASED TREE TOPOLOGY
                // 
                // All geometry is now defined in ENU meters (not degree offsets).
                // The lat/lon values below are ONLY for the trunk anchor point.
                // All branches, sheets, and filaments are positioned using ENU offsets
                // in meters via the FilamentRenderer and CANONICAL_LAYOUT constants.
                // 
                // CANONICAL TREE TOPOLOGY:
                // - Trunk: Vertical along ENU Up (local +Z, not world Z)
                // - Branches: Parallel ribs along ENU East (+X), tight spacing in ENU North (+Y)
                // - Sheets: Horizontal planes (ENU Up normal), above branch endpoints
                // - Filaments: Staged (Cell ‚Üí Spine ‚Üí Branch conduit)
                // - Timeboxes: Dynamic spacing (length-derived or commit-window-derived)
                
                const trunkLat = 32.0853;  // Trunk anchor only
                const trunkLon = 34.7818;  // Trunk anchor only
                
                // NOTE: branchSpacing and branchLength below are DEPRECATED
                // All geometry is now computed in ENU meters via CANONICAL_LAYOUT
                // These values are kept for backwards compatibility with sheet lat/lon
                // but are NOT used by the primitive renderer
                const branchSpacing = 0.0002;  // DEPRECATED: Use CANONICAL_LAYOUT.branch.separation (35m)
                const branchLength = 0.005;    // DEPRECATED: Use CANONICAL_LAYOUT.branch.length (800m)
                
                // NOTE: 'timeboxes' is the canonical field name for timebox summary input.
                // This is NOT raw commit log data ‚Äî it is aggregated timebox state used by VIS-4 slab rendering.
                // Shape: { timeboxId, commitCount, openDrifts, eriAvg (0-100), scarCount (0-3+) }
                // The renderer also accepts legacy 'commits' for module-loaded data.
                const demoTree = {
                    nodes: [
                        {
                            id: "trunk.avgol",
                            type: "trunk",
                            name: "Avgol",
                            lat: trunkLat,
                            lon: trunkLon,
                            height: 0,        // Ground
                            alt: 2000,        // Top at 2000m
                            timeboxes: [
                                { timeboxId: 'T1', commitCount: 25, openDrifts: 1, eriAvg: 82, scarCount: 0 },
                                { timeboxId: 'T2', commitCount: 22, openDrifts: 0, eriAvg: 85, scarCount: 0 },
                                { timeboxId: 'T3', commitCount: 28, openDrifts: 2, eriAvg: 78, scarCount: 1 },
                                { timeboxId: 'T4', commitCount: 30, openDrifts: 0, eriAvg: 88, scarCount: 0 },
                                { timeboxId: 'T5', commitCount: 26, openDrifts: 1, eriAvg: 84, scarCount: 0 },
                                { timeboxId: 'T6', commitCount: 32, openDrifts: 3, eriAvg: 76, scarCount: 2 }
                            ]
                        },
                        // BASIN-RING-1 (R3): Extra trunks at same anchor for N=6 basin ring proof (stable sort by id).
                        { id: "trunk.avgol2", type: "trunk", name: "Avgol B2", lat: trunkLat, lon: trunkLon, height: 0, alt: 2000, timeboxes: [] },
                        { id: "trunk.avgol3", type: "trunk", name: "Avgol B3", lat: trunkLat, lon: trunkLon, height: 0, alt: 2000, timeboxes: [] },
                        { id: "trunk.avgol4", type: "trunk", name: "Avgol B4", lat: trunkLat, lon: trunkLon, height: 0, alt: 2000, timeboxes: [] },
                        { id: "trunk.avgol5", type: "trunk", name: "Avgol B5", lat: trunkLat, lon: trunkLon, height: 0, alt: 2000, timeboxes: [] },
                        { id: "trunk.avgol6", type: "trunk", name: "Avgol B6", lat: trunkLat, lon: trunkLon, height: 0, alt: 2000, timeboxes: [] },
                        // ‚ïê‚ïê‚ïê DEPARTMENT BRANCH: Operations ‚ïê‚ïê‚ïê
                        {
                            id: "branch.operations",
                            type: "branch",
                            name: "Operations",
                            parent: "trunk.avgol",
                            lat: trunkLat,
                            lon: trunkLon + branchLength,
                            alt: 2000,
                            // GLOBE-VOTE-VISIBILITY-1: voteStatus controls globe-level visibility
                            // PASSED = visible at globe, PENDING = hidden at globe, shown at company
                            voteStatus: 'PASSED',
                            // VIS-MOCK-TREE-HISTORY-1: 5-timebox architect spec
                            // T0=Import baseline, T1=3 exceptions, T2=2 resolved,
                            // T3=Vendor mismatch, T4=Decision committed
                            timeboxes: [
                                { timeboxId: 'OPS-T0', commitCount: 20, openDrifts: 0, eriAvg: 88, scarCount: 0 },
                                { timeboxId: 'OPS-T1', commitCount: 15, openDrifts: 3, eriAvg: 62, scarCount: 3 },
                                { timeboxId: 'OPS-T2', commitCount: 22, openDrifts: 1, eriAvg: 80, scarCount: 0 },
                                { timeboxId: 'OPS-T3', commitCount: 12, openDrifts: 2, eriAvg: 70, scarCount: 1 },
                                { timeboxId: 'OPS-T4', commitCount: 28, openDrifts: 0, eriAvg: 90, scarCount: 0 }
                            ]
                        },
                        // ‚ïê‚ïê‚ïê DEPARTMENT BRANCH: Finance ‚ïê‚ïê‚ïê
                        {
                            id: "branch.finance",
                            type: "branch",
                            name: "Finance",
                            parent: "trunk.avgol",
                            lat: trunkLat + branchSpacing,
                            lon: trunkLon + branchLength,
                            alt: 2000,
                            // GLOBE-VOTE-VISIBILITY-1: PENDING = hidden at globe, visible at company
                            voteStatus: 'PENDING',
                            timeboxes: [
                                { timeboxId: 'FIN-T1', commitCount: 18, openDrifts: 0, eriAvg: 85, scarCount: 0 },
                                { timeboxId: 'FIN-T2', commitCount: 22, openDrifts: 1, eriAvg: 78, scarCount: 0 },
                                { timeboxId: 'FIN-T3', commitCount: 15, openDrifts: 0, eriAvg: 82, scarCount: 0 },
                                { timeboxId: 'FIN-T4', commitCount: 20, openDrifts: 2, eriAvg: 72, scarCount: 1 }
                            ]
                        },
                        // ‚ïê‚ïê‚ïê DEPARTMENT BRANCH: Supply Chain ‚ïê‚ïê‚ïê
                        {
                            id: "branch.supplychain",
                            type: "branch",
                            name: "Supply Chain",
                            parent: "trunk.avgol",
                            lat: trunkLat - branchSpacing,
                            lon: trunkLon + branchLength,
                            alt: 2000,
                            // GLOBE-VOTE-VISIBILITY-1: PASSED = visible at globe
                            voteStatus: 'PASSED',
                            timeboxes: [
                                { timeboxId: 'SCM-T0', commitCount: 10, openDrifts: 0, eriAvg: 90, scarCount: 0 },
                                { timeboxId: 'SCM-T1', commitCount: 14, openDrifts: 1, eriAvg: 75, scarCount: 0 },
                                { timeboxId: 'SCM-T2', commitCount: 20, openDrifts: 3, eriAvg: 58, scarCount: 2 },
                                { timeboxId: 'SCM-T3', commitCount: 16, openDrifts: 0, eriAvg: 80, scarCount: 0 },
                                { timeboxId: 'SCM-T4', commitCount: 24, openDrifts: 0, eriAvg: 88, scarCount: 0 }
                            ]
                        },
                        // ‚ïê‚ïê‚ïê SHEETS: Operations ‚ïê‚ïê‚ïê
                        {
                            id: "sheet.packaging",
                            type: "sheet",
                            name: "Packaging Division",
                            parent: "branch.operations",
                            lat: trunkLat,
                            lon: trunkLon + branchLength,
                            alt: 2300,
                            eri: 85,
                            rows: 10,
                            cols: 6,
                            cellData: [
                                { row: 0, col: 0, timeboxCount: 8, hasFormula: false, value: 'Q1 Revenue', display: 'Q1 Revenue' },
                                { row: 0, col: 1, timeboxCount: 5, hasFormula: false, value: 'Q2 Revenue', display: 'Q2 Revenue' },
                                { row: 0, col: 2, timeboxCount: 12, hasFormula: false, value: 'Q3 Revenue', display: 'Q3 Revenue' },
                                { row: 0, col: 3, timeboxCount: 3, hasFormula: false, value: 'Q4 Revenue', display: 'Q4 Revenue' },
                                { row: 0, col: 4, timeboxCount: 10, hasFormula: false, value: 'Total', display: 'Total' },
                                { row: 0, col: 5, timeboxCount: 6, hasFormula: false, value: 'Avg', display: 'Avg' },
                                { row: 1, col: 0, timeboxCount: 15, hasFormula: false, value: 120, display: '120' },
                                { row: 1, col: 1, timeboxCount: 4, hasFormula: false, value: 150, display: '150' },
                                { row: 1, col: 2, timeboxCount: 9, hasFormula: false, value: 180, display: '180' },
                                { row: 1, col: 3, timeboxCount: 7, hasFormula: false, value: 200, display: '200' },
                                { row: 1, col: 4, timeboxCount: 11, hasFormula: true, formula: '=A2+B2+C2+D2' },
                                { row: 1, col: 5, timeboxCount: 2, hasFormula: true, formula: '=E2/4' },
                                { row: 2, col: 0, timeboxCount: 6, hasFormula: false, value: 85, display: '85' },
                                { row: 2, col: 1, timeboxCount: 13, hasFormula: false, value: 92, display: '92' },
                                { row: 2, col: 2, timeboxCount: 8, hasFormula: false, value: 110, display: '110' },
                                { row: 2, col: 3, timeboxCount: 10, hasFormula: false, value: 125, display: '125' },
                                { row: 2, col: 4, timeboxCount: 5, hasFormula: true, formula: '=A3+B3+C3+D3' },
                                { row: 2, col: 5, timeboxCount: 14, hasFormula: true, formula: '=E3/4' },
                                { row: 3, col: 0, timeboxCount: 4, hasFormula: false, value: 45, display: '45' },
                                { row: 3, col: 1, timeboxCount: 7, hasFormula: false, value: 60, display: '60' },
                                { row: 3, col: 2, timeboxCount: 3, hasFormula: false, value: 55, display: '55' },
                                { row: 3, col: 3, timeboxCount: 12, hasFormula: false, value: 70, display: '70' },
                                { row: 3, col: 4, timeboxCount: 6, hasFormula: true, formula: '=A4+B4+C4+D4' },
                                { row: 3, col: 5, timeboxCount: 9, hasFormula: true, formula: '=E4/4' },
                                { row: 4, col: 0, timeboxCount: 11, hasFormula: false, value: 210, display: '210' },
                                { row: 4, col: 1, timeboxCount: 5, hasFormula: false, value: 230, display: '230' },
                                { row: 4, col: 2, timeboxCount: 8, hasFormula: false, value: 250, display: '250' },
                                { row: 4, col: 3, timeboxCount: 4, hasFormula: false, value: 275, display: '275' },
                                { row: 4, col: 4, timeboxCount: 10, hasFormula: true, formula: '=A5+B5+C5+D5' },
                                { row: 4, col: 5, timeboxCount: 7, hasFormula: true, formula: '=E5/4' },
                                { row: 5, col: 0, timeboxCount: 6, hasFormula: true, formula: '=SUM(A2:A5)' },
                                { row: 5, col: 1, timeboxCount: 14, hasFormula: true, formula: '=SUM(B2:B5)' },
                                { row: 5, col: 2, timeboxCount: 3, hasFormula: true, formula: '=SUM(C2:C5)' },
                                { row: 5, col: 3, timeboxCount: 9, hasFormula: true, formula: '=SUM(D2:D5)' },
                                { row: 5, col: 4, timeboxCount: 5, hasFormula: true, formula: '=SUM(E2:E5)' },
                                { row: 5, col: 5, timeboxCount: 12, hasFormula: true, formula: '=E6/4' },
                                { row: 6, col: 0, timeboxCount: 8, hasFormula: true, formula: '=D2/A2' },
                                { row: 6, col: 1, timeboxCount: 4, hasFormula: true, formula: '=D3/A3' },
                                { row: 6, col: 2, timeboxCount: 11, hasFormula: true, formula: '=D4/A4' },
                                { row: 6, col: 3, timeboxCount: 6, hasFormula: true, formula: '=D5/A5' },
                                { row: 6, col: 4, timeboxCount: 13, hasFormula: true, formula: '=AVERAGE(A7:D7)' },
                                { row: 6, col: 5, timeboxCount: 7, hasFormula: false, value: 'Growth', display: 'Growth' },
                                { row: 7, col: 0, timeboxCount: 5, hasFormula: true, formula: '=MAX(A2:A5)' },
                                { row: 7, col: 1, timeboxCount: 10, hasFormula: true, formula: '=MAX(B2:B5)' },
                                { row: 7, col: 2, timeboxCount: 4, hasFormula: true, formula: '=MAX(C2:C5)' },
                                { row: 7, col: 3, timeboxCount: 8, hasFormula: true, formula: '=MAX(D2:D5)' },
                                { row: 7, col: 4, timeboxCount: 6, hasFormula: true, formula: '=MAX(E2:E5)' },
                                { row: 7, col: 5, timeboxCount: 15, hasFormula: false, value: 'Max', display: 'Max' },
                                { row: 8, col: 0, timeboxCount: 2, hasFormula: true, formula: '=IF(A2>100,"High","Low")' },
                                { row: 8, col: 1, timeboxCount: 2, hasFormula: true, formula: '=IF(A3>100,"High","Low")' },
                                { row: 8, col: 2, timeboxCount: 2, hasFormula: true, formula: '=IF(A4>100,"High","Low")' },
                                { row: 8, col: 3, timeboxCount: 2, hasFormula: true, formula: '=IF(A5>100,"High","Low")' },
                                { row: 8, col: 4, timeboxCount: 2, hasFormula: true, formula: '=COUNTIF(A2:A5,">100")' },
                                { row: 8, col: 5, timeboxCount: 2, hasFormula: false, value: 'IF/COUNTIF', display: 'IF/COUNTIF' },
                                { row: 9, col: 0, timeboxCount: 2, hasFormula: true, formula: '=SUMIF(A2:A5,">100",E2:E5)' },
                                { row: 9, col: 1, timeboxCount: 2, hasFormula: true, formula: '=INDEX(A2:D5,2,3)' },
                                { row: 9, col: 2, timeboxCount: 2, hasFormula: true, formula: '=MATCH(210,A2:A5,0)' },
                                { row: 9, col: 3, timeboxCount: 2, hasFormula: true, formula: '=MIN(A2:A5)' },
                                { row: 9, col: 4, timeboxCount: 2, hasFormula: true, formula: '=SUMIF(E2:E5,">500")' },
                                { row: 9, col: 5, timeboxCount: 2, hasFormula: false, value: 'SUMIF/IDX', display: 'SUMIF/IDX' }
                            ]
                        },
                        {
                            id: "sheet.mfg.materialIssues",
                            type: "sheet",
                            name: "Material Issues",
                            parent: "branch.operations",
                            lat: trunkLat,
                            lon: trunkLon + branchLength,
                            alt: 2300,
                            eri: 72,
                            rows: 6,
                            cols: 10,
                            cellData: [
                                // Architect's MFG spec: Item, Line, Batch, Planned Qty, Actual Qty, Variance, Root Cause, Owner, Status, Last Update
                                { row: 0, col: 0, timeboxCount: 1, hasFormula: false, value: 'Item', display: 'Item' },
                                { row: 0, col: 1, timeboxCount: 1, hasFormula: false, value: 'Line', display: 'Line' },
                                { row: 0, col: 2, timeboxCount: 1, hasFormula: false, value: 'Batch', display: 'Batch' },
                                { row: 0, col: 3, timeboxCount: 1, hasFormula: false, value: 'Planned', display: 'Planned' },
                                { row: 0, col: 4, timeboxCount: 1, hasFormula: false, value: 'Actual', display: 'Actual' },
                                { row: 0, col: 5, timeboxCount: 1, hasFormula: false, value: 'Variance', display: 'Variance' },
                                { row: 0, col: 6, timeboxCount: 1, hasFormula: false, value: 'Root Cause', display: 'Root Cause' },
                                { row: 0, col: 7, timeboxCount: 1, hasFormula: false, value: 'Owner', display: 'Owner' },
                                { row: 0, col: 8, timeboxCount: 1, hasFormula: false, value: 'Status', display: 'Status' },
                                { row: 0, col: 9, timeboxCount: 1, hasFormula: false, value: 'Updated', display: 'Updated' },
                                { row: 1, col: 0, timeboxCount: 4, hasFormula: false, value: 'Resin_A', display: 'Resin_A' },
                                { row: 1, col: 1, timeboxCount: 3, hasFormula: false, value: 'Line_2', display: 'Line_2' },
                                { row: 1, col: 2, timeboxCount: 2, hasFormula: false, value: '1841', display: '1841' },
                                { row: 1, col: 3, timeboxCount: 5, hasFormula: false, value: 1000, display: '1000' },
                                { row: 1, col: 4, timeboxCount: 6, hasFormula: false, value: 920, display: '920' },
                                { row: 1, col: 5, timeboxCount: 8, hasFormula: true, formula: '=D2-E2' },
                                { row: 1, col: 6, timeboxCount: 3, hasFormula: false, value: 'Moisture', display: 'Moisture' },
                                { row: 1, col: 7, timeboxCount: 2, hasFormula: false, value: 'QA', display: 'QA' },
                                { row: 1, col: 8, timeboxCount: 7, hasFormula: false, value: 'OPEN', display: 'OPEN' },
                                { row: 1, col: 9, timeboxCount: 1, hasFormula: false, value: '2026-02-10', display: '2026-02-10' },
                                { row: 2, col: 0, timeboxCount: 3, hasFormula: false, value: 'Resin_B', display: 'Resin_B' },
                                { row: 2, col: 1, timeboxCount: 2, hasFormula: false, value: 'Line_1', display: 'Line_1' },
                                { row: 2, col: 2, timeboxCount: 1, hasFormula: false, value: '1842', display: '1842' },
                                { row: 2, col: 3, timeboxCount: 4, hasFormula: false, value: 500, display: '500' },
                                { row: 2, col: 4, timeboxCount: 3, hasFormula: false, value: 505, display: '505' },
                                { row: 2, col: 5, timeboxCount: 5, hasFormula: true, formula: '=D3-E3' },
                                { row: 2, col: 6, timeboxCount: 2, hasFormula: false, value: 'Scale cal', display: 'Scale cal' },
                                { row: 2, col: 7, timeboxCount: 1, hasFormula: false, value: 'MFG', display: 'MFG' },
                                { row: 2, col: 8, timeboxCount: 4, hasFormula: false, value: 'RESOLVED', display: 'RESOLVED' },
                                { row: 2, col: 9, timeboxCount: 1, hasFormula: false, value: '2026-02-12', display: '2026-02-12' },
                                { row: 3, col: 0, timeboxCount: 2, hasFormula: false, value: 'Poly_C', display: 'Poly_C' },
                                { row: 3, col: 1, timeboxCount: 3, hasFormula: false, value: 'Line_3', display: 'Line_3' },
                                { row: 3, col: 2, timeboxCount: 1, hasFormula: false, value: '1843', display: '1843' },
                                { row: 3, col: 3, timeboxCount: 6, hasFormula: false, value: 750, display: '750' },
                                { row: 3, col: 4, timeboxCount: 5, hasFormula: false, value: 740, display: '740' },
                                { row: 3, col: 5, timeboxCount: 3, hasFormula: true, formula: '=D4-E4' },
                                { row: 3, col: 6, timeboxCount: 2, hasFormula: false, value: 'Feeder', display: 'Feeder' },
                                { row: 3, col: 7, timeboxCount: 1, hasFormula: false, value: 'MFG', display: 'MFG' },
                                { row: 3, col: 8, timeboxCount: 3, hasFormula: false, value: 'RESOLVED', display: 'RESOLVED' },
                                { row: 3, col: 9, timeboxCount: 1, hasFormula: false, value: '2026-02-11', display: '2026-02-11' },
                                { row: 4, col: 0, timeboxCount: 5, hasFormula: false, value: 'Adh_D', display: 'Adh_D' },
                                { row: 4, col: 1, timeboxCount: 2, hasFormula: false, value: 'Line_2', display: 'Line_2' },
                                { row: 4, col: 2, timeboxCount: 1, hasFormula: false, value: '1844', display: '1844' },
                                { row: 4, col: 3, timeboxCount: 4, hasFormula: false, value: 300, display: '300' },
                                { row: 4, col: 4, timeboxCount: 6, hasFormula: false, value: 310, display: '310' },
                                { row: 4, col: 5, timeboxCount: 3, hasFormula: true, formula: '=D5-E5' },
                                { row: 4, col: 6, timeboxCount: 1, hasFormula: false, value: 'Temp drift', display: 'Temp drift' },
                                { row: 4, col: 7, timeboxCount: 2, hasFormula: false, value: 'QA', display: 'QA' },
                                { row: 4, col: 8, timeboxCount: 5, hasFormula: false, value: 'OPEN', display: 'OPEN' },
                                { row: 4, col: 9, timeboxCount: 1, hasFormula: false, value: '2026-02-13', display: '2026-02-13' },
                                // Summary row
                                { row: 5, col: 3, timeboxCount: 2, hasFormula: true, formula: '=SUM(D2:D5)' },
                                { row: 5, col: 4, timeboxCount: 2, hasFormula: true, formula: '=SUM(E2:E5)' },
                                { row: 5, col: 5, timeboxCount: 2, hasFormula: true, formula: '=SUM(F2:F5)' },
                                { row: 5, col: 8, timeboxCount: 3, hasFormula: true, formula: '=COUNTIF(I2:I5,"OPEN")' }
                            ]
                        },
                        // ‚ïê‚ïê‚ïê SHEETS: Finance ‚ïê‚ïê‚ïê
                        {
                            id: "sheet.fin.apAging",
                            type: "sheet",
                            name: "AP Aging",
                            parent: "branch.finance",
                            lat: trunkLat + branchSpacing,
                            lon: trunkLon + branchLength,
                            alt: 2300,
                            eri: 78,
                            rows: 8,
                            cols: 10,
                            cellData: [
                                { row: 0, col: 0, timeboxCount: 1, hasFormula: false, value: 'Vendor', display: 'Vendor' },
                                { row: 0, col: 1, timeboxCount: 1, hasFormula: false, value: 'Invoice#', display: 'Invoice#' },
                                { row: 0, col: 2, timeboxCount: 1, hasFormula: false, value: 'Amount', display: 'Amount' },
                                { row: 0, col: 3, timeboxCount: 1, hasFormula: false, value: 'Due Date', display: 'Due Date' },
                                { row: 0, col: 4, timeboxCount: 1, hasFormula: false, value: 'Days Out', display: 'Days Out' },
                                { row: 0, col: 5, timeboxCount: 1, hasFormula: false, value: 'Status', display: 'Status' },
                                { row: 0, col: 6, timeboxCount: 1, hasFormula: false, value: 'Category', display: 'Category' },
                                { row: 0, col: 7, timeboxCount: 1, hasFormula: false, value: 'Currency', display: 'Currency' },
                                { row: 0, col: 8, timeboxCount: 1, hasFormula: false, value: 'Approver', display: 'Approver' },
                                { row: 0, col: 9, timeboxCount: 1, hasFormula: false, value: 'Notes', display: 'Notes' },
                                { row: 1, col: 0, timeboxCount: 4, hasFormula: false, value: 'Acme Corp', display: 'Acme Corp' },
                                { row: 1, col: 2, timeboxCount: 6, hasFormula: false, value: 45000, display: '45,000' },
                                { row: 1, col: 4, timeboxCount: 8, hasFormula: false, value: 32, display: '32' },
                                { row: 1, col: 5, timeboxCount: 5, hasFormula: false, value: 'OVERDUE', display: 'OVERDUE' },
                                { row: 2, col: 0, timeboxCount: 3, hasFormula: false, value: 'TechParts', display: 'TechParts' },
                                { row: 2, col: 2, timeboxCount: 5, hasFormula: false, value: 12500, display: '12,500' },
                                { row: 2, col: 4, timeboxCount: 2, hasFormula: false, value: 15, display: '15' },
                                { row: 2, col: 5, timeboxCount: 3, hasFormula: false, value: 'PENDING', display: 'PENDING' },
                                { row: 7, col: 2, timeboxCount: 2, hasFormula: true, formula: '=SUM(C2:C7)' },
                                { row: 7, col: 4, timeboxCount: 2, hasFormula: true, formula: '=AVERAGE(E2:E7)' }
                            ]
                        },
                        {
                            id: "sheet.fin.cashForecast",
                            type: "sheet",
                            name: "Cash Forecast",
                            parent: "branch.finance",
                            lat: trunkLat + branchSpacing,
                            lon: trunkLon + branchLength,
                            alt: 2300,
                            eri: 82,
                            rows: 6,
                            cols: 8,
                            cellData: [
                                { row: 0, col: 0, timeboxCount: 1, hasFormula: false, value: 'Month', display: 'Month' },
                                { row: 0, col: 1, timeboxCount: 1, hasFormula: false, value: 'Opening', display: 'Opening' },
                                { row: 0, col: 2, timeboxCount: 1, hasFormula: false, value: 'Inflows', display: 'Inflows' },
                                { row: 0, col: 3, timeboxCount: 1, hasFormula: false, value: 'Outflows', display: 'Outflows' },
                                { row: 0, col: 4, timeboxCount: 1, hasFormula: false, value: 'Net', display: 'Net' },
                                { row: 0, col: 5, timeboxCount: 1, hasFormula: false, value: 'Closing', display: 'Closing' },
                                { row: 0, col: 6, timeboxCount: 1, hasFormula: false, value: 'Variance', display: 'Variance' },
                                { row: 0, col: 7, timeboxCount: 1, hasFormula: false, value: 'Flag', display: 'Flag' },
                                { row: 1, col: 0, timeboxCount: 3, hasFormula: false, value: 'Jan', display: 'Jan' },
                                { row: 1, col: 1, timeboxCount: 4, hasFormula: false, value: 500000, display: '500K' },
                                { row: 1, col: 2, timeboxCount: 6, hasFormula: false, value: 320000, display: '320K' },
                                { row: 1, col: 3, timeboxCount: 5, hasFormula: false, value: 280000, display: '280K' },
                                { row: 1, col: 4, timeboxCount: 7, hasFormula: true, formula: '=C2-D2' },
                                { row: 1, col: 5, timeboxCount: 4, hasFormula: true, formula: '=B2+E2' }
                            ]
                        },
                        // ‚ïê‚ïê‚ïê DEPARTMENT BRANCH: Quality ‚ïê‚ïê‚ïê
                        // COMPANY-TREE-TEMPLATE-DENSITY-1: new dept for tree crown density
                        {
                            id: "branch.quality",
                            type: "branch",
                            name: "Quality",
                            parent: "trunk.avgol",
                            lat: trunkLat + branchSpacing * 2,
                            lon: trunkLon + branchLength,
                            alt: 2000,
                            voteStatus: 'PASSED',
                            timeboxes: [
                                { timeboxId: 'QA-T0', commitCount: 16, openDrifts: 0, eriAvg: 92, scarCount: 0 },
                                { timeboxId: 'QA-T1', commitCount: 20, openDrifts: 1, eriAvg: 85, scarCount: 0 },
                                { timeboxId: 'QA-T2', commitCount: 18, openDrifts: 0, eriAvg: 88, scarCount: 0 },
                                { timeboxId: 'QA-T3', commitCount: 14, openDrifts: 2, eriAvg: 74, scarCount: 1 },
                                { timeboxId: 'QA-T4', commitCount: 22, openDrifts: 0, eriAvg: 91, scarCount: 0 }
                            ]
                        },
                        // ‚ïê‚ïê‚ïê DEPARTMENT BRANCH: Maintenance ‚ïê‚ïê‚ïê
                        {
                            id: "branch.maintenance",
                            type: "branch",
                            name: "Maintenance",
                            parent: "trunk.avgol",
                            lat: trunkLat - branchSpacing * 2,
                            lon: trunkLon + branchLength,
                            alt: 2000,
                            voteStatus: 'PENDING',
                            timeboxes: [
                                { timeboxId: 'MNT-T0', commitCount: 12, openDrifts: 0, eriAvg: 80, scarCount: 0 },
                                { timeboxId: 'MNT-T1', commitCount: 18, openDrifts: 4, eriAvg: 55, scarCount: 2 },
                                { timeboxId: 'MNT-T2', commitCount: 15, openDrifts: 1, eriAvg: 78, scarCount: 0 },
                                { timeboxId: 'MNT-T3', commitCount: 20, openDrifts: 0, eriAvg: 86, scarCount: 0 }
                            ]
                        },
                        // ‚ïê‚ïê‚ïê DEPARTMENT BRANCH: IT/Engineering ‚ïê‚ïê‚ïê
                        {
                            id: "branch.it",
                            type: "branch",
                            name: "IT & Engineering",
                            parent: "trunk.avgol",
                            lat: trunkLat + branchSpacing * 3,
                            lon: trunkLon + branchLength,
                            alt: 2000,
                            voteStatus: 'PASSED',
                            timeboxes: [
                                { timeboxId: 'IT-T0', commitCount: 30, openDrifts: 0, eriAvg: 95, scarCount: 0 },
                                { timeboxId: 'IT-T1', commitCount: 25, openDrifts: 1, eriAvg: 88, scarCount: 0 },
                                { timeboxId: 'IT-T2', commitCount: 28, openDrifts: 0, eriAvg: 92, scarCount: 0 },
                                { timeboxId: 'IT-T3', commitCount: 22, openDrifts: 3, eriAvg: 65, scarCount: 2 },
                                { timeboxId: 'IT-T4', commitCount: 35, openDrifts: 0, eriAvg: 94, scarCount: 0 }
                            ]
                        },
                        // ‚ïê‚ïê‚ïê SHEETS: Operations (adding 1 more for density) ‚ïê‚ïê‚ïê
                        {
                            id: "sheet.ops.productionSummary",
                            type: "sheet",
                            name: "Production Summary",
                            parent: "branch.operations",
                            lat: trunkLat, lon: trunkLon + branchLength, alt: 2300,
                            eri: 90, rows: 6, cols: 8,
                            cellData: [
                                { row: 0, col: 0, timeboxCount: 1, hasFormula: false, value: 'Line', display: 'Line' },
                                { row: 0, col: 1, timeboxCount: 1, hasFormula: false, value: 'Output', display: 'Output' },
                                { row: 0, col: 2, timeboxCount: 1, hasFormula: false, value: 'Target', display: 'Target' },
                                { row: 0, col: 3, timeboxCount: 1, hasFormula: false, value: 'Efficiency', display: 'Efficiency' },
                                { row: 0, col: 4, timeboxCount: 1, hasFormula: false, value: 'Downtime', display: 'Downtime' },
                                { row: 0, col: 5, timeboxCount: 1, hasFormula: false, value: 'Scrap %', display: 'Scrap %' },
                                { row: 0, col: 6, timeboxCount: 1, hasFormula: false, value: 'OEE', display: 'OEE' },
                                { row: 0, col: 7, timeboxCount: 1, hasFormula: false, value: 'Status', display: 'Status' },
                                { row: 1, col: 0, timeboxCount: 3, hasFormula: false, value: 'Line_1', display: 'Line_1' },
                                { row: 1, col: 1, timeboxCount: 5, hasFormula: false, value: 4200, display: '4,200' },
                                { row: 1, col: 2, timeboxCount: 4, hasFormula: false, value: 5000, display: '5,000' },
                                { row: 1, col: 3, timeboxCount: 6, hasFormula: true, formula: '=B2/C2' }
                            ]
                        },
                        // ‚ïê‚ïê‚ïê SHEETS: Operations (adding shift report for 20+ density) ‚ïê‚ïê‚ïê
                        {
                            id: "sheet.ops.shiftReport",
                            type: "sheet",
                            name: "Shift Report",
                            parent: "branch.operations",
                            lat: trunkLat, lon: trunkLon + branchLength, alt: 2300,
                            eri: 78, rows: 6, cols: 8,
                            cellData: [
                                { row: 0, col: 0, timeboxCount: 1, hasFormula: false, value: 'Shift', display: 'Shift' },
                                { row: 0, col: 1, timeboxCount: 1, hasFormula: false, value: 'Operator', display: 'Operator' },
                                { row: 0, col: 2, timeboxCount: 1, hasFormula: false, value: 'Output', display: 'Output' },
                                { row: 0, col: 3, timeboxCount: 1, hasFormula: false, value: 'Scrap', display: 'Scrap' },
                                { row: 0, col: 4, timeboxCount: 1, hasFormula: false, value: 'Downtime', display: 'Downtime' },
                                { row: 0, col: 5, timeboxCount: 1, hasFormula: false, value: 'Safety', display: 'Safety' },
                                { row: 0, col: 6, timeboxCount: 1, hasFormula: false, value: 'Notes', display: 'Notes' },
                                { row: 0, col: 7, timeboxCount: 1, hasFormula: false, value: 'Sign-Off', display: 'Sign-Off' }
                            ]
                        },
                        // ‚ïê‚ïê‚ïê SHEETS: Finance (adding 1 more) ‚ïê‚ïê‚ïê
                        {
                            id: "sheet.fin.budgetVariance",
                            type: "sheet",
                            name: "Budget Variance",
                            parent: "branch.finance",
                            lat: trunkLat + branchSpacing, lon: trunkLon + branchLength, alt: 2300,
                            eri: 80, rows: 6, cols: 6,
                            cellData: [
                                { row: 0, col: 0, timeboxCount: 1, hasFormula: false, value: 'Dept', display: 'Dept' },
                                { row: 0, col: 1, timeboxCount: 1, hasFormula: false, value: 'Budget', display: 'Budget' },
                                { row: 0, col: 2, timeboxCount: 1, hasFormula: false, value: 'Actual', display: 'Actual' },
                                { row: 0, col: 3, timeboxCount: 1, hasFormula: false, value: 'Variance', display: 'Variance' },
                                { row: 0, col: 4, timeboxCount: 1, hasFormula: false, value: '% Used', display: '% Used' },
                                { row: 0, col: 5, timeboxCount: 1, hasFormula: false, value: 'Flag', display: 'Flag' }
                            ]
                        },
                        // ‚ïê‚ïê‚ïê SHEETS: Supply Chain (adding 1 more) ‚ïê‚ïê‚ïê
                        {
                            id: "sheet.scm.inventoryLevels",
                            type: "sheet",
                            name: "Inventory Levels",
                            parent: "branch.supplychain",
                            lat: trunkLat - branchSpacing, lon: trunkLon + branchLength, alt: 2300,
                            eri: 76, rows: 8, cols: 6,
                            cellData: [
                                { row: 0, col: 0, timeboxCount: 1, hasFormula: false, value: 'SKU', display: 'SKU' },
                                { row: 0, col: 1, timeboxCount: 1, hasFormula: false, value: 'On Hand', display: 'On Hand' },
                                { row: 0, col: 2, timeboxCount: 1, hasFormula: false, value: 'Reorder Pt', display: 'Reorder Pt' },
                                { row: 0, col: 3, timeboxCount: 1, hasFormula: false, value: 'Lead Days', display: 'Lead Days' },
                                { row: 0, col: 4, timeboxCount: 1, hasFormula: false, value: 'Safety Stock', display: 'Safety Stock' },
                                { row: 0, col: 5, timeboxCount: 1, hasFormula: false, value: 'Status', display: 'Status' }
                            ]
                        },
                        // ‚ïê‚ïê‚ïê SHEETS: Quality (3 sheets) ‚ïê‚ïê‚ïê
                        {
                            id: "sheet.qa.auditFindings",
                            type: "sheet",
                            name: "Audit Findings",
                            parent: "branch.quality",
                            lat: trunkLat + branchSpacing * 2, lon: trunkLon + branchLength, alt: 2300,
                            eri: 88, rows: 8, cols: 8,
                            cellData: [
                                { row: 0, col: 0, timeboxCount: 1, hasFormula: false, value: 'Finding#', display: 'Finding#' },
                                { row: 0, col: 1, timeboxCount: 1, hasFormula: false, value: 'Area', display: 'Area' },
                                { row: 0, col: 2, timeboxCount: 1, hasFormula: false, value: 'Severity', display: 'Severity' },
                                { row: 0, col: 3, timeboxCount: 1, hasFormula: false, value: 'CAPA', display: 'CAPA' },
                                { row: 0, col: 4, timeboxCount: 1, hasFormula: false, value: 'Owner', display: 'Owner' },
                                { row: 0, col: 5, timeboxCount: 1, hasFormula: false, value: 'Due Date', display: 'Due Date' },
                                { row: 0, col: 6, timeboxCount: 1, hasFormula: false, value: 'Status', display: 'Status' },
                                { row: 0, col: 7, timeboxCount: 1, hasFormula: false, value: 'Evidence', display: 'Evidence' }
                            ]
                        },
                        {
                            id: "sheet.qa.ncTracking",
                            type: "sheet",
                            name: "NC Tracking",
                            parent: "branch.quality",
                            lat: trunkLat + branchSpacing * 2, lon: trunkLon + branchLength, alt: 2300,
                            eri: 72, rows: 6, cols: 8,
                            cellData: [
                                { row: 0, col: 0, timeboxCount: 1, hasFormula: false, value: 'NC#', display: 'NC#' },
                                { row: 0, col: 1, timeboxCount: 1, hasFormula: false, value: 'Product', display: 'Product' },
                                { row: 0, col: 2, timeboxCount: 1, hasFormula: false, value: 'Defect Type', display: 'Defect Type' },
                                { row: 0, col: 3, timeboxCount: 1, hasFormula: false, value: 'Qty Affected', display: 'Qty Affected' },
                                { row: 0, col: 4, timeboxCount: 1, hasFormula: false, value: 'Root Cause', display: 'Root Cause' },
                                { row: 0, col: 5, timeboxCount: 1, hasFormula: false, value: 'Disposition', display: 'Disposition' },
                                { row: 0, col: 6, timeboxCount: 1, hasFormula: false, value: 'Cost Impact', display: 'Cost Impact' },
                                { row: 0, col: 7, timeboxCount: 1, hasFormula: false, value: 'Status', display: 'Status' }
                            ]
                        },
                        {
                            id: "sheet.qa.spcCharts",
                            type: "sheet",
                            name: "SPC Charts",
                            parent: "branch.quality",
                            lat: trunkLat + branchSpacing * 2, lon: trunkLon + branchLength, alt: 2300,
                            eri: 94, rows: 6, cols: 6,
                            cellData: [
                                { row: 0, col: 0, timeboxCount: 1, hasFormula: false, value: 'Parameter', display: 'Parameter' },
                                { row: 0, col: 1, timeboxCount: 1, hasFormula: false, value: 'UCL', display: 'UCL' },
                                { row: 0, col: 2, timeboxCount: 1, hasFormula: false, value: 'Mean', display: 'Mean' },
                                { row: 0, col: 3, timeboxCount: 1, hasFormula: false, value: 'LCL', display: 'LCL' },
                                { row: 0, col: 4, timeboxCount: 1, hasFormula: false, value: 'Cp', display: 'Cp' },
                                { row: 0, col: 5, timeboxCount: 1, hasFormula: false, value: 'Cpk', display: 'Cpk' }
                            ]
                        },
                        // ‚ïê‚ïê‚ïê SHEETS: Maintenance (3 sheets) ‚ïê‚ïê‚ïê
                        {
                            id: "sheet.mnt.workOrders",
                            type: "sheet",
                            name: "Work Orders",
                            parent: "branch.maintenance",
                            lat: trunkLat - branchSpacing * 2, lon: trunkLon + branchLength, alt: 2300,
                            eri: 68, rows: 8, cols: 8,
                            cellData: [
                                { row: 0, col: 0, timeboxCount: 1, hasFormula: false, value: 'WO#', display: 'WO#' },
                                { row: 0, col: 1, timeboxCount: 1, hasFormula: false, value: 'Asset', display: 'Asset' },
                                { row: 0, col: 2, timeboxCount: 1, hasFormula: false, value: 'Type', display: 'Type' },
                                { row: 0, col: 3, timeboxCount: 1, hasFormula: false, value: 'Priority', display: 'Priority' },
                                { row: 0, col: 4, timeboxCount: 1, hasFormula: false, value: 'Assigned', display: 'Assigned' },
                                { row: 0, col: 5, timeboxCount: 1, hasFormula: false, value: 'Est Hours', display: 'Est Hours' },
                                { row: 0, col: 6, timeboxCount: 1, hasFormula: false, value: 'Status', display: 'Status' },
                                { row: 0, col: 7, timeboxCount: 1, hasFormula: false, value: 'Completed', display: 'Completed' }
                            ]
                        },
                        {
                            id: "sheet.mnt.assetRegistry",
                            type: "sheet",
                            name: "Asset Registry",
                            parent: "branch.maintenance",
                            lat: trunkLat - branchSpacing * 2, lon: trunkLon + branchLength, alt: 2300,
                            eri: 82, rows: 6, cols: 8,
                            cellData: [
                                { row: 0, col: 0, timeboxCount: 1, hasFormula: false, value: 'Asset ID', display: 'Asset ID' },
                                { row: 0, col: 1, timeboxCount: 1, hasFormula: false, value: 'Name', display: 'Name' },
                                { row: 0, col: 2, timeboxCount: 1, hasFormula: false, value: 'Location', display: 'Location' },
                                { row: 0, col: 3, timeboxCount: 1, hasFormula: false, value: 'Last PM', display: 'Last PM' },
                                { row: 0, col: 4, timeboxCount: 1, hasFormula: false, value: 'Next PM', display: 'Next PM' },
                                { row: 0, col: 5, timeboxCount: 1, hasFormula: false, value: 'Condition', display: 'Condition' },
                                { row: 0, col: 6, timeboxCount: 1, hasFormula: false, value: 'Criticality', display: 'Criticality' },
                                { row: 0, col: 7, timeboxCount: 1, hasFormula: false, value: 'Cost YTD', display: 'Cost YTD' }
                            ]
                        },
                        {
                            id: "sheet.mnt.sparePartsInventory",
                            type: "sheet",
                            name: "Spare Parts Inventory",
                            parent: "branch.maintenance",
                            lat: trunkLat - branchSpacing * 2, lon: trunkLon + branchLength, alt: 2300,
                            eri: 75, rows: 6, cols: 6,
                            cellData: [
                                { row: 0, col: 0, timeboxCount: 1, hasFormula: false, value: 'Part#', display: 'Part#' },
                                { row: 0, col: 1, timeboxCount: 1, hasFormula: false, value: 'Description', display: 'Description' },
                                { row: 0, col: 2, timeboxCount: 1, hasFormula: false, value: 'Qty', display: 'Qty' },
                                { row: 0, col: 3, timeboxCount: 1, hasFormula: false, value: 'Min Level', display: 'Min Level' },
                                { row: 0, col: 4, timeboxCount: 1, hasFormula: false, value: 'Unit Cost', display: 'Unit Cost' },
                                { row: 0, col: 5, timeboxCount: 1, hasFormula: false, value: 'Reorder', display: 'Reorder' }
                            ]
                        },
                        // ‚ïê‚ïê‚ïê SHEETS: IT & Engineering (4 sheets) ‚ïê‚ïê‚ïê
                        {
                            id: "sheet.it.systemUptime",
                            type: "sheet",
                            name: "System Uptime",
                            parent: "branch.it",
                            lat: trunkLat + branchSpacing * 3, lon: trunkLon + branchLength, alt: 2300,
                            eri: 96, rows: 6, cols: 8,
                            cellData: [
                                { row: 0, col: 0, timeboxCount: 1, hasFormula: false, value: 'System', display: 'System' },
                                { row: 0, col: 1, timeboxCount: 1, hasFormula: false, value: 'Uptime %', display: 'Uptime %' },
                                { row: 0, col: 2, timeboxCount: 1, hasFormula: false, value: 'SLA Target', display: 'SLA Target' },
                                { row: 0, col: 3, timeboxCount: 1, hasFormula: false, value: 'Incidents', display: 'Incidents' },
                                { row: 0, col: 4, timeboxCount: 1, hasFormula: false, value: 'MTTR (hrs)', display: 'MTTR (hrs)' },
                                { row: 0, col: 5, timeboxCount: 1, hasFormula: false, value: 'Last Outage', display: 'Last Outage' },
                                { row: 0, col: 6, timeboxCount: 1, hasFormula: false, value: 'Owner', display: 'Owner' },
                                { row: 0, col: 7, timeboxCount: 1, hasFormula: false, value: 'Tier', display: 'Tier' }
                            ]
                        },
                        {
                            id: "sheet.it.changeRequests",
                            type: "sheet",
                            name: "Change Requests",
                            parent: "branch.it",
                            lat: trunkLat + branchSpacing * 3, lon: trunkLon + branchLength, alt: 2300,
                            eri: 82, rows: 8, cols: 8,
                            cellData: [
                                { row: 0, col: 0, timeboxCount: 1, hasFormula: false, value: 'CR#', display: 'CR#' },
                                { row: 0, col: 1, timeboxCount: 1, hasFormula: false, value: 'System', display: 'System' },
                                { row: 0, col: 2, timeboxCount: 1, hasFormula: false, value: 'Type', display: 'Type' },
                                { row: 0, col: 3, timeboxCount: 1, hasFormula: false, value: 'Risk', display: 'Risk' },
                                { row: 0, col: 4, timeboxCount: 1, hasFormula: false, value: 'Requester', display: 'Requester' },
                                { row: 0, col: 5, timeboxCount: 1, hasFormula: false, value: 'Approver', display: 'Approver' },
                                { row: 0, col: 6, timeboxCount: 1, hasFormula: false, value: 'Scheduled', display: 'Scheduled' },
                                { row: 0, col: 7, timeboxCount: 1, hasFormula: false, value: 'Status', display: 'Status' }
                            ]
                        },
                        {
                            id: "sheet.it.projectTracker",
                            type: "sheet",
                            name: "Project Tracker",
                            parent: "branch.it",
                            lat: trunkLat + branchSpacing * 3, lon: trunkLon + branchLength, alt: 2300,
                            eri: 78, rows: 8, cols: 8,
                            cellData: [
                                { row: 0, col: 0, timeboxCount: 1, hasFormula: false, value: 'Project', display: 'Project' },
                                { row: 0, col: 1, timeboxCount: 1, hasFormula: false, value: 'Phase', display: 'Phase' },
                                { row: 0, col: 2, timeboxCount: 1, hasFormula: false, value: '% Complete', display: '% Complete' },
                                { row: 0, col: 3, timeboxCount: 1, hasFormula: false, value: 'Budget', display: 'Budget' },
                                { row: 0, col: 4, timeboxCount: 1, hasFormula: false, value: 'Spent', display: 'Spent' },
                                { row: 0, col: 5, timeboxCount: 1, hasFormula: false, value: 'PM', display: 'PM' },
                                { row: 0, col: 6, timeboxCount: 1, hasFormula: false, value: 'Risk', display: 'Risk' },
                                { row: 0, col: 7, timeboxCount: 1, hasFormula: false, value: 'ETA', display: 'ETA' }
                            ]
                        },
                        {
                            id: "sheet.it.securityDashboard",
                            type: "sheet",
                            name: "Security Dashboard",
                            parent: "branch.it",
                            lat: trunkLat + branchSpacing * 3, lon: trunkLon + branchLength, alt: 2300,
                            eri: 90, rows: 6, cols: 6,
                            cellData: [
                                { row: 0, col: 0, timeboxCount: 1, hasFormula: false, value: 'Category', display: 'Category' },
                                { row: 0, col: 1, timeboxCount: 1, hasFormula: false, value: 'Open', display: 'Open' },
                                { row: 0, col: 2, timeboxCount: 1, hasFormula: false, value: 'Resolved', display: 'Resolved' },
                                { row: 0, col: 3, timeboxCount: 1, hasFormula: false, value: 'Critical', display: 'Critical' },
                                { row: 0, col: 4, timeboxCount: 1, hasFormula: false, value: 'MTTR', display: 'MTTR' },
                                { row: 0, col: 5, timeboxCount: 1, hasFormula: false, value: 'Trend', display: 'Trend' }
                            ]
                        },
                        // ‚ïê‚ïê‚ïê SHEETS: Supply Chain ‚ïê‚ïê‚ïê
                        {
                            id: "sheet.scm.inboundRequests",
                            type: "sheet",
                            name: "Inbound Requests",
                            parent: "branch.supplychain",
                            lat: trunkLat - branchSpacing,
                            lon: trunkLon + branchLength,
                            alt: 2300,
                            eri: 70,
                            rows: 8,
                            cols: 10,
                            cellData: [
                                { row: 0, col: 0, timeboxCount: 1, hasFormula: false, value: 'Req#', display: 'Req#' },
                                { row: 0, col: 1, timeboxCount: 1, hasFormula: false, value: 'Supplier', display: 'Supplier' },
                                { row: 0, col: 2, timeboxCount: 1, hasFormula: false, value: 'Material', display: 'Material' },
                                { row: 0, col: 3, timeboxCount: 1, hasFormula: false, value: 'Qty', display: 'Qty' },
                                { row: 0, col: 4, timeboxCount: 1, hasFormula: false, value: 'ETA', display: 'ETA' },
                                { row: 0, col: 5, timeboxCount: 1, hasFormula: false, value: 'Status', display: 'Status' },
                                { row: 0, col: 6, timeboxCount: 1, hasFormula: false, value: 'Priority', display: 'Priority' },
                                { row: 0, col: 7, timeboxCount: 1, hasFormula: false, value: 'Dock', display: 'Dock' },
                                { row: 0, col: 8, timeboxCount: 1, hasFormula: false, value: 'PO Ref', display: 'PO Ref' },
                                { row: 0, col: 9, timeboxCount: 1, hasFormula: false, value: 'Notes', display: 'Notes' },
                                { row: 1, col: 0, timeboxCount: 3, hasFormula: false, value: 'REQ-4401', display: 'REQ-4401' },
                                { row: 1, col: 1, timeboxCount: 4, hasFormula: false, value: 'GlobalPoly', display: 'GlobalPoly' },
                                { row: 1, col: 3, timeboxCount: 5, hasFormula: false, value: 2000, display: '2000' },
                                { row: 1, col: 5, timeboxCount: 6, hasFormula: false, value: 'IN_TRANSIT', display: 'IN_TRANSIT' },
                                { row: 1, col: 6, timeboxCount: 2, hasFormula: false, value: 'HIGH', display: 'HIGH' }
                            ]
                        },
                        {
                            id: "sheet.scm.supplierScorecard",
                            type: "sheet",
                            name: "Supplier Scorecard",
                            parent: "branch.supplychain",
                            lat: trunkLat - branchSpacing,
                            lon: trunkLon + branchLength,
                            alt: 2300,
                            eri: 85,
                            rows: 6,
                            cols: 8,
                            cellData: [
                                { row: 0, col: 0, timeboxCount: 1, hasFormula: false, value: 'Supplier', display: 'Supplier' },
                                { row: 0, col: 1, timeboxCount: 1, hasFormula: false, value: 'On-Time %', display: 'On-Time %' },
                                { row: 0, col: 2, timeboxCount: 1, hasFormula: false, value: 'Quality %', display: 'Quality %' },
                                { row: 0, col: 3, timeboxCount: 1, hasFormula: false, value: 'Cost Index', display: 'Cost Index' },
                                { row: 0, col: 4, timeboxCount: 1, hasFormula: false, value: 'Lead Days', display: 'Lead Days' },
                                { row: 0, col: 5, timeboxCount: 1, hasFormula: false, value: 'Score', display: 'Score' },
                                { row: 0, col: 6, timeboxCount: 1, hasFormula: false, value: 'Trend', display: 'Trend' },
                                { row: 0, col: 7, timeboxCount: 1, hasFormula: false, value: 'Tier', display: 'Tier' },
                                { row: 1, col: 0, timeboxCount: 3, hasFormula: false, value: 'GlobalPoly', display: 'GlobalPoly' },
                                { row: 1, col: 1, timeboxCount: 5, hasFormula: false, value: 94, display: '94%' },
                                { row: 1, col: 2, timeboxCount: 4, hasFormula: false, value: 98, display: '98%' },
                                { row: 1, col: 3, timeboxCount: 3, hasFormula: false, value: 1.02, display: '1.02' },
                                { row: 1, col: 4, timeboxCount: 2, hasFormula: false, value: 14, display: '14' },
                                { row: 1, col: 5, timeboxCount: 6, hasFormula: true, formula: '=(B2+C2)/2' },
                                { row: 1, col: 7, timeboxCount: 2, hasFormula: false, value: 'A', display: 'A' }
                            ]
                        },
                    ],
                    edges: [
                        // Trunk ‚Üí Department branches (6 departments)
                        { source: "trunk.avgol", target: "branch.operations" },
                        { source: "trunk.avgol", target: "branch.finance" },
                        { source: "trunk.avgol", target: "branch.supplychain" },
                        { source: "trunk.avgol", target: "branch.quality" },
                        { source: "trunk.avgol", target: "branch.maintenance" },
                        { source: "trunk.avgol", target: "branch.it" },
                        // Operations ‚Üí 4 sheets
                        { source: "branch.operations", target: "sheet.packaging" },
                        { source: "branch.operations", target: "sheet.mfg.materialIssues" },
                        { source: "branch.operations", target: "sheet.ops.productionSummary" },
                        { source: "branch.operations", target: "sheet.ops.shiftReport" },
                        // Finance ‚Üí 3 sheets
                        { source: "branch.finance", target: "sheet.fin.apAging" },
                        { source: "branch.finance", target: "sheet.fin.cashForecast" },
                        { source: "branch.finance", target: "sheet.fin.budgetVariance" },
                        // Supply Chain ‚Üí 3 sheets
                        { source: "branch.supplychain", target: "sheet.scm.inboundRequests" },
                        { source: "branch.supplychain", target: "sheet.scm.supplierScorecard" },
                        { source: "branch.supplychain", target: "sheet.scm.inventoryLevels" },
                        // Quality ‚Üí 3 sheets
                        { source: "branch.quality", target: "sheet.qa.auditFindings" },
                        { source: "branch.quality", target: "sheet.qa.ncTracking" },
                        { source: "branch.quality", target: "sheet.qa.spcCharts" },
                        // Maintenance ‚Üí 3 sheets
                        { source: "branch.maintenance", target: "sheet.mnt.workOrders" },
                        { source: "branch.maintenance", target: "sheet.mnt.assetRegistry" },
                        { source: "branch.maintenance", target: "sheet.mnt.sparePartsInventory" },
                        // IT & Engineering ‚Üí 4 sheets
                        { source: "branch.it", target: "sheet.it.systemUptime" },
                        { source: "branch.it", target: "sheet.it.changeRequests" },
                        { source: "branch.it", target: "sheet.it.projectTracker" },
                        { source: "branch.it", target: "sheet.it.securityDashboard" }
                    ]
                };
                
                // Load demo tree into relayState
                relayState.tree.nodes = demoTree.nodes;
                relayState.tree.edges = demoTree.edges;

                // ‚ïê‚ïê‚ïê FILAMENT-LIFECYCLE-1: Registry + Demo Filaments + State Machines ‚ïê‚ïê‚ïê
                {
                    const now = Date.now();
                    const DAY_MS = 86400000;

                    // --- appendTimeboxEvent: always targets trunk node only ---
                    window.appendTimeboxEvent = function appendTimeboxEvent(trunkNode, event) {
                        if (!trunkNode || trunkNode.type !== 'trunk') {
                            console.log('[TIMEBOX] event REFUSED target is not trunk');
                            return;
                        }
                        if (!trunkNode.timeboxes || !trunkNode.timeboxes.length) return;
                        const latest = trunkNode.timeboxes[trunkNode.timeboxes.length - 1];
                        latest.commitCount = (latest.commitCount || 0) + 1;
                        if (!latest.events) latest.events = [];
                        latest.events.push(event);
                        const line = `[TIMEBOX] event type=${event.type} id=${event.filamentId || event.type} applied=PASS target=${trunkNode.id} timeboxId=${latest.timeboxId}`;
                        RelayLog.info(line);
                        console.log(line);
                        // E1-CRYPTO-1: update timebox Merkle tree (non-mutating of event objects)
                        if (window.__relayCryptoState?.initialized) {
                            updateTimeboxChainEntry(window.__relayCryptoState.tbChain, latest.timeboxId, latest.events).then(entry => {
                                const merkleMsg = `[CRYPTO] merkleUpdate timeboxId=${latest.timeboxId} events=${entry.eventCount} merkleRoot=${entry.merkleRoot.slice(0, 16)}`;
                                RelayLog.info(merkleMsg); console.log(merkleMsg);
                                const rollingMsg = `[CRYPTO] rollingRoot updated=${entry.rollingRoot.slice(0, 16)}`;
                                RelayLog.info(rollingMsg); console.log(rollingMsg);
                            });
                        }
                    };

                    // --- Valid state transitions ---
                    const VALID_WORK_TRANSITIONS = {
                        'DRAFT': ['PROPOSE', 'HOLD', 'REVERT'],
                        'HOLD': ['DRAFT', 'PROPOSE', 'ACTIVE', 'COMMIT', 'REVERT'],
                        'PROPOSE': ['ACTIVE', 'HOLD', 'REVERT'],
                        'ACTIVE': ['COMMIT', 'HOLD', 'REVERT'],
                        'COMMIT': ['HOLD', 'REVERT'],
                        'REVERT': ['DRAFT', 'HOLD']
                    };
                    const VALID_LIFECYCLE_TRANSITIONS = {
                        'OPEN': ['ACTIVE', 'REFUSAL'],
                        'ACTIVE': ['SETTLING', 'REFUSAL'],
                        'SETTLING': ['CLOSED', 'REFUSAL'],
                        'CLOSED': ['ARCHIVED'],
                        'ARCHIVED': [],
                        'REFUSAL': []
                    };

                    // --- transitionWorkState ---
                    window.transitionWorkState = function transitionWorkState(filamentId, newState) {
                        const fil = relayState.filaments.get(filamentId);
                        if (!fil) { console.log(`[FILAMENT] workTransition id=${filamentId} result=NOT_FOUND`); return false; }
                        const valid = VALID_WORK_TRANSITIONS[fil.workState];
                        if (!valid || !valid.includes(newState)) {
                            console.log(`[FILAMENT] workTransition id=${filamentId} from=${fil.workState} to=${newState} result=INVALID`);
                            return false;
                        }
                        const old = fil.workState;
                        fil.workState = newState;
                        fil.updatedAt = Date.now();
                        const line = `[FILAMENT] workTransition id=${filamentId} from=${old} to=${newState} result=PASS`;
                        RelayLog.info(line);
                        console.log(line);
                        return true;
                    };

                    // --- transitionLifecycleState ---
                    window.transitionLifecycleState = function transitionLifecycleState(filamentId, newState) {
                        const fil = relayState.filaments.get(filamentId);
                        if (!fil) { console.log(`[FILAMENT] lifecycleTransition id=${filamentId} result=NOT_FOUND`); return false; }
                        const valid = VALID_LIFECYCLE_TRANSITIONS[fil.lifecycleState];
                        if (!valid || !valid.includes(newState)) {
                            console.log(`[FILAMENT] lifecycleTransition id=${filamentId} from=${fil.lifecycleState} to=${newState} result=INVALID`);
                            return false;
                        }

                        // Closure enforcement (Tightening 2)
                        if (newState === 'CLOSED') {
                            const branch = (relayState.tree.nodes || []).find(n => n.id === fil.branchId);
                            // Check workState
                            if (fil.workState !== 'COMMIT') {
                                const refLine = `[REFUSAL] reason=FILAMENT_CLOSE_BLOCKED_WORK_STATE filament=${filamentId}`;
                                RelayLog.info(refLine);
                                console.log(refLine);
                                return false;
                            }
                            // Check governance
                            if (branch && branch.voteStatus === 'REJECTED') {
                                const refLine = `[REFUSAL] reason=FILAMENT_CLOSE_BLOCKED_GOVERNANCE filament=${filamentId}`;
                                RelayLog.info(refLine);
                                console.log(refLine);
                                return false;
                            }
                            // Check openDrifts on filament's timebox
                            if (branch && branch.timeboxes) {
                                const tb = branch.timeboxes.find(t => t.timeboxId === fil.timeboxId);
                                if (tb && (tb.openDrifts || 0) > 0) {
                                    const refLine = `[REFUSAL] reason=FILAMENT_CLOSE_BLOCKED_DRIFTS filament=${filamentId}`;
                                    RelayLog.info(refLine);
                                    console.log(refLine);
                                    return false;
                                }
                            }
                        }

                        const old = fil.lifecycleState;
                        fil.lifecycleState = newState;
                        fil.updatedAt = Date.now();

                        if (newState === 'SETTLING') {
                            fil.settledAt = Date.now();
                        }
                        if (newState === 'CLOSED') {
                            fil.closedAt = Date.now();
                            fil.turnoverMs = fil.closedAt - fil.openedAt;
                            const turnLine = `[FILAMENT] turnover id=${filamentId} durationMs=${fil.turnoverMs} branch=${fil.branchId} result=PASS`;
                            RelayLog.info(turnLine);
                            console.log(turnLine);
                        }
                        if (newState === 'ARCHIVED') {
                            fil.archivedAt = Date.now();
                            // Trunk absorption (Tightening 3)
                            const trunkNode = (relayState.tree.nodes || []).find(n => n.type === 'trunk' && n.id === 'trunk.avgol');
                            if (trunkNode) {
                                window.appendTimeboxEvent(trunkNode, {
                                    type: 'FILAMENT_ARCHIVE',
                                    filamentId: fil.filamentId,
                                    magnitude: fil.magnitude,
                                    branchId: fil.branchId,
                                    turnoverMs: fil.turnoverMs || 0
                                });
                            }
                            // Branch-level turnover aggregate
                            const branchFilaments = [];
                            for (const [, f] of relayState.filaments) {
                                if (f.branchId === fil.branchId && f.closedAt && f.turnoverMs > 0) {
                                    branchFilaments.push(f);
                                }
                            }
                            if (branchFilaments.length > 0) {
                                const avgMs = Math.round(branchFilaments.reduce((s, f) => s + f.turnoverMs, 0) / branchFilaments.length);
                                const aggLine = `[FILAMENT] branchTurnover branch=${fil.branchId} avgMs=${avgMs} closedCount=${branchFilaments.length} result=PASS`;
                                RelayLog.info(aggLine);
                                console.log(aggLine);
                            }
                        }

                        const line = `[FILAMENT] lifecycleTransition id=${filamentId} from=${old} to=${newState} result=PASS`;
                        RelayLog.info(line);
                        console.log(line);
                        return true;
                    };

                    // --- Create 6 demo filaments ---
                    const demoFilaments = [
                        {
                            filamentId: 'FIL-001', sourceEntityId: 'customer.acme', targetEntityId: 'trunk.avgol',
                            branchId: 'branch.finance', sheetId: 'sheet.fin.apAging', cellId: null,
                            workState: 'DRAFT', lifecycleState: 'OPEN',
                            openedAt: now - 2 * DAY_MS, updatedAt: now - 2 * DAY_MS,
                            closedAt: null, settledAt: null, archivedAt: null,
                            magnitude: 15000, evidencePointers: [], visibilityScope: 'PRIVATE',
                            timeboxId: 'FIN-T4', turnoverMs: null
                        },
                        {
                            filamentId: 'FIL-002', sourceEntityId: 'customer.beta', targetEntityId: 'trunk.avgol',
                            branchId: 'branch.finance', sheetId: 'sheet.fin.cashForecast', cellId: null,
                            workState: 'ACTIVE', lifecycleState: 'ACTIVE',
                            openedAt: now - 5 * DAY_MS, updatedAt: now - 1 * DAY_MS,
                            closedAt: null, settledAt: null, archivedAt: null,
                            magnitude: 32000, evidencePointers: [], visibilityScope: 'PRIVATE',
                            timeboxId: 'FIN-T3', turnoverMs: null
                        },
                        {
                            filamentId: 'FIL-003', sourceEntityId: 'customer.gamma', targetEntityId: 'trunk.avgol',
                            branchId: 'branch.finance', sheetId: 'sheet.fin.budgetVariance', cellId: null,
                            workState: 'COMMIT', lifecycleState: 'SETTLING',
                            openedAt: now - 10 * DAY_MS, updatedAt: now,
                            closedAt: null, settledAt: now - 1 * DAY_MS, archivedAt: null,
                            magnitude: 48000, evidencePointers: [], visibilityScope: 'PRIVATE',
                            timeboxId: 'FIN-T1', turnoverMs: null
                        },
                        {
                            filamentId: 'FIL-004', sourceEntityId: 'vendor.delta', targetEntityId: 'trunk.avgol',
                            branchId: 'branch.maintenance', sheetId: 'sheet.mnt.workOrders', cellId: null,
                            workState: 'COMMIT', lifecycleState: 'CLOSED',
                            openedAt: now - 14 * DAY_MS, updatedAt: now - 3 * DAY_MS,
                            closedAt: now - 3 * DAY_MS, settledAt: now - 5 * DAY_MS, archivedAt: null,
                            magnitude: 22000, evidencePointers: [], visibilityScope: 'PRIVATE',
                            timeboxId: 'MNT-T0', turnoverMs: (now - 3 * DAY_MS) - (now - 14 * DAY_MS)
                        },
                        {
                            filamentId: 'FIL-005', sourceEntityId: 'vendor.epsilon', targetEntityId: 'trunk.avgol',
                            branchId: 'branch.maintenance', sheetId: 'sheet.mnt.assetRegistry', cellId: null,
                            workState: 'COMMIT', lifecycleState: 'ARCHIVED',
                            openedAt: now - 30 * DAY_MS, updatedAt: now - 10 * DAY_MS,
                            closedAt: now - 12 * DAY_MS, settledAt: now - 15 * DAY_MS, archivedAt: now - 10 * DAY_MS,
                            magnitude: 8500, evidencePointers: [], visibilityScope: 'PRIVATE',
                            timeboxId: 'MNT-T0', turnoverMs: (now - 12 * DAY_MS) - (now - 30 * DAY_MS)
                        },
                        {
                            filamentId: 'FIL-006', sourceEntityId: 'vendor.zeta', targetEntityId: 'trunk.avgol',
                            branchId: 'branch.maintenance', sheetId: 'sheet.mnt.sparePartsInventory', cellId: null,
                            workState: 'REVERT', lifecycleState: 'REFUSAL',
                            openedAt: now - 7 * DAY_MS, updatedAt: now - 2 * DAY_MS,
                            closedAt: null, settledAt: null, archivedAt: null,
                            magnitude: 5000, evidencePointers: [], visibilityScope: 'PRIVATE',
                            timeboxId: 'MNT-T1', turnoverMs: null
                        }
                    ];

                    // Register in global filament registry
                    for (const fil of demoFilaments) {
                        relayState.filaments.set(fil.filamentId, fil);
                    }

                    // Add filamentIds references to branch nodes
                    for (const node of relayState.tree.nodes) {
                        if (node.type === 'branch') {
                            node.filamentIds = [];
                            for (const [fId, fil] of relayState.filaments) {
                                if (fil.branchId === node.id) {
                                    node.filamentIds.push(fId);
                                }
                            }
                        }
                    }

                    const regLine = `[FILAMENT] registry initialized=PASS total=${relayState.filaments.size}`;
                    RelayLog.info(regLine);
                    console.log(regLine);
                }
                // ‚ïê‚ïê‚ïê END FILAMENT-LIFECYCLE-1 ‚ïê‚ïê‚ïê

                // ‚ïê‚ïê‚ïê FILAMENT-DISCLOSURE-1: Visibility Physics ‚ïê‚ïê‚ïê
                {
                    // --- Visibility tier ordering (monotonic, no retraction) ---
                    const VISIBILITY_TIERS = ['PRIVATE', 'WITNESSED', 'PUBLIC_SUMMARY', 'FULL_PUBLIC'];
                    const VISIBILITY_RANK = { PRIVATE: 0, WITNESSED: 1, PUBLIC_SUMMARY: 2, FULL_PUBLIC: 3 };

                    // Lifecycle √ó Visibility: default tier and max-without-vote
                    const LIFECYCLE_VISIBILITY_DEFAULTS = {
                        'OPEN':      { default: 'PRIVATE',        maxWithoutVote: 'PRIVATE' },
                        'ACTIVE':    { default: 'PRIVATE',        maxWithoutVote: 'WITNESSED' },
                        'SETTLING':  { default: 'WITNESSED',      maxWithoutVote: 'WITNESSED' },
                        'CLOSED':    { default: 'PUBLIC_SUMMARY', maxWithoutVote: 'PUBLIC_SUMMARY' },
                        'ARCHIVED':  { default: 'PUBLIC_SUMMARY', maxWithoutVote: 'PUBLIC_SUMMARY' },
                        'REFUSAL':   { default: 'WITNESSED',      maxWithoutVote: 'WITNESSED' }
                    };

                    // --- transitionVisibility: monotonic, governance-gated, timebox-integrated ---
                    window.transitionVisibility = function transitionVisibility(filamentId, newTier, reason, evidencePointersToAdd) {
                        const fil = relayState.filaments.get(filamentId);
                        if (!fil) {
                            console.log(`[DISCLOSURE] id=${filamentId} result=NOT_FOUND`);
                            return false;
                        }
                        const oldTier = fil.visibilityScope || 'PRIVATE';
                        const oldRank = VISIBILITY_RANK[oldTier] !== undefined ? VISIBILITY_RANK[oldTier] : 0;
                        const newRank = VISIBILITY_RANK[newTier];
                        if (newRank === undefined) {
                            console.log(`[DISCLOSURE] id=${filamentId} result=INVALID_TIER attempted=${newTier}`);
                            return false;
                        }

                        // Monotonic constraint: no downgrades
                        if (newRank <= oldRank) {
                            const refLine = `[REFUSAL] reason=DISCLOSURE_DOWNGRADE_BLOCKED filament=${filamentId} attempted=${newTier}`;
                            RelayLog.info(refLine);
                            console.log(refLine);
                            return false;
                        }

                        // Governance gating: check if newTier exceeds max-without-vote
                        const lifecycleVis = LIFECYCLE_VISIBILITY_DEFAULTS[fil.lifecycleState] || LIFECYCLE_VISIBILITY_DEFAULTS['OPEN'];
                        const maxWithoutVoteRank = VISIBILITY_RANK[lifecycleVis.maxWithoutVote] || 0;
                        if (newRank > maxWithoutVoteRank) {
                            // Requires branch.voteStatus === 'PASSED'
                            const branch = (relayState.tree.nodes || []).find(n => n.id === fil.branchId);
                            if (!branch || branch.voteStatus !== 'PASSED') {
                                const refLine = `[REFUSAL] reason=DISCLOSURE_REQUIRES_VOTE filament=${filamentId} attempted=${newTier} voteStatus=${branch ? branch.voteStatus || 'NONE' : 'NO_BRANCH'}`;
                                RelayLog.info(refLine);
                                console.log(refLine);
                                return false;
                            }
                        }

                        // Apply transition
                        const from = oldTier;
                        fil.visibilityScope = newTier;
                        fil.updatedAt = Date.now();

                        // Append evidence (additive only, never remove)
                        if (evidencePointersToAdd && Array.isArray(evidencePointersToAdd) && evidencePointersToAdd.length > 0) {
                            if (!fil.evidencePointers) fil.evidencePointers = [];
                            for (const ptr of evidencePointersToAdd) {
                                fil.evidencePointers.push(ptr);
                            }
                            const evLine = `[DISCLOSURE] evidenceAppended id=${filamentId} count=${fil.evidencePointers.length} result=PASS`;
                            RelayLog.info(evLine);
                            console.log(evLine);
                        }

                        // Timebox event
                        const trunkNode = (relayState.tree.nodes || []).find(n => n.type === 'trunk' && n.id === 'trunk.avgol');
                        if (trunkNode) {
                            window.appendTimeboxEvent(trunkNode, {
                                type: 'DISCLOSURE_CHANGE',
                                filamentId: fil.filamentId,
                                from: from,
                                to: newTier,
                                reason: reason || 'explicit'
                            });
                        }

                        const line = `[DISCLOSURE] id=${filamentId} from=${from} to=${newTier} reason=${reason || 'explicit'} result=PASS`;
                        RelayLog.info(line);
                        console.log(line);

                        // Persist after any disclosure change
                        if (typeof window.persistDisclosureStore === 'function') {
                            window.persistDisclosureStore();
                        }

                        return true;
                    };

                    // --- Auto-upgrade on lifecycle transition (hook) ---
                    // Save original transitionLifecycleState, wrap with auto-upgrade
                    const _originalTransitionLifecycleState = window.transitionLifecycleState;
                    window.transitionLifecycleState = function transitionLifecycleStateWithDisclosure(filamentId, newState) {
                        const result = _originalTransitionLifecycleState(filamentId, newState);
                        if (!result) return false;

                        // After successful lifecycle transition, check default visibility
                        const fil = relayState.filaments.get(filamentId);
                        if (!fil) return true;
                        const lifecycleVis = LIFECYCLE_VISIBILITY_DEFAULTS[newState];
                        if (!lifecycleVis) return true;
                        const currentRank = VISIBILITY_RANK[fil.visibilityScope || 'PRIVATE'] || 0;
                        const defaultRank = VISIBILITY_RANK[lifecycleVis.default] || 0;
                        if (currentRank < defaultRank) {
                            // Auto-upgrade to lifecycle default
                            window.transitionVisibility(filamentId, lifecycleVis.default, 'lifecycle_default');
                        }
                        return true;
                    };

                    // --- Disclosure Persistence (demo: localStorage) ---
                    const RELAY_DISCLOSURE_STORE_KEY = 'RELAY_FILAMENT_DISCLOSURE_STORE_V0';

                    window.persistDisclosureStore = function persistDisclosureStore() {
                        try {
                            const store = {};
                            for (const [fId, fil] of relayState.filaments) {
                                store[fId] = {
                                    visibilityScope: fil.visibilityScope || 'PRIVATE',
                                    evidencePointers: fil.evidencePointers || []
                                };
                            }
                            localStorage.setItem(RELAY_DISCLOSURE_STORE_KEY, JSON.stringify(store));
                            const count = Object.keys(store).length;
                            const line = `[DISCLOSURE] persist backend=localStorage stored=${count} result=PASS`;
                            RelayLog.info(line);
                            console.log(line);
                        } catch (e) {
                            console.log('[DISCLOSURE] persist backend=localStorage result=ERROR');
                        }
                    };

                    window.restoreDisclosureStore = function restoreDisclosureStore() {
                        try {
                            const raw = localStorage.getItem(RELAY_DISCLOSURE_STORE_KEY);
                            if (!raw) {
                                const line = '[DISCLOSURE] restore backend=localStorage loaded=0 result=PASS';
                                RelayLog.info(line);
                                console.log(line);
                                return;
                            }
                            const store = JSON.parse(raw);
                            let loaded = 0;
                            for (const [fId, data] of Object.entries(store)) {
                                const fil = relayState.filaments.get(fId);
                                if (fil && data.visibilityScope) {
                                    // Only restore if stored tier is >= current (monotonic)
                                    const storedRank = VISIBILITY_RANK[data.visibilityScope] || 0;
                                    const currentRank = VISIBILITY_RANK[fil.visibilityScope || 'PRIVATE'] || 0;
                                    if (storedRank >= currentRank) {
                                        fil.visibilityScope = data.visibilityScope;
                                    }
                                    // Restore evidence pointers (merge, no duplicates by pointer id)
                                    if (data.evidencePointers && Array.isArray(data.evidencePointers)) {
                                        if (!fil.evidencePointers) fil.evidencePointers = [];
                                        const existingIds = new Set(fil.evidencePointers.map(p => typeof p === 'object' ? p.id : p));
                                        for (const ptr of data.evidencePointers) {
                                            const ptrId = typeof ptr === 'object' ? ptr.id : ptr;
                                            if (!existingIds.has(ptrId)) {
                                                fil.evidencePointers.push(ptr);
                                            }
                                        }
                                    }
                                    loaded++;
                                }
                            }
                            const line = `[DISCLOSURE] restore backend=localStorage loaded=${loaded} result=PASS`;
                            RelayLog.info(line);
                            console.log(line);
                        } catch (e) {
                            console.log('[DISCLOSURE] restore backend=localStorage result=ERROR');
                        }
                    };

                    // --- Restore persisted disclosure tiers BEFORE auto-upgrades ---
                    // This ensures manually-upgraded tiers survive page reload.
                    if (typeof window.restoreDisclosureStore === 'function') {
                        window.restoreDisclosureStore();
                    }

                    // --- Demo auto-upgrades on boot (lifecycle defaults) ---
                    // FIL-003 SETTLING ‚Üí WITNESSED; FIL-004 CLOSED ‚Üí PUBLIC_SUMMARY;
                    // FIL-005 ARCHIVED ‚Üí PUBLIC_SUMMARY; FIL-006 REFUSAL ‚Üí WITNESSED
                    // Only upgrades if current tier is below default (monotonic).
                    for (const [fId, fil] of relayState.filaments) {
                        const lifecycleVis = LIFECYCLE_VISIBILITY_DEFAULTS[fil.lifecycleState];
                        if (!lifecycleVis) continue;
                        const currentRank = VISIBILITY_RANK[fil.visibilityScope || 'PRIVATE'] || 0;
                        const defaultRank = VISIBILITY_RANK[lifecycleVis.default] || 0;
                        if (currentRank < defaultRank) {
                            window.transitionVisibility(fId, lifecycleVis.default, 'lifecycle_default');
                        }
                    }

                    // --- Simulate Disclosure function (demo, launch-only) ---
                    window.relaySimulateDisclosure = function relaySimulateDisclosure() {
                        // Governance gating: OPEN max-without-vote is PRIVATE.
                        // To upgrade to WITNESSED, branch must have voteStatus PASSED.
                        // Demo: ensure branch.finance has PASSED vote before disclosure.
                        const fil = relayState.filaments.get('FIL-001');
                        if (fil) {
                            const branch = (relayState.tree.nodes || []).find(n => n.id === fil.branchId);
                            if (branch && branch.voteStatus !== 'PASSED') {
                                branch.voteStatus = 'PASSED';
                                console.log(`[DISCLOSURE] demo voteOverride branch=${branch.id} voteStatus=PASSED reason=disclosure_demo`);
                            }
                        }
                        // Upgrade FIL-001 from PRIVATE to WITNESSED with evidence
                        const evidencePtr = { id: 'EV-DEMO-001', hash: 'sha256:demo', description: 'Call recording transcript', addedAt: Date.now() };
                        const result = window.transitionVisibility('FIL-001', 'WITNESSED', 'demo_manual', [evidencePtr]);
                        return { ok: result, filamentId: 'FIL-001', targetTier: 'WITNESSED' };
                    };
                }
                // ‚ïê‚ïê‚ïê END FILAMENT-DISCLOSURE-1 ‚ïê‚ïê‚ïê

                // ‚îÄ‚îÄ‚îÄ Load Process Modules (Phase B1/C1) ‚îÄ‚îÄ‚îÄ
                p2pModuleDef = null;
                loadedModuleDefs = new Map();
                sheetToModuleId = new Map();
                const registerLoadedModule = (moduleDef) => {
                    if (!moduleDef?.moduleId) return;
                    loadedModuleDefs.set(String(moduleDef.moduleId), moduleDef);
                    const allSheets = [
                        ...(moduleDef.factSheets || []),
                        ...(moduleDef.matchSheets || []),
                        ...(moduleDef.summarySheets || [])
                    ];
                    for (const s of allSheets) {
                        if (s?.sheetId) sheetToModuleId.set(String(s.sheetId), String(moduleDef.moduleId));
                    }
                };
                try {
                    const p2pModuleResp = await fetch('./config/modules/p2p-module.json');
                    if (p2pModuleResp.ok) {
                        p2pModuleDef = await p2pModuleResp.json();
                        const trunkNode = demoTree.nodes.find(n => n.type === 'trunk');
                        if (trunkNode) {
                            const p2p = loadModule(p2pModuleDef, trunkNode);
                            relayState.tree.nodes.push(...p2p.nodes);
                            relayState.tree.edges.push(...p2p.edges);
                            registerLoadedModule(p2pModuleDef);
                            RelayLog.info(`[MODULE] P2P merged into tree: +${p2p.nodes.length} nodes, +${p2p.edges.length} edges`);
                            if (typeof window !== 'undefined' && window.RELAY_LAUNCH_MODE === true) {
                                RelayLog.info('[FLOW] moduleLoaded=P2P result=PASS');
                            }
                        }
                    } else {
                        RelayLog.warn('[MODULE] P2P module JSON not found ‚Äî skipping');
                    }
                } catch (e) {
                    RelayLog.warn(`[MODULE] P2P load error: ${e.message} ‚Äî skipping`);
                }

                // C1: Manufacturing module is config-only and must load through the same engine path.
                try {
                    const mfgModuleResp = await fetch('./config/modules/mfg-module.json');
                    if (mfgModuleResp.ok) {
                        const mfgModuleDef = await mfgModuleResp.json();
                        const trunkNode = demoTree.nodes.find(n => n.type === 'trunk');
                        if (trunkNode) {
                            const mfg = loadModule(mfgModuleDef, trunkNode);
                            relayState.tree.nodes.push(...mfg.nodes);
                            relayState.tree.edges.push(...mfg.edges);
                            registerLoadedModule(mfgModuleDef);
                            RelayLog.info(`[MODULE] MFG merged into tree: +${mfg.nodes.length} nodes, +${mfg.edges.length} edges`);
                        }
                    } else {
                        RelayLog.warn('[MODULE] MFG module JSON not found ‚Äî skipping');
                    }
                } catch (e) {
                    RelayLog.warn(`[MODULE] MFG load error: ${e.message} ‚Äî skipping`);
                }

                // ‚îÄ‚îÄ‚îÄ C0: Route Engine ‚Äî load route configs ‚îÄ‚îÄ‚îÄ
                try {
                    const routeResp = await fetch('./config/routes/p2p-routes.json');
                    if (routeResp.ok) {
                        const routeConfig = await routeResp.json();
                        loadRoutes(routeConfig);
                    }
                } catch (e) {
                    RelayLog.warn(`[ROUTE] route config load error: ${e.message}`);
                }
                try {
                    const mfgRouteResp = await fetch('./config/routes/mfg-routes.json');
                    if (mfgRouteResp.ok) {
                        const routeConfig = await mfgRouteResp.json();
                        loadRoutes(routeConfig);
                    }
                } catch (e) {
                    RelayLog.warn(`[ROUTE] mfg route config load error: ${e.message}`);
                }
                computeTrunkAggregation();
                renderUx3Panel();

                // VOTE-COMMIT-PERSISTENCE-1: Restore persisted vote outcomes before first render
                if (window.RELAY_LAUNCH_MODE === true) {
                    restoreVoteStore();
                }

                // FILAMENT-DISCLOSURE-1: Disclosure restore is handled in the FILAMENT-DISCLOSURE-1 block
                // (before auto-upgrades, after registry initialization)

                // ‚ïê‚ïê‚ïê ATTENTION-CONFIDENCE-1: Compute Foundation ‚ïê‚ïê‚ïê
                // Read-only functions deriving attention + confidence from existing stores.
                // No new schema. No storage mutations. Fractal aggregation.
                {
                    const LIFECYCLE_ATTN_WEIGHTS = {
                        OPEN: 0.3, ACTIVE: 0.6, SETTLING: 0.8, REFUSAL: 0.9, CLOSED: 0.2, ARCHIVED: 0.1
                    };
                    const DISCLOSURE_ATTN_WEIGHTS = {
                        PRIVATE: 0.2, WITNESSED: 0.5, PUBLIC_SUMMARY: 0.8, FULL_PUBLIC: 1.0
                    };
                    const VOTE_ATTN_WEIGHTS = {
                        NONE: 0.2, PENDING: 0.4, PASSED: 0.6, REJECTED: 0.9
                    };

                    /**
                     * getBackingRefs(objectId) ‚Äî walks existing stores to return backing references.
                     * No new storage. Just a standardized read path.
                     */
                    window.getBackingRefs = function getBackingRefs(objectId) {
                        const result = { filamentIds: [], timeboxIds: [], evidenceRefs: [], missingRefs: [] };
                        if (!relayState || !relayState.tree) return result;

                        const nodes = relayState.tree.nodes || [];
                        const node = nodes.find(n => n.id === objectId);
                        const filaments = relayState.filaments || new Map();

                        // Case 1: objectId is a filament
                        if (filaments.has(objectId)) {
                            const fil = filaments.get(objectId);
                            result.filamentIds.push(fil.filamentId);
                            if (fil.timeboxId) result.timeboxIds.push(fil.timeboxId);
                            if (fil.evidencePointers && fil.evidencePointers.length > 0) {
                                result.evidenceRefs.push(...fil.evidencePointers);
                            }
                            if ((!fil.evidencePointers || fil.evidencePointers.length === 0) && !fil.timeboxId) {
                                result.missingRefs.push(fil.filamentId);
                            }
                            return result;
                        }

                        // Case 2: objectId is a node (trunk/branch/sheet)
                        if (node) {
                            // Collect filaments for this node
                            const relevantFilaments = [];
                            if (node.type === 'branch') {
                                for (const [fId, fil] of filaments) {
                                    if (fil.branchId === objectId) relevantFilaments.push(fil);
                                }
                            } else if (node.type === 'trunk') {
                                for (const [fId, fil] of filaments) {
                                    relevantFilaments.push(fil);
                                }
                            } else if (node.type === 'sheet') {
                                for (const [fId, fil] of filaments) {
                                    if (fil.sheetId === objectId) relevantFilaments.push(fil);
                                }
                            }

                            for (const fil of relevantFilaments) {
                                result.filamentIds.push(fil.filamentId);
                                if (fil.timeboxId) result.timeboxIds.push(fil.timeboxId);
                                if (fil.evidencePointers && fil.evidencePointers.length > 0) {
                                    result.evidenceRefs.push(...fil.evidencePointers);
                                }
                                if ((!fil.evidencePointers || fil.evidencePointers.length === 0) && !fil.timeboxId) {
                                    result.missingRefs.push(fil.filamentId);
                                }
                            }

                            // Collect timeboxes from node itself
                            if (node.timeboxes && Array.isArray(node.timeboxes)) {
                                for (const tb of node.timeboxes) {
                                    const tbId = tb.id || tb.label || `tb-${node.id}-${node.timeboxes.indexOf(tb)}`;
                                    if (!result.timeboxIds.includes(tbId)) result.timeboxIds.push(tbId);
                                }
                            }
                        }

                        return result;
                    };

                    /**
                     * computeConfidence(objectId) -> 0..1
                     * Derived solely from existing refs. No new schema.
                     */
                    window.computeConfidence = function computeConfidence(objectId) {
                        const refs = window.getBackingRefs(objectId);
                        let conf = 0;

                        // +0.2 if timebox exists
                        if (refs.timeboxIds.length > 0) conf += 0.2;

                        // +0.3 if evidenceRefs exist
                        if (refs.evidenceRefs.length > 0) conf += 0.3;

                        // +0.2 if any filament disclosure >= WITNESSED
                        const filaments = relayState.filaments || new Map();
                        const DISC_RANK = { PRIVATE: 0, WITNESSED: 1, PUBLIC_SUMMARY: 2, FULL_PUBLIC: 3 };
                        let maxDisc = 0;
                        for (const fId of refs.filamentIds) {
                            const fil = filaments.get(fId);
                            if (fil) {
                                const rank = DISC_RANK[fil.visibilityScope] || 0;
                                if (rank > maxDisc) maxDisc = rank;
                            }
                        }
                        if (maxDisc >= 1) conf += 0.2; // WITNESSED or higher

                        // +0.3 if voteStatus === PASSED
                        const nodes = relayState.tree?.nodes || [];
                        const node = nodes.find(n => n.id === objectId);
                        if (node && node.voteStatus === 'PASSED') conf += 0.3;
                        // For filaments, check their owning branch
                        if (filaments.has(objectId)) {
                            const fil = filaments.get(objectId);
                            const branch = nodes.find(n => n.id === fil.branchId);
                            if (branch && branch.voteStatus === 'PASSED') conf += 0.3;
                        }

                        // Penalty for missing refs
                        conf -= refs.missingRefs.length * 0.1;

                        return Math.max(0, Math.min(1, conf));
                    };

                    /**
                     * computeAttention(objectId) -> 0..1
                     * Product of weights from existing state, normalized.
                     */
                    window.computeAttention = function computeAttention(objectId) {
                        const filaments = relayState.filaments || new Map();
                        const nodes = relayState.tree?.nodes || [];

                        // Collect relevant filaments
                        let relevantFils = [];
                        if (filaments.has(objectId)) {
                            relevantFils = [filaments.get(objectId)];
                        } else {
                            const node = nodes.find(n => n.id === objectId);
                            if (node) {
                                if (node.type === 'branch') {
                                    for (const [fId, fil] of filaments) {
                                        if (fil.branchId === objectId) relevantFils.push(fil);
                                    }
                                } else if (node.type === 'trunk') {
                                    for (const [fId, fil] of filaments) relevantFils.push(fil);
                                } else if (node.type === 'sheet') {
                                    for (const [fId, fil] of filaments) {
                                        if (fil.sheetId === objectId) relevantFils.push(fil);
                                    }
                                }
                            }
                        }

                        if (relevantFils.length === 0) return 0.1; // minimal default

                        // Use max lifecycle weight and max disclosure weight across filaments
                        let maxLifecycleW = 0;
                        let maxDisclosureW = 0;
                        let maxVoteW = 0;

                        for (const fil of relevantFils) {
                            const lw = LIFECYCLE_ATTN_WEIGHTS[fil.lifecycleState] || 0.1;
                            const dw = DISCLOSURE_ATTN_WEIGHTS[fil.visibilityScope] || 0.2;
                            if (lw > maxLifecycleW) maxLifecycleW = lw;
                            if (dw > maxDisclosureW) maxDisclosureW = dw;
                        }

                        // Vote weight from owning branch
                        const branchIds = new Set(relevantFils.map(f => f.branchId));
                        for (const bId of branchIds) {
                            const branch = nodes.find(n => n.id === bId);
                            const vs = branch?.voteStatus || 'NONE';
                            const vw = VOTE_ATTN_WEIGHTS[vs] || 0.2;
                            if (vw > maxVoteW) maxVoteW = vw;
                        }

                        // Product normalized: max possible = 0.9 * 1.0 * 0.9 = 0.81
                        const raw = maxLifecycleW * maxDisclosureW * maxVoteW;
                        // Normalize to 0..1 (max raw = 0.9 * 1.0 * 0.9 = 0.81)
                        return Math.min(1, raw / 0.81);
                    };

                    /**
                     * aggregateAttention(scopeNodeId) ‚Äî fractal rollup.
                     * branch->company: weighted max. company->global: weighted max.
                     */
                    window.aggregateAttention = function aggregateAttention(scopeNodeId) {
                        const nodes = relayState.tree?.nodes || [];
                        const node = nodes.find(n => n.id === scopeNodeId);
                        if (!node) return 0;

                        if (node.type === 'trunk') {
                            // Aggregate from branches: weighted max
                            const branches = nodes.filter(n => n.type === 'branch' && n.parent === scopeNodeId);
                            if (branches.length === 0) return window.computeAttention(scopeNodeId);
                            let maxAttn = 0;
                            for (const b of branches) {
                                const a = window.computeAttention(b.id);
                                if (a > maxAttn) maxAttn = a;
                            }
                            return maxAttn;
                        }

                        if (node.type === 'branch') {
                            // Aggregate from sheets: avg weighted by filament count
                            const sheets = nodes.filter(n => n.type === 'sheet' && n.parent === scopeNodeId);
                            if (sheets.length === 0) return window.computeAttention(scopeNodeId);
                            let totalWeight = 0;
                            let totalAttn = 0;
                            for (const s of sheets) {
                                const refs = window.getBackingRefs(s.id);
                                const weight = Math.max(1, refs.filamentIds.length);
                                totalAttn += window.computeAttention(s.id) * weight;
                                totalWeight += weight;
                            }
                            return totalWeight > 0 ? totalAttn / totalWeight : 0;
                        }

                        return window.computeAttention(scopeNodeId);
                    };

                    /**
                     * aggregateConfidence(scopeNodeId) ‚Äî fractal rollup.
                     * Uses average at all levels.
                     */
                    window.aggregateConfidence = function aggregateConfidence(scopeNodeId) {
                        const nodes = relayState.tree?.nodes || [];
                        const node = nodes.find(n => n.id === scopeNodeId);
                        if (!node) return 0;

                        if (node.type === 'trunk') {
                            const branches = nodes.filter(n => n.type === 'branch' && n.parent === scopeNodeId);
                            if (branches.length === 0) return window.computeConfidence(scopeNodeId);
                            let total = 0;
                            for (const b of branches) total += window.computeConfidence(b.id);
                            return total / branches.length;
                        }

                        if (node.type === 'branch') {
                            const sheets = nodes.filter(n => n.type === 'sheet' && n.parent === scopeNodeId);
                            if (sheets.length === 0) return window.computeConfidence(scopeNodeId);
                            let total = 0;
                            for (const s of sheets) total += window.computeConfidence(s.id);
                            return total / sheets.length;
                        }

                        return window.computeConfidence(scopeNodeId);
                    };

                    // --- Emit boot logs for all 6 demo filaments ---
                    if (window.RELAY_LAUNCH_MODE === true && relayState.filaments && relayState.filaments.size > 0) {
                        // Log backing refs for branches with filaments
                        const branchesWithFils = new Set();
                        for (const [fId, fil] of relayState.filaments) {
                            branchesWithFils.add(fil.branchId);
                        }
                        for (const bId of branchesWithFils) {
                            const refs = window.getBackingRefs(bId);
                            const conf = window.computeConfidence(bId);
                            const attn = window.computeAttention(bId);
                            console.log(`[BACKING] id=${bId} filaments=${refs.filamentIds.length} timeboxes=${refs.timeboxIds.length} evidence=${refs.evidenceRefs.length} missing=${refs.missingRefs.length}`);
                            const hasTimebox = refs.timeboxIds.length > 0 ? 1 : 0;
                            const hasEvidence = refs.evidenceRefs.length > 0 ? 1 : 0;
                            const hasDisclosure = (() => {
                                const DISC_RANK = { PRIVATE: 0, WITNESSED: 1, PUBLIC_SUMMARY: 2, FULL_PUBLIC: 3 };
                                for (const fId2 of refs.filamentIds) {
                                    const fil2 = relayState.filaments.get(fId2);
                                    if (fil2 && (DISC_RANK[fil2.visibilityScope] || 0) >= 1) return 1;
                                }
                                return 0;
                            })();
                            const node = (relayState.tree?.nodes || []).find(n => n.id === bId);
                            const hasVote = (node && node.voteStatus === 'PASSED') ? 1 : 0;
                            console.log(`[CONF] id=${bId} conf=${conf.toFixed(2)} breakdown=tb:${hasTimebox},ev:${hasEvidence},disc:${hasDisclosure},vote:${hasVote}`);

                            // Determine dominant lifecycle/disclosure/vote for attention log
                            let maxLC = 'NONE', maxDT = 'PRIVATE', maxVS = 'NONE';
                            for (const fId2 of refs.filamentIds) {
                                const fil2 = relayState.filaments.get(fId2);
                                if (fil2) {
                                    if ((LIFECYCLE_ATTN_WEIGHTS[fil2.lifecycleState] || 0) > (LIFECYCLE_ATTN_WEIGHTS[maxLC] || 0)) maxLC = fil2.lifecycleState;
                                    const DR = { PRIVATE: 0, WITNESSED: 1, PUBLIC_SUMMARY: 2, FULL_PUBLIC: 3 };
                                    if ((DR[fil2.visibilityScope] || 0) > (DR[maxDT] || 0)) maxDT = fil2.visibilityScope;
                                }
                            }
                            maxVS = node?.voteStatus || 'NONE';
                            console.log(`[ATTN] id=${bId} attn=${attn.toFixed(2)} lifecycle=${maxLC} disclosure=${maxDT} vote=${maxVS}`);
                        }

                        // Aggregate for trunk
                        const trunkNode = (relayState.tree?.nodes || []).find(n => n.type === 'trunk');
                        if (trunkNode) {
                            const aggAttn = window.aggregateAttention(trunkNode.id);
                            const aggConf = window.aggregateConfidence(trunkNode.id);
                            const branchCount = (relayState.tree?.nodes || []).filter(n => n.type === 'branch' && n.parent === trunkNode.id).length;
                            console.log(`[AC] aggregateAttention scope=company result=${aggAttn.toFixed(2)} children=${branchCount}`);
                            console.log(`[AC] aggregateConfidence scope=company result=${aggConf.toFixed(2)} children=${branchCount}`);
                        }

                        const acInitLine = `[AC] initialized=PASS functions=5 filaments=${relayState.filaments.size}`;
                        RelayLog.info(acInitLine);
                        console.log(acInitLine);
                    }

                    // Expose attention/confidence state for HUD
                    window._relayACState = {
                        getBackingRefs: window.getBackingRefs,
                        computeConfidence: window.computeConfidence,
                        computeAttention: window.computeAttention,
                        aggregateAttention: window.aggregateAttention,
                        aggregateConfidence: window.aggregateConfidence
                    };
                }
                // ‚ïê‚ïê‚ïê END ATTENTION-CONFIDENCE-1 ‚ïê‚ïê‚ïê

                // ‚ïê‚ïê‚ïê VIS-MEGASHEET-1: TopDown Projection Lens ‚ïê‚ïê‚ïê
                {
                    /**
                     * Compute deterministic megasheet layout for all sheets.
                     * Uses importance-biased radial positioning seeded by trunk hash.
                     */
                    window._relayComputeMegasheetLayout = function computeMegasheetLayout() {
                        const nodes = relayState.tree?.nodes || [];
                        const sheets = nodes.filter(n => n.type === 'sheet');
                        const trunk = nodes.find(n => n.type === 'trunk');
                        if (!trunk || sheets.length === 0) return;

                        // Deterministic seed from trunk ID
                        let seed = 0;
                        const trunkId = trunk.id || 'trunk';
                        for (let i = 0; i < trunkId.length; i++) {
                            seed = ((seed << 5) - seed + trunkId.charCodeAt(i)) | 0;
                        }
                        seed = Math.abs(seed);

                        console.log(`[MEGA] enter seed=${seed} sheets=${sheets.length}`);

                        // Compute importance for each sheet
                        const filaments = relayState.filaments || new Map();
                        const sheetImportances = [];
                        for (const s of sheets) {
                            let openFils = 0, driftCount = 0, exceptions = 0;
                            for (const [fId, fil] of filaments) {
                                if (fil.sheetId === s.id || fil.branchId === s.parent) {
                                    if (fil.lifecycleState === 'OPEN' || fil.lifecycleState === 'ACTIVE') openFils++;
                                    if (fil.lifecycleState === 'REFUSAL') exceptions++;
                                }
                            }
                            // Get parent branch for drift data
                            const parentBranch = nodes.find(n => n.id === s.parent);
                            if (parentBranch && parentBranch.timeboxes) {
                                for (const tb of parentBranch.timeboxes) {
                                    driftCount += (tb.openDrifts || 0);
                                }
                            }
                            const attn = typeof window.computeAttention === 'function' ? window.computeAttention(s.id) : 0;
                            const conf = typeof window.computeConfidence === 'function' ? window.computeConfidence(s.id) : 0;
                            const importance = 0.3 * openFils + 0.3 * attn + 0.2 * driftCount + 0.2 * exceptions;

                            sheetImportances.push({ sheet: s, importance, attn, conf });
                        }

                        // Sort by importance descending
                        sheetImportances.sort((a, b) => b.importance - a.importance);

                        // Place sheets in concentric rings (important near center)
                        const minGapM = 15;
                        const tileSize = 20; // base tile size
                        const maxRadiusM = 500;
                        const positions = [];
                        let currentRadius = 0;
                        let currentAngle = (seed % 360) * (Math.PI / 180);
                        let sheetsInCurrentRing = 0;
                        const maxSheetsPerRing = 8;

                        for (let i = 0; i < sheetImportances.length; i++) {
                            const { sheet, importance, attn, conf } = sheetImportances[i];

                            if (sheetsInCurrentRing >= maxSheetsPerRing || (currentRadius > 0 && sheetsInCurrentRing >= Math.floor(2 * Math.PI * currentRadius / (tileSize + minGapM)))) {
                                // VIS-GRAMMAR-POLISH-1: Increase inter-ring spacing to prevent overlap
                                currentRadius += (tileSize + minGapM) * 1.8;
                                currentAngle = (seed % 360 + currentRadius * 0.1) * (Math.PI / 180);
                                sheetsInCurrentRing = 0;
                            }

                            if (i === 0) {
                                // Most important sheet at center
                                positions.push({ sheet, x: 0, y: 0, importance, attn, conf });
                            } else {
                                if (currentRadius === 0) currentRadius = (tileSize + minGapM) * 1.5;
                                const angleStep = (2 * Math.PI) / Math.max(1, Math.min(maxSheetsPerRing, Math.floor(2 * Math.PI * currentRadius / (tileSize + minGapM))));
                                const x = Math.cos(currentAngle) * currentRadius;
                                const y = Math.sin(currentAngle) * currentRadius;
                                positions.push({ sheet, x, y, importance, attn, conf });
                                currentAngle += angleStep;
                            }
                            sheetsInCurrentRing++;
                        }

                        // AABB overlap resolution (radial push-apart)
                        // VIS-GRAMMAR-POLISH-1: Use radial displacement to preserve ring structure
                        const halfSize = tileSize / 2;
                        let resolvedOverlaps = 0;
                        for (let iter = 0; iter < 30; iter++) {
                            let pushCount = 0;
                            for (let i = 0; i < positions.length; i++) {
                                for (let j = i + 1; j < positions.length; j++) {
                                    const a = positions[i], b = positions[j];
                                    const dx = b.x - a.x, dy = b.y - a.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    const minDist = tileSize + minGapM;
                                    if (dist < minDist && dist > 0) {
                                        // Push radially along the line connecting centers
                                        const pushDist = (minDist - dist) * 0.5;
                                        const nx = dx / dist, ny = dy / dist;
                                        a.x -= nx * pushDist;
                                        a.y -= ny * pushDist;
                                        b.x += nx * pushDist;
                                        b.y += ny * pushDist;
                                        pushCount++;
                                    }
                                }
                            }
                            resolvedOverlaps += pushCount;
                            // Early exit if no more overlaps
                            if (pushCount === 0) break;
                        }

                        // Clamp to maxRadius
                        let actualMaxRadius = 0;
                        for (const p of positions) {
                            const r = Math.sqrt(p.x * p.x + p.y * p.y);
                            if (r > actualMaxRadius) actualMaxRadius = r;
                            if (r > maxRadiusM) {
                                const scale = maxRadiusM / r;
                                p.x *= scale;
                                p.y *= scale;
                            }
                        }

                        // Check remaining overlaps after resolution
                        let overlaps = 0;
                        for (let i = 0; i < positions.length; i++) {
                            for (let j = i + 1; j < positions.length; j++) {
                                const dx = Math.abs(positions[j].x - positions[i].x);
                                const dy = Math.abs(positions[j].y - positions[i].y);
                                if (dx < (tileSize + minGapM) && dy < (tileSize + minGapM)) overlaps++;
                            }
                        }

                        console.log(`[MEGA] layout overlaps=${overlaps} minGapM=${minGapM} radiusM=${Math.round(actualMaxRadius)}`);
                        console.log(`[VIS-GRAMMAR] scaffold spacing depts=${positions.length} minGapM=${minGapM} overlapsResolved=${resolvedOverlaps > 0 ? 'PASS' : 'SKIP'}`);

                        // Store layout for renderer and log mappings
                        window._relayMegasheetLayout = positions;
                        for (const p of positions) {
                            console.log(`[MEGA] mapping tile=${p.sheet.id} x=${Math.round(p.x)} y=${Math.round(p.y)} w=${tileSize} h=${tileSize} importance=${p.importance.toFixed(2)}`);
                        }

                        // Determine state for each tile
                        for (const p of positions) {
                            const parentBranch = nodes.find(n => n.id === p.sheet.parent);
                            const voteStatus = parentBranch?.voteStatus || 'NONE';
                            if (voteStatus === 'PASSED') p.state = 'PASS';
                            else if (voteStatus === 'REJECTED') p.state = 'REFUSAL';
                            else if (voteStatus === 'PENDING') p.state = 'DEGRADED';
                            else p.state = 'INDETERMINATE';
                        }
                    };
                }
                // ‚ïê‚ïê‚ïê END VIS-MEGASHEET-1 ‚ïê‚ïê‚ïê

                // Render full tree (demo + modules)
                filamentRenderer.renderTree();
                // CAM0.4.2-TIGHTENING: Stamp filament IDs on cubes after initial render
                if (typeof window.relayStampFilamentCubes === 'function') {
                    window.relayStampFilamentCubes();
                }
                
                RelayLog.info(`‚úÖ Demo tree rendered: Avgol @ Tel Aviv`);
                const syncWorldAnchorTrunks = (anchors = []) => {
                    if (RELAY_PROFILE !== 'world') return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
                    if (!Array.isArray(relayState?.tree?.nodes)) return { ok: false, reason: 'TREE_UNAVAILABLE' };
                    const previousIds = Array.isArray(window.__relayWorldAnchorTrunkIds)
                        ? window.__relayWorldAnchorTrunkIds
                        : [];
                    if (previousIds.length > 0) {
                        const stale = new Set(previousIds);
                        relayState.tree.nodes = relayState.tree.nodes.filter((node) => !stale.has(String(node?.id || '')));
                        relayState.tree.edges = relayState.tree.edges.filter((edge) => !stale.has(String(edge?.source || '')) && !stale.has(String(edge?.target || '')));
                    }
                    const generated = [];
                    const generatedIds = [];
                    for (const anchor of anchors) {
                        const idRaw = String(anchor?.id || '').replace(/[^a-zA-Z0-9_-]/g, '').toLowerCase();
                        if (!idRaw) continue;
                        const lat = Number(anchor?.lat);
                        const lon = Number(anchor?.lon);
                        if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue;
                        // Keep the canonical detailed Tel Aviv company as primary.
                        if (Math.abs(lat - trunkLat) < 0.25 && Math.abs(lon - trunkLon) < 0.25) continue;
                        const trunkId = `trunk.world.${idRaw}`;
                        generatedIds.push(trunkId);
                        generated.push({
                            id: trunkId,
                            type: 'trunk',
                            name: `${String(anchor?.name || idRaw)} Co.`,
                            lat,
                            lon,
                            height: 0,
                            alt: 1800,
                            commits: [
                                { timeboxId: 'W1', commitCount: 8, openDrifts: 0, eriAvg: 80, scarCount: 0 },
                                { timeboxId: 'W2', commitCount: 10, openDrifts: 1, eriAvg: 78, scarCount: 0 },
                                { timeboxId: 'W3', commitCount: 9, openDrifts: 0, eriAvg: 82, scarCount: 0 }
                            ]
                        });
                    }
                    if (generated.length > 0) {
                        relayState.tree.nodes.push(...generated);
                    }
                    window.__relayWorldAnchorTrunkIds = generatedIds;
                    RelayLog.info(`[GLOBE] worldTrunks synced added=${generated.length} total=${generated.length + 1}`);
                    if (filamentRenderer && relayState.tree.nodes.length > 0) {
                        filamentRenderer.renderTree('world-anchor-trunks');
                    }
                    return { ok: true, added: generated.length };
                };
                const renderDatasetAnchors = async () => {
                    if (RELAY_PROFILE !== 'world') {
                        return { ok: false, reason: 'PROFILE_LOCKED_PROOF' };
                    }
                    if (!viewer?.entities) {
                        return { ok: false, reason: 'VIEWER_UNAVAILABLE' };
                    }
                    let dataset = null;
                    try {
                        const resp = await fetch('./app/cesium/fixtures/world-dataset-v0.json', { cache: 'no-store' });
                        if (resp.ok) {
                            dataset = await resp.json();
                        }
                    } catch {
                        // fallback below
                    }
                    const fallback = [
                        { id: 'usp1-anchor-il', name: 'IL Anchor', lon: trunkLon, lat: trunkLat },
                        { id: 'usp1-anchor-us', name: 'US Anchor', lon: -122.4194, lat: 37.7749 }
                    ];
                    const anchorsRaw = Array.isArray(dataset?.anchors) && dataset.anchors.length > 0 ? dataset.anchors : fallback;
                    const anchors = anchorsRaw
                        .map((a, idx) => ({
                            id: String(a.id || `anchor-${idx + 1}`),
                            name: String(a.name || a.id || `Anchor ${idx + 1}`),
                            lon: Number(a.lon),
                            lat: Number(a.lat)
                        }))
                        .filter((a) => Number.isFinite(a.lon) && Number.isFinite(a.lat));
                    const staleIds = (viewer.entities.values || [])
                        .filter((entity) => typeof entity?.id === 'string' && entity.id.startsWith('world-dataset-anchor-'))
                        .map((entity) => entity.id);
                    for (const id of staleIds) {
                        viewer.entities.removeById(id);
                    }
                    for (const anchor of anchors) {
                        const anchorEntityId = `world-dataset-anchor-${anchor.id}`;
                        if (viewer.entities.getById(anchorEntityId)) {
                            viewer.entities.removeById(anchorEntityId);
                        }
                        viewer.entities.add({
                            id: anchorEntityId,
                            position: Cesium.Cartesian3.fromDegrees(anchor.lon, anchor.lat, 0),
                            point: {
                                pixelSize: 7,
                                color: Cesium.Color.ORANGE.withAlpha(0.92),
                                outlineColor: Cesium.Color.BLACK.withAlpha(0.8),
                                outlineWidth: 1
                            },
                            label: {
                                text: anchor.name,
                                font: '11px sans-serif',
                                pixelOffset: new Cesium.Cartesian2(0, -14),
                                showBackground: true,
                                backgroundColor: Cesium.Color.BLACK.withAlpha(0.5),
                                fillColor: Cesium.Color.WHITE
                            }
                        });
                    }
                    window.__relayWorldDatasetMeta = {
                        datasetVersion: String(dataset?.datasetVersion || 'WORLD-DATASET-FALLBACK'),
                        anchors: anchors.map((a) => ({ id: a.id, name: a.name, lon: a.lon, lat: a.lat }))
                    };
                    syncWorldAnchorTrunks(anchors);
                    RelayLog.info(`[GLOBE] datasetLoad anchors=${anchors.length}`);
                    RelayLog.info(`[UX] multiCountrySmoke=PASS anchors=${anchors.length}`);
                    return { ok: true, anchors: anchors.length, datasetVersion: window.__relayWorldDatasetMeta.datasetVersion };
                };
                window.relayLoadWorldDataset = () => renderDatasetAnchors();
                window.relayGetWorldDatasetMeta = () => JSON.parse(JSON.stringify(window.__relayWorldDatasetMeta || { datasetVersion: null, anchors: [] }));
                if (RELAY_PROFILE === 'world') {
                    await renderDatasetAnchors();
                }
                
                // ‚ïê‚ïê‚ïê LAUNCH READABILITY PASS (D): Deterministic camera frame ‚ïê‚ïê‚ïê
                // Extracted as reusable function for "Reset view" affordance
                window._launchResetCameraFrame = () => {
                    if (!window.RELAY_LAUNCH_MODE || !viewer) return;
                    const primaryTrunk = relayState?.tree?.nodes?.find(n => n.type === 'trunk');
                    if (primaryTrunk && Number.isFinite(primaryTrunk.lon) && Number.isFinite(primaryTrunk.lat)) {
                        const launchScale = window.RELAY_LAUNCH_SCALE || 1;
                        // Tree-framing camera: position south of tree, looking north toward it
                        // At 0.25 scale: tree is ~500m tall, branches ~200m long
                        // Camera far enough to frame the full tree, close enough for clear trunk
                        const treeH = 2000 * launchScale;            // tree height in meters
                        const frameDist = treeH * 1.5;               // camera altitude ‚âà 1.5√ó tree height
                        const horzDist = treeH * 2.0;                // horizontal distance ‚âà 2√ó tree height
                        const latOffset = -horzDist / 111000;        // convert meters ‚Üí degrees latitude
                        const lonOffset = 0.003;                     // east offset to see branches extending right
                        const heading = Cesium.Math.toRadians(350);  // nearly north (toward tree)
                        const pitch = Cesium.Math.toRadians(-25);    // looking down 25¬∞ (shows vertical extent)
                        // If in edit-sheet mode, exit first
                        if (isEditSheetMode && typeof window.exitEditSheetMode === 'function') {
                            window.exitEditSheetMode();
                        }
                        viewer.camera.setView({
                            destination: Cesium.Cartesian3.fromDegrees(
                                primaryTrunk.lon + lonOffset,
                                primaryTrunk.lat + latOffset,
                                frameDist
                            ),
                            orientation: { heading, pitch, roll: 0 }
                        });
                        RelayLog.info(`[LAUNCH-FIX] cameraFrame target=${primaryTrunk.id} result=PASS distM=${frameDist.toFixed(0)} horzM=${horzDist.toFixed(0)} heading=355 pitch=-28 applied=PASS`);
                    }
                };
                if (window.RELAY_LAUNCH_MODE) {
                    window._launchResetCameraFrame();
                }
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // CANONICAL CAMERA PRESETS (Phase 2.1)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const cameraPoseForMoveLog = () => {
                    const carto = viewer?.camera?.positionCartographic || null;
                    if (!carto) return 'n/a';
                    return `${Cesium.Math.toDegrees(carto.longitude).toFixed(5)},${Cesium.Math.toDegrees(carto.latitude).toFixed(5)},${Number(carto.height).toFixed(1)}`;
                };
                const travelCamera = ({ destination, orientation, reason = 'CAM_PRESET', durationMs = 900 }) => new Promise((resolve) => {
                    if (!viewer?.camera || !destination) {
                        resolve({ ok: false, reason: 'CAMERA_UNAVAILABLE' });
                        return;
                    }
                    const fromPose = cameraPoseForMoveLog();
                    const t0 = performance.now();
                    viewer.camera.flyTo({
                        destination,
                        orientation,
                        duration: Math.max(0.25, Number(durationMs || 900) / 1000),
                        complete: () => {
                            const elapsedMs = Math.round(performance.now() - t0);
                            const toPose = cameraPoseForMoveLog();
                            RelayLog.info(`[MOVE] mode=travel from=${fromPose} to=${toPose} reason=${reason} durationMs=${elapsedMs}`);
                            resolve({ ok: true, mode: 'travel', durationMs: elapsedMs, from: fromPose, to: toPose, reason });
                        },
                        cancel: () => resolve({ ok: false, reason: 'TRAVEL_CANCELLED' })
                    });
                });
                const CAMERA_PRESET_REGISTRY_V0 = [
                    { presetId: 'cam.company.sideProfile', lod: 'COMPANY', label: 'Side Profile', apply: () => window.setSideProfileView() },
                    { presetId: 'cam.company.faceOn', lod: 'COMPANY', label: 'Sheet Face On', apply: () => window.setLookDownBranchView() },
                    { presetId: 'cam.sheet.topDown', lod: 'SHEET', label: 'Sheet Top Down', apply: () => window.setTopDownView() },
                    { presetId: 'cam.cell.spineInspection', lod: 'CELL', label: 'Spine Inspection', apply: () => window.setSpineInspectionView() }
                ];
                window.setTopDownView = () => {
                    const sheets = relayState.tree.nodes.filter(n => n.type === 'sheet');
                    const sheet = sheets.find(s => s._center && s._normal) || sheets[0];
                    if (!sheet || !sheet._center || !sheet._normal) {
                        RelayLog.warn('‚ö†Ô∏è Sheet top-down view unavailable (sheet not ready)');
                        return Promise.resolve({ ok: false, reason: 'SHEET_NOT_READY' });
                    }
                    RelayLog.info('[CAM] SheetTopDown: grid readability mode');
                    const normal = Cesium.Cartesian3.normalize(sheet._normal, new Cesium.Cartesian3());
                    const offset = Cesium.Cartesian3.multiplyByScalar(normal, 1200, new Cesium.Cartesian3());
                    const cameraPos = Cesium.Cartesian3.add(sheet._center, offset, new Cesium.Cartesian3());
                    const direction = Cesium.Cartesian3.normalize(
                        Cesium.Cartesian3.subtract(sheet._center, cameraPos, new Cesium.Cartesian3()),
                        new Cesium.Cartesian3()
                    );
                    return travelCamera({
                        destination: cameraPos,
                        orientation: {
                            direction,
                            up: sheet._xAxis || Cesium.Cartesian3.UNIT_Z
                        },
                        reason: 'PRESET_SHEET_TOPDOWN',
                        durationMs: 900
                    });
                };
                
                window.setSideProfileView = () => {
                    RelayLog.info('üì∑ Camera: Side Profile View');
                    return travelCamera({
                        destination: Cesium.Cartesian3.fromDegrees(trunkLon - 0.02, trunkLat, 2500),
                        orientation: {
                            heading: Cesium.Math.toRadians(90),  // Looking at tree from side
                            pitch: 0,
                            roll: 0
                        },
                        reason: 'PRESET_COMPANY_SIDE',
                        durationMs: 900
                    });
                };
                
                // LookDownBranch: Camera positioned behind trunk, looking along branch tangent toward sheet
                // This is the "page in a book" view - sheet should appear face-on
                window.setLookDownBranchView = () => {
                    RelayLog.info('[CAM] SheetFaceOn: look down branch');
                    
                    // Find first branch with frames
                    const tree = relayState.tree;
                    const branch = tree.nodes.find(n => n.type === 'branch' && n._branchFrames);
                    
                    if (!branch) {
                        RelayLog.warn('‚ö†Ô∏è No branch with frames found');
                        return Promise.resolve({ ok: false, reason: 'BRANCH_NOT_READY' });
                    }
                    
                    // Get branch frame at endpoint
                    const frame = branch._branchFrames[branch._branchFrames.length - 1];
                    const branchEndWorld = branch._worldEndpoint;
                    const enuFrame = branch._enuFrame;
                    
                    // Convert frame vectors to world directions
                    const enuOrigin = new Cesium.Cartesian3();
                    Cesium.Matrix4.multiplyByPoint(enuFrame, new Cesium.Cartesian3(0, 0, 0), enuOrigin);
                    
                    const enuT = new Cesium.Cartesian3(frame.T.east, frame.T.north, frame.T.up);
                    const enuN = new Cesium.Cartesian3(frame.N.east, frame.N.north, frame.N.up);
                    Cesium.Matrix4.multiplyByPointAsVector(enuFrame, enuT, enuT);
                    Cesium.Matrix4.multiplyByPointAsVector(enuFrame, enuN, enuN);
                    Cesium.Cartesian3.normalize(enuT, enuT);
                    Cesium.Cartesian3.normalize(enuN, enuN);
                    
                    // Position camera 450m back from branch endpoint along -T, 120m up along +N
                    const back = Cesium.Cartesian3.multiplyByScalar(enuT, -450, new Cesium.Cartesian3());
                    const up = Cesium.Cartesian3.multiplyByScalar(enuN, 120, new Cesium.Cartesian3());
                    
                    const cameraPos = Cesium.Cartesian3.add(branchEndWorld, back, new Cesium.Cartesian3());
                    Cesium.Cartesian3.add(cameraPos, up, cameraPos);
                    
                    // Look toward branch endpoint (along +T)
                    const direction = Cesium.Cartesian3.subtract(branchEndWorld, cameraPos, new Cesium.Cartesian3());
                    Cesium.Cartesian3.normalize(direction, direction);
                    
                    return travelCamera({
                        destination: cameraPos,
                        orientation: {
                            direction: direction,
                            up: enuN
                        },
                        reason: 'PRESET_COMPANY_FACEON',
                        durationMs: 900
                    });
                };

                window.setSpineInspectionView = () => {
                    const sheets = relayState.tree.nodes.filter(n => n.type === 'sheet');
                    const sheet = sheets.find(s => s._center && s._normal) || sheets[0];
                    if (!sheet || !sheet._center || !sheet._normal) {
                        RelayLog.warn('‚ö†Ô∏è Spine inspection unavailable (sheet not ready)');
                        return Promise.resolve({ ok: false, reason: 'SHEET_NOT_READY' });
                    }
                    const spine = window.cellAnchors?.[sheet.id]?.spine;
                    const targetSpine = spine || sheet._center;
                    if (!spine) RelayLog.warn('‚ö†Ô∏è Spine inspection fallback: spine not ready, using sheet center');
                    RelayLog.info('[CAM] SpineInspection: comb readability mode');
                    const right = sheet._yAxis || Cesium.Cartesian3.UNIT_X;
                    const up = sheet._xAxis || Cesium.Cartesian3.UNIT_Z;
                    const offset = Cesium.Cartesian3.add(
                        Cesium.Cartesian3.multiplyByScalar(right, 300, new Cesium.Cartesian3()),
                        Cesium.Cartesian3.multiplyByScalar(up, 100, new Cesium.Cartesian3()),
                        new Cesium.Cartesian3()
                    );
                    const cameraPos = Cesium.Cartesian3.add(targetSpine, offset, new Cesium.Cartesian3());
                    const direction = Cesium.Cartesian3.normalize(
                        Cesium.Cartesian3.subtract(targetSpine, cameraPos, new Cesium.Cartesian3()),
                        new Cesium.Cartesian3()
                    );
                    return travelCamera({
                        destination: cameraPos,
                        orientation: {
                            direction,
                            up
                        },
                        reason: 'PRESET_CELL_SPINE',
                        durationMs: 900
                    });
                };
                window.relayListCameraPresets = (lod = '') => {
                    const requested = String(lod || '').trim().toUpperCase();
                    const currentLod = String(lodGovernor?.getCurrentLevel?.() || filamentRenderer?.currentLOD || 'COMPANY').toUpperCase();
                    const effective = requested || currentLod;
                    return CAMERA_PRESET_REGISTRY_V0
                        .filter((p) => !effective || String(p.lod).toUpperCase() === effective)
                        .map((p) => ({ presetId: p.presetId, lod: p.lod, label: p.label }))
                        .sort((a, b) => a.presetId.localeCompare(b.presetId));
                };
                window.relayApplyCameraPreset = async (presetId) => {
                    const preset = CAMERA_PRESET_REGISTRY_V0.find((p) => String(p.presetId) === String(presetId));
                    if (!preset) return { ok: false, reason: 'CAM_PRESET_UNKNOWN' };
                    const contextBefore = {
                        focusObjectId: String(window.__relayArtifactFocusedObjectId || ''),
                        activeObjectId: String(getActiveObjectIdForInspector() || '')
                    };
                    const result = await preset.apply();
                    const contextAfter = {
                        focusObjectId: String(window.__relayArtifactFocusedObjectId || ''),
                        activeObjectId: String(getActiveObjectIdForInspector() || '')
                    };
                    return {
                        ...(result || { ok: false, reason: 'CAM_PRESET_FAILED' }),
                        presetId: preset.presetId,
                        lod: preset.lod,
                        contextBefore,
                        contextAfter,
                        contextPreserved: contextBefore.focusObjectId === contextAfter.focusObjectId && contextBefore.activeObjectId === contextAfter.activeObjectId
                    };
                };
                window.relaySetBasinSoftLock = (enabled, targetId = null) => {
                    const state = window.__relayBasinState;
                    state.softLockEnabled = enabled === true;
                    state.softLockTargetId = state.softLockEnabled ? String(targetId || state.targetId || '') : null;
                    RelayLog.info(`[CAM] basin-softlock enabled=${state.softLockEnabled ? 'true' : 'false'} target=${state.softLockTargetId || state.targetId || 'none'}`);
                    return { ok: true, ...JSON.parse(JSON.stringify(state)) };
                };
                window.relayGetBasinState = () => JSON.parse(JSON.stringify(window.__relayBasinState || {}));
                window.relayCameraTravelTo = async (input = {}) => {
                    const lon = Number(input.lon);
                    const lat = Number(input.lat);
                    const height = Number(input.height);
                    if (!Number.isFinite(lon) || !Number.isFinite(lat) || !Number.isFinite(height)) {
                        return { ok: false, reason: 'CAM_TRAVEL_INVALID_INPUT' };
                    }
                    return travelCamera({
                        destination: Cesium.Cartesian3.fromDegrees(lon, lat, height),
                        orientation: {
                            heading: Number.isFinite(Number(input.heading)) ? Number(input.heading) : 0,
                            pitch: Number.isFinite(Number(input.pitch)) ? Number(input.pitch) : -Cesium.Math.toRadians(35),
                            roll: Number.isFinite(Number(input.roll)) ? Number(input.roll) : 0
                        },
                        reason: String(input.reason || 'CAM_TRAVEL_API'),
                        durationMs: Number(input.durationMs || 900)
                    });
                };
                
                // LOD Lock feature (for debugging tree at SHEET level)
                // Note: lodLocked and lodLockedLevel are declared at top-level scope
                window.toggleLODLock = () => {
                    if (!lodLocked) {
                        // Lock LOD at current level
                        lodLockedLevel = lodGovernor.getCurrentLevel();
                        lodLocked = true;
                        RelayLog.info(`üîí LOD locked at: ${lodLockedLevel}`);
                    } else {
                        // Unlock LOD
                        lodLocked = false;
                        lodLockedLevel = null;
                        RelayLog.info(`üîì LOD unlocked (governor active)`);
                    }
                };
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // FOCUS LENS (D-Lens-0) ‚Äî Non-truth camera + layout lens
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

                /**
                 * Resolve the nearest focusable node to the camera.
                 * Returns { node, nodeType } or null.
                 */
                const getNearestFocusableNode = () => {
                    const nodes = relayState.tree.nodes.filter(n => n._center);
                    if (nodes.length === 0) return null;
                    const camPos = viewer.camera.position;
                    let nearest = null;
                    let nearestDist = Infinity;
                    nodes.forEach(n => {
                        const dist = Cesium.Cartesian3.distance(camPos, n._center);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearest = n;
                        }
                    });
                    return nearest ? { node: nearest, nodeType: nearest.type } : null;
                };

                /**
                 * Resolve a picked entity ID to a focusable tree node.
                 */
                const resolvePickedToNode = (pickedId) => {
                    if (!pickedId || typeof pickedId !== 'string') return null;
                    // Strip suffixes to get base node ID
                    const idBase = pickedId
                        .split('.cell.')[0]
                        .split('-surface')[0]
                        .split('-outline')[0]
                        .split('-segment')[0]
                        .split('-root')[0]
                        .split('-anchor')[0]
                        .split('-spine')[0]
                        .split('-lane')[0]
                        .split('-timebox')[0]
                        .split('-label')[0]
                        .split('-presence')[0]
                        .split('-formula')[0];
                    return relayState.tree.nodes.find(n => n.id === idBase) || null;
                };

                /**
                 * Find the parent branch of a node (sheet ‚Üí branch, branch ‚Üí trunk).
                 */
                const findParentChain = (node) => {
                    const result = { parentBranch: null, parentTrunk: null };
                    if (!node) return result;
                    const tree = relayState.tree;
                    if (node.type === 'sheet') {
                        result.parentBranch = tree.nodes.find(n => n.id === node.parent && n.type === 'branch');
                        if (result.parentBranch) {
                            result.parentTrunk = tree.nodes.find(n => n.id === result.parentBranch.parent && n.type === 'trunk');
                        }
                    } else if (node.type === 'branch') {
                        result.parentBranch = node;
                        result.parentTrunk = tree.nodes.find(n => n.id === node.parent && n.type === 'trunk');
                    } else if (node.type === 'trunk') {
                        result.parentTrunk = node;
                    }
                    return result;
                };
                const deriveFocusRadiusFromObject = (node, contract = null) => {
                    if (!node) return 600;
                    if (node.type === 'sheet') {
                        const w = Number(CANONICAL_LAYOUT?.sheet?.width || 600);
                        const h = Number(CANONICAL_LAYOUT?.sheet?.height || 300);
                        return Math.max(220, Math.min(2200, Math.sqrt(w * w + h * h) * 0.9));
                    }
                    if (node.type === 'branch') {
                        const len = Number(CANONICAL_LAYOUT?.branch?.length || 800);
                        return Math.max(700, Math.min(5000, len * 0.8));
                    }
                    if (node.type === 'trunk') {
                        const top = Number(node.alt || 2000);
                        return Math.max(1800, Math.min(10000, top * 1.2));
                    }
                    if (contract?.type === 'cell') return 260;
                    if (contract?.type === 'match') return 420;
                    return 600;
                };
                const resolveFocusInputToNode = (input) => {
                    const idOrRef = (typeof input === 'string') ? { id: input } : (input || {});
                    const contract = resolveContractForTargetRef(idOrRef?.id ? { id: idOrRef.id, type: idOrRef.type } : idOrRef);
                    if (!contract) return null;
                    let node = null;
                    if (contract.type === 'trunk' || contract.type === 'branch' || contract.type === 'sheet') {
                        node = relayState.tree.nodes.find(n => n.id === contract.id) || null;
                    } else if ((contract.type === 'cell' || contract.type === 'match') && contract.sheetId) {
                        node = relayState.tree.nodes.find(n => n.id === contract.sheetId) || null;
                    } else if (contract.type === 'route') {
                        const route = getRoute(contract.id);
                        const sheetId = route?.targetSheet || null;
                        if (sheetId) node = relayState.tree.nodes.find(n => n.id === sheetId) || null;
                    }
                    if (!node && idOrRef?.id) {
                        node = relayState.tree.nodes.find(n => n.id === String(idOrRef.id)) || null;
                    }
                    if (!node) return null;
                    return { node, contract };
                };

                /**
                 * Compute ideal camera position for focusing on a node.
                 */
                const computeFocusCameraView = (node) => {
                    const center = node._center;
                    if (!center) return null;

                    if (node.type === 'sheet') {
                        // Face-on view at comfortable distance (wider than docking)
                        const normal = Cesium.Cartesian3.normalize(
                            node._renderNormal || node._normal || Cesium.Cartesian3.UNIT_Z,
                            new Cesium.Cartesian3()
                        );
                        const outward = Cesium.Cartesian3.normalize(
                            Cesium.Cartesian3.clone(center, new Cesium.Cartesian3()),
                            new Cesium.Cartesian3()
                        );
                        const viewNormal = Cesium.Cartesian3.dot(normal, outward) >= 0
                            ? normal
                            : Cesium.Cartesian3.negate(normal, new Cesium.Cartesian3());
                        const distance = 600; // wider than dock (420) for context
                        const cameraPos = Cesium.Cartesian3.add(
                            center,
                            Cesium.Cartesian3.multiplyByScalar(viewNormal, distance, new Cesium.Cartesian3()),
                            new Cesium.Cartesian3()
                        );
                        const direction = Cesium.Cartesian3.normalize(
                            Cesium.Cartesian3.subtract(center, cameraPos, new Cesium.Cartesian3()),
                            new Cesium.Cartesian3()
                        );
                        let up = node._xAxis || Cesium.Cartesian3.UNIT_Z;
                        if (Math.abs(Cesium.Cartesian3.dot(up, direction)) > 0.9) {
                            up = node._yAxis || Cesium.Cartesian3.UNIT_Y;
                        }
                        return { destination: cameraPos, orientation: { direction, up } };
                    }

                    if (node.type === 'branch') {
                        // Side profile along branch ‚Äî show branch + child sheets
                        // Position camera at 45¬∞ between branch tangent and outward normal for context
                        const outward = Cesium.Cartesian3.normalize(
                            Cesium.Cartesian3.clone(center, new Cesium.Cartesian3()),
                            new Cesium.Cartesian3()
                        );
                        // If branch has endpoint data, offset sideways from the midpoint
                        const branchEnd = node._worldEndpoint;
                        let sideOffset;
                        if (branchEnd) {
                            // Compute a perpendicular direction to the branch axis
                            const branchDir = Cesium.Cartesian3.normalize(
                                Cesium.Cartesian3.subtract(branchEnd, center, new Cesium.Cartesian3()),
                                new Cesium.Cartesian3()
                            );
                            sideOffset = Cesium.Cartesian3.cross(branchDir, outward, new Cesium.Cartesian3());
                            Cesium.Cartesian3.normalize(sideOffset, sideOffset);
                        } else {
                            sideOffset = outward;
                        }
                        // Camera at outward + side offset for 3/4 view
                        const camOffset = Cesium.Cartesian3.add(
                            Cesium.Cartesian3.multiplyByScalar(outward, 800, new Cesium.Cartesian3()),
                            Cesium.Cartesian3.multiplyByScalar(sideOffset, 600, new Cesium.Cartesian3()),
                            new Cesium.Cartesian3()
                        );
                        const cameraPos = Cesium.Cartesian3.add(center, camOffset, new Cesium.Cartesian3());
                        const direction = Cesium.Cartesian3.normalize(
                            Cesium.Cartesian3.subtract(center, cameraPos, new Cesium.Cartesian3()),
                            new Cesium.Cartesian3()
                        );
                        return { destination: cameraPos, orientation: { direction, up: Cesium.Cartesian3.UNIT_Z } };
                    }

                    if (node.type === 'trunk') {
                        // Top-down overview of entire company tree
                        const outward = Cesium.Cartesian3.normalize(center, new Cesium.Cartesian3());
                        const cameraPos = Cesium.Cartesian3.add(
                            center,
                            Cesium.Cartesian3.multiplyByScalar(outward, 3000, new Cesium.Cartesian3()),
                            new Cesium.Cartesian3()
                        );
                        const direction = Cesium.Cartesian3.normalize(
                            Cesium.Cartesian3.subtract(center, cameraPos, new Cesium.Cartesian3()),
                            new Cesium.Cartesian3()
                        );
                        return { destination: cameraPos, orientation: { direction, up: Cesium.Cartesian3.UNIT_Z } };
                    }

                    return null;
                };

                /**
                 * Update the focus breadcrumb bar.
                 */
                const updateFocusBreadcrumb = (node, parentBranch, parentTrunk) => {
                    const crumbBranch = document.getElementById('focusCrumbBranch');
                    const crumbTarget = document.getElementById('focusCrumbTarget');
                    if (!crumbBranch || !crumbTarget) return;
                    crumbBranch.textContent = parentBranch
                        ? (parentBranch.name || parentBranch.id)
                        : (parentTrunk ? (parentTrunk.name || parentTrunk.id) : '‚Äî');
                    crumbTarget.textContent = node.name || node.metadata?.sheetName || node.id;
                };
                const buildRelatedIdsForLensTarget = (targetNode, parentBranch, parentTrunk) => {
                    const relatedIds = new Set();
                    if (parentBranch) relatedIds.add(parentBranch.id);
                    if (parentTrunk) relatedIds.add(parentTrunk.id);
                    // Add sibling sheets on same branch
                    if (parentBranch) {
                        relayState.tree.nodes
                            .filter(n => n.parent === parentBranch.id && n.id !== targetNode.id)
                            .forEach(n => relatedIds.add(n.id));
                    }
                    // Add child nodes if focusing on branch/trunk
                    if (targetNode.type === 'branch' || targetNode.type === 'trunk') {
                        relayState.tree.nodes
                            .filter(n => n.parent === targetNode.id)
                            .forEach(n => relatedIds.add(n.id));
                    }
                    return relatedIds;
                };
                const clearSoftIsolation = () => {
                    if (!softIsolationTargetId || isFocusMode) return;
                    if (filamentRenderer) filamentRenderer.clearFocusDimming();
                    softIsolationTargetId = null;
                };
                const applySoftIsolation = (targetNode) => {
                    if (!targetNode || !filamentRenderer || isFocusMode || isEditSheetMode || isEditingCell) {
                        clearSoftIsolation();
                        return;
                    }
                    if (softIsolationTargetId === targetNode.id) return;
                    const { parentBranch, parentTrunk } = findParentChain(targetNode);
                    const relatedIds = buildRelatedIdsForLensTarget(targetNode, parentBranch, parentTrunk);
                    filamentRenderer.applyFocusDimming(targetNode.id, relatedIds, { mode: 'soft', dimAlpha: 0.15 });
                    softIsolationTargetId = targetNode.id;
                };
                const scheduleSoftIsolationFromMouse = () => {
                    if (softIsolationRafPending) return;
                    softIsolationRafPending = true;
                    requestAnimationFrame(() => {
                        softIsolationRafPending = false;
                        if (!viewer || !softIsolationLastMousePos || isFocusMode || isEditSheetMode || isEditingCell) {
                            clearSoftIsolation();
                            return;
                        }
                        const picked = viewer.scene.pick(softIsolationLastMousePos);
                        const pickedId = typeof picked?.id === 'string'
                            ? picked.id
                            : (picked?.id?._relayNodeId ? String(picked.id._relayNodeId) : null);
                        const node = pickedId ? resolvePickedToNode(pickedId) : null;
                        if (node && (node.type === 'trunk' || node.type === 'branch' || node.type === 'sheet')) {
                            applySoftIsolation(node);
                        } else {
                            clearSoftIsolation();
                        }
                    });
                };
                if (!window.__relaySoftIsolationListenersInstalled && viewer?.canvas) {
                    viewer.canvas.addEventListener('mousemove', (event) => {
                        const rect = viewer.canvas.getBoundingClientRect();
                        softIsolationLastMousePos = new Cesium.Cartesian2(
                            event.clientX - rect.left,
                            event.clientY - rect.top
                        );
                        scheduleSoftIsolationFromMouse();
                    });
                    viewer.canvas.addEventListener('mouseleave', () => {
                        softIsolationLastMousePos = null;
                        clearSoftIsolation();
                    });
                    window.__relaySoftIsolationListenersInstalled = true;
                }

                /**
                 * Enter Focus Lens mode on a target node.
                 */
                window.enterFocusMode = (targetNode, options = {}) => {
                    if (!targetNode || !targetNode._center) {
                        const blockSig = 'noTarget';
                        if (window.__relayLensFocusBlockedSig !== blockSig) {
                            RelayLog.warn('[LENS] focusBlocked reason=noTarget');
                            window.__relayLensFocusBlockedSig = blockSig;
                        }
                        if (hudManager && typeof hudManager.update === 'function') {
                            hudManager.update({ focusHint: 'Select an object first' });
                            if (window.__relayLensFocusHintTimer) {
                                clearTimeout(window.__relayLensFocusHintTimer);
                            }
                            window.__relayLensFocusHintTimer = setTimeout(() => {
                                if (hudManager && typeof hudManager.update === 'function') {
                                    hudManager.update({ focusHint: '' });
                                }
                            }, 2500);
                        }
                        return Promise.resolve({ ok: false, reason: 'INVALID_TARGET' });
                    }
                    // If already focused on same target, exit instead (toggle behavior)
                    if (isFocusMode && focusTarget?.node?.id === targetNode.id) {
                        window.exitFocusMode();
                        return Promise.resolve({ ok: true, toggledOff: true });
                    }
                    // If switching focus target, don't restore camera ‚Äî just switch
                    const isSwitch = isFocusMode;
                    if (!isSwitch) {
                        // Save camera state only on first focus entry
                        preFocusCameraState = {
                            position: Cesium.Cartesian3.clone(viewer.camera.positionWC),
                            direction: Cesium.Cartesian3.clone(viewer.camera.directionWC),
                            up: Cesium.Cartesian3.clone(viewer.camera.upWC)
                        };
                    }

                    const { parentBranch, parentTrunk } = findParentChain(targetNode);
                    // UX-1.1: Resolve Universal Object Contract for focused target
                    const focusContract = (options?.contractOverride && typeof options.contractOverride === 'object')
                        ? options.contractOverride
                        : toRelayObject(targetNode, relayState);
                    const previousSelectionObjectId = getActiveObjectIdForInspector();
                    const previousLod = String(lodGovernor?.getCurrentLevel?.() || filamentRenderer?.currentLOD || 'UNKNOWN');
                    const frameId = `lens.${Date.now().toString(36)}.${Math.random().toString(36).slice(2, 7)}`;
                    focusTarget = { node: targetNode, nodeType: targetNode.type, parentBranch, parentTrunk, contract: focusContract };
                    isFocusMode = true;
                    focusLensState = {
                        active: true,
                        frameId,
                        radiusM: deriveFocusRadiusFromObject(targetNode, focusContract),
                        targetObjectId: String(focusContract?.id || targetNode.id),
                        targetType: String(focusContract?.type || targetNode.type || 'object'),
                        previousSelectionObjectId: previousSelectionObjectId ? String(previousSelectionObjectId) : null,
                        previousLod,
                        previousArtifactFocusedObjectId: window.__relayArtifactFocusedObjectId ? String(window.__relayArtifactFocusedObjectId) : null
                    };
                    if (focusContract) {
                        RelayLog.info(`[LENS] contract: type=${focusContract.type} id=${focusContract.id} actions=${focusContract.actions.length}`);
                    }

                    // Camera transition
                    const cameraView = computeFocusCameraView(targetNode);
                    const travelPromise = cameraView
                        ? travelCamera({
                            destination: cameraView.destination,
                            orientation: cameraView.orientation,
                            reason: `LENS_ENTER:${focusLensState.targetObjectId}`,
                            durationMs: 1200
                        }).then(() => {
                            RelayLog.info(`[LENS] camera settled on ${targetNode.id}`);
                        })
                        : Promise.resolve();

                    // Visual: apply focus lens CSS
                    document.body.classList.add('focus-lens-active');

                    // Breadcrumb
                    updateFocusBreadcrumb(targetNode, parentBranch, parentTrunk);

                    // Apply entity dimming via filament renderer
                    if (filamentRenderer) {
                        const relatedIds = buildRelatedIdsForLensTarget(targetNode, parentBranch, parentTrunk);
                        filamentRenderer.applyFocusDimming(targetNode.id, relatedIds, { mode: 'hard' });
                    }

                    RelayLog.info(`[LENS] focus-enter target=${focusLensState.targetObjectId} frame=${frameId}`);
                    renderArtifactInspector();
                    return travelPromise.then(() => ({ ok: true, frameId, targetObjectId: focusLensState.targetObjectId }));
                };

                /**
                 * Exit Focus Lens mode and restore prior view.
                 */
                window.exitFocusMode = () => {
                    if (!isFocusMode) return Promise.resolve({ ok: true, noop: true });
                    const prevTarget = focusTarget?.node?.id || 'unknown';
                    const prevSelection = focusLensState.previousSelectionObjectId ? String(focusLensState.previousSelectionObjectId) : null;
                    const prevLod = String(focusLensState.previousLod || 'UNKNOWN');
                    const prevArtifactFocus = focusLensState.previousArtifactFocusedObjectId ? String(focusLensState.previousArtifactFocusedObjectId) : null;

                    // Restore camera
                    let restorePromise = Promise.resolve({ ok: true, restoredCamera: false });
                    if (preFocusCameraState) {
                        restorePromise = travelCamera({
                            destination: preFocusCameraState.position,
                            orientation: {
                                direction: preFocusCameraState.direction,
                                up: preFocusCameraState.up
                            },
                            reason: `LENS_EXIT:${prevTarget}`,
                            durationMs: 900
                        });
                        preFocusCameraState = null;
                    }

                    // Remove visual focus
                    document.body.classList.remove('focus-lens-active');

                    // Clear entity dimming
                    if (filamentRenderer) {
                        filamentRenderer.clearFocusDimming();
                    }

                    isFocusMode = false;
                    focusTarget = null;

                    RelayLog.info(`[LENS] focus-exit target=${prevTarget} restoreView=true`);
                    if (prevArtifactFocus) {
                        window.__relayArtifactFocusedObjectId = prevArtifactFocus;
                    }
                    focusLensState = {
                        active: false,
                        frameId: null,
                        radiusM: 0,
                        targetObjectId: null,
                        targetType: null,
                        previousSelectionObjectId: null,
                        previousLod: null,
                        previousArtifactFocusedObjectId: null
                    };
                    renderArtifactInspector();
                    return restorePromise.then(async () => {
                        await new Promise((resolve) => requestAnimationFrame(() => requestAnimationFrame(resolve)));
                        const selectionPreserved = String(getActiveObjectIdForInspector() || '') === String(prevSelection || '');
                        const lodNow = String(lodGovernor?.getCurrentLevel?.() || filamentRenderer?.currentLOD || 'UNKNOWN');
                        const lodPreserved = lodNow === prevLod;
                        const restoreState = selectionPreserved && lodPreserved ? 'PASS' : 'WARN';
                        RelayLog.info(`[LENS] focus-restore state=${restoreState} selectionPreserved=${selectionPreserved ? 'true' : 'false'} lodPreserved=${lodPreserved ? 'true' : 'false'}`);
                        return { ok: true, selectionPreserved, lodPreserved };
                    });
                };
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // BASIN-FOCUS-LOCK-1: Company-level focus on double-click
                // Uses travelCamera(). Does NOT steal input, enter sheet,
                // or modify FreeFly. Reversible via Esc.
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                window.focusCompanyOverview = (trunkNode) => {
                    if (!trunkNode || trunkNode.type !== 'trunk') {
                        RelayLog.warn('[CAM] focusLock blocked reason=notTrunk');
                        return Promise.resolve({ ok: false, reason: 'NOT_TRUNK' });
                    }
                    // Enforce clean company scope before any canopy/company render.
                    const editWasActive = isEditSheetMode === true;
                    if (editWasActive && typeof window.exitEditSheetMode === 'function') {
                        window.exitEditSheetMode();
                    }
                    // Clear all sheet-scoped selection/cache so no stale sheet-only state can bleed into company.
                    if (typeof window.relayExitSheet === 'function' && String(window.__relayEntryState?.scope || '') === 'sheet') {
                        window.relayExitSheet();
                    }
                    if (window.__relayEntryState) {
                        window.__relayEntryState.scope = 'company';
                        window.__relayEntryState.sheetId = null;
                        window.__relayEntryState.sheetAnchorCell = null;
                    }
                    window.__relayForceCompanyScope = true;
                    sheetSelection = null;
                    if (window.filamentRenderer) {
                        window.filamentRenderer._visSheetOnlyRenderSig = null;
                        window.filamentRenderer._sheetEnterLogEmitted = false;
                    }
                    if (typeof window.relayEnterCompany === 'function') {
                        window.relayEnterCompany(trunkNode.id);
                    }
                    RelayLog.info(`[FOCUS] companyScope enforced=PASS sheetCleared=true editExited=${editWasActive ? 'true' : 'false'}`);
                    // If already focused on same company, exit (toggle)
                    if (isCompanyFocusMode && companyFocusTarget?.id === trunkNode.id) {
                        return window.exitCompanyFocus();
                    }
                    // If in Focus Lens, exit first
                    if (isFocusMode && typeof window.exitFocusMode === 'function') {
                        window.exitFocusMode();
                    }

                    // Save prior camera state for Esc restore
                    if (!isCompanyFocusMode) {
                        preCompanyFocusCameraState = {
                            position: Cesium.Cartesian3.clone(viewer.camera.positionWC),
                            direction: Cesium.Cartesian3.clone(viewer.camera.directionWC),
                            up: Cesium.Cartesian3.clone(viewer.camera.upWC)
                        };
                        preCompanyFocusLodLocked = lodLocked;
                        preCompanyFocusLodLevel = lodLockedLevel;
                    }

                    isCompanyFocusMode = true;
                    companyFocusTarget = trunkNode;

                    // Compute camera destination: above and south of trunk, looking north
                    const launchScale = window.RELAY_LAUNCH_SCALE || 1;
                    const treeH = (trunkNode.alt || 2000) * launchScale;
                    const frameDist = treeH * 1.8;     // altitude ‚Äî 1.8x tree height for full framing
                    const horzDist = treeH * 1.5;      // horizontal offset south
                    const trunkLon = Number(trunkNode.lon);
                    const trunkLat = Number(trunkNode.lat);
                    const latOffset = -horzDist / 111000; // meters ‚Üí degrees
                    const headingRad = Cesium.Math.toRadians(350);  // nearly north toward tree
                    const pitchRad = Cesium.Math.toRadians(-55);    // VIS-RADIAL-CANOPY-1: steeper to show radial spread

                    const destination = Cesium.Cartesian3.fromDegrees(
                        trunkLon + 0.002,              // slight east offset for branch visibility
                        trunkLat + latOffset,
                        frameDist
                    );

                    // Lock LOD to COMPANY ‚Äî reveals full tree detail
                    lodLocked = true;
                    lodLockedLevel = 'COMPANY';
                    if (lodGovernor) lodGovernor.currentLevel = 'COMPANY';
                    if (filamentRenderer) {
                        filamentRenderer.setLOD('COMPANY');
                        filamentRenderer.renderTree('basin-focus-lock');
                    }

                    // Expose state on window for proofs
                    window._companyFocusState = {
                        active: true,
                        target: trunkNode.id,
                        scope: 'company',
                        inputOwner: 'CAMERA',
                        mode: 'FreeFly'
                    };

                    RelayLog.info(`[CAM] focusLock target=${trunkNode.id} scope=company result=PASS`);
                    RelayLog.info(`[INPUT] owner=CAMERA mode=FreeFly reason=focusLock`);
                    RelayLog.info(`[LOD] lock level=COMPANY reason=basinFocus`);

                    // Fly camera using existing travelCamera()
                    return travelCamera({
                        destination,
                        orientation: {
                            heading: headingRad,
                            pitch: pitchRad,
                            roll: 0
                        },
                        reason: `BASIN_FOCUS:${trunkNode.id}`,
                        durationMs: 1200
                    }).then((result) => {
                        RelayLog.info(`[CAM] basinFocus settled target=${trunkNode.id} distM=${frameDist.toFixed(0)} pitch=-55`);
                        if (hudManager) {
                            hudManager.update({ focusHint: `Company: ${trunkNode.name || trunkNode.id}` });
                        }
                        return { ok: true, target: trunkNode.id, scope: 'company' };
                    });
                };
                // Launch auto-focus: start at company canopy unless explicitly disabled.
                // Use ?autofocus=0 to keep manual globe-only startup.
                if (window.RELAY_LAUNCH_MODE === true && window.__relayAutoCompanyFocusScheduled !== true) {
                    const autoFocusDisabled = new URLSearchParams(window.location.search).get('autofocus') === '0';
                    if (!autoFocusDisabled) {
                        window.__relayAutoCompanyFocusScheduled = true;
                        setTimeout(() => {
                            if (window.__relayAutoCompanyFocusDone === true || typeof window.focusCompanyOverview !== 'function') return;
                            const trunk = (relayState?.tree?.nodes || []).find((n) => n.type === 'trunk');
                            if (!trunk) return;
                            window.focusCompanyOverview(trunk);
                            window.__relayAutoCompanyFocusDone = true;
                            RelayLog.info('[FOCUS] launchAutoFocus applied=PASS');
                            // VOTE-COMMIT-PERSISTENCE-1: Show HUD vote summary after company focus
                            updateHudVoteSummary();
                        }, 1300);
                    }
                }

                window.exitCompanyFocus = () => {
                    if (!isCompanyFocusMode) return Promise.resolve({ ok: true, noop: true });
                    const prevTarget = companyFocusTarget?.id || 'unknown';

                    // Restore camera
                    let restorePromise = Promise.resolve({ ok: true, restoredCamera: false });
                    if (preCompanyFocusCameraState) {
                        restorePromise = travelCamera({
                            destination: preCompanyFocusCameraState.position,
                            orientation: {
                                direction: preCompanyFocusCameraState.direction,
                                up: preCompanyFocusCameraState.up
                            },
                            reason: `BASIN_EXIT:${prevTarget}`,
                            durationMs: 900
                        });
                        preCompanyFocusCameraState = null;
                    }

                    // Restore LOD state
                    lodLocked = preCompanyFocusLodLocked;
                    lodLockedLevel = preCompanyFocusLodLevel;
                    if (lodGovernor && !lodLocked) {
                        // Let governor resume automatic LOD updates
                        const height = typeof getCameraHeightAboveGround === 'function' && viewer
                            ? getCameraHeightAboveGround(viewer) : null;
                        if (height !== null) lodGovernor.update(height);
                    }

                    isCompanyFocusMode = false;
                    companyFocusTarget = null;
                    window.__relayForceCompanyScope = false;

                    window._companyFocusState = {
                        active: false,
                        target: null,
                        scope: null,
                        inputOwner: 'CAMERA',
                        mode: 'FreeFly'
                    };

                    RelayLog.info(`[CAM] basinFocus exit target=${prevTarget} restoreView=true`);
                    if (hudManager) {
                        hudManager.update({ focusHint: '' });
                    }
                    return restorePromise;
                };

                const getMatchRowsForSheet = (sheetNode) => {
                    if (!sheetNode || !sheetNode.metadata?.isMatchSheet) return [];
                    const schema = Array.isArray(sheetNode.metadata?.schema) ? sheetNode.metadata.schema : [];
                    const matchCol = schema.findIndex((c) => c.id === 'matchId' || c.name === 'matchId');
                    if (matchCol < 0) return [];
                    const byRow = new Map();
                    (sheetNode.cellData || []).forEach((cell) => {
                        if (Number(cell.col) !== Number(matchCol)) return;
                        const row = Number(cell.row);
                        if (!Number.isFinite(row) || row <= 0) return;
                        const value = String(cell.value ?? cell.display ?? '').trim();
                        if (!value) return;
                        byRow.set(row, value);
                    });
                    return Array.from(byRow.keys())
                        .sort((a, b) => a - b)
                        .slice(0, 40)
                        .map((row) => {
                            const contract = toRelayObject({ sheetId: sheetNode.id, row, isMatch: true }, relayState);
                            return {
                                row,
                                objectId: String(contract?.id || `${sheetNode.id}.match.${row}`),
                                contract
                            };
                        });
                };
                const buildBranchWalkPath = (branchNode) => {
                    if (!branchNode || branchNode.type !== 'branch') return [];
                    const nodes = relayState?.tree?.nodes || [];
                    const trunk = nodes.find((n) => n.id === branchNode.parent && n.type === 'trunk') || null;
                    const sheets = nodes
                        .filter((n) => n.type === 'sheet' && n.parent === branchNode.id)
                        .slice()
                        .sort((a, b) => String(a.id).localeCompare(String(b.id)));
                    const path = [];
                    if (trunk) {
                        path.push({ kind: 'trunk', objectId: String(trunk.id), node: trunk });
                    }
                    path.push({ kind: 'branch', objectId: String(branchNode.id), node: branchNode });
                    sheets.forEach((sheet) => {
                        path.push({ kind: 'sheet', objectId: String(sheet.id), node: sheet });
                        getMatchRowsForSheet(sheet).forEach((m) => {
                            path.push({
                                kind: 'match',
                                objectId: String(m.objectId),
                                node: sheet,
                                sheetId: String(sheet.id),
                                row: Number(m.row)
                            });
                        });
                    });
                    return path;
                };
                const computeBranchWalkCameraView = (step) => {
                    if (!step?.node) return null;
                    if (step.kind !== 'match') {
                        const direct = computeFocusCameraView(step.node);
                        if (direct) return direct;
                        const lon = Number(step.node.lon);
                        const lat = Number(step.node.lat);
                        const alt = Number(step.node.alt || step.node.height || 0);
                        if (!Number.isFinite(lon) || !Number.isFinite(lat)) return null;
                        const center = Cesium.Cartesian3.fromDegrees(lon, lat, alt);
                        const outward = Cesium.Cartesian3.normalize(
                            Cesium.Cartesian3.clone(center, new Cesium.Cartesian3()),
                            new Cesium.Cartesian3()
                        );
                        const distance = step.kind === 'trunk' ? 3200 : (step.kind === 'branch' ? 1300 : 850);
                        const cameraPos = Cesium.Cartesian3.add(
                            center,
                            Cesium.Cartesian3.multiplyByScalar(outward, distance, new Cesium.Cartesian3()),
                            new Cesium.Cartesian3()
                        );
                        const direction = Cesium.Cartesian3.normalize(
                            Cesium.Cartesian3.subtract(center, cameraPos, new Cesium.Cartesian3()),
                            new Cesium.Cartesian3()
                        );
                        return { destination: cameraPos, orientation: { direction, up: Cesium.Cartesian3.UNIT_Z } };
                    }
                    const sheet = step.node;
                    if (!sheet._center) return null;
                    const center = sheet._center;
                    const normal = Cesium.Cartesian3.normalize(
                        sheet._renderNormal || sheet._normal || Cesium.Cartesian3.UNIT_Z,
                        new Cesium.Cartesian3()
                    );
                    const outward = Cesium.Cartesian3.normalize(Cesium.Cartesian3.clone(center, new Cesium.Cartesian3()), new Cesium.Cartesian3());
                    const viewNormal = Cesium.Cartesian3.dot(normal, outward) >= 0
                        ? normal
                        : Cesium.Cartesian3.negate(normal, new Cesium.Cartesian3());
                    const rows = Number(sheet.rows || CANONICAL_LAYOUT?.sheet?.cellRows || 20);
                    const sheetHeight = Number(CANONICAL_LAYOUT?.sheet?.height || 300);
                    const rowSpan = rows > 0 ? (sheetHeight / Math.max(1, rows)) : 16;
                    const rowOffset = (Number(step.row || 1) - 0.5 - (rows / 2)) * rowSpan;
                    const axisY = Cesium.Cartesian3.normalize(
                        sheet._yAxis || Cesium.Cartesian3.UNIT_Y,
                        new Cesium.Cartesian3()
                    );
                    const target = Cesium.Cartesian3.add(
                        center,
                        Cesium.Cartesian3.multiplyByScalar(axisY, rowOffset, new Cesium.Cartesian3()),
                        new Cesium.Cartesian3()
                    );
                    const up = Cesium.Cartesian3.normalize(
                        sheet._xAxis || Cesium.Cartesian3.UNIT_Z,
                        new Cesium.Cartesian3()
                    );
                    const cameraPos = Cesium.Cartesian3.add(
                        target,
                        Cesium.Cartesian3.multiplyByScalar(viewNormal, 620, new Cesium.Cartesian3()),
                        new Cesium.Cartesian3()
                    );
                    Cesium.Cartesian3.add(
                        cameraPos,
                        Cesium.Cartesian3.multiplyByScalar(up, 35, new Cesium.Cartesian3()),
                        cameraPos
                    );
                    const direction = Cesium.Cartesian3.normalize(
                        Cesium.Cartesian3.subtract(target, cameraPos, new Cesium.Cartesian3()),
                        new Cesium.Cartesian3()
                    );
                    return { destination: cameraPos, orientation: { direction, up } };
                };
                const branchWalkSnapshot = () => ({
                    active: branchWalkState.active === true,
                    branchId: branchWalkState.branchId || null,
                    currentIndex: Number.isFinite(Number(branchWalkState.currentIndex)) ? Number(branchWalkState.currentIndex) : -1,
                    currentObjectId: branchWalkState.currentObjectId || null,
                    path: (branchWalkState.path || []).map((p) => ({ kind: p.kind, objectId: p.objectId }))
                });
                const hashDeterministic = (text) => {
                    let h = 2166136261 >>> 0;
                    const s = String(text || '');
                    for (let i = 0; i < s.length; i++) {
                        h ^= s.charCodeAt(i);
                        h = Math.imul(h, 16777619) >>> 0;
                    }
                    return `fr-${h.toString(16).padStart(8, '0')}`;
                };
                // ‚îÄ‚îÄ CAM0.4.2-TIGHTENING-1: Cell‚ÜíFilament mapping + deterministic resolver ‚îÄ‚îÄ
                // Build a mapping from cellId and sheetId to filament IDs using the filament registry.
                // This ensures the ride keys on real filament IDs, not cellId naming coincidences.
                const buildCellToFilamentMap = () => {
                    const map = new Map(); // cellId|sheetId ‚Üí filamentId[]
                    const filaments = relayState?.filaments || new Map();
                    for (const [fId, fil] of filaments) {
                        // Map by cellId (if filament specifies a cell)
                        if (fil.cellId) {
                            const existing = map.get(fil.cellId) || [];
                            existing.push(fId);
                            map.set(fil.cellId, existing);
                        }
                        // Map by sheetId (always ‚Äî sheet-level fallback)
                        if (fil.sheetId) {
                            const existing = map.get(fil.sheetId) || [];
                            if (!existing.includes(fId)) existing.push(fId);
                            map.set(fil.sheetId, existing);
                        }
                        // Map by branchId (branch-level fallback)
                        if (fil.branchId) {
                            const existing = map.get(fil.branchId) || [];
                            if (!existing.includes(fId)) existing.push(fId);
                            map.set(fil.branchId, existing);
                        }
                    }
                    return map;
                };
                // Stamp filament IDs on cubes ‚Äî call after every renderTree().
                window.relayStampFilamentCubes = () => {
                    if (!filamentRenderer || typeof filamentRenderer.stampFilamentIds !== 'function') return { stamped: 0, total: 0 };
                    const map = buildCellToFilamentMap();
                    return filamentRenderer.stampFilamentIds(map);
                };

                // Deterministic filament resolver.
                // Chain: FIL-prefix ‚Üí filament registry ‚Üí cellId on cubes ‚Üí sheet/branch fallback ‚Üí refuse.
                const resolveFilamentIdFromInput = (input) => {
                    if (!input) return null;
                    const filaments = relayState?.filaments || new Map();
                    const cubes = Array.isArray(filamentRenderer?.timeboxCubes) ? filamentRenderer.timeboxCubes : [];

                    // Case A: string input
                    let raw = null;
                    if (typeof input === 'string') {
                        raw = input.trim();
                    } else if (input?.filamentId) {
                        raw = String(input.filamentId).trim();
                    } else if (input?.cellId) {
                        raw = String(input.cellId).trim();
                    } else {
                        const targetRef = input?.targetRef ? input.targetRef : input;
                        const contract = resolveContractForTargetRef(targetRef);
                        if (contract?.type === 'cell' && Number.isFinite(contract.row) && Number.isFinite(contract.col) && contract.sheetId) {
                            raw = `${contract.sheetId}.cell.${contract.row}.${contract.col}`;
                        } else if (contract?.id) {
                            raw = String(contract.id);
                        }
                    }
                    if (!raw) return null;

                    // Rule 1: If starts with FIL- and exists in filament registry ‚Üí use directly
                    if (raw.startsWith('FIL-') && filaments.has(raw)) {
                        return raw;
                    }

                    // Rule 2: If it matches a cellId on any cube ‚Üí return as-is (cube ride)
                    if (cubes.some(c => String(c?.cellId || '') === raw)) {
                        return raw;
                    }

                    // Rule 3: Sheet/branch ‚Üí find first filament with matching sheetId or branchId
                    for (const [fId, fil] of filaments) {
                        if (fil.sheetId === raw || fil.branchId === raw) return raw; // ride the sheet/branch cells
                    }

                    // Rule 4: If it looks like a cellId (*.cell.N.N), extract sheetId and check cubes
                    const cellParts = raw.match(/^(.+)\.cell\.\d+\.\d+$/);
                    if (cellParts) {
                        // It's a cellId ‚Äî valid for cube matching
                        return raw;
                    }

                    // Rule 5: Refuse ‚Äî cannot resolve to a rideable target
                    return raw; // pass through; buildFilamentRidePath will produce empty path
                };

                // Build ride path from cubes.
                // Matches on cube.filamentId (stamped) OR cube.cellId (v0 fallback).
                const buildFilamentRidePath = (filamentId) => {
                    const cubes = Array.isArray(filamentRenderer?.timeboxCubes) ? filamentRenderer.timeboxCubes : [];
                    // Primary: match on stamped filamentId
                    let matched = cubes.filter((c) => c?.filamentId && String(c.filamentId) === String(filamentId));
                    // Fallback: match on cellId (v0 compat ‚Äî cubes may not be stamped yet)
                    if (matched.length === 0) {
                        matched = cubes.filter((c) => String(c?.cellId || '') === String(filamentId));
                    }
                    return matched
                        .map((c) => {
                            const timeboxId = String(c?.instanceId || '');
                            const match = timeboxId.match(/-timebox-(\d+)$/);
                            const idx = Number(match?.[1] || 0);
                            return {
                                index: Number.isFinite(idx) ? idx : 0,
                                timeboxId,
                                filamentId: String(c?.filamentId || c?.cellId || filamentId),
                                center: c?.center || null
                            };
                        })
                        .filter((x) => x.timeboxId && x.center)
                        .sort((a, b) => a.index - b.index);
                };
                const computeFilamentRideCameraView = (step) => {
                    if (!step?.center) return null;
                    const target = step.center;
                    const outward = Cesium.Cartesian3.normalize(
                        Cesium.Cartesian3.clone(target, new Cesium.Cartesian3()),
                        new Cesium.Cartesian3()
                    );
                    const cameraPos = Cesium.Cartesian3.add(
                        target,
                        Cesium.Cartesian3.multiplyByScalar(outward, 460, new Cesium.Cartesian3()),
                        new Cesium.Cartesian3()
                    );
                    const direction = Cesium.Cartesian3.normalize(
                        Cesium.Cartesian3.subtract(target, cameraPos, new Cesium.Cartesian3()),
                        new Cesium.Cartesian3()
                    );
                    return { destination: cameraPos, orientation: { direction, up: Cesium.Cartesian3.UNIT_Z } };
                };
                const filamentRideSnapshot = () => ({
                    active: filamentRideState.active === true,
                    filamentId: filamentRideState.filamentId || null,
                    currentIndex: Number.isFinite(Number(filamentRideState.currentIndex)) ? Number(filamentRideState.currentIndex) : -1,
                    currentTimeboxId: filamentRideState.currentTimeboxId || null,
                    determinismHash: String(filamentRideState.determinismHash || ''),
                    path: (filamentRideState.path || []).map((p) => ({ timeboxId: p.timeboxId, filamentId: p.filamentId })),
                    // v1 epistemic fields
                    currentLifecycleState: filamentRideState.currentLifecycleState || null,
                    currentDisclosureTier: filamentRideState.currentDisclosureTier || null,
                    currentConfidence: filamentRideState.currentConfidence || 0,
                    currentAttention: filamentRideState.currentAttention || 0,
                    currentCommitCount: filamentRideState.currentCommitCount || 0,
                    currentContributorCount: filamentRideState.currentContributorCount || 0,
                    rideMode: filamentRideState.rideMode || null
                });
                // CAM0.4.2-TIGHTENING: resolveSlabMeta helper with fallback chain + per-ride cache.
                // Avoids scanning the full registry on every arrow step.
                let _slabMetaCache = null; // timeboxId ‚Üí {commitCount, scarCount, eriAvg, openDrifts}
                const resolveSlabMeta = (step) => {
                    const EMPTY = { commitCount: 0, scarCount: 0, eriAvg: 0, openDrifts: 0 };
                    const slabRegistry = filamentRenderer?._vis4SlabRegistry;
                    if (!slabRegistry || slabRegistry.size === 0) return EMPTY;
                    // Build cache on first call per ride
                    if (!_slabMetaCache) {
                        _slabMetaCache = new Map();
                        for (const [key, meta] of slabRegistry) {
                            // Index by timeboxId field (canonical)
                            if (meta.timeboxId) {
                                _slabMetaCache.set(meta.timeboxId, meta);
                            }
                            // Also index by slab key (for direct lookups)
                            _slabMetaCache.set(key, meta);
                        }
                    }
                    // Try 1: direct timeboxId
                    const m1 = _slabMetaCache.get(step.timeboxId);
                    if (m1) return { commitCount: m1.commitCount || 0, scarCount: m1.scarCount || 0, eriAvg: m1.eriAvg || 0, openDrifts: m1.openDrifts || 0 };
                    // Try 2: extract timebox index from instanceId and try common patterns
                    const tbMatch = step.timeboxId?.match(/-timebox-(\d+)$/);
                    if (tbMatch) {
                        const tbSuffix = tbMatch[1];
                        for (const [key, meta] of _slabMetaCache) {
                            if (key.endsWith('-' + tbSuffix) || meta.timeboxId === tbSuffix) {
                                return { commitCount: meta.commitCount || 0, scarCount: meta.scarCount || 0, eriAvg: meta.eriAvg || 0, openDrifts: meta.openDrifts || 0 };
                            }
                        }
                    }
                    // Not found ‚Äî log once
                    if (!resolveSlabMeta._warned) resolveSlabMeta._warned = new Set();
                    if (!resolveSlabMeta._warned.has(step.timeboxId)) {
                        RelayLog.info(`[RIDE] slabMeta missing step=${step.timeboxId}`);
                        resolveSlabMeta._warned.add(step.timeboxId);
                    }
                    return EMPTY;
                };
                const setFilamentRideIndex = async (nextIndex) => {
                    if (!filamentRideState.active) return { ok: false, reason: 'FILAMENT_RIDE_NOT_ACTIVE' };
                    const path = filamentRideState.path || [];
                    if (!path.length) return { ok: false, reason: 'FILAMENT_RIDE_PATH_EMPTY' };
                    const idx = Math.max(0, Math.min(path.length - 1, Number(nextIndex)));
                    const step = path[idx];
                    if (!step) return { ok: false, reason: 'FILAMENT_RIDE_STEP_MISSING' };

                    // ‚îÄ‚îÄ v1: Disclosure gate ‚Äî skip PRIVATE filaments with REFUSAL ‚îÄ‚îÄ
                    // Gate only applies to cross-filament stops (foreign filaments that are PRIVATE).
                    // Rider's own filament is always accessible (spec: "rider is not the owner").
                    const filaments = relayState?.filaments || new Map();
                    const fil = filaments.get(step.filamentId) || filaments.get(filamentRideState.filamentId);
                    const disclosureTier = fil?.visibilityScope || 'PRIVATE';
                    const isOwnFilament = String(step.filamentId) === String(filamentRideState.filamentId);
                    if (disclosureTier === 'PRIVATE' && !isOwnFilament) {
                        const refusalLine = `[REFUSAL] reason=RIDE_DISCLOSURE_BLOCKED filament=${step.filamentId} timebox=${step.timeboxId} tier=PRIVATE`;
                        RelayLog.info(refusalLine);
                        console.log(refusalLine);
                        // Auto-advance: find next non-PRIVATE stop (bounded to prevent infinite loop)
                        const direction = idx >= Number(filamentRideState.currentIndex) ? 1 : -1;
                        let skipIdx = idx + direction;
                        let skips = 0;
                        const maxSkips = path.length;
                        while (skips < maxSkips && skipIdx >= 0 && skipIdx < path.length) {
                            const skipStep = path[skipIdx];
                            const skipFil = filaments.get(skipStep?.filamentId) || filaments.get(filamentRideState.filamentId);
                            const skipIsOwn = String(skipStep?.filamentId) === String(filamentRideState.filamentId);
                            if (skipIsOwn || (skipFil?.visibilityScope || 'PRIVATE') !== 'PRIVATE') {
                                return setFilamentRideIndex(skipIdx);
                            }
                            skipIdx += direction;
                            skips++;
                        }
                        // All remaining stops are PRIVATE ‚Äî stay at current position
                        return { ok: false, reason: 'RIDE_ALL_REMAINING_PRIVATE', ...filamentRideSnapshot() };
                    }

                    const view = computeFilamentRideCameraView(step);
                    const fromTimeboxId = String(filamentRideState.currentTimeboxId || 'none');
                    // Camera travel is best-effort ‚Äî epistemic state updates even if travel fails
                    // (e.g. headless mode, camera locked by another system)
                    let travelOk = false;
                    if (view) {
                        const travelResult = await travelCamera({
                            destination: view.destination,
                            orientation: view.orientation,
                            reason: `FILAMENT_STEP:${step.timeboxId}`,
                            durationMs: 700
                        });
                        travelOk = travelResult?.ok === true;
                        if (!travelOk) {
                            RelayLog.info(`[RIDE] travelSoft timebox=${step.timeboxId} camera=UNAVAILABLE`);
                        }
                    }

                    // ‚îÄ‚îÄ v1: Read epistemic state at this stop ‚îÄ‚îÄ
                    const lifecycleState = fil?.lifecycleState || 'UNKNOWN';
                    const confidence = (typeof window.computeConfidence === 'function')
                        ? window.computeConfidence(step.filamentId) : 0;
                    const attention = (typeof window.computeAttention === 'function')
                        ? window.computeAttention(step.filamentId) : 0;

                    // Commit count from slab registry via resolveSlabMeta helper
                    const slabMeta = resolveSlabMeta(step);
                    const commitCount = slabMeta.commitCount;
                    const slabScarCount = slabMeta.scarCount;

                    // Contributor count: derive from getBackingRefs if available, else
                    // fall back to evidencePointers, else default to 1 if filament exists
                    let contributorCount = 0;
                    if (typeof window.getBackingRefs === 'function') {
                        const refs = window.getBackingRefs(step.filamentId);
                        contributorCount = (refs?.evidenceRefs?.length || 0);
                    }
                    if (contributorCount === 0) {
                        const evidencePointers = fil?.evidencePointers || [];
                        const contributorSet = new Set();
                        for (const ep of evidencePointers) {
                            if (ep?.author) contributorSet.add(ep.author);
                            if (ep?.userId) contributorSet.add(ep.userId);
                        }
                        contributorCount = contributorSet.size || (fil ? 1 : 0);
                    }

                    // ‚îÄ‚îÄ v1: Detect boundary crossing ‚îÄ‚îÄ
                    const previousLifecycle = filamentRideState.previousStopLifecycle;
                    const boundaries = [];
                    if (fromTimeboxId !== 'none' && fromTimeboxId !== String(step.timeboxId)) {
                        boundaries.push('timebox');
                    }
                    if (previousLifecycle && previousLifecycle !== lifecycleState) {
                        boundaries.push(`lifecycle:${previousLifecycle}->${lifecycleState}`);
                    }

                    // Update state
                    filamentRideState.previousStopLifecycle = lifecycleState;
                    filamentRideState.currentIndex = idx;
                    filamentRideState.currentTimeboxId = String(step.timeboxId);
                    filamentRideState.currentLifecycleState = lifecycleState;
                    filamentRideState.currentDisclosureTier = disclosureTier;
                    filamentRideState.currentConfidence = confidence;
                    filamentRideState.currentAttention = attention;
                    filamentRideState.currentCommitCount = commitCount;
                    filamentRideState.currentContributorCount = contributorCount;
                    if (typeof window.relayPresenceEventBind === 'function') {
                        window.relayPresenceEventBind('ride');
                    }
                    if (typeof window.relayPresenceRenderNow === 'function') {
                        window.relayPresenceRenderNow('CELL');
                    }
                    window.__relayArtifactFocusedObjectId = String(step.filamentId);

                    // ‚îÄ‚îÄ v1: Lifecycle highlight overlay ‚îÄ‚îÄ
                    if (filamentRenderer && typeof filamentRenderer.clearRideHighlight === 'function') {
                        filamentRenderer.clearRideHighlight();
                    }
                    if (filamentRenderer && typeof filamentRenderer.renderRideHighlight === 'function' && step.center) {
                        filamentRenderer.renderRideHighlight(step.center, lifecycleState);
                    }

                    // ‚îÄ‚îÄ v1: Update HUD with ride context ‚îÄ‚îÄ
                    if (typeof hudManager !== 'undefined' && hudManager && typeof hudManager.update === 'function') {
                        hudManager.update({
                            operationMode: 'FilamentRide',
                            rideFilamentId: filamentRideState.filamentId,
                            rideStep: idx + 1,
                            rideTotal: path.length,
                            rideTimeboxId: step.timeboxId,
                            rideLifecycle: lifecycleState,
                            rideDisclosure: disclosureTier,
                            rideConf: Math.round(confidence * 100),
                            rideAttn: Math.round(attention * 100),
                            rideCommits: commitCount,
                            rideContributors: contributorCount
                        });
                    }

                    // ‚îÄ‚îÄ v1: Structured logs ‚îÄ‚îÄ
                    const stepLine = `[RIDE] step from=${fromTimeboxId} to=${step.timeboxId} index=${idx + 1}/${path.length} lifecycle=${lifecycleState} disclosure=${disclosureTier} conf=${Math.round(confidence * 100)} attn=${Math.round(attention * 100)}`;
                    RelayLog.info(stepLine);
                    console.log(stepLine);

                    if (boundaries.length > 0) {
                        const boundaryLine = `[RIDE] boundary timebox=${step.timeboxId} crossed=${boundaries.join(',')} detail=${boundaries.join('; ')}`;
                        RelayLog.info(boundaryLine);
                        console.log(boundaryLine);
                    }

                    const hudLine = `[RIDE] hudContext filament=${filamentRideState.filamentId} step=${idx + 1} lifecycle=${lifecycleState} disclosure=${disclosureTier} conf=${Math.round(confidence * 100)} attn=${Math.round(attention * 100)}`;
                    RelayLog.info(hudLine);
                    console.log(hudLine);

                    // v0 compat log
                    RelayLog.info(`[MOVE] ride-step from=${fromTimeboxId} to=${filamentRideState.currentTimeboxId}`);
                    renderArtifactInspector();
                    return { ok: true, ...filamentRideSnapshot() };
                };
                const setBranchWalkIndex = async (nextIndex) => {
                    if (!branchWalkState.active) return { ok: false, reason: 'BRANCH_WALK_NOT_ACTIVE' };
                    const path = branchWalkState.path || [];
                    const idx = Math.max(0, Math.min(path.length - 1, Number(nextIndex)));
                    const step = path[idx];
                    if (!step) return { ok: false, reason: 'BRANCH_WALK_STEP_MISSING' };
                    const fromObjectId = String(branchWalkState.currentObjectId || 'none');
                    const view = computeBranchWalkCameraView(step);
                    if (!view) return { ok: false, reason: 'BRANCH_WALK_VIEW_UNAVAILABLE' };
                    const travelResult = await travelCamera({
                        destination: view.destination,
                        orientation: view.orientation,
                        reason: `BRANCH_STEP:${step.objectId}`,
                        durationMs: 850
                    });
                    if (travelResult?.ok !== true) return { ok: false, reason: 'BRANCH_WALK_TRAVEL_FAILED' };
                    branchWalkState.currentIndex = idx;
                    branchWalkState.currentObjectId = String(step.objectId);
                    window.__relayArtifactFocusedObjectId = String(step.objectId);
                    RelayLog.info(`[MOVE] branch-step from=${fromObjectId} to=${branchWalkState.currentObjectId}`);
                    renderArtifactInspector();
                    return { ok: true, ...branchWalkSnapshot() };
                };
                window.enterBranchWalk = async (branchIdInput) => {
                    if (!viewer?.camera) return { ok: false, reason: 'CAMERA_UNAVAILABLE' };
                    let branchId = String(branchIdInput || '').trim();
                    if (!branchId) return { ok: false, reason: 'BRANCH_WALK_MISSING_BRANCH' };
                    const contract = resolveContractForTargetRef({ id: branchId, type: 'branch' });
                    if (contract?.type === 'branch' && contract.id) branchId = String(contract.id);
                    const branchNode = (relayState?.tree?.nodes || []).find((n) => n.type === 'branch' && n.id === branchId) || null;
                    if (!branchNode) return { ok: false, reason: 'BRANCH_WALK_BRANCH_UNKNOWN' };
                    if (isFocusMode && typeof window.exitFocusMode === 'function') {
                        await window.exitFocusMode();
                    }
                    if (branchWalkState.active && typeof window.exitBranchWalk === 'function') {
                        await window.exitBranchWalk();
                    }
                    const path = buildBranchWalkPath(branchNode);
                    if (!path.length) return { ok: false, reason: 'BRANCH_WALK_PATH_EMPTY' };
                    branchWalkState = {
                        active: true,
                        branchId: String(branchNode.id),
                        currentIndex: -1,
                        currentObjectId: null,
                        path,
                        previousSelectionObjectId: String(getActiveObjectIdForInspector() || ''),
                        previousLod: String(lodGovernor?.getCurrentLevel?.() || filamentRenderer?.currentLOD || 'UNKNOWN'),
                        previousArtifactFocusedObjectId: String(window.__relayArtifactFocusedObjectId || ''),
                        preCameraState: {
                            position: Cesium.Cartesian3.clone(viewer.camera.positionWC),
                            direction: Cesium.Cartesian3.clone(viewer.camera.directionWC),
                            up: Cesium.Cartesian3.clone(viewer.camera.upWC)
                        }
                    };
                    RelayLog.info(`[MOVE] mode=branch target=${branchWalkState.branchId}`);
                    const first = await setBranchWalkIndex(0);
                    if (first?.ok !== true) {
                        branchWalkState = {
                            active: false, branchId: null, currentIndex: -1, currentObjectId: null, path: [],
                            previousSelectionObjectId: null, previousLod: null, previousArtifactFocusedObjectId: null, preCameraState: null
                        };
                        return first;
                    }
                    return { ok: true, ...branchWalkSnapshot() };
                };
                window.branchWalkNext = async () => {
                    if (!branchWalkState.active) return { ok: false, reason: 'BRANCH_WALK_NOT_ACTIVE' };
                    const path = branchWalkState.path || [];
                    const next = Math.min(path.length - 1, Number(branchWalkState.currentIndex) + 1);
                    return setBranchWalkIndex(next);
                };
                window.branchWalkPrev = async () => {
                    if (!branchWalkState.active) return { ok: false, reason: 'BRANCH_WALK_NOT_ACTIVE' };
                    const prev = Math.max(0, Number(branchWalkState.currentIndex) - 1);
                    return setBranchWalkIndex(prev);
                };
                window.exitBranchWalk = async () => {
                    if (!branchWalkState.active) return { ok: true, noop: true, ...branchWalkSnapshot() };
                    const prevSelection = String(branchWalkState.previousSelectionObjectId || '');
                    const prevLod = String(branchWalkState.previousLod || 'UNKNOWN');
                    const prevArtifactFocus = String(branchWalkState.previousArtifactFocusedObjectId || '');
                    const preCamera = branchWalkState.preCameraState;
                    if (prevArtifactFocus) {
                        window.__relayArtifactFocusedObjectId = prevArtifactFocus;
                    }
                    let restore = { ok: true };
                    if (preCamera?.position && preCamera?.direction && preCamera?.up) {
                        restore = await travelCamera({
                            destination: preCamera.position,
                            orientation: { direction: preCamera.direction, up: preCamera.up },
                            reason: `BRANCH_EXIT:${branchWalkState.branchId}`,
                            durationMs: 900
                        });
                    }
                    branchWalkState = {
                        active: false,
                        branchId: null,
                        currentIndex: -1,
                        currentObjectId: null,
                        path: [],
                        previousSelectionObjectId: null,
                        previousLod: null,
                        previousArtifactFocusedObjectId: null,
                        preCameraState: null
                    };
                    RelayLog.info('[MOVE] branch-exit restoreView=true');
                    renderArtifactInspector();
                    await new Promise((resolve) => requestAnimationFrame(() => requestAnimationFrame(resolve)));
                    const selectionPreserved = String(getActiveObjectIdForInspector() || '') === prevSelection;
                    const lodNow = String(lodGovernor?.getCurrentLevel?.() || filamentRenderer?.currentLOD || 'UNKNOWN');
                    const lodPreserved = lodNow === prevLod;
                    return { ok: restore?.ok !== false, selectionPreserved, lodPreserved, ...branchWalkSnapshot() };
                };
                window.enterFilamentRide = async (targetInput) => {
                    if (!viewer?.camera) return { ok: false, reason: 'CAMERA_UNAVAILABLE' };
                    const focusedRaw = String(window.__relayArtifactFocusedObjectId || '').trim();
                    const filamentId = resolveFilamentIdFromInput(targetInput) || focusedRaw;
                    if (!filamentId) return { ok: false, reason: 'FILAMENT_RIDE_TARGET_MISSING' };
                    // CAM0.4.2-TIGHTENING-1: Diagnostic logs for ID resolution
                    const cubes = Array.isArray(filamentRenderer?.timeboxCubes) ? filamentRenderer.timeboxCubes : [];
                    const resolvedKind = filamentId.startsWith('FIL-') ? 'filament'
                        : filamentId.match(/\.cell\.\d+\.\d+$/) ? 'cell'
                        : (relayState?.tree?.nodes || []).some(n => n.id === filamentId && n.type === 'sheet') ? 'sheet'
                        : (relayState?.tree?.nodes || []).some(n => n.id === filamentId && n.type === 'branch') ? 'branch'
                        : 'unknown';
                    const uniqueCellIds = [...new Set(cubes.map(c => c.cellId).filter(Boolean))];
                    const sampleIds = uniqueCellIds.slice(0, 5);
                    RelayLog.info(`[RIDE] resolve focusId=${filamentId} kind=${resolvedKind}`);
                    console.log(`[RIDE] resolve focusId=${filamentId} kind=${resolvedKind}`);
                    RelayLog.info(`[RIDE] cubeIds sample=[${sampleIds.join(',')}] unique=${uniqueCellIds.length}`);
                    console.log(`[RIDE] cubeIds sample=[${sampleIds.join(',')}] unique=${uniqueCellIds.length}`);
                    // Invalidate slab meta cache for fresh ride + stamp filament IDs on cubes
                    _slabMetaCache = null;
                    if (typeof window.relayStampFilamentCubes === 'function') {
                        const stampResult = window.relayStampFilamentCubes();
                        if (stampResult.stamped > 0) {
                            RelayLog.info(`[RIDE] stampFilamentCubes stamped=${stampResult.stamped} total=${stampResult.total}`);
                        }
                    }
                    const path = buildFilamentRidePath(filamentId);
                    if (!path.length) {
                        const refusalLine = `[REFUSAL] reason=RIDE_NO_FILAMENT_RESOLVED focus=${filamentId} kind=${resolvedKind} cubes=${cubes.length}`;
                        RelayLog.info(refusalLine);
                        console.log(refusalLine);
                        return { ok: false, reason: 'FILAMENT_RIDE_PATH_UNAVAILABLE' };
                    }
                    // Safety: clear any stale ride highlight from a previous abnormal exit
                    if (filamentRenderer && typeof filamentRenderer.clearRideHighlight === 'function') {
                        filamentRenderer.clearRideHighlight();
                    }
                    // v1: Do NOT exit focus mode ‚Äî ride coexists with company focus
                    // (exiting focus would zoom to globe, destroying timebox cubes).
                    // Exit other movement modes that conflict with camera control.
                    if (branchWalkState.active && typeof window.exitBranchWalk === 'function') {
                        await window.exitBranchWalk();
                    }
                    if (filamentRideState.active && typeof window.exitFilamentRide === 'function') {
                        await window.exitFilamentRide();
                    }
                    // v1: Detect render mode for scaffold-awareness
                    const rideMode = (window._relayRenderMode === 'TREE_SCAFFOLD') ? 'scaffold' : 'canopy';
                    filamentRideState = {
                        active: true,
                        filamentId: String(filamentId),
                        currentIndex: -1,
                        currentTimeboxId: null,
                        path,
                        determinismHash: hashDeterministic(path.map((p) => p.timeboxId).join('|')),
                        previousSelectionObjectId: String(getActiveObjectIdForInspector() || ''),
                        previousLod: String(lodGovernor?.getCurrentLevel?.() || filamentRenderer?.currentLOD || 'UNKNOWN'),
                        previousArtifactFocusedObjectId: String(window.__relayArtifactFocusedObjectId || ''),
                        preCameraState: {
                            position: Cesium.Cartesian3.clone(viewer.camera.positionWC),
                            direction: Cesium.Cartesian3.clone(viewer.camera.directionWC),
                            up: Cesium.Cartesian3.clone(viewer.camera.upWC)
                        },
                        // v1 epistemic fields (set on first step)
                        currentLifecycleState: null,
                        currentDisclosureTier: null,
                        currentConfidence: 0,
                        currentAttention: 0,
                        currentCommitCount: 0,
                        currentContributorCount: 0,
                        previousStopLifecycle: null,
                        rideMode
                    };
                    // v1: [RIDE] enter log
                    const enterLine = `[RIDE] enter filament=${filamentRideState.filamentId} stops=${path.length} mode=${rideMode} hash=${filamentRideState.determinismHash}`;
                    RelayLog.info(enterLine);
                    console.log(enterLine);
                    RelayLog.info(`[MOVE] mode=filamentRide target=${filamentRideState.filamentId}`);
                    const first = await setFilamentRideIndex(0);
                    if (first?.ok !== true) {
                        filamentRideState = {
                            active: false,
                            filamentId: null,
                            currentIndex: -1,
                            currentTimeboxId: null,
                            path: [],
                            determinismHash: '',
                            previousSelectionObjectId: null,
                            previousLod: null,
                            previousArtifactFocusedObjectId: null,
                            preCameraState: null,
                            currentLifecycleState: null,
                            currentDisclosureTier: null,
                            currentConfidence: 0,
                            currentAttention: 0,
                            currentCommitCount: 0,
                            currentContributorCount: 0,
                            previousStopLifecycle: null,
                            rideMode: null
                        };
                        return first;
                    }
                    return { ok: true, ...filamentRideSnapshot() };
                };
                window.filamentRideNext = async () => {
                    if (!filamentRideState.active) return { ok: false, reason: 'FILAMENT_RIDE_NOT_ACTIVE' };
                    const path = filamentRideState.path || [];
                    const next = Math.min(path.length - 1, Number(filamentRideState.currentIndex) + 1);
                    return setFilamentRideIndex(next);
                };
                window.filamentRidePrev = async () => {
                    if (!filamentRideState.active) return { ok: false, reason: 'FILAMENT_RIDE_NOT_ACTIVE' };
                    const prev = Math.max(0, Number(filamentRideState.currentIndex) - 1);
                    return setFilamentRideIndex(prev);
                };
                window.exitFilamentRide = async () => {
                    if (!filamentRideState.active) return { ok: true, noop: true, ...filamentRideSnapshot() };
                    const prevSelection = String(filamentRideState.previousSelectionObjectId || '');
                    const prevLod = String(filamentRideState.previousLod || 'UNKNOWN');
                    const prevArtifactFocus = String(filamentRideState.previousArtifactFocusedObjectId || '');
                    const preCamera = filamentRideState.preCameraState;
                    const exitFilamentId = filamentRideState.filamentId;
                    const exitStopCount = (filamentRideState.path || []).length;
                    const exitMode = filamentRideState.rideMode || 'canopy';
                    if (prevArtifactFocus) {
                        window.__relayArtifactFocusedObjectId = prevArtifactFocus;
                    }
                    // v1: Clear highlight overlay
                    if (filamentRenderer && typeof filamentRenderer.clearRideHighlight === 'function') {
                        filamentRenderer.clearRideHighlight();
                    }
                    let restore = { ok: true };
                    if (preCamera?.position && preCamera?.direction && preCamera?.up) {
                        restore = await travelCamera({
                            destination: preCamera.position,
                            orientation: { direction: preCamera.direction, up: preCamera.up },
                            reason: `FILAMENT_EXIT:${exitFilamentId}`,
                            durationMs: 850
                        });
                    }
                    filamentRideState = {
                        active: false,
                        filamentId: null,
                        currentIndex: -1,
                        currentTimeboxId: null,
                        path: [],
                        determinismHash: '',
                        previousSelectionObjectId: null,
                        previousLod: null,
                        previousArtifactFocusedObjectId: null,
                        preCameraState: null,
                        currentLifecycleState: null,
                        currentDisclosureTier: null,
                        currentConfidence: 0,
                        currentAttention: 0,
                        currentCommitCount: 0,
                        currentContributorCount: 0,
                        previousStopLifecycle: null,
                        rideMode: null
                    };
                    const selectionPreserved = String(getActiveObjectIdForInspector() || '') === prevSelection;
                    const lodNow = String(lodGovernor?.getCurrentLevel?.() || filamentRenderer?.currentLOD || 'UNKNOWN');
                    const lodPreserved = lodNow === prevLod;
                    // v1: Invalidate slab meta cache
                    _slabMetaCache = null;
                    // v1: [RIDE] exit log
                    const exitLine = `[RIDE] exit filament=${exitFilamentId} stops=${exitStopCount} mode=${exitMode} selectionPreserved=${selectionPreserved} lodPreserved=${lodPreserved}`;
                    RelayLog.info(exitLine);
                    console.log(exitLine);
                    // v1: Reset HUD mode
                    if (typeof hudManager !== 'undefined' && hudManager && typeof hudManager.update === 'function') {
                        hudManager.update({ operationMode: 'FreeFly' });
                    }
                    if (typeof window.relayPresenceEventBind === 'function') {
                        window.relayPresenceEventBind('ride');
                    }
                    if (typeof window.relayPresenceRenderNow === 'function') {
                        window.relayPresenceRenderNow('SHEET');
                    }
                    RelayLog.info('[MOVE] ride-exit restoreView=true');
                    renderArtifactInspector();
                    return { ok: restore?.ok !== false, selectionPreserved, lodPreserved, ...filamentRideSnapshot() };
                };

                // Wire focus exit button
                const focusExitBtn = document.getElementById('focusExitBtn');
                if (focusExitBtn) {
                    focusExitBtn.addEventListener('click', () => window.exitFocusMode());
                }

                const getAggregateCFStatus = (tree) => {
                    const sheets = tree?.nodes?.filter(n => n.type === 'sheet') || [];
                    if (sheets.length === 0) return 'INDETERMINATE';
                    const statuses = sheets.map(s => s?.metadata?.cfStatus).filter(Boolean);
                    if (statuses.length === 0) return 'INDETERMINATE';
                    if (statuses.every(s => s === 'VERIFIED')) return 'VERIFIED';
                    if (statuses.every(s => s === 'INDETERMINATE')) return 'INDETERMINATE';
                    return 'MIXED';
                };

                window.setSpreadsheetProofView = () => {
                    const sheets = relayState.tree.nodes.filter(n => n.type === 'sheet');
                    const sheet = sheets.find(s => s._center && s._normal) || sheets[0];
                    if (!sheet || !sheet._center || !sheet._normal) {
                        RelayLog.warn('‚ö†Ô∏è Spreadsheet proof view unavailable (sheet not ready)');
                        return;
                    }
                    const normal = Cesium.Cartesian3.normalize(sheet._normal, new Cesium.Cartesian3());
                    const up = sheet._xAxis ? Cesium.Cartesian3.normalize(sheet._xAxis, new Cesium.Cartesian3()) : Cesium.Cartesian3.UNIT_Z;
                    const sheetW = CANONICAL_LAYOUT.sheet.width;
                    const sheetH = CANONICAL_LAYOUT.sheet.height;
                    const proofDist = Math.max(sheetW, sheetH) * 2;
                    const proofUp = sheetH * 0.5;
                    const offset = Cesium.Cartesian3.add(
                        Cesium.Cartesian3.multiplyByScalar(normal, proofDist, new Cesium.Cartesian3()),
                        Cesium.Cartesian3.multiplyByScalar(up, proofUp, new Cesium.Cartesian3()),
                        new Cesium.Cartesian3()
                    );
                    const cameraPos = Cesium.Cartesian3.add(sheet._center, offset, new Cesium.Cartesian3());
                    const direction = Cesium.Cartesian3.normalize(
                        Cesium.Cartesian3.subtract(sheet._center, cameraPos, new Cesium.Cartesian3()),
                        new Cesium.Cartesian3()
                    );
                    viewer.camera.setView({
                        destination: cameraPos,
                        orientation: {
                            direction,
                            up
                        }
                    });
                };

                window.enterEditSheetMode = (sheet) => {
                    if (isEditSheetMode) return;
                    isEditSheetMode = true;
                    window._isEditSheetMode = true; // PROJ-SHEET-FACING-1: expose for projection block
                    // LAUNCH-FIX-1b: Mark explicit enter to suppress auto-dock conflict
                    window._relayExplicitEnterActive = true;
                    window._r0AutoDockSuppressLogged = false;
                    suppressPointerLock = true;
                    editSheetManualExit = false;  // reset ‚Äî will be set again on next exit
                    // LAUNCH-ALIGN-1: Store anchor cell for smooth 3D/2D transition
                    const anchorR = sheetSelection?.row ?? 0;
                    const anchorC = sheetSelection?.col ?? 0;
                    if (window.__relayEntryState) {
                        window.__relayEntryState.sheetAnchorCell = { r: anchorR, c: anchorC };
                    }
                    // Stop any in-progress WASD movement and reset Cesium controls
                    if (flightControls) flightControls.resetMoveState();
                    if (document.pointerLockElement) {
                        document.exitPointerLock();
                    }
                    if (viewer?.scene?.screenSpaceCameraController) {
                        const c = viewer.scene.screenSpaceCameraController;
                        c.enableInputs = false;
                        c.enableRotate = false;
                        c.enableTranslate = false;
                        c.enableZoom = false;
                    }
                    lodLocked = true;
                    lodLockedLevel = 'SHEET';
                    RelayLog.info('[MODE] enter EDIT_SHEET ‚Äî docking from any angle');
                    RelayLog.info('[INPUT] owner=GRID mode=SheetEdit reason=explicitEnter');
                    RelayLog.info('[LOD] editSheet override=ON level=SHEET');
                    hudManager.update({ editSheetMode: true });

                    // Phase 1: Camera orbits/flies to face-on position
                    // No overlay yet ‚Äî just the 3D world dimming slightly as camera rotates
                    // LAUNCH READABILITY (3): Zero-transition in launch mode (setView, no flyTo)
                    const launchInstant = window.RELAY_LAUNCH_MODE === true;
                    if (!launchInstant) document.body.classList.add('edit-sheet-preview');
                    const targetSheet = sheet || editSheetTargetSheet;
                    window.setCompanyTopDownView(targetSheet, {
                        duration: launchInstant ? 0 : 1.2,
                        onDocked: () => {
                            // Phase 2: Camera is now face-on ‚Üí wait one frame for Cesium to render,
                            // then project 3D sheet to screen coords and size the 2D grid to match
                            RelayLog.info('[MODE] Camera aligned ‚Äî transitioning to 2D');
                            requestAnimationFrame(() => {
                                // LAUNCH-ALIGN-1: Scroll viewport to anchor cell for smooth transition
                                const anchor = window.__relayEntryState?.sheetAnchorCell;
                                if (anchor && Number.isFinite(anchor.r) && Number.isFinite(anchor.c)) {
                                    viewportRowStart = Math.max(0, anchor.r);
                                    viewportColStart = Math.max(0, anchor.c);
                                    RelayLog.info(`[SHEET-2D] viewport anchor r=${anchor.r} c=${anchor.c}`);
                                }
                                renderHtmlGrid(true);  // isDockEvent=true ‚Üí triggers diagnostic + log
                                document.body.classList.remove('edit-sheet-preview');
                                document.body.classList.add('edit-sheet-mode');
                                if (sheetOverlay) sheetOverlay.style.pointerEvents = 'auto';
                                if (sheetGridOverlay) {
                                    sheetGridOverlay.style.pointerEvents = 'auto';
                                    // Clear inline opacity override set on exit ‚Äî let CSS class control
                                    sheetGridOverlay.style.opacity = '';
                                    // Restore child pointer-events that were force-cleared on exit (C0)
                                    sheetGridOverlay.querySelectorAll('*').forEach(el => {
                                        el.style.pointerEvents = '';
                                    });
                                }
                                RelayLog.info('[MODE] EDIT_SHEET docking complete ‚Äî 2D controls active');
                                // ‚îÄ‚îÄ‚îÄ A0 Gate: Spreadsheet engine readiness proof ‚îÄ‚îÄ‚îÄ
                                const _a0Sheet = getActiveGridSheet();
                                const _a0Rows = _a0Sheet?.rows || CANONICAL_LAYOUT.sheet.cellRows;
                                const _a0Cols = _a0Sheet?.cols || CANONICAL_LAYOUT.sheet.cellCols;
                                const _a0Cells = _a0Sheet?.cellData?.length || 0;
                                const _a0Formulas = _a0Sheet?.cellData?.filter(c => c.hasFormula)?.length || 0;
                                const _a0HasScrollbars = !!document.getElementById('gridScrollbarVThumb') && !!document.getElementById('gridScrollbarHThumb');
                                const _a0HasNameBox = !!document.getElementById('sheetGridCellRefInput');
                                const _a0HasFormulaBar = !!document.getElementById('sheetGridFormulaInput');
                                RelayLog.info(`[A0-GATE] engine=READY grid=${_a0Rows}√ó${_a0Cols} cells=${_a0Cells} formulas=${_a0Formulas} scrollbars=${_a0HasScrollbars} nameBox=${_a0HasNameBox} formulaBar=${_a0HasFormulaBar} editCommit=commitEdit+applyCellValue 3DLabelSync=getCellEntity+entity.label.text gridDiag=computeSheetScreenRect`);
                            });
                        }
                    });

                    if (!editSheetWheelHandler) {
                        editSheetWheelHandler = (event) => {
                            if (!isEditSheetMode) return;
                            event.preventDefault();
                            event.stopPropagation();
                            if (sheetOverlayBody) {
                                sheetOverlayBody.scrollTop += event.deltaY;
                            }
                        };
                    }
                    if (!editSheetKeyHandler) {
                        editSheetKeyHandler = (event) => {
                            if (!isEditSheetMode || isEditingCell) return;
                            // Don't intercept keys when name box is focused
                            if (document.activeElement && document.activeElement.id === 'sheetGridCellRefInput') return;
                            const key = event.key;
                            const isPrintable = key.length === 1 && !event.ctrlKey && !event.metaKey && !event.altKey;
                            const isNavKey = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Tab', 'Enter', 'Backspace'].includes(key);
                            if (!isPrintable && !isNavKey) return;
                            event.preventDefault();
                            event.stopPropagation();
                            if (key === 'ArrowUp') moveSelectionBy(-1, 0);
                            else if (key === 'ArrowDown') moveSelectionBy(1, 0);
                            else if (key === 'ArrowLeft') moveSelectionBy(0, -1);
                            else if (key === 'ArrowRight') moveSelectionBy(0, 1);
                            else if (key === 'Enter') beginEdit();
                            else if (isPrintable) {
                                beginEdit();
                                const editInput = getEditInput();
                                if (!editInput?.disabled) {
                                    editInput.value = key;
                                    editInput.setSelectionRange(1, 1);
                                }
                            }
                        };
                    }
                    const wheelTarget = sheetGridOverlay || sheetOverlay;
                    if (wheelTarget) {
                        wheelTarget.addEventListener('wheel', editSheetWheelHandler, { passive: false });
                    }
                    document.addEventListener('keydown', editSheetKeyHandler, true);
                    if (!editSheetInputLogged) {
                        RelayLog.info('[MODE] EDIT_SHEET inputOwner=GRID wheelCaptured=true keyCaptured=true');
                        editSheetInputLogged = true;
                    }
                };

                window.exitEditSheetMode = () => {
                    if (!isEditSheetMode) return;
                    isEditSheetMode = false;
                    window._isEditSheetMode = false; // PROJ-SHEET-FACING-1: expose for projection block
                    suppressPointerLock = false;
                    window._dockLayout = null;  // Clear dock-aligned layout
                    _gridDiagLogged = false;    // Reset diagnostic for next dock session
                    RelayLog.info('[MODE] exit EDIT_SHEET ‚Äî instant undock');
                    hudManager.update({ editSheetMode: false });

                    // Instant exit: kill CSS transitions, snap everything back in one frame
                    const cesiumEl = document.getElementById('cesiumContainer');
                    if (cesiumEl) cesiumEl.style.transition = 'none';
                    const overlayEl = document.getElementById('spreadsheetOverlay');
                    if (overlayEl) overlayEl.style.transition = 'none';

                    document.body.classList.remove('edit-sheet-mode');
                    document.body.classList.remove('edit-sheet-preview');

                    // Snap camera to pre-dock position (no animation)
                    const preDock = window._preDockCameraState;
                    if (preDock && viewer) {
                        viewer.camera.setView({
                            destination: preDock.position,
                            orientation: {
                                direction: preDock.direction,
                                up: preDock.up
                            }
                        });
                    }
                    window._preDockCameraState = null;

                    // ‚îÄ‚îÄ‚îÄ C0 Gate: Comprehensive mode restore ‚îÄ‚îÄ‚îÄ
                    // 1. Force ALL overlay pointer-events to none (root cause of mouse death)
                    if (sheetOverlay) sheetOverlay.style.pointerEvents = 'none';
                    if (sheetGridOverlay) {
                        sheetGridOverlay.style.pointerEvents = 'none';
                        sheetGridOverlay.style.opacity = '0';
                        // Force all children to also be non-interactive
                        sheetGridOverlay.querySelectorAll('*').forEach(el => {
                            el.style.pointerEvents = 'none';
                        });
                    }

                    // 2. Remove event handlers BEFORE re-enabling Cesium controls
                    const wheelTarget = sheetGridOverlay || sheetOverlay;
                    if (wheelTarget && editSheetWheelHandler) {
                        wheelTarget.removeEventListener('wheel', editSheetWheelHandler);
                    }
                    if (editSheetKeyHandler) {
                        document.removeEventListener('keydown', editSheetKeyHandler, true);
                    }
                    if (sheetGridFormulaInput) {
                        sheetGridFormulaInput.disabled = true;
                    }
                    isEditingCell = false;

                    // 3. Restore all 3D controls immediately
                    if (flightControls) flightControls.resetMoveState();
                    const ssc = viewer?.scene?.screenSpaceCameraController;
                    if (ssc) {
                        ssc.enableInputs = true;
                        ssc.enableRotate = true;
                        ssc.enableTranslate = true;
                        ssc.enableZoom = true;
                        ssc.enableTilt = true;
                        ssc.enableLook = true;
                    }

                    // 4. Release any lingering pointer lock
                    if (document.pointerLockElement) {
                        document.exitPointerLock();
                    }

                    // 5. Transfer focus to Cesium canvas so WASD + clicks register immediately
                    // Blur ALL focused elements first (inputs, textareas, panels)
                    try {
                        if (document.activeElement && document.activeElement !== document.body) {
                            document.activeElement.blur();
                        }
                    } catch (_) { /* ignore blur errors on detached elements */ }
                    const cesiumCanvas = viewer?.canvas;
                    if (cesiumCanvas) {
                        cesiumCanvas.tabIndex = 0; // ensure focusable BEFORE focus()
                        cesiumCanvas.focus();
                    }
                    // Deferred re-focus: some browsers need a frame to complete overlay teardown
                    requestAnimationFrame(() => {
                        if (cesiumCanvas && document.activeElement !== cesiumCanvas) {
                            cesiumCanvas.focus();
                        }
                    });

                    // 6. Prevent auto re-dock until user moves away
                    editSheetManualExit = true;
                    editSheetAutoCooldownUntil = Date.now() + 2000;

                    // 6b. LAUNCH-FIX-1b: Clear all stale sheet scope state
                    if (typeof window._relayClearSheetScopeState === 'function') {
                        window._relayClearSheetScopeState();
                    }

                    // 7. Re-enable CSS transitions after one frame
                    requestAnimationFrame(() => {
                        if (cesiumEl) cesiumEl.style.transition = '';
                        if (overlayEl) overlayEl.style.transition = '';
                        // Second enforcement: ensure overlay is non-interactive after transition restore
                        if (sheetGridOverlay) {
                            sheetGridOverlay.style.pointerEvents = 'none';
                        }
                    });

                    // 8. Mode restore audit log (C0 gate proof)
                    const _overlayPE = sheetGridOverlay?.style?.pointerEvents || 'n/a';
                    const _sscEnabled = ssc?.enableInputs ?? false;
                    const _freeFlyBound = !!flightControls;
                    const _pointerLocked = !!document.pointerLockElement;
                    const _activeEl = document.activeElement?.tagName || 'BODY';
                    const _canvasFocused = (document.activeElement === cesiumCanvas);
                    RelayLog.info(`[MODE-RESTORE] overlayPointer=${_overlayPE} ssc.enableInputs=${_sscEnabled} freeFlyBound=${_freeFlyBound} pointerLocked=${_pointerLocked} activeElement=${_activeEl} canvasFocused=${_canvasFocused} isEditingCell=${isEditingCell}`);
                    RelayLog.info('[INPUT] owner=CAMERA mode=FreeFly reason=exit');
                    RelayLog.info('[FLIGHT] WASD controls active ‚Äî press ` (backquote) to toggle pointer lock for mouse-look');
                };

                // Keyboard shortcuts for camera presets + LOD lock + Focus Lens
                document.addEventListener('keydown', (event) => {
                    // Escape priority invariant (CAM0.4.2-TIGHTENING):
                    //   megasheet exit > filament ride exit > buds > slab focus > markers > editing > focus mode
                    //   If ride active ‚Üí ride exit MUST win over everything except hard browser-level UI.
                    //   megasheet can't coexist with ride (M blocked during ride) so megasheet check is first.
                    if (event.key === 'Escape') {
                        // VIS-MEGASHEET-1: Exit megasheet mode first (can't coexist with ride ‚Äî M blocked)
                        if (window._relayRenderMode === 'MEGASHEET') {
                            event.preventDefault();
                            const restoreTo = window._relayPreMegasheetMode || 'LAUNCH_CANOPY';
                            window._relayRenderMode = restoreTo;
                            window._relayPreMegasheetMode = null;
                            console.log(`[MODE] renderMode=${restoreTo}`);
                            console.log(`[MODE] viewMode=${restoreTo === 'TREE_SCAFFOLD' ? 'SCAFFOLD' : 'CANOPY'}`);
                            if (filamentRenderer) {
                                filamentRenderer.renderTree('megasheet-exit');
                            }
                            return;
                        }
                        // CAM0.4.2-FILAMENT-RIDE-V1: Exit filament ride on Escape
                        if (filamentRideState.active && typeof window.exitFilamentRide === 'function') {
                            event.preventDefault();
                            window.exitFilamentRide();
                            return;
                        }
                        // Close buds first if open
                        const budsPanel = document.getElementById('capabilityBuds');
                        if (budsPanel && budsPanel.style.display !== 'none' && budsPanel.style.display !== '') {
                            budsPanel.style.display = 'none';
                            event.preventDefault();
                            RelayLog.info('[BUD] closed (Escape)');
                            return;
                        }
                        // VIS-4d: Clear slab focus on Escape (takes priority over pin)
                        const renderer = window.filamentRenderer;
                        if (renderer && renderer._vis4dFocusState) {
                            event.preventDefault();
                            window.vis4dFocusClear();
                            return;
                        }
                        // VIS-7b: Unpin presence marker on Escape (before VIS-4c)
                        if (renderer && renderer._vis7bPinnedMarkerId) {
                            event.preventDefault();
                            window.vis7bUnpin('escape');
                            return;
                        }
                        // VIS-4c: Unpin slab inspect on Escape
                        if (renderer && renderer._vis4cPinnedId) {
                            event.preventDefault();
                            window.vis4cUnpin();
                            return;
                        }
                        if (isEditSheetMode && !isEditingCell) {
                            event.preventDefault();
                            window.exitEditSheetMode();
                            return;
                        }
                        if (!isEditSheetMode && isFocusMode) {
                            event.preventDefault();
                            window.exitFocusMode();
                            return;
                        }
                        // BASIN-FOCUS-LOCK-1: Exit company focus (returns to globe)
                        if (!isEditSheetMode && !isFocusMode && isCompanyFocusMode) {
                            event.preventDefault();
                            window.exitCompanyFocus();
                            return;
                        }
                    }
                    // E key: Enter/exit sheet (launch-mode unified entry, dev-mode toggle)
                    // Guard: don't steal E when user is typing in an input/textarea/contenteditable
                    if ((event.key === 'e' || event.key === 'E') && !isEditingCell && !event.ctrlKey && !event.metaKey) {
                        const activeTag = String(document.activeElement?.tagName || '').toUpperCase();
                        if (activeTag === 'INPUT' || activeTag === 'TEXTAREA' || document.activeElement?.isContentEditable) {
                            return; // Don't intercept typing
                        }
                        event.preventDefault();
                        if (isEditSheetMode) {
                            // Already in sheet ‚Üí E exits (same as Escape for symmetry)
                            window.exitEditSheetMode();
                            RelayLog.info('[CAM] E-toggle action=EXIT result=PASS');
                        } else {
                            // Enter sheet ‚Äî use unified resolver in launch mode, or nearest in dev
                            if (window.RELAY_LAUNCH_MODE && typeof window._launchResolveSheetForEnter === 'function') {
                                const resolved = window._launchResolveSheetForEnter();
                                if (resolved) {
                                    window._launchEnterSheetInstant(resolved);
                                    if (resolved.sheet && typeof window.enterFocusMode === 'function') {
                                        window.enterFocusMode(resolved.sheet);
                                    }
                                    RelayLog.info(`[CAM] E-accept action=ENTER_SHEET target=${resolved.sheet?.id || 'unknown'} durationMs=0 method=setView result=PASS`);
                                }
                            } else {
                                // Dev mode: enter nearest sheet with standard docking
                                const nearest = typeof getNearestSheetToCamera === 'function' ? getNearestSheetToCamera() : null;
                                if (nearest) {
                                    editSheetTargetSheet = nearest;
                                    window.enterEditSheetMode(nearest);
                                    RelayLog.info(`[CAM] E-accept action=ENTER_SHEET target=${nearest.id || 'unknown'} method=dock result=PASS`);
                                }
                            }
                        }
                        return;
                    }
                    // H key: HUD-CONSOLIDATION-1 ‚Äî Toggle Tier 2 (diagnostics) in launch mode
                    if ((event.key === 'h' || event.key === 'H') && window.RELAY_LAUNCH_MODE && hudManager && !event.ctrlKey && !event.metaKey && !event.altKey) {
                        const activeTag = String(document.activeElement?.tagName || '').toUpperCase();
                        if (activeTag !== 'INPUT' && activeTag !== 'TEXTAREA' && !document.activeElement?.isContentEditable) {
                            event.preventDefault();
                            hudManager.toggleTier2('hotkey');
                        }
                        return;
                    }
                    // CAM0.4.2-TIGHTENING: M key blocked during active ride
                    if ((event.key === 'm' || event.key === 'M') && filamentRideState?.active && !event.ctrlKey && !event.metaKey && !event.altKey) {
                        event.preventDefault();
                        const refLine = `[REFUSAL] reason=RIDE_MODE_CHANGE_BLOCKED key=M renderMode=${window._relayRenderMode || 'LAUNCH_CANOPY'}`;
                        RelayLog.info(refLine);
                        console.log(refLine);
                        return;
                    }
                    // VIS-MEGASHEET-1: M key ‚Äî Enter MegaSheet top-down lens (company scope only)
                    // CAM0.4.2-FILAMENT-RIDE-V1: Block megasheet during active ride
                    if ((event.key === 'm' || event.key === 'M') && window.RELAY_LAUNCH_MODE && !isEditSheetMode && !filamentRideState?.active && !event.ctrlKey && !event.metaKey && !event.altKey) {
                        const activeTag = String(document.activeElement?.tagName || '').toUpperCase();
                        if (activeTag !== 'INPUT' && activeTag !== 'TEXTAREA' && !document.activeElement?.isContentEditable) {
                            event.preventDefault();
                            const current = window._relayRenderMode || 'LAUNCH_CANOPY';
                            if (current === 'MEGASHEET') {
                                // Already in megasheet ‚Äî ignore (use Esc to exit)
                                return;
                            }
                            // Store previous mode for restore on Esc
                            window._relayPreMegasheetMode = current;
                            window._relayRenderMode = 'MEGASHEET';
                            console.log(`[MODE] renderMode=MEGASHEET`);
                            console.log(`[MODE] viewMode=MEGASHEET`);
                            const scopeLabel = (window.__relayEntryState?.scope) || 'world';
                            console.log(`[SCOPE] effective=${scopeLabel}`);
                            // Compute megasheet layout
                            if (typeof window._relayComputeMegasheetLayout === 'function') {
                                window._relayComputeMegasheetLayout();
                            }
                            // Re-render tree to apply megasheet mode
                            if (filamentRenderer) {
                                filamentRenderer.renderTree('megasheet-enter');
                            }
                        }
                        return;
                    }
                    // VIS-MEGASHEET-1: Esc key ‚Äî Exit MegaSheet mode (restore previous)
                    if (event.key === 'Escape' && window._relayRenderMode === 'MEGASHEET') {
                        event.preventDefault();
                        const restoreTo = window._relayPreMegasheetMode || 'LAUNCH_CANOPY';
                        window._relayRenderMode = restoreTo;
                        window._relayPreMegasheetMode = null;
                        console.log(`[MODE] renderMode=${restoreTo}`);
                        console.log(`[MODE] viewMode=${restoreTo === 'TREE_SCAFFOLD' ? 'SCAFFOLD' : 'CANOPY'}`);
                        if (filamentRenderer) {
                            filamentRenderer.renderTree('megasheet-exit');
                        }
                        return;
                    }
                    // CAM0.4.2-FILAMENT-RIDE-V1: R key ‚Äî Enter filament ride when focused on a filament
                    if ((event.key === 'r' || event.key === 'R') && window.RELAY_LAUNCH_MODE && !isEditSheetMode && !event.ctrlKey && !event.metaKey && !event.altKey) {
                        const activeTag = String(document.activeElement?.tagName || '').toUpperCase();
                        if (activeTag !== 'INPUT' && activeTag !== 'TEXTAREA' && !document.activeElement?.isContentEditable) {
                            // Only enter ride if we have a focused artifact that maps to a filament
                            const focusedId = String(window.__relayArtifactFocusedObjectId || '').trim();
                            if (focusedId) {
                                event.preventDefault();
                                if (filamentRideState.active) {
                                    // Already in ride ‚Äî exit
                                    window.exitFilamentRide();
                                } else {
                                    window.enterFilamentRide(focusedId);
                                }
                                return;
                            }
                        }
                    }
                    // CAM0.4.2-FILAMENT-RIDE-V1: Left/Right arrow keys ‚Äî Navigate during active ride
                    if (filamentRideState.active && (event.key === 'ArrowLeft' || event.key === 'ArrowRight') && !event.ctrlKey && !event.metaKey && !event.altKey) {
                        const activeTag = String(document.activeElement?.tagName || '').toUpperCase();
                        if (activeTag !== 'INPUT' && activeTag !== 'TEXTAREA' && !document.activeElement?.isContentEditable) {
                            event.preventDefault();
                            if (event.key === 'ArrowRight') {
                                window.filamentRideNext();
                            } else {
                                window.filamentRidePrev();
                            }
                            return;
                        }
                    }
                    // CAM0.4.2-TIGHTENING: T key blocked during active ride (stale path positions)
                    if ((event.key === 't' || event.key === 'T') && filamentRideState?.active && !event.ctrlKey && !event.metaKey && !event.altKey) {
                        event.preventDefault();
                        const refLine = `[REFUSAL] reason=RIDE_MODE_CHANGE_BLOCKED key=T renderMode=${window._relayRenderMode || 'LAUNCH_CANOPY'}`;
                        RelayLog.info(refLine);
                        console.log(refLine);
                        return;
                    }
                    // VIS-TREE-SCAFFOLD-1: T key ‚Äî Toggle renderMode between LAUNCH_CANOPY and TREE_SCAFFOLD
                    // CAM0.4.2-FILAMENT-RIDE-V1: Block mode toggle during active ride (stale path positions)
                    if ((event.key === 't' || event.key === 'T') && window.RELAY_LAUNCH_MODE && !isEditSheetMode && !filamentRideState?.active && !event.ctrlKey && !event.metaKey && !event.altKey) {
                        const activeTag = String(document.activeElement?.tagName || '').toUpperCase();
                        if (activeTag !== 'INPUT' && activeTag !== 'TEXTAREA' && !document.activeElement?.isContentEditable) {
                            event.preventDefault();
                            const current = window._relayRenderMode || 'LAUNCH_CANOPY';
                            const next = current === 'LAUNCH_CANOPY' ? 'TREE_SCAFFOLD' : 'LAUNCH_CANOPY';
                            window._relayRenderMode = next;
                            console.log(`[MODE] renderMode=${next}`);
                            console.log(`[MODE] viewMode=${next === 'TREE_SCAFFOLD' ? 'SCAFFOLD' : 'CANOPY'}`);
                            const scopeLabel = (window.__relayEntryState?.scope) || 'world';
                            console.log(`[SCOPE] effective=${scopeLabel}`);
                            // Re-render tree to apply new mode
                            if (filamentRenderer) {
                                filamentRenderer.renderTree('scaffold-toggle');
                            }
                        }
                        return;
                    }
                    // F key: In launch mode = View Assist (face nearest platform without entering)
                    //         In dev mode = Focus Lens (original behavior)
                    if ((event.key === 'f' || event.key === 'F') && !isEditSheetMode && !isEditingCell && !event.ctrlKey && !event.metaKey) {
                        event.preventDefault();
                        // ‚îÄ‚îÄ CAM-VIEWASSIST-FACE-SHEET-1: Launch mode view assist ‚îÄ‚îÄ
                        if (window.RELAY_LAUNCH_MODE && typeof window._launchFaceSheet === 'function') {
                            const resolved = window._launchResolveSheetForEnter();
                            if (resolved && resolved.sheet) {
                                window._launchFaceSheet(resolved.sheet);
                            }
                            return;
                        }
                        // Dev mode: original Focus Lens behavior
                        let target = null;
                        if (hoveredCellEntity?._relayNodeId) {
                            target = relayState.tree.nodes.find(n => n.id === hoveredCellEntity._relayNodeId);
                        }
                        if (!target && editSheetTargetSheet) {
                            target = editSheetTargetSheet;
                        }
                        if (!target) {
                            const nearest = getNearestFocusableNode();
                            target = nearest?.node || null;
                        }
                        if (target) {
                            window.enterFocusMode(target);
                        }
                        return;
                    }
                    // ‚îÄ‚îÄ UX-1.2: Space key ‚Üí Capability Buds ‚îÄ‚îÄ
                    if (event.key === ' ' && !isEditingCell && !event.ctrlKey && !event.metaKey) {
                        event.preventDefault();
                        const budsPanel = document.getElementById('capabilityBuds');
                        if (!budsPanel) return;

                        // Toggle off if already visible
                        if (budsPanel.style.display !== 'none' && budsPanel.style.display !== '') {
                            budsPanel.style.display = 'none';
                            RelayLog.info('[BUD] closed');
                            return;
                        }

                        // Resolve current target to a contract
                        let budTarget = null;

                        // Priority 1: Focus mode target
                        if (isFocusMode && focusTarget?.node) {
                            budTarget = focusTarget.node;
                        }
                        // Priority 2: Selected cell in edit sheet mode
                        else if (isEditSheetMode && sheetSelection?.sheetId) {
                            const sheet = relayState.tree.nodes.find(n => n.id === sheetSelection.sheetId);
                            if (sheet?.metadata?.isMatchSheet && Number.isFinite(sheetSelection.row) && sheetSelection.row > 0) {
                                budTarget = { sheetId: sheetSelection.sheetId, row: sheetSelection.row, isMatch: true };
                            } else if (Number.isFinite(sheetSelection.row) && Number.isFinite(sheetSelection.col)) {
                                budTarget = { sheetId: sheetSelection.sheetId, row: sheetSelection.row, col: sheetSelection.col };
                            } else {
                                budTarget = sheet;
                            }
                        }
                        // Priority 3: Hovered entity in 3D
                        else if (hoveredCellEntity?._relayNodeId) {
                            budTarget = relayState.tree.nodes.find(n => n.id === hoveredCellEntity._relayNodeId) || hoveredCellEntity;
                        }
                        // Priority 4: Nearest focusable node
                        else {
                            const nearest = getNearestFocusableNode();
                            budTarget = nearest?.node || null;
                        }

                        if (!budTarget) {
                            RelayLog.warn('[BUD] No target resolved');
                            return;
                        }

                        const contract = toRelayObject(budTarget, relayState);
                        if (!contract || !contract.actions || contract.actions.length === 0) {
                            RelayLog.warn(`[BUD] No actions for target`);
                            return;
                        }

                        // Populate buds panel
                        const header = document.getElementById('capBudsHeader');
                        const actionsDiv = document.getElementById('capBudsActions');
                        if (header) header.textContent = `${contract.type}: ${contract.label}`;
                        if (actionsDiv) {
                            actionsDiv.innerHTML = '';
                            contract.actions.forEach(action => {
                                const btn = document.createElement('div');
                                btn.style.cssText = 'padding:4px 8px; cursor:pointer; border-radius:3px; white-space:nowrap; transition:background 0.15s;';
                                btn.textContent = `${action.icon || '‚Ä¢'} ${action.label}`;
                                btn.addEventListener('mouseenter', () => { btn.style.background = 'rgba(0,180,255,0.2)'; });
                                btn.addEventListener('mouseleave', () => { btn.style.background = 'transparent'; });
                                btn.addEventListener('click', () => {
                                    RelayLog.info(`[BUD] action=${action.id} target=${contract.type}:${contract.id}`);
                                    budsPanel.style.display = 'none';
                                    if (typeof window.relayInvokeAction === 'function') {
                                        window.relayInvokeAction(action.id, {
                                            targetRef: { type: contract.type, id: contract.id },
                                            uiSource: 'buds'
                                        });
                                    }
                                });
                                actionsDiv.appendChild(btn);
                            });
                        }

                        // Position buds panel near the selection or center of screen
                        let posX = window.innerWidth / 2 - 90;
                        let posY = window.innerHeight / 2 - 60;
                        if (isEditSheetMode && sheetSelection) {
                            const selectedCell = document.querySelector(`.grid-data[data-row="${sheetSelection.row}"][data-col="${sheetSelection.col}"]`);
                            if (selectedCell) {
                                const rect = selectedCell.getBoundingClientRect();
                                posX = Math.min(rect.right + 8, window.innerWidth - 270);
                                posY = Math.max(rect.top - 20, 10);
                            }
                        }
                        budsPanel.style.left = posX + 'px';
                        budsPanel.style.top = posY + 'px';
                        budsPanel.style.display = 'block';

                        RelayLog.info(`[BUD] opened: type=${contract.type} id=${contract.id} actions=${contract.actions.length}`);
                        return;
                    }

                    // Block camera presets during edit sheet mode (prevents accidental camera jumps)
                    if (isEditSheetMode) return;
                    if (event.key === '1') {
                        window.setTopDownView();
                    } else if (event.key === '2') {
                        window.setSideProfileView();
                    } else if (event.key === '3') {
                        window.setLookDownBranchView();
                    } else if (event.key === '4') {
                        window.setSpreadsheetProofView();
                    } else if (event.key === '5') {
                        window.setSpineInspectionView();
                    } else if (event.key === 'P' || event.key === 'p') {
                        // Proof capture: force LOD, enable formula lens, emit consolidated logs
                        if (!lodLocked) {
                            lodLocked = true;
                            lodLockedLevel = 'SHEET';
                            RelayLog.info('üîí LOD locked at: SHEET (proof capture)');
                        }
                        if (filamentRenderer) {
                            if (typeof window.relayEnterSheet === 'function') {
                                window.relayEnterSheet();
                            }
                            filamentRenderer.setLOD('SHEET');
                            filamentRenderer.renderTree();
                        }
                        
                        if (hudManager) {
                            const proofLensState = { value: false, formula: true, cf: false, history: true };
                            hudManager.setLensState(proofLensState);
                        }
                        
                        let formulaStats = { edgesRendered: 0, cyclesDetected: 0, scarsRendered: 0 };
                        if (filamentRenderer) {
                            formulaStats = filamentRenderer.renderFormulaDependencies() || formulaStats;
                        }
                        const p3a = filamentRenderer?.lastP3A || {};
                        RelayLog.info('[PROOF] P3-A exitDotToBranchMax=' + (Number.isFinite(p3a.exitDotToBranchMax) ? p3a.exitDotToBranchMax.toFixed(3) : 'n/a'));
                        RelayLog.info('[PROOF] P3-A slabAngleDeltaMaxDeg=' + (Number.isFinite(p3a.slabAngleDeltaMaxDeg) ? p3a.slabAngleDeltaMaxDeg.toFixed(3) : 'n/a'));
                        RelayLog.info('[PROOF] P3-A stage2ConduitsPerSheet=' + (Number.isFinite(p3a.stage2ConduitsPerSheet) ? p3a.stage2ConduitsPerSheet : 'n/a'));
                        RelayLog.info('[PROOF] F2 formulaEdgesRendered=' + formulaStats.edgesRendered);
                        RelayLog.info('[PROOF] F2 cyclesDetected=' + formulaStats.cyclesDetected);
                        RelayLog.info('[PROOF] F2 scarsRendered=' + formulaStats.scarsRendered);
                    } else if (event.key === 'L' || event.key === 'l') {
                        window.toggleLODLock();
                    }
                });
                
                RelayLog.info('üì∑ Camera presets: Press 1=SheetTopDown, 2=SideProfile, 3=SheetFaceOn, 4=SpreadsheetProof, 5=SpineInspection');
                RelayLog.info('üîí LOD Lock: Press L to lock/unlock LOD at current level');
                RelayLog.info('üéÆ Free-fly pointer lock: Press ` (backquote) to toggle');
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                
                // Initialize HUD Manager (HUD-1 + policy-driven params)
                hudManager = new HUDManager('hud', window.__relayHudPolicy || defaultHudParams());
                window.hudManager = hudManager;
                loadHudParams(getActivePolicyRef('hud')).then(({ params }) => {
                    if (hudManager) hudManager.setPolicy(params);
                });
                // Launch mode: minimal HUD (no dev noise)
                if (window.RELAY_LAUNCH_MODE) {
                    hudManager.update({ launchMode: true, debugLogs: false });
                }
                const lensState = { value: false, formula: false, cf: false, history: true };
                hudManager.setLensState(lensState);
                hudManager.setLensToggleHandler((lens, enabled) => {
                    lensState[lens] = enabled;
                    hudManager.setLensState(lensState);
                    
                    if (lens === 'formula') {
                        if (enabled) {
                            const stats = filamentRenderer.renderFormulaDependencies();
                            hudManager.update({
                                formulaCycles: stats.cyclesDetected,
                                formulaScars: stats.scarsRendered
                            });
                        } else {
                            filamentRenderer.clearFormulaDependencies();
                            hudManager.update({ formulaCycles: 0, formulaScars: 0 });
                        }
                    } else if (lens === 'cf') {
                        const cfStatus = getAggregateCFStatus(relayState.tree);
                        hudManager.update({ cfStatus });
                        RelayLog.info(`[CF] lens=${enabled ? 'ON' : 'OFF'} status=${cfStatus}`);
                    }
                });
                const storedDebugRange = localStorage.getItem(DEBUG_RANGE_STORAGE_KEY);
                window.DEBUG_RANGE_OPS = storedDebugRange === 'true';
                const storedDebugSpine = localStorage.getItem(DEBUG_SPINE_STORAGE_KEY);
                window.DEBUG_SPINE_GUIDE = storedDebugSpine === 'true';
                const storedDebugLogs = localStorage.getItem(DEBUG_LOGS_STORAGE_KEY);
                // LAUNCH-ALIGN-2a: Billboard labels policy
                // Labels always face the camera; geometry stays canonical (truth).
                // Default ON for launch profile, OFF for proof/dev profiles.
                window.RELAY_BILLBOARD_LABELS = window.RELAY_LAUNCH_MODE ? true : false;
                RelayLog.info(`[PRES] billboard=${window.RELAY_BILLBOARD_LABELS ? 'ON' : 'OFF'} reason=${window.RELAY_LAUNCH_MODE ? 'launch-default' : 'canonical'}`);

                // Launch mode: force debug off for clean observer view
                if (window.RELAY_LAUNCH_MODE) {
                    window.RELAY_DEBUG_LOGS = false;
                    window.RELAY_DEBUG_VERBOSE = false;
                } else {
                    window.RELAY_DEBUG_LOGS = storedDebugLogs === null ? false : storedDebugLogs === 'true';
                    window.RELAY_DEBUG_VERBOSE = window.RELAY_DEBUG_LOGS === true;
                }
                RelayLog.info(`[UX] debugLogs=${window.RELAY_DEBUG_LOGS ? 'true' : 'false'}${window.RELAY_LAUNCH_MODE ? ' (launch mode)' : ''}`);
                
                // ‚ïê‚ïê‚ïê LAUNCH READABILITY PASS (A+B+C+D+E+F) ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                if (window.RELAY_LAUNCH_MODE) {
                    // A) Set body class to hide dev panels via CSS
                    document.body.classList.add('launch-mode');
                    RelayLog.info('[LAUNCH-FIX] uiGating launch=true hiddenPanels=artifacts,ux3,p2p,topicLane,vote,workMode,logConsole applied=PASS');
                    
                    // B) Two-tier HUD proof log
                    RelayLog.info('[LAUNCH-FIX] hud tier1=ON tier2=OFF default=collapsed');
                    
                    // C) Help overlay ‚Äî dismiss handler (remembered for session)
                    const helpOverlay = document.getElementById('launchHelpOverlay');
                    const helpDismiss = document.getElementById('launchHelpDismiss');
                    const helpWasDismissed = sessionStorage.getItem('relay-launch-help-dismissed') === '1';
                    if (helpWasDismissed && helpOverlay) {
                        helpOverlay.style.display = 'none';
                    }
                    RelayLog.info(`[LAUNCH-FIX] helpOverlay shown=${!helpWasDismissed} dismissed=${helpWasDismissed} source=${helpWasDismissed ? 'session' : 'first'}`);
                    if (helpDismiss) {
                        helpDismiss.addEventListener('click', () => {
                            if (helpOverlay) helpOverlay.style.display = 'none';
                            sessionStorage.setItem('relay-launch-help-dismissed', '1');
                        });
                    }
                    
                    // ‚îÄ‚îÄ Unified sheet entry: resolveSheetForEnter + enterSheetInstant ‚îÄ‚îÄ
                    // Single source of truth used by both E key and "Enter Sheet" button
                    window._launchResolveSheetForEnter = () => {
                        // Priority 1: currently selected sheet
                        if (sheetSelection?.sheetId) {
                            const sel = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === sheetSelection.sheetId);
                            if (sel && sel._center) return { sheet: sel, source: 'selected' };
                        }
                        // Priority 2: nearest sheet to camera
                        if (typeof getNearestSheetToCamera === 'function') {
                            const nearest = getNearestSheetToCamera();
                            if (nearest) return { sheet: nearest, source: 'nearest' };
                        }
                        // Priority 3: first available sheet
                        const sheets = (relayState?.tree?.nodes || []).filter(n => n.type === 'sheet');
                        if (sheets.length > 0) return { sheet: sheets[0], source: 'fallback' };
                        return null;
                    };
                    
                    window._launchEnterSheetInstant = (resolved) => {
                        if (!resolved || !resolved.sheet) return;
                        const sheet = resolved.sheet;
                        const source = resolved.source || 'unknown';
                        const sheetId = sheet.id || sheet.name || 'unknown';
                        editSheetTargetSheet = sheet;
                        
                        // Log the enter intent
                        RelayLog.info(`[LAUNCH-FIX] enterSheetBtn shown=true action=${source} sheet=${sheetId}`);
                        
                        // In launch mode: zero-transition entry (duration=0 ‚Üí setView)
                        window.enterEditSheetMode(sheet);
                    };

                    // ‚îÄ‚îÄ CAM-VIEWASSIST-FACE-SHEET-1: Face sheet without entering ‚îÄ‚îÄ
                    // F key flies camera to a readable above-and-angled view of the nearest platform.
                    // Does NOT enter edit mode. Uses proxy cache (Tightening 1), not sheet._* truth.
                    window._launchFaceSheet = (sheet) => {
                        if (!sheet || !viewer) return;
                        const proxyCache = window._sheetProxyCache;
                        if (!proxyCache || !proxyCache.has(sheet.id)) {
                            RelayLog.warn(`[CAM] viewAssist target=${sheet.id} action=FACE_SHEET result=FAIL reason=noProxy`);
                            return;
                        }
                        const proxy = proxyCache.get(sheet.id);
                        const { center, xAxisWorld, upWorld, halfTileX, halfTileY } = proxy;
                        if (!center || !xAxisWorld || !upWorld) return;

                        // Camera contract: pitch=-55¬∞, heading=aligned to long axis, distance=diagonal*2.5
                        const pitchDeg = -55;
                        const diag = Math.sqrt(halfTileX * halfTileX + halfTileY * halfTileY);
                        const distM = diag * 2.5; // ~174m for 120x70

                        // Position camera: above-and-behind platform along negative long axis direction
                        const pitchRad = Cesium.Math.toRadians(pitchDeg);
                        const cosP = Math.cos(-pitchRad); // cos(55¬∞) ‚âà 0.574
                        const sinP = Math.sin(-pitchRad); // sin(55¬∞) ‚âà 0.819

                        // Camera offset: backward along -xAxis by dist*cosP, up by dist*sinP
                        const backDir = new Cesium.Cartesian3();
                        Cesium.Cartesian3.negate(xAxisWorld, backDir);
                        Cesium.Cartesian3.normalize(backDir, backDir);

                        const upDir = new Cesium.Cartesian3();
                        Cesium.Cartesian3.normalize(upWorld, upDir);

                        const offset = new Cesium.Cartesian3();
                        Cesium.Cartesian3.add(
                            Cesium.Cartesian3.multiplyByScalar(backDir, distM * cosP, new Cesium.Cartesian3()),
                            Cesium.Cartesian3.multiplyByScalar(upDir, distM * sinP, new Cesium.Cartesian3()),
                            offset
                        );

                        const camPos = Cesium.Cartesian3.add(center, offset, new Cesium.Cartesian3());

                        // Compute heading from xAxisWorld direction
                        // Convert xAxisWorld to ENU east/north to get compass heading
                        const centerCarto = Cesium.Cartographic.fromCartesian(center);
                        const enuTransform = Cesium.Transforms.eastNorthUpToFixedFrame(center);
                        const enuInverse = Cesium.Matrix4.inverse(enuTransform, new Cesium.Matrix4());
                        const xLocal = Cesium.Matrix4.multiplyByPointAsVector(enuInverse, xAxisWorld, new Cesium.Cartesian3());
                        // Heading = angle from north (Y) toward east (X) in ENU
                        const headingRad = Math.atan2(xLocal.x, xLocal.y);
                        const headingDeg = Cesium.Math.toDegrees(headingRad);

                        viewer.camera.flyTo({
                            destination: camPos,
                            orientation: {
                                heading: headingRad,
                                pitch: Cesium.Math.toRadians(pitchDeg),
                                roll: 0
                            },
                            duration: 0.7,
                            complete: () => {
                                RelayLog.info(`[CAM] viewAssist target=sheet.${sheet.id} action=FACE_SHEET heading=${headingDeg.toFixed(1)} pitch=${pitchDeg} distM=${distM.toFixed(0)} result=PASS`);
                                if (typeof window !== 'undefined') {
                                    window._lastViewAssist = { target: sheet.id, action: 'FACE_SHEET', heading: headingDeg, pitch: pitchDeg, distM };
                                }
                            }
                        });
                    };

                    // ‚îÄ‚îÄ View Assist Prompt (proximity HUD) ‚îÄ‚îÄ
                    // Show "F: Face Sheet | E: Enter Sheet" when within 300-800m of a platform
                    const viewAssistPrompt = document.createElement('div');
                    viewAssistPrompt.id = 'viewAssistPrompt';
                    viewAssistPrompt.style.cssText = 'position:fixed;bottom:80px;left:50%;transform:translateX(-50%);' +
                        'background:rgba(10,30,50,0.85);color:#90e0ff;font:13px monospace;padding:6px 16px;' +
                        'border:1px solid rgba(144,224,255,0.3);border-radius:4px;display:none;z-index:9999;' +
                        'pointer-events:none;white-space:nowrap;';
                    viewAssistPrompt.textContent = 'F: Face Sheet  |  E: Enter Sheet';
                    document.body.appendChild(viewAssistPrompt);

                    // Poll camera distance to platforms for prompt visibility
                    setInterval(() => {
                        if (!viewer || !window._sheetProxyCache || window._sheetProxyCache.size === 0) {
                            viewAssistPrompt.style.display = 'none';
                            return;
                        }
                        // Don't show in edit mode
                        if (isEditSheetMode) {
                            viewAssistPrompt.style.display = 'none';
                            return;
                        }
                        const camPos = viewer.camera.positionWC;
                        let minDist = Infinity;
                        for (const [, proxy] of window._sheetProxyCache) {
                            const d = Cesium.Cartesian3.distance(camPos, proxy.center);
                            if (d < minDist) minDist = d;
                        }
                        // Show prompt when within 300-800m of any platform
                        viewAssistPrompt.style.display = (minDist >= 50 && minDist <= 800) ? 'block' : 'none';
                    }, 500);
                    
                    // F) "Enter Selected Sheet" button wiring (uses unified resolver)
                    const enterBtn = document.getElementById('launchEnterSheetBtn');
                    if (enterBtn) {
                        enterBtn.addEventListener('click', () => {
                            const resolved = window._launchResolveSheetForEnter();
                            window._launchEnterSheetInstant(resolved);
                        });
                    }
                    // COMPANY-TEMPLATE-FLOW-1: Simulate Event button
                    const simulateFlowBtn = document.getElementById('launchSimulateFlowBtn');
                    if (simulateFlowBtn && typeof window.relaySimulateFlowEvent === 'function') {
                        simulateFlowBtn.addEventListener('click', () => { window.relaySimulateFlowEvent(); });
                    }
                    // VOTE-COMMIT-PERSISTENCE-1: Simulate Vote button
                    const simulateVoteBtn = document.getElementById('launchSimulateVoteBtn');
                    if (simulateVoteBtn && typeof window.relaySimulateGovernanceDecision === 'function') {
                        simulateVoteBtn.addEventListener('click', () => {
                            // Demo: branch.finance ‚Üí PASSED, branch.maintenance ‚Üí REJECTED
                            window.relaySimulateGovernanceDecision('branch.finance', 'PASSED');
                            window.relaySimulateGovernanceDecision('branch.maintenance', 'REJECTED');
                        });
                    }
                    // FILAMENT-DISCLOSURE-1: Simulate Disclosure button
                    const simulateDisclosureBtn = document.getElementById('launchSimulateDisclosureBtn');
                    if (simulateDisclosureBtn && typeof window.relaySimulateDisclosure === 'function') {
                        simulateDisclosureBtn.addEventListener('click', () => { window.relaySimulateDisclosure(); });
                    }
                }
                // ‚ïê‚ïê‚ïê END LAUNCH READABILITY PASS ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                
                window.IMPORT_MODE = 'ATTACH_TO_TEMPLATE';
                const storedCompanyMarkers = localStorage.getItem(COMPANY_MARKERS_STORAGE_KEY);
                window.SHOW_CELL_MARKERS_AT_COMPANY = storedCompanyMarkers === 'true';
                const storedActiveMarkers = localStorage.getItem(ACTIVE_MARKERS_STORAGE_KEY);
                window.SHOW_ACTIVE_MARKERS = storedActiveMarkers !== 'false';
                const storedActiveMode = localStorage.getItem(ACTIVE_MARKER_MODE_STORAGE_KEY);
                window.ACTIVE_MARKER_MODE = storedActiveMode || 'auto';
                hudManager.update({
                    debugRangeOps: window.DEBUG_RANGE_OPS,
                    debugSpineGuide: window.DEBUG_SPINE_GUIDE,
                    debugLogs: window.RELAY_DEBUG_LOGS,
                    imageryMode: String(window.RELAY_WORLD_IMAGERY_MODE || defaultWorldImageryMode()).toUpperCase(),
                    showCellMarkersAtCompany: window.SHOW_CELL_MARKERS_AT_COMPANY,
                    showActiveMarkers: window.SHOW_ACTIVE_MARKERS,
                    activeMarkerMode: window.ACTIVE_MARKER_MODE
                });
                hudManager.setImageryModeChangeHandler((mode) => {
                    const out = window.relayApplyImageryMode(mode);
                    if (out?.ok) {
                        hudManager.update({ imageryMode: String(out.modeId || mode).toUpperCase() });
                    }
                });
                hudManager.setDebugLogsToggleHandler((enabled) => {
                    window.relaySetDebugLogs(enabled);
                });
                hudManager.setDebugRangeToggleHandler((enabled) => {
                    window.DEBUG_RANGE_OPS = !!enabled;
                    localStorage.setItem(DEBUG_RANGE_STORAGE_KEY, window.DEBUG_RANGE_OPS ? 'true' : 'false');
                    hudManager.update({ debugRangeOps: window.DEBUG_RANGE_OPS });
                    RelayLog.info(`[UI] debugRangeOps enabled=${window.DEBUG_RANGE_OPS}`);
                });
                hudManager.setDebugSpineGuideToggleHandler((enabled) => {
                    window.DEBUG_SPINE_GUIDE = !!enabled;
                    localStorage.setItem(DEBUG_SPINE_STORAGE_KEY, window.DEBUG_SPINE_GUIDE ? 'true' : 'false');
                    hudManager.update({ debugSpineGuide: window.DEBUG_SPINE_GUIDE });
                    RelayLog.info(`[UI] debugSpineGuide enabled=${window.DEBUG_SPINE_GUIDE}`);
                });
                hudManager.setCompanyMarkersToggleHandler((enabled) => {
                    window.SHOW_CELL_MARKERS_AT_COMPANY = !!enabled;
                    localStorage.setItem(COMPANY_MARKERS_STORAGE_KEY, window.SHOW_CELL_MARKERS_AT_COMPANY ? 'true' : 'false');
                    hudManager.update({ showCellMarkersAtCompany: window.SHOW_CELL_MARKERS_AT_COMPANY });
                    RelayLog.info(`[HUD] showCellMarkersAtCompany enabled=${window.SHOW_CELL_MARKERS_AT_COMPANY}`);
                    filamentRenderer?.renderTree();
                });
                hudManager.setActiveMarkersToggleHandler((enabled) => {
                    window.SHOW_ACTIVE_MARKERS = !!enabled;
                    localStorage.setItem(ACTIVE_MARKERS_STORAGE_KEY, window.SHOW_ACTIVE_MARKERS ? 'true' : 'false');
                    hudManager.update({ showActiveMarkers: window.SHOW_ACTIVE_MARKERS });
                    RelayLog.info(`[HUD] showPresenceMarkers enabled=${window.SHOW_ACTIVE_MARKERS}`);
                    filamentRenderer?.renderTree();
                });
                hudManager.setActiveMarkerModeChangeHandler((mode) => {
                    window.ACTIVE_MARKER_MODE = mode || 'auto';
                    localStorage.setItem(ACTIVE_MARKER_MODE_STORAGE_KEY, window.ACTIVE_MARKER_MODE);
                    hudManager.update({ activeMarkerMode: window.ACTIVE_MARKER_MODE });
                    RelayLog.info(`[HUD] presenceMarkerMode=${window.ACTIVE_MARKER_MODE}`);
                    filamentRenderer?.renderTree();
                });
                hudManager.setEditSheetModeToggleHandler(() => {
                    if (isEditSheetMode) {
                        window.exitEditSheetMode();
                    } else {
                        window.enterEditSheetMode();
                    }
                });
                hudManager.setInspectorToggleHandler(() => {
                    const panel = document.getElementById('matchInspector');
                    if (!panel) return;
                    const isOpen = panel.style.display !== 'none';
                    panel.style.display = isOpen ? 'none' : 'block';
                });
                // PROJ-SHEET-FACING-1: Facing Sheets toggle
                const FACING_SHEETS_STORAGE_KEY = 'relay_facing_sheets';
                const storedFacingSheets = localStorage.getItem(FACING_SHEETS_STORAGE_KEY);
                window.RELAY_FACING_SHEETS = storedFacingSheets === 'true';
                hudManager.setFacingSheetsToggleHandler((enabled) => {
                    window.RELAY_FACING_SHEETS = !!enabled;
                    localStorage.setItem(FACING_SHEETS_STORAGE_KEY, window.RELAY_FACING_SHEETS ? 'true' : 'false');
                    hudManager.update({ facingSheets: window.RELAY_FACING_SHEETS });
                    if (window.RELAY_FACING_SHEETS) {
                        RelayLog.info('[PROJ] sheetFacing enabled=PASS mode=projection');
                    } else {
                        RelayLog.info('[PROJ] sheetFacing disabled=PASS mode=truth');
                    }
                    filamentRenderer?.renderTree();
                });
                window.relayRefreshHudNow = (currentHeight = null) => {
                    if (!hudManager || !lodGovernor) return { ok: false, reason: 'HUD_UNAVAILABLE' };
                    const stats = getTreeStats();
                    const displayLOD = lodLocked ? `${lodGovernor.getCurrentLevel() || lodLockedLevel} üîí` : lodGovernor.getCurrentLevel() || 'UNKNOWN';
                    const activeSheetNode = getActiveGridSheet ? getActiveGridSheet() : null;
                    const activeBranchId = String(branchWalkState?.branchId || relayWorkState?.scopeRef?.branchId || 'n/a');
                    const activeBranchNode = relayState.tree.nodes.find(n => n.type === 'branch' && n.id === activeBranchId) || null;
                    const activeCompanyNode = relayState.tree.nodes.find(n => n.type === 'trunk') || null;
                    const focusState = typeof window.relayGetFocusState === 'function'
                        ? window.relayGetFocusState()
                        : { active: false, targetObjectId: null };
                    const basinState = typeof window.relayGetBasinState === 'function'
                        ? window.relayGetBasinState()
                        : { targetId: null };
                    const selectedSheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === sheetSelection?.sheetId) || null;
                    const selectedCellInfo = (selectedSheet && Number.isFinite(sheetSelection?.row) && Number.isFinite(sheetSelection?.col))
                        ? getCellInfo(selectedSheet, sheetSelection.row, sheetSelection.col)
                        : null;
                    const operationMode = isEditSheetMode
                        ? 'SheetEdit'
                        : (sheetSelection?.sheetId
                            ? 'Sheet'
                            : (isCompanyFocusMode
                                ? 'CompanyFocus'
                                : (filamentRideState?.active
                                    ? 'FilamentRide'
                                    : (branchWalkState?.active ? 'BranchWalk' : (isFocusMode ? 'Focus' : 'FreeFly')))));
                    const hudMeta = window.relayGetHudPolicyMeta ? window.relayGetHudPolicyMeta() : { policyRef: HUD_PARAMS_POLICY_REF, paramsVersion: 'HUD-PARAMS-v0' };
                    const boundaryDataset = window.__relayBoundaryDatasetStatus || { state: 'OK', missing: 0, first: 'n/a' };
                    const detailCollapsedAt = String(window.__relayLodDetailCollapsed || '');
                    // PRESENCE-RENDER-1: event-driven bind triggers derived from actual state transitions.
                    const _scopeSig = `${activeBranchId}|${String(activeSheetNode?.id || '')}|${String(isCompanyFocusMode ? 'company' : '')}`;
                    const _focusSig = String(window.__relayArtifactFocusedObjectId || '');
                    if (window.__presenceLastScopeSig !== _scopeSig) {
                        window.__presenceLastScopeSig = _scopeSig;
                        if (typeof window.relayPresenceEventBind === 'function') window.relayPresenceEventBind('scope');
                    }
                    if (window.__presenceLastFocusSig !== _focusSig) {
                        window.__presenceLastFocusSig = _focusSig;
                        if (typeof window.relayPresenceEventBind === 'function') window.relayPresenceEventBind('focus');
                    }
                    // CAM0.4.2-FILAMENT-RIDE-V1: Derive ride context from persistent filamentRideState
                    // so the continuous HUD update cycle never overwrites ride-specific fields.
                    const rideCtx = filamentRideState?.active ? {
                        rideFilamentId: filamentRideState.filamentId || null,
                        rideStep: (filamentRideState.currentIndex >= 0) ? filamentRideState.currentIndex + 1 : 0,
                        rideTotal: (filamentRideState.path || []).length,
                        rideTimeboxId: filamentRideState.currentTimeboxId || null,
                        rideLifecycle: filamentRideState.currentLifecycleState || 'UNKNOWN',
                        rideDisclosure: filamentRideState.currentDisclosureTier || 'PRIVATE',
                        rideConf: Math.round((filamentRideState.currentConfidence || 0) * 100),
                        rideAttn: Math.round((filamentRideState.currentAttention || 0) * 100),
                        rideCommits: filamentRideState.currentCommitCount || 0,
                        rideContributors: filamentRideState.currentContributorCount || 0
                    } : {
                        rideFilamentId: null,
                        rideStep: 0,
                        rideTotal: 0,
                        rideTimeboxId: null,
                        rideLifecycle: null,
                        rideDisclosure: null,
                        rideConf: null,
                        rideAttn: null,
                        rideCommits: 0,
                        rideContributors: 0
                    };
                    hudManager.update({
                        lod: displayLOD,
                        altitude: Number.isFinite(Number(currentHeight)) ? Number(currentHeight) : 0,
                        nodeCount: stats.nodes,
                        fps: fps,
                        boundaryStatus: window.getBoundaryStatus ? window.getBoundaryStatus() : 'UNKNOWN',
                        boundaryMissing: Number(boundaryDataset.missing || 0),
                        buildings: window.getBuildingsStatus ? window.getBuildingsStatus() : 'UNKNOWN',
                        filamentMode: window.getFilamentMode ? window.getFilamentMode() : 'ENTITY',
                        importStatus: relayState.importStatus || 'OK',
                        operationMode,
                        activeCompany: String(activeCompanyNode?.name || activeCompanyNode?.id || 'n/a'),
                        activeBranch: String(activeBranchNode?.name || activeBranchNode?.id || activeBranchId || 'n/a'),
                        activeSheet: String(activeSheetNode?.name || activeSheetNode?.id || 'n/a'),
                        basin: String(basinState?.targetId || basinState?.activeTarget || 'None'),
                        branchStep: branchWalkState?.active
                            ? `${Number(branchWalkState.currentIndex || 0) + 1}/${Math.max(0, Number(branchWalkState.path?.length || 0))}`
                            : '‚Äî',
                        filamentStep: filamentRideState?.active
                            ? `${String(filamentRideState.currentTimeboxId || 'none')} (${Number(filamentRideState.currentIndex || 0) + 1}/${Math.max(0, Number(filamentRideState.path?.length || 0))})`
                            : '‚Äî',
                        focusTarget: focusState?.targetObjectId || 'none',
                        focusRestore: focusState?.active ? 'restoreView=true' : 'n/a',
                        selectedCellRef: sheetSelection?.cellRef || '‚Äî',
                        selectedCellValue: selectedCellInfo?.display ?? selectedCellInfo?.value ?? '‚Äî',
                        selectedCellFormula: selectedCellInfo?.formula || '‚Äî',
                        selectedCellFormulaState: selectedCellInfo?.formulaState || 'DETERMINATE',
                        policyRef: hudMeta.policyRef || HUD_PARAMS_POLICY_REF,
                        paramsVersion: hudMeta.paramsVersion || 'HUD-PARAMS-v0',
                        imageryMode: String(window.RELAY_WORLD_IMAGERY_MODE || defaultWorldImageryMode()).toUpperCase(),
                        debugLogs: window.RELAY_DEBUG_LOGS === true,
                        editSheetMode: isEditSheetMode,
                        detailCollapsedAt,
                        ...rideCtx,
                        // PRESENCE-COMMIT-BOUNDARY-1: derive call commit state for HUD Tier 2
                        callCommitState: window._callCommitState?.state || 'IDLE',
                        callCommitMissing: window._callCommitState?.state === 'COLLECTING'
                            ? (window._callCommitState.participants.length - window._callCommitState.votes.size)
                            : null,
                        callLastSummaryId: window._callCommitState?.lastSummaryId || null,
                        // E3-REPLAY-1: derive replay state for HUD Tier 2
                        replayStatus: window.__relayReplayState?.status || 'IDLE',
                        replayModule: window.__relayReplayState?.moduleId || null,
                        // E1-CRYPTO-1: derive integrity state for HUD Tier 2
                        cryptoIntegrity: window.__relayCryptoState?.lastVerify?.overall || (window.__relayCryptoState?.initialized ? 'UNCHECKED' : 'INIT'),
                        cryptoChainLen: window.__relayCryptoState?.globalChain?.length || 0,
                        cryptoTbCount: window.__relayCryptoState?.tbChain?.length || 0
                    });
                    return { ok: true, mode: operationMode };
                };
                // Initialize Excel Importer
                excelImporter = new ExcelImporter('dropZone');
                excelImporter.setupDragAndDrop();
                window.relayImportCsvToRoute = (csvText, meta = {}) => {
                    const res = excelImporter.importCsvToRoute(csvText, meta, window.relayIngestBatch);
                    RelayLog.info(`[D2] import source=csv route=${res.routeId || 'none'} mapped=${res.mappedRows || 0} ingested=${res.ingestResult?.ingested || 0}`);
                    return res;
                };
                window.relayImportXlsxBase64ToRoute = (base64, meta = {}) => {
                    const res = excelImporter.importWorkbookBase64ToRoute(base64, meta, window.relayIngestBatch);
                    RelayLog.info(`[D2] import source=xlsx route=${res.routeId || 'none'} mapped=${res.mappedRows || 0} ingested=${res.ingestResult?.ingested || 0}`);
                    return res;
                };
                window.relayImportRowsToRoute = (rows, meta = {}) => {
                    const res = excelImporter.importRowsToRoute(rows, meta, window.relayIngestBatch);
                    RelayLog.info(`[D2] import source=rows route=${res.routeId || 'none'} mapped=${res.mappedRows || 0} ingested=${res.ingestResult?.ingested || 0}`);
                    return res;
                };
                excelImporter.onImport((tree) => {
                    RelayLog.info(`‚úÖ Tree imported: ${tree.nodes.length} nodes`);
                    filamentRenderer.renderTree();
                    const markerStats = filamentRenderer?.lastMarkerStats;
                    if (markerStats && markerStats.lod === 'COMPANY' && markerStats.markerCells === 0 && markerStats.anchoredCells > 0) {
                        RelayLog.info(`[HINT] Data loaded (${markerStats.anchoredCells} cells). At COMPANY LOD markers are hidden. Press L to lock SHEET or enable "Show cell markers at COMPANY".`);
                    }
                    hudManager.update({
                        nodeCount: tree.nodes.length,
                        cfStatus: getAggregateCFStatus(tree)
                    });

                    // ‚ïê‚ïê‚ïê Step 1A: Import Signature Stamp ‚ïê‚ïê‚ïê
                    if (!window._importIdCounter) window._importIdCounter = 0;
                    window._importIdCounter += 1;
                    const importId = window._importIdCounter;
                    const filename = relayState.metadata?.filename || '(unknown)';
                    const sheets = tree.nodes.filter(n => n.type === 'sheet');

                    // Build per-sheet stamp data
                    sheets.forEach(s => {
                        const cellData = s.cellData || [];
                        const nonEmpty = cellData.filter(c =>
                            (c.value !== null && c.value !== undefined && String(c.value).trim() !== '') || c.hasFormula
                        ).length;
                        const formulas = cellData.filter(c => c.hasFormula).length;
                        const usedRange = s.metadata?.usedRange || `A1:${String.fromCharCode(65 + Math.min((s.cols || 1) - 1, 25))}${s.rows || 1}`;
                        const stamp = {
                            file: filename,
                            sheet: s.metadata?.sheetName || s.name || s.id,
                            usedRange,
                            rows: s.rows || 0,
                            cols: s.cols || 0,
                            cells: nonEmpty,
                            formulas,
                            importId
                        };
                        s._importStamp = stamp;

                        // Canonical log line
                        RelayLog.info(`[IMPORT-STAMP] file="${stamp.file}" sheet="${stamp.sheet}" usedRange="${stamp.usedRange}" rows=${stamp.rows} cols=${stamp.cols} cells=${stamp.cells} formulas=${stamp.formulas} importId=${stamp.importId}`);
                    });

                    // Store the primary (first) sheet stamp for UI display
                    const primarySheet = sheets[0];
                    const ps = primarySheet?._importStamp;
                    if (ps) {
                        window._importStamp = ps;
                        window._importSignature = `IMPORT: ${ps.file} | sheet="${ps.sheet}" | range=${ps.usedRange} | ${ps.rows}√ó${ps.cols} | cells=${ps.cells} | formulas=${ps.formulas} | id=${ps.importId}`;
                    }

                    // ‚îÄ‚îÄ‚îÄ 3D stamp: Cesium label entity near the sheet ‚îÄ‚îÄ‚îÄ
                    if (window._importStampEntity && viewer) {
                        viewer.entities.remove(window._importStampEntity);
                        window._importStampEntity = null;
                    }
                    if (ps && primarySheet?._center && viewer) {
                        const offset = primarySheet._xAxis
                            ? Cesium.Cartesian3.multiplyByScalar(primarySheet._xAxis, -(CANONICAL_LAYOUT.sheet.height / 2 + 20), new Cesium.Cartesian3())
                            : new Cesium.Cartesian3(0, 0, -30);
                        const stampPos = Cesium.Cartesian3.add(primarySheet._center, offset, new Cesium.Cartesian3());
                        const stampText = `IMPORT: ${ps.file}\nsheet="${ps.sheet}"  range=${ps.usedRange}\n${ps.rows} rows √ó ${ps.cols} cols  |  cells=${ps.cells}  formulas=${ps.formulas}\nimportId=${ps.importId}`;
                        window._importStampEntity = viewer.entities.add({
                            position: stampPos,
                            label: {
                                text: stampText,
                                font: '13px monospace',
                                fillColor: Cesium.Color.fromCssColorString('#00ddff'),
                                outlineColor: Cesium.Color.BLACK,
                                outlineWidth: 2,
                                style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                                verticalOrigin: Cesium.VerticalOrigin.TOP,
                                horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
                                pixelOffset: new Cesium.Cartesian2(8, 4),
                                disableDepthTestDistance: Number.POSITIVE_INFINITY,
                                showBackground: true,
                                backgroundColor: Cesium.Color.fromCssColorString('rgba(8, 14, 28, 0.85)')
                            }
                        });
                    }

                    // Force overlay visible so user can see the 2D stamp
                    if (window.renderHtmlGrid) window.renderHtmlGrid();
                });

                // Spreadsheet overlay (MVP: read-only selection + formula bar)
                sheetOverlay = document.getElementById('sheetOverlay');
                sheetOverlaySheet = document.getElementById('sheetOverlaySheet');
                sheetOverlayCell = document.getElementById('sheetOverlayCell');
                sheetOverlayValue = document.getElementById('sheetOverlayValue');
                sheetOverlayFormula = document.getElementById('sheetOverlayFormula');
                sheetOverlayInput = document.getElementById('sheetOverlayInput');
                sheetOverlayBody = sheetOverlay ? sheetOverlay.querySelector('.body') : null;
                sheetGridOverlay = document.getElementById('spreadsheetOverlay');
                sheetGridScroll = document.getElementById('sheetGridScroll');
                sheetGridTable = document.getElementById('sheetGridTable');
                sheetGridTitle = document.getElementById('sheetGridTitle');
                sheetGridCellRef = document.getElementById('sheetGridCellRef');
                sheetGridFormulaInput = document.getElementById('sheetGridFormulaInput');
                if (sheetGridFormulaInput) {
                    sheetGridFormulaInput.disabled = true;
                }
                console.log('[BUILD]', '2026-02-09T12:30Z ux-1.1-universal-object-contract');
                console.assert(sheetGridOverlay, 'Overlay missing from DOM');
                // Populate grid immediately on init if FORCE is on
                if (window.RELAY_FORCE_OVERLAY === true) {
                    setTimeout(() => {
                        renderHtmlGrid();
                        RelayLog.info('[OVERLAY] force-populated grid on init');
                    }, 500);
                }
                const normalizeInput = (value) => {
                    if (value === null || value === undefined) return '';
                    return String(value).replace(/\r\n/g, '\n').replace(/\s+$/g, '');
                };
                const markRecentCells = (sheet, cellIds) => {
                    if (!sheet || !Array.isArray(cellIds) || cellIds.length === 0) return;
                    if (!sheet._recentCells) {
                        sheet._recentCells = new Map();
                    }
                    const now = Date.now();
                    cellIds.forEach((cellId) => {
                        sheet._recentCells.set(cellId, now);
                    });
                };
                const updateSelectionRange = (sheet, range) => {
                    if (!sheet || !range?.start || !range?.end) return;
                    sheet._selectionRange = {
                        start: { row: range.start.row, col: range.start.col },
                        end: { row: range.end.row, col: range.end.col }
                    };
                };
                const MAX_PASTE_CELLS = 5000;

                const toCellRef = (row, col) => `${colToLetter(col)}${row + 1}`;

                const getCellCoordsFromId = (cellId) => {
                    if (!cellId) return null;
                    const idParts = cellId.split('.');
                    const row = Number.parseInt(idParts[idParts.length - 2], 10);
                    const col = Number.parseInt(idParts[idParts.length - 1], 10);
                    if (!Number.isFinite(row) || !Number.isFinite(col)) return null;
                    return { row, col };
                };

                const ensureCellIndex = (sheet) => {
                    if (!sheet._cellIndex) {
                        sheet._cellIndex = new Map(sheet.cellData.map(c => [`${c.row},${c.col}`, c]));
                    }
                };

                const getOrCreateCellInfo = (sheet, row, col, cellId, cellRef) => {
                    ensureCellIndex(sheet);
                    const key = `${row},${col}`;
                    let cellInfo = sheet._cellIndex.get(key);
                    if (!cellInfo) {
                        cellInfo = { row, col, id: cellId, a1: cellRef };
                        sheet._cellIndex.set(key, cellInfo);
                        sheet.cellData.push(cellInfo);
                    } else if (!cellInfo.id && cellId) {
                        cellInfo.id = cellId;
                    }
                    if (!cellInfo.a1 && cellRef) {
                        cellInfo.a1 = cellRef;
                    }
                    return cellInfo;
                };

                const getCellInfo = (sheet, row, col) => {
                    ensureCellIndex(sheet);
                    return sheet._cellIndex.get(`${row},${col}`) || null;
                };

                const getCellEntity = (sheetId, cellId) => {
                    const key = `${sheetId}|${cellId}`;
                    if (cellEntityIndex.has(key)) return cellEntityIndex.get(key);
                    const match = viewer?.entities?.values?.find(entity => {
                        const props = entity?.properties;
                        const now = Cesium.JulianDate.now();
                        const entitySheetId = props?.sheetId?.getValue ? props.sheetId.getValue(now) : props?.sheetId;
                        const entityCellId = props?.cellId?.getValue ? props.cellId.getValue(now) : props?.cellId;
                        return entitySheetId === sheetId && entityCellId === cellId;
                    }) || null;
                    if (match) {
                        cellEntityIndex.set(key, match);
                    }
                    return match;
                };

                const getRangeBounds = (range) => {
                    if (!range?.start || !range?.end) return null;
                    const minRow = Math.min(range.start.row, range.end.row);
                    const maxRow = Math.max(range.start.row, range.end.row);
                    const minCol = Math.min(range.start.col, range.end.col);
                    const maxCol = Math.max(range.start.col, range.end.col);
                    return {
                        minRow,
                        maxRow,
                        minCol,
                        maxCol,
                        rows: maxRow - minRow + 1,
                        cols: maxCol - minCol + 1
                    };
                };

                const getRangeLabel = (range) => {
                    if (!range?.start || !range?.end) return '‚Äî';
                    const startRef = range.start.cellRef || toCellRef(range.start.row, range.start.col);
                    const endRef = range.end.cellRef || toCellRef(range.end.row, range.end.col);
                    if (startRef === endRef) return startRef;
                    return `${startRef}:${endRef}`;
                };

                const uniqueStable = (items) => {
                    const out = [];
                    const seen = new Set();
                    for (const item of items || []) {
                        const key = String(item || '').trim();
                        if (!key || seen.has(key)) continue;
                        seen.add(key);
                        out.push(key);
                    }
                    return out;
                };

                const extractFormulaRefsMetadata = (formulaText) => {
                    const formula = typeof formulaText === 'string' ? formulaText.trim() : '';
                    if (!formula.startsWith('=')) {
                        return {
                            refsSchemaVersion: 'PQ4-REFS-V1',
                            parseVersion: 'PQ4-REFS-V1',
                            refs: [],
                            ranges: [],
                            refCount: 0,
                            rangeCount: 0
                        };
                    }
                    const expr = formula.slice(1);
                    const tokenRe = /(?:'[^']+'|[A-Za-z_][A-Za-z0-9_.-]*)?!?\$?[A-Z]{1,3}\$?\d+(?::\$?[A-Z]{1,3}\$?\d+)?/g;
                    const tokens = expr.match(tokenRe) || [];
                    const refs = [];
                    const ranges = [];
                    for (const raw of tokens) {
                        const normalized = String(raw).replace(/\$/g, '');
                        if (normalized.includes(':')) ranges.push(normalized);
                        else refs.push(normalized);
                    }
                    const stableRefs = uniqueStable(refs);
                    const stableRanges = uniqueStable(ranges);
                    return {
                        refsSchemaVersion: 'PQ4-REFS-V1',
                        parseVersion: 'PQ4-REFS-V1',
                        refs: stableRefs,
                        ranges: stableRanges,
                        refCount: stableRefs.length,
                        rangeCount: stableRanges.length
                    };
                };

                const recordFormulaRefsCommit = ({ sheetId, cellId, cellRef, formula, commitId, cellInfo }) => {
                    const refsMeta = extractFormulaRefsMetadata(formula);
                    if (cellInfo && typeof cellInfo === 'object') {
                        cellInfo.formulaRefsMeta = refsMeta;
                    }
                    window.__relayCellFormulaCommits.push({
                        id: `frefs_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
                        timestamp: new Date().toISOString(),
                        type: 'CELL_FORMULA_SET',
                        commitId: String(commitId || ''),
                        sheetId: String(sheetId || ''),
                        cellId: String(cellId || ''),
                        cellRef: String(cellRef || ''),
                        formula: String(formula || ''),
                        refsMeta
                    });
                    RelayLog.info(`[F] refsExtracted cell=${cellRef || cellId} refs=${refsMeta.refCount} ranges=${refsMeta.rangeCount}`);
                    return refsMeta;
                };

                const canonicalizeReplayValue = (input) => {
                    if (input === null || typeof input === 'undefined') return null;
                    if (typeof input === 'number') {
                        if (!Number.isFinite(input)) return null;
                        const fixed = input.toFixed(6);
                        return fixed.replace(/\.?0+$/, '');
                    }
                    if (typeof input !== 'object') return String(input);
                    if (Array.isArray(input)) return input.map(canonicalizeReplayValue);
                    const out = {};
                    for (const key of Object.keys(input).sort()) {
                        out[key] = canonicalizeReplayValue(input[key]);
                    }
                    return out;
                };

                const normalizeCellStateForReplay = (cellInfo = {}) => {
                    const refsMeta = cellInfo.formulaRefsMeta || {
                        refsSchemaVersion: cellInfo.refsSchemaVersion || cellInfo.parseVersion || 'PQ4-REFS-V1',
                        parseVersion: cellInfo.parseVersion || cellInfo.refsSchemaVersion || 'PQ4-REFS-V1',
                        refs: Array.isArray(cellInfo.refs) ? cellInfo.refs : [],
                        ranges: Array.isArray(cellInfo.ranges) ? cellInfo.ranges : [],
                        refCount: Number.isFinite(Number(cellInfo.refCount)) ? Number(cellInfo.refCount) : (Array.isArray(cellInfo.refs) ? cellInfo.refs.length : 0),
                        rangeCount: Number.isFinite(Number(cellInfo.rangeCount)) ? Number(cellInfo.rangeCount) : (Array.isArray(cellInfo.ranges) ? cellInfo.ranges.length : 0)
                    };
                    return {
                        value: cellInfo.value ?? '',
                        formula: cellInfo.formula ?? null,
                        display: cellInfo.display ?? '',
                        hasFormula: !!cellInfo.hasFormula,
                        refsSchemaVersion: refsMeta.refsSchemaVersion || refsMeta.parseVersion || 'PQ4-REFS-V1',
                        parseVersion: refsMeta.parseVersion || 'PQ4-REFS-V1',
                        refs: uniqueStable(refsMeta.refs || []),
                        ranges: uniqueStable(refsMeta.ranges || [])
                    };
                };

                const recordSheetCellCommit = ({ commitId, sheetId, cellId, cellRef, type, cellInfo }) => {
                    const seq = (++window.__relaySheetCommitSeq);
                    const payload = normalizeCellStateForReplay(cellInfo || {});
                    const sheetCommitRecord = {
                        seq,
                        timestamp: new Date().toISOString(),
                        commitId: String(commitId || ''),
                        sheetId: String(sheetId || ''),
                        cellId: String(cellId || ''),
                        cellRef: String(cellRef || ''),
                        type: String(type || ''),
                        payload
                    };
                    window.__relaySheetCommits.push(sheetCommitRecord);
                    // E1-CRYPTO-1: append to derived per-sheet chain (non-mutating)
                    if (window.__relayCryptoState?.initialized) {
                        appendSheetChainEntry(window.__relayCryptoState.sheetChains, sheetCommitRecord, window.__relayCryptoState.globalChain).then(entry => {
                            const logMsg = `[CRYPTO] sheetCommit chainLink sheetId=${sheetId} seq=${seq} prevSheetHash=${entry.prevSheetHash.slice(0, 16)}`;
                            RelayLog.info(logMsg); console.log(logMsg);
                        });
                    }
                    return seq;
                };

                const getSheetCommitLog = (sheetId) => {
                    return (window.__relaySheetCommits || [])
                        .filter(c => c.sheetId === sheetId)
                        .slice()
                        .sort((a, b) => Number(a.seq || 0) - Number(b.seq || 0));
                };

                const replaySheetStateFromCommitLog = (sheetId) => {
                    const commits = getSheetCommitLog(sheetId);
                    const replayMap = new Map();
                    for (const commit of commits) {
                        replayMap.set(commit.cellRef, {
                            ...(commit.payload || {}),
                            fromCommitId: commit.commitId,
                            seq: commit.seq
                        });
                    }
                    return { commits, replayMap };
                };

                const snapshotLiveStateForCommittedCells = (sheet, replayMap) => {
                    ensureCellIndex(sheet);
                    const keys = [...replayMap.keys()].sort((a, b) => a.localeCompare(b));
                    const out = {};
                    for (const key of keys) {
                        const parsed = parseCellRef(key);
                        if (!parsed) continue;
                        const ci = sheet._cellIndex.get(`${parsed.row},${parsed.col}`) || null;
                        out[key] = normalizeCellStateForReplay(ci || {});
                    }
                    return out;
                };

                const snapshotReplayState = (replayMap) => {
                    const keys = [...replayMap.keys()].sort((a, b) => a.localeCompare(b));
                    const out = {};
                    for (const key of keys) {
                        const state = replayMap.get(key) || {};
                        out[key] = normalizeCellStateForReplay(state);
                    }
                    return out;
                };

                const computeSheetReplay = (sheetId, { emitLog = true } = {}) => {
                    const sheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === sheetId);
                    if (!sheet) {
                        return { ok: false, reason: 'SHEET_NOT_FOUND', sheetId, replayHash: null, liveHash: null, matchesLive: false };
                    }
                    const { commits, replayMap } = replaySheetStateFromCommitLog(sheetId);
                    const replayState = snapshotReplayState(replayMap);
                    const liveState = snapshotLiveStateForCommittedCells(sheet, replayMap);
                    const replayCanonical = canonicalizeReplayValue(replayState);
                    const liveCanonical = canonicalizeReplayValue(liveState);
                    const replayHash = fnv1aHex(JSON.stringify(replayCanonical));
                    const liveHash = fnv1aHex(JSON.stringify(liveCanonical));
                    const matchesLive = replayHash === liveHash;
                    if (emitLog) {
                        RelayLog.info(`[R] replayHash=${replayHash} matchesLive=${matchesLive ? 'true' : 'false'}`);
                    }
                    return {
                        ok: true,
                        sheetId,
                        commitCount: commits.length,
                        replayHash,
                        liveHash,
                        matchesLive,
                        replayState: replayCanonical,
                        liveState: liveCanonical
                    };
                };

                const getCellCommitHistory = (sheetId, cellRef) => {
                    const ref = String(cellRef || '').toUpperCase();
                    return getSheetCommitLog(sheetId)
                        .filter(c => String(c.cellRef || '').toUpperCase() === ref)
                        .sort((a, b) => Number(a.seq || 0) - Number(b.seq || 0));
                };

                const buildCellInspectionRecord = (sheetId, cellRef, latestN = 8) => {
                    const sheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === sheetId);
                    if (!sheet) return { ok: false, reason: 'SHEET_NOT_FOUND', sheetId, cellRef };
                    const parsed = parseCellRef(String(cellRef || '').toUpperCase());
                    if (!parsed) return { ok: false, reason: 'INVALID_CELL_REF', sheetId, cellRef };
                    ensureCellIndex(sheet);
                    const ci = sheet._cellIndex.get(`${parsed.row},${parsed.col}`);
                    if (!ci) return { ok: false, reason: 'CELL_NOT_FOUND', sheetId, cellRef: String(cellRef).toUpperCase() };
                    const normalized = normalizeCellStateForReplay(ci);
                    const history = getCellCommitHistory(sheetId, cellRef);
                    const last = history.length ? history[history.length - 1] : null;
                    return {
                        ok: true,
                        type: 'cell',
                        sheetId,
                        cellRef: String(cellRef).toUpperCase(),
                        cellId: ci.id || `${sheetId}.cell.${parsed.row}.${parsed.col}`,
                        value: normalized.value,
                        formula: normalized.formula,
                        display: normalized.display,
                        refsMeta: {
                            refsSchemaVersion: normalized.refsSchemaVersion,
                            parseVersion: normalized.parseVersion,
                            refs: normalized.refs,
                            ranges: normalized.ranges
                        },
                        formulaState: ci.formulaState || 'DETERMINATE',
                        formulaStateReason: ci.formulaStateReason || (ci.formulaState === 'INDETERMINATE' ? 'UNKNOWN' : 'ACYCLIC'),
                        lastCommitId: last?.commitId || null,
                        lastSeq: Number.isFinite(Number(last?.seq)) ? Number(last.seq) : null,
                        commitHistoryCount: history.length,
                        latestCommits: history.slice(Math.max(0, history.length - Math.max(1, Number(latestN) || 8))).map((c) => ({
                            seq: Number(c.seq),
                            commitId: c.commitId,
                            type: c.type,
                            timestamp: c.timestamp
                        }))
                    };
                };

                const showCellInspectionPanel = (record) => {
                    const panel = document.getElementById('matchInspector');
                    const content = document.getElementById('matchInspectorContent');
                    const title = document.getElementById('inspectorTitle');
                    if (!panel || !content) return;
                    if (title) title.textContent = 'Inspector v1: Cell Provenance';
                    const refs = record?.refsMeta?.refs?.length ? record.refsMeta.refs.join(', ') : '‚Äî';
                    const ranges = record?.refsMeta?.ranges?.length ? record.refsMeta.ranges.join(', ') : '‚Äî';
                    const stateColor = record.formulaState === 'INDETERMINATE' ? '#ffb86c' : '#50fa7b';
                    const latestRows = (record.latestCommits || []).map((entry) =>
                        `<div style="color:#c8d6e5; font-size:10px; padding-left:8px;">#${entry.seq} ${entry.type} ${entry.commitId}</div>`
                    ).join('');
                    let html = '';
                    html += `<div style="margin-bottom:8px; color:#ffd700; font-weight:bold;">${record.sheetId} ‚Üí ${record.cellRef}</div>`;
                    html += `<div style="color:#c8d6e5; font-size:10px;">Value: <span style="color:#50fa7b;">${record.display ?? record.value ?? ''}</span></div>`;
                    html += `<div style="color:#c8d6e5; font-size:10px;">Formula: <span style="color:#ff79c6;">${record.formula || '‚Äî'}</span></div>`;
                    html += `<div style="color:#c8d6e5; font-size:10px;">Refs: <span style="color:#8be9fd;">${refs}</span></div>`;
                    html += `<div style="color:#c8d6e5; font-size:10px;">Ranges: <span style="color:#8be9fd;">${ranges}</span></div>`;
                    html += `<div style="color:#c8d6e5; font-size:10px;">Formula State: <span style="color:${stateColor};">${record.formulaState}</span> reason=${record.formulaStateReason || 'n/a'}</div>`;
                    html += `<div style="margin-top:6px; color:#c8d6e5; font-size:10px;">lastCommitId=${record.lastCommitId || 'n/a'} lastSeq=${record.lastSeq ?? 'n/a'} commits=${record.commitHistoryCount}</div>`;
                    html += `<div style="margin-top:6px; color:#7fd3ff; font-weight:600; font-size:10px;">Latest Commits</div>`;
                    html += latestRows || '<div style="color:#6272a4; font-size:10px; padding-left:8px;">‚Äî</div>';
                    content.innerHTML = html;
                    panel.style.display = 'block';
                };

                const inspectCellProvenance = (sheetId, cellRef, { emitLog = true, showPanel = true, latestN = 8 } = {}) => {
                    const record = buildCellInspectionRecord(sheetId, cellRef, latestN);
                    if (!record.ok) return record;
                    if (showPanel) showCellInspectionPanel(record);
                    if (emitLog) {
                        RelayLog.info(`[I] inspect cell=${record.cellRef} commits=${record.commitHistoryCount} lastSeq=${record.lastSeq ?? 0}`);
                    }
                    return record;
                };

                const inspectTimeboxProvenance = (timeboxId, { emitLog = true, showPanel = true } = {}) => {
                    const id = String(timeboxId || '');
                    const entry = filamentRenderer?.timeboxByInstanceId?.get?.(id) || null;
                    if (!entry) return { ok: false, reason: 'TIMEBOX_NOT_FOUND', timeboxId: id };
                    const cellId = String(entry.cellId || '');
                    const cellMatch = cellId.match(/^(.*)\.cell\.(\d+)\.(\d+)$/);
                    if (!cellMatch) return { ok: false, reason: 'CELL_ID_PARSE_FAIL', timeboxId: id, cellId };
                    const sheetId = cellMatch[1];
                    const row = Number(cellMatch[2]);
                    const col = Number(cellMatch[3]);
                    const cellRef = toCellRef(row, col);
                    const history = getCellCommitHistory(sheetId, cellRef);
                    const idxMatch = id.match(/-timebox-(\d+)$/);
                    const ordinal = Number(idxMatch?.[1] || 0) + 1;
                    const commits = (ordinal >= 1 && ordinal <= history.length) ? 1 : 0;
                    const start = commits ? ordinal : 0;
                    const end = commits ? ordinal : 0;
                    const record = {
                        ok: true,
                        type: 'timebox',
                        timeboxId: id,
                        sheetId,
                        cellId,
                        cellRef,
                        commits,
                        range: `${start}-${end}`,
                        historyCount: history.length
                    };
                    if (showPanel) {
                        const panel = document.getElementById('matchInspector');
                        const content = document.getElementById('matchInspectorContent');
                        const title = document.getElementById('inspectorTitle');
                        if (panel && content) {
                            if (title) title.textContent = 'Inspector v1: Timebox Provenance';
                            content.innerHTML = `
                                <div style="margin-bottom:8px; color:#ffd700; font-weight:bold;">${record.timeboxId}</div>
                                <div style="color:#c8d6e5; font-size:10px;">Cell: <span style="color:#7fd3ff;">${record.sheetId} ‚Üí ${record.cellRef}</span></div>
                                <div style="color:#c8d6e5; font-size:10px;">Commits: <span style="color:#50fa7b;">${record.commits}</span></div>
                                <div style="color:#c8d6e5; font-size:10px;">Range: <span style="color:#8be9fd;">${record.range}</span></div>
                            `;
                            panel.style.display = 'block';
                        }
                    }
                    if (emitLog) {
                        RelayLog.info(`[I] inspect timebox=${record.timeboxId} commits=${record.commits} range=${record.range}`);
                    }
                    return record;
                };

                const getSheetBoundsFromCells = (sheet) => {
                    const cells = Array.isArray(sheet?.cellData) ? sheet.cellData : [];
                    let maxRow = 0;
                    let maxCol = 0;
                    for (const ci of cells) {
                        const row = Number(ci?.row);
                        const col = Number(ci?.col);
                        if (Number.isFinite(row) && row > maxRow) maxRow = row;
                        if (Number.isFinite(col) && col > maxCol) maxCol = col;
                    }
                    // Keep deterministic finite bounds even for sparse sheets.
                    return { minRow: 0, minCol: 0, maxRow: Math.max(200, maxRow), maxCol: Math.max(200, maxCol) };
                };

                const normalizeRefTokenForSheet = (sheet, token) => {
                    const raw = String(token || '').trim();
                    if (!raw) return null;
                    if (!raw.includes('!')) return raw;
                    const bangIdx = raw.indexOf('!');
                    const sheetPart = raw.substring(0, bangIdx).replace(/^['"]|['"]$/g, '').trim();
                    const localPart = raw.substring(bangIdx + 1).trim();
                    const matchesCurrent = sheetPart === String(sheet?.id || '') || sheetPart === String(sheet?.name || '');
                    return matchesCurrent ? localPart : null;
                };

                const expandTokenToRefsInBounds = (sheet, token, bounds) => {
                    const normalized = normalizeRefTokenForSheet(sheet, token);
                    if (!normalized) return [];
                    if (normalized.includes(':')) {
                        const r = parseRange(normalized);
                        if (!r) return [];
                        const startRow = Math.max(bounds.minRow, r.startRow);
                        const endRow = Math.min(bounds.maxRow, r.endRow);
                        const startCol = Math.max(bounds.minCol, r.startCol);
                        const endCol = Math.min(bounds.maxCol, r.endCol);
                        const refs = [];
                        for (let row = startRow; row <= endRow; row++) {
                            for (let col = startCol; col <= endCol; col++) {
                                refs.push(toCellRef(row, col));
                            }
                        }
                        return refs;
                    }
                    const parsed = parseCellRef(normalized);
                    if (!parsed) return [];
                    if (parsed.row < bounds.minRow || parsed.row > bounds.maxRow || parsed.col < bounds.minCol || parsed.col > bounds.maxCol) {
                        return [];
                    }
                    return [toCellRef(parsed.row, parsed.col)];
                };

                const buildFormulaDagForSheet = (sheet, { emitLog = true } = {}) => {
                    if (!sheet || sheet.type !== 'sheet') {
                        return { sheetId: null, nodes: [], edges: [], cycleCount: 0, cycleNodes: [], affectedNodes: [] };
                    }
                    ensureCellIndex(sheet);
                    const formulaCells = (sheet.cellData || [])
                        .filter(ci => ci?.hasFormula && typeof ci?.formula === 'string' && ci.formula.startsWith('='))
                        .sort((a, b) => String(a.a1 || toCellRef(a.row, a.col)).localeCompare(String(b.a1 || toCellRef(b.row, b.col))));
                    const nodeRefs = formulaCells.map(ci => ci.a1 || toCellRef(ci.row, ci.col));
                    const nodeSet = new Set(nodeRefs);
                    const bounds = getSheetBoundsFromCells(sheet);
                    const edges = [];
                    const adjacency = new Map();
                    for (const ref of nodeRefs) adjacency.set(ref, []);

                    for (const ci of formulaCells) {
                        const sourceRef = ci.a1 || toCellRef(ci.row, ci.col);
                        const refsMeta = ci.formulaRefsMeta || extractFormulaRefsMetadata(ci.formula);
                        const targetRefs = [];
                        for (const r of (refsMeta.refs || [])) targetRefs.push(...expandTokenToRefsInBounds(sheet, r, bounds));
                        for (const r of (refsMeta.ranges || [])) targetRefs.push(...expandTokenToRefsInBounds(sheet, r, bounds));
                        const stableTargets = uniqueStable(targetRefs)
                            .filter(t => nodeSet.has(t))
                            .sort((a, b) => a.localeCompare(b));
                        for (const targetRef of stableTargets) {
                            edges.push({ from: sourceRef, to: targetRef });
                            adjacency.get(sourceRef).push(targetRef);
                        }
                    }

                    // Deterministic cycle detection (Tarjan SCC) over formula-only graph.
                    let indexCounter = 0;
                    const stack = [];
                    const onStack = new Set();
                    const indexMap = new Map();
                    const lowMap = new Map();
                    const sccs = [];
                    const selfLoops = new Set(edges.filter(e => e.from === e.to).map(e => e.from));
                    const strongConnect = (node) => {
                        indexMap.set(node, indexCounter);
                        lowMap.set(node, indexCounter);
                        indexCounter += 1;
                        stack.push(node);
                        onStack.add(node);
                        for (const next of adjacency.get(node) || []) {
                            if (!indexMap.has(next)) {
                                strongConnect(next);
                                lowMap.set(node, Math.min(lowMap.get(node), lowMap.get(next)));
                            } else if (onStack.has(next)) {
                                lowMap.set(node, Math.min(lowMap.get(node), indexMap.get(next)));
                            }
                        }
                        if (lowMap.get(node) === indexMap.get(node)) {
                            const component = [];
                            let w = null;
                            do {
                                w = stack.pop();
                                onStack.delete(w);
                                component.push(w);
                            } while (w !== node);
                            sccs.push(component.sort((a, b) => a.localeCompare(b)));
                        }
                    };
                    for (const node of nodeRefs) {
                        if (!indexMap.has(node)) strongConnect(node);
                    }
                    const cycleGroups = sccs.filter(group => group.length > 1 || selfLoops.has(group[0]));
                    const cycleNodes = uniqueStable(cycleGroups.flat()).sort((a, b) => a.localeCompare(b));

                    // Affected nodes = cycle members + formula nodes that depend on any cycle member.
                    const reverseAdj = new Map();
                    for (const node of nodeRefs) reverseAdj.set(node, []);
                    for (const e of edges) {
                        if (!reverseAdj.has(e.to)) reverseAdj.set(e.to, []);
                        reverseAdj.get(e.to).push(e.from);
                    }
                    const affected = new Set(cycleNodes);
                    const queue = [...cycleNodes];
                    while (queue.length > 0) {
                        const current = queue.shift();
                        for (const parent of reverseAdj.get(current) || []) {
                            if (affected.has(parent)) continue;
                            affected.add(parent);
                            queue.push(parent);
                        }
                    }
                    const affectedNodes = [...affected].sort((a, b) => a.localeCompare(b));

                    for (const ci of formulaCells) {
                        const ref = ci.a1 || toCellRef(ci.row, ci.col);
                        if (affected.has(ref)) {
                            ci.formulaState = 'INDETERMINATE';
                            ci.formulaStateReason = 'CYCLE';
                            if (typeof ci.display === 'undefined' || ci.display === null || String(ci.display).trim() === '') {
                                ci.display = 'INDETERMINATE';
                            }
                        } else {
                            ci.formulaState = 'DETERMINATE';
                            ci.formulaStateReason = 'ACYCLIC';
                        }
                    }

                    const dag = {
                        sheetId: String(sheet.id || ''),
                        schemaVersion: 'PQ5-DAG-V1',
                        refsSchemaVersion: 'PQ4-REFS-V1',
                        builtAt: new Date().toISOString(),
                        nodes: [...nodeRefs].sort((a, b) => a.localeCompare(b)),
                        edges: edges
                            .slice()
                            .sort((a, b) => `${a.from}>${a.to}`.localeCompare(`${b.from}>${b.to}`)),
                        cycleCount: cycleGroups.length,
                        cycleNodes,
                        affectedNodes
                    };
                    window.__relayFormulaDagBySheet.set(dag.sheetId, dag);
                    if (emitLog) {
                        RelayLog.info(`[F] dag nodes=${dag.nodes.length} edges=${dag.edges.length} cycles=${dag.cycleCount}`);
                        if (dag.cycleCount > 0) {
                            RelayLog.info(`[F] indeterminate cells=${dag.affectedNodes.join(',')} reason=cycle`);
                        }
                    }
                    return dag;
                };

                const updateOverlayForRange = (range, cellInfo) => {
                    const bounds = getRangeBounds(range);
                    if (!bounds) return;
                    const rangeLabel = getRangeLabel(range);
                    sheetOverlayCell.textContent = rangeLabel;
                    if (bounds.rows * bounds.cols === 1) {
                        const valueText = (cellInfo?.display ?? cellInfo?.value ?? '‚Äî');
                        const formulaText = (cellInfo?.formula ?? '‚Äî');
                        sheetOverlayValue.textContent = `Value: ${valueText}`;
                        if (cellInfo?.hasFormula && typeof cellInfo?.formula === 'string') {
                            const refsMeta = cellInfo?.formulaRefsMeta || extractFormulaRefsMetadata(cellInfo.formula);
                            const refsText = refsMeta.refs.length ? refsMeta.refs.join(',') : '‚Äî';
                            const rangesText = refsMeta.ranges.length ? refsMeta.ranges.join(',') : '‚Äî';
                            sheetOverlayFormula.textContent = `Formula: ${formulaText} | Refs: ${refsText} | Ranges: ${rangesText}`;
                        } else {
                            sheetOverlayFormula.textContent = `Formula: ${formulaText}`;
                        }
                    } else {
                        sheetOverlayValue.textContent = `Value: (range ${bounds.rows}x${bounds.cols})`;
                        sheetOverlayFormula.textContent = `Formula: ‚Äî`;
                    }
                };

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // (Old formula engine removed ‚Äî replaced by A0.2 engine above computeCellUpdate)

                // ‚îÄ‚îÄ‚îÄ A0.2: Formula Engine ‚Äî evaluate, recalc, propagate ‚îÄ‚îÄ‚îÄ

                const getCellNumericValue = (sheet, row, col) => {
                    if (!sheet._cellIndex) return 0;
                    const ci = sheet._cellIndex.get(`${row},${col}`);
                    if (!ci) return 0;
                    const v = ci.value ?? ci.display ?? 0;
                    const n = Number(v);
                    return Number.isFinite(n) ? n : 0;
                };

                // ‚îÄ‚îÄ‚îÄ Formula helpers: argument parser, range resolver, condition evaluator ‚îÄ‚îÄ‚îÄ

                /** Get the raw value (string or number) of a cell */
                const getCellRawValue = (sheet, row, col) => {
                    if (!sheet._cellIndex) return '';
                    const ci = sheet._cellIndex.get(`${row},${col}`);
                    if (!ci) return '';
                    return ci.value ?? ci.display ?? '';
                };

                /** Resolve a cross-sheet reference prefix: "SheetId!Range" ‚Üí { sheet, ref }
                 *  Supports: P2P.ThreeWayMatch!N2:N8  or  'Sheet Name'!A1  */
                const resolveSheetRef = (refStr) => {
                    const bangIdx = refStr.indexOf('!');
                    if (bangIdx < 0) return null;
                    let sheetRef = refStr.substring(0, bangIdx).trim();
                    const cellPart = refStr.substring(bangIdx + 1).trim();
                    // Strip surrounding quotes from sheet name
                    if ((sheetRef.startsWith("'") && sheetRef.endsWith("'")) ||
                        (sheetRef.startsWith('"') && sheetRef.endsWith('"')))
                        sheetRef = sheetRef.slice(1, -1);
                    // Look up sheet by id or name
                    const allSheets = relayState.tree.nodes.filter(n => n.type === 'sheet');
                    const targetSheet = allSheets.find(s => s.id === sheetRef || s.name === sheetRef);
                    if (!targetSheet) return null;
                    ensureCellIndex(targetSheet);
                    return { sheet: targetSheet, ref: cellPart };
                };

                /** Parse a range string "A1:C3" into {startRow, endRow, startCol, endCol} */
                const parseRange = (rangeStr) => {
                    const parts = rangeStr.trim().split(':');
                    if (parts.length !== 2) return null;
                    const a = parseCellRef(parts[0].trim());
                    const b = parseCellRef(parts[1].trim());
                    if (!a || !b) return null;
                    return { startRow: Math.min(a.row, b.row), endRow: Math.max(a.row, b.row),
                             startCol: Math.min(a.col, b.col), endCol: Math.max(a.col, b.col) };
                };

                /** Resolve a range into array of {row, col, value, numValue} and add deps.
                 *  Supports cross-sheet: "P2P.ThreeWayMatch!N2:N8" */
                const resolveRange = (rangeStr, sheet, deps) => {
                    let targetSheet = sheet;
                    let actualRange = rangeStr.trim();
                    // Cross-sheet reference
                    const xref = resolveSheetRef(actualRange);
                    if (xref) { targetSheet = xref.sheet; actualRange = xref.ref; }
                    const r = parseRange(actualRange);
                    if (!r) return [];
                    const cells = [];
                    const totalCells = (r.endRow - r.startRow + 1) * (r.endCol - r.startCol + 1);
                    // D0: For large ranges, push one range dep instead of per-cell deps (avoids O(n) allocations)
                    const useRangeDep = totalCells > 100;
                    if (useRangeDep) {
                        const rangeRef = xref
                            ? `${targetSheet.id}!${toCellRef(r.startRow, r.startCol)}:${toCellRef(r.endRow, r.endCol)}`
                            : `${toCellRef(r.startRow, r.startCol)}:${toCellRef(r.endRow, r.endCol)}`;
                        deps.push(rangeRef);
                    }
                    ensureCellIndex(targetSheet);
                    for (let row = r.startRow; row <= r.endRow; row++)
                        for (let col = r.startCol; col <= r.endCol; col++) {
                            if (!useRangeDep) {
                                deps.push(xref ? `${targetSheet.id}!${toCellRef(row, col)}` : toCellRef(row, col));
                            }
                            const ci = targetSheet._cellIndex.get(`${row},${col}`);
                            const raw = ci ? (ci.value ?? ci.display ?? '') : '';
                            const n = Number(raw);
                            cells.push({ row, col, value: raw, numValue: Number.isFinite(n) ? n : 0 });
                        }
                    return cells;
                };

                /** Split function arguments respecting nested parens and quoted strings */
                const parseFunctionArgs = (argsStr) => {
                    const args = [];
                    let depth = 0, current = '', inStr = false, strChar = '';
                    for (let i = 0; i < argsStr.length; i++) {
                        const ch = argsStr[i];
                        if (inStr) {
                            current += ch;
                            if (ch === strChar) inStr = false;
                            continue;
                        }
                        if (ch === '"' || ch === "'") { inStr = true; strChar = ch; current += ch; continue; }
                        if (ch === '(') { depth++; current += ch; continue; }
                        if (ch === ')') { depth--; current += ch; continue; }
                        if (ch === ',' && depth === 0) { args.push(current.trim()); current = ''; continue; }
                        current += ch;
                    }
                    if (current.trim()) args.push(current.trim());
                    return args;
                };

                /** Evaluate a comparison condition: "A1>100", ">50", "=text", etc. */
                const evaluateCondition = (leftVal, criteriaStr) => {
                    if (typeof criteriaStr !== 'string') criteriaStr = String(criteriaStr);
                    // Parse operator prefix from criteria
                    const opMatch = criteriaStr.match(/^(>=|<=|<>|>|<|=)(.*)$/);
                    let op = '=', target;
                    if (opMatch) { op = opMatch[1]; target = opMatch[2]; }
                    else { target = criteriaStr; }
                    // Strip surrounding quotes from target
                    if ((target.startsWith('"') && target.endsWith('"')) || (target.startsWith("'") && target.endsWith("'")))
                        target = target.slice(1, -1);
                    const leftNum = Number(leftVal), targetNum = Number(target);
                    const bothNumeric = Number.isFinite(leftNum) && Number.isFinite(targetNum);
                    switch (op) {
                        case '>=': return bothNumeric ? leftNum >= targetNum : String(leftVal) >= target;
                        case '<=': return bothNumeric ? leftNum <= targetNum : String(leftVal) <= target;
                        case '<>': return bothNumeric ? leftNum !== targetNum : String(leftVal).toLowerCase() !== target.toLowerCase();
                        case '>':  return bothNumeric ? leftNum > targetNum : String(leftVal) > target;
                        case '<':  return bothNumeric ? leftNum < targetNum : String(leftVal) < target;
                        case '=':  return bothNumeric ? leftNum === targetNum : String(leftVal).toLowerCase() === target.toLowerCase();
                        default: return false;
                    }
                };

                /** Recursively evaluate a formula argument ‚Äî could be a number, string, cell ref, range, or sub-formula.
                 *  Supports cross-sheet references: P2P.ThreeWayMatch!N2 or P2P.InvoiceLines!A1:A10 */
                const resolveArg = (arg, sheet, deps) => {
                    if (!arg) return { value: '', type: 'empty' };
                    // Quoted string
                    if ((arg.startsWith('"') && arg.endsWith('"')) || (arg.startsWith("'") && arg.endsWith("'")))
                        return { value: arg.slice(1, -1), type: 'string' };
                    // Boolean
                    if (arg.toUpperCase() === 'TRUE') return { value: true, type: 'boolean' };
                    if (arg.toUpperCase() === 'FALSE') return { value: false, type: 'boolean' };
                    // Numeric literal
                    const n = Number(arg);
                    if (Number.isFinite(n) && /^-?\d+(\.\d+)?$/.test(arg)) return { value: n, type: 'number' };
                    // Cross-sheet range (contains ! and :)
                    if (arg.includes('!') && arg.includes(':')) return { value: arg, type: 'range' };
                    // Cross-sheet single cell reference (contains !)
                    if (arg.includes('!')) {
                        const xref = resolveSheetRef(arg);
                        if (xref) {
                            const ref = parseCellRef(xref.ref);
                            if (ref) {
                                deps.push(`${xref.sheet.id}!${toCellRef(ref.row, ref.col)}`);
                                const raw = getCellRawValue(xref.sheet, ref.row, ref.col);
                                const num = Number(raw);
                                return { value: raw, numValue: Number.isFinite(num) ? num : 0, type: 'cell', row: ref.row, col: ref.col };
                            }
                        }
                    }
                    // Local range (contains :)
                    if (arg.includes(':')) return { value: arg, type: 'range' };
                    // Local cell reference
                    const ref = parseCellRef(arg);
                    if (ref) {
                        deps.push(toCellRef(ref.row, ref.col));
                        const raw = getCellRawValue(sheet, ref.row, ref.col);
                        const num = Number(raw);
                        return { value: raw, numValue: Number.isFinite(num) ? num : 0, type: 'cell', row: ref.row, col: ref.col };
                    }
                    // Sub-expression (contains function call or operators) ‚Äî evaluate recursively
                    const subResult = evaluateFormula('=' + arg, sheet);
                    if (subResult.deps) subResult.deps.forEach(d => deps.push(d));
                    return { value: subResult.value ?? arg, type: subResult.error ? 'string' : 'number' };
                };

                // ‚îÄ‚îÄ‚îÄ Function Registry ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                const formulaFunctions = {};

                // SUM(range)
                formulaFunctions['SUM'] = (args, sheet, deps) => {
                    let sum = 0;
                    args.forEach(a => {
                        const cells = resolveRange(a, sheet, deps);
                        cells.forEach(c => sum += c.numValue);
                    });
                    return { value: sum, type: 'number' };
                };

                // AVERAGE(range)
                formulaFunctions['AVERAGE'] = (args, sheet, deps) => {
                    let sum = 0, cnt = 0;
                    args.forEach(a => {
                        const cells = resolveRange(a, sheet, deps);
                        cells.forEach(c => { sum += c.numValue; cnt++; });
                    });
                    return { value: cnt > 0 ? sum / cnt : 0, type: 'number' };
                };

                // COUNT(range)
                formulaFunctions['COUNT'] = (args, sheet, deps) => {
                    let cnt = 0;
                    args.forEach(a => {
                        const cells = resolveRange(a, sheet, deps);
                        cells.forEach(c => { if (c.numValue !== 0) cnt++; });
                    });
                    return { value: cnt, type: 'number' };
                };

                // MIN(range)
                formulaFunctions['MIN'] = (args, sheet, deps) => {
                    let min = Infinity;
                    args.forEach(a => {
                        const cells = resolveRange(a, sheet, deps);
                        cells.forEach(c => { min = Math.min(min, c.numValue); });
                    });
                    return { value: Number.isFinite(min) ? min : 0, type: 'number' };
                };

                // MAX(range)
                formulaFunctions['MAX'] = (args, sheet, deps) => {
                    let max = -Infinity;
                    args.forEach(a => {
                        const cells = resolveRange(a, sheet, deps);
                        cells.forEach(c => { max = Math.max(max, c.numValue); });
                    });
                    return { value: Number.isFinite(max) ? max : 0, type: 'number' };
                };

                // IF(condition, trueValue, falseValue)
                formulaFunctions['IF'] = (args, sheet, deps) => {
                    if (args.length < 2) return { value: null, type: 'error', error: 'IF requires 2-3 args' };
                    // Evaluate the condition ‚Äî could be "A1>100" or a comparison expression
                    const condStr = args[0];
                    let condResult = false;
                    // Parse comparison operators in condition
                    const compMatch = condStr.match(/^(.+?)\s*(>=|<=|<>|>|<|=)\s*(.+)$/);
                    if (compMatch) {
                        const leftResolved = resolveArg(compMatch[1].trim(), sheet, deps);
                        const rightResolved = resolveArg(compMatch[3].trim(), sheet, deps);
                        const leftVal = leftResolved.numValue !== undefined ? leftResolved.numValue : leftResolved.value;
                        const rightVal = rightResolved.numValue !== undefined ? rightResolved.numValue : rightResolved.value;
                        const op = compMatch[2];
                        const lN = Number(leftVal), rN = Number(rightVal);
                        const bothNum = Number.isFinite(lN) && Number.isFinite(rN);
                        switch (op) {
                            case '>=': condResult = bothNum ? lN >= rN : String(leftVal) >= String(rightVal); break;
                            case '<=': condResult = bothNum ? lN <= rN : String(leftVal) <= String(rightVal); break;
                            case '<>': condResult = bothNum ? lN !== rN : String(leftVal) !== String(rightVal); break;
                            case '>':  condResult = bothNum ? lN > rN : String(leftVal) > String(rightVal); break;
                            case '<':  condResult = bothNum ? lN < rN : String(leftVal) < String(rightVal); break;
                            case '=':  condResult = bothNum ? lN === rN : String(leftVal).toLowerCase() === String(rightVal).toLowerCase(); break;
                        }
                    } else {
                        // Bare value ‚Äî truthy check
                        const resolved = resolveArg(condStr, sheet, deps);
                        condResult = !!resolved.value && resolved.value !== 0;
                    }
                    const trueArg = resolveArg(args[1], sheet, deps);
                    const falseArg = args.length >= 3 ? resolveArg(args[2], sheet, deps) : { value: false, type: 'boolean' };
                    const result = condResult ? trueArg : falseArg;
                    return { value: result.value, type: typeof result.value === 'number' ? 'number' : 'string' };
                };

                // VLOOKUP(lookupValue, tableRange, colIndex, [exactMatch])
                formulaFunctions['VLOOKUP'] = (args, sheet, deps) => {
                    if (args.length < 3) return { value: null, type: 'error', error: 'VLOOKUP requires 3-4 args' };
                    const lookupResolved = resolveArg(args[0], sheet, deps);
                    const lookupVal = lookupResolved.value;
                    const tableRangeStr = args[1].trim();
                    const colIdx = Number(resolveArg(args[2], sheet, deps).value);
                    const exactMatch = args.length >= 4 ? resolveArg(args[3], sheet, deps).value : true;
                    if (!Number.isFinite(colIdx) || colIdx < 1) return { value: null, type: 'error', error: 'VLOOKUP: invalid col index' };
                    const rng = parseRange(tableRangeStr);
                    if (!rng) return { value: null, type: 'error', error: 'VLOOKUP: invalid range' };
                    // Add all cells in range as dependencies
                    for (let r = rng.startRow; r <= rng.endRow; r++)
                        for (let c = rng.startCol; c <= rng.endCol; c++)
                            deps.push(toCellRef(r, c));
                    // Search first column
                    const targetCol = rng.startCol + (colIdx - 1);
                    if (targetCol > rng.endCol) return { value: null, type: 'error', error: 'VLOOKUP: col index out of range' };
                    let bestRow = -1;
                    for (let r = rng.startRow; r <= rng.endRow; r++) {
                        const cellVal = getCellRawValue(sheet, r, rng.startCol);
                        if (exactMatch === false || exactMatch === 0 || String(exactMatch).toUpperCase() === 'FALSE') {
                            // Exact match
                            if (String(cellVal).toLowerCase() === String(lookupVal).toLowerCase() ||
                                (Number.isFinite(Number(cellVal)) && Number(cellVal) === Number(lookupVal))) {
                                bestRow = r; break;
                            }
                        } else {
                            // Approximate match (sorted ascending) ‚Äî find largest value <= lookupVal
                            const cN = Number(cellVal), lN = Number(lookupVal);
                            if (Number.isFinite(cN) && Number.isFinite(lN) && cN <= lN) bestRow = r;
                            else if (String(cellVal).toLowerCase() === String(lookupVal).toLowerCase()) { bestRow = r; break; }
                        }
                    }
                    if (bestRow === -1) return { value: '#N/A', type: 'string' };
                    const foundVal = getCellRawValue(sheet, bestRow, targetCol);
                    const foundNum = Number(foundVal);
                    return { value: Number.isFinite(foundNum) ? foundNum : foundVal, type: Number.isFinite(foundNum) ? 'number' : 'string' };
                };

                // SUMIF(criteriaRange, criteria, [sumRange])
                formulaFunctions['SUMIF'] = (args, sheet, deps) => {
                    if (args.length < 2) return { value: null, type: 'error', error: 'SUMIF requires 2-3 args' };
                    const critCells = resolveRange(args[0], sheet, deps);
                    const criteriaResolved = resolveArg(args[1], sheet, deps);
                    const criteriaStr = String(criteriaResolved.value);
                    const sumCells = args.length >= 3 ? resolveRange(args[2], sheet, deps) : critCells;
                    let sum = 0;
                    critCells.forEach((cc, i) => {
                        if (evaluateCondition(cc.value, criteriaStr)) {
                            sum += (sumCells[i] ? sumCells[i].numValue : 0);
                        }
                    });
                    return { value: sum, type: 'number' };
                };

                // COUNTIF(range, criteria)
                formulaFunctions['COUNTIF'] = (args, sheet, deps) => {
                    if (args.length < 2) return { value: null, type: 'error', error: 'COUNTIF requires 2 args' };
                    const cells = resolveRange(args[0], sheet, deps);
                    const criteriaResolved = resolveArg(args[1], sheet, deps);
                    const criteriaStr = String(criteriaResolved.value);
                    let cnt = 0;
                    cells.forEach(c => { if (evaluateCondition(c.value, criteriaStr)) cnt++; });
                    return { value: cnt, type: 'number' };
                };

                // INDEX(range, rowNum, [colNum])
                formulaFunctions['INDEX'] = (args, sheet, deps) => {
                    if (args.length < 2) return { value: null, type: 'error', error: 'INDEX requires 2-3 args' };
                    const rng = parseRange(args[0].trim());
                    if (!rng) return { value: null, type: 'error', error: 'INDEX: invalid range' };
                    const rowNum = Number(resolveArg(args[1], sheet, deps).value);
                    const colNum = args.length >= 3 ? Number(resolveArg(args[2], sheet, deps).value) : 1;
                    if (!Number.isFinite(rowNum) || rowNum < 1) return { value: null, type: 'error', error: 'INDEX: invalid row' };
                    if (!Number.isFinite(colNum) || colNum < 1) return { value: null, type: 'error', error: 'INDEX: invalid col' };
                    const targetRow = rng.startRow + (rowNum - 1);
                    const targetCol = rng.startCol + (colNum - 1);
                    if (targetRow > rng.endRow || targetCol > rng.endCol) return { value: '#REF!', type: 'string' };
                    // Add all cells in range as deps
                    for (let r = rng.startRow; r <= rng.endRow; r++)
                        for (let c = rng.startCol; c <= rng.endCol; c++)
                            deps.push(toCellRef(r, c));
                    const val = getCellRawValue(sheet, targetRow, targetCol);
                    const num = Number(val);
                    return { value: Number.isFinite(num) ? num : val, type: Number.isFinite(num) ? 'number' : 'string' };
                };

                // MATCH(lookupValue, lookupRange, [matchType])
                formulaFunctions['MATCH'] = (args, sheet, deps) => {
                    if (args.length < 2) return { value: null, type: 'error', error: 'MATCH requires 2-3 args' };
                    const lookupResolved = resolveArg(args[0], sheet, deps);
                    const lookupVal = lookupResolved.value;
                    const cells = resolveRange(args[1], sheet, deps);
                    const matchType = args.length >= 3 ? Number(resolveArg(args[2], sheet, deps).value) : 1;
                    if (matchType === 0) {
                        // Exact match
                        for (let i = 0; i < cells.length; i++) {
                            if (String(cells[i].value).toLowerCase() === String(lookupVal).toLowerCase() ||
                                (Number.isFinite(cells[i].numValue) && cells[i].numValue === Number(lookupVal))) {
                                return { value: i + 1, type: 'number' };
                            }
                        }
                        return { value: '#N/A', type: 'string' };
                    } else if (matchType === 1) {
                        // Largest value <= lookupVal (assumes ascending sorted)
                        let best = -1;
                        const lN = Number(lookupVal);
                        for (let i = 0; i < cells.length; i++) {
                            if (Number.isFinite(cells[i].numValue) && Number.isFinite(lN) && cells[i].numValue <= lN)
                                best = i;
                        }
                        return best >= 0 ? { value: best + 1, type: 'number' } : { value: '#N/A', type: 'string' };
                    } else {
                        // matchType === -1: Smallest value >= lookupVal (assumes descending sorted)
                        const lN = Number(lookupVal);
                        for (let i = 0; i < cells.length; i++) {
                            if (Number.isFinite(cells[i].numValue) && Number.isFinite(lN) && cells[i].numValue >= lN)
                                return { value: i + 1, type: 'number' };
                        }
                        return { value: '#N/A', type: 'string' };
                    }
                };

                // ‚îÄ‚îÄ‚îÄ D0.5: Date Functions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                formulaFunctions['TODAY'] = (args, sheet, deps) => {
                    const now = new Date();
                    const dateStr = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
                    return { value: dateStr, type: 'string' };
                };

                formulaFunctions['NOW'] = (args, sheet, deps) => {
                    return { value: new Date().toISOString(), type: 'string' };
                };

                formulaFunctions['DATEVALUE'] = (args, sheet, deps) => {
                    if (args.length < 1) return { value: null, type: 'error', error: 'DATEVALUE requires 1 arg' };
                    const resolved = resolveArg(args[0], sheet, deps);
                    const dateStr = String(resolved.value);
                    const d = new Date(dateStr);
                    if (isNaN(d.getTime())) return { value: '#VALUE!', type: 'string' };
                    // Return Excel-style serial number (days since 1900-01-01, with Excel's leap year bug)
                    const epoch = new Date(1899, 11, 30); // Dec 30, 1899 (Excel epoch)
                    const days = Math.floor((d - epoch) / 86400000);
                    return { value: days, type: 'number' };
                };

                formulaFunctions['DATEDIF'] = (args, sheet, deps) => {
                    if (args.length < 3) return { value: null, type: 'error', error: 'DATEDIF requires 3 args (start, end, unit)' };
                    const startResolved = resolveArg(args[0], sheet, deps);
                    const endResolved = resolveArg(args[1], sheet, deps);
                    const unitResolved = resolveArg(args[2], sheet, deps);
                    const startDate = new Date(String(startResolved.value));
                    const endDate = new Date(String(endResolved.value));
                    const unit = String(unitResolved.value).toUpperCase().replace(/"/g, '');
                    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) return { value: '#VALUE!', type: 'string' };
                    if (endDate < startDate) return { value: '#NUM!', type: 'string' };

                    switch (unit) {
                        case 'D': return { value: Math.floor((endDate - startDate) / 86400000), type: 'number' };
                        case 'M': {
                            let months = (endDate.getFullYear() - startDate.getFullYear()) * 12 + (endDate.getMonth() - startDate.getMonth());
                            if (endDate.getDate() < startDate.getDate()) months--;
                            return { value: Math.max(0, months), type: 'number' };
                        }
                        case 'Y': {
                            let years = endDate.getFullYear() - startDate.getFullYear();
                            if (endDate.getMonth() < startDate.getMonth() || (endDate.getMonth() === startDate.getMonth() && endDate.getDate() < startDate.getDate())) years--;
                            return { value: Math.max(0, years), type: 'number' };
                        }
                        default: return { value: '#VALUE!', type: 'string' };
                    }
                };

                formulaFunctions['DAYS'] = (args, sheet, deps) => {
                    if (args.length < 2) return { value: null, type: 'error', error: 'DAYS requires 2 args (end, start)' };
                    const endResolved = resolveArg(args[0], sheet, deps);
                    const startResolved = resolveArg(args[1], sheet, deps);
                    const endDate = new Date(String(endResolved.value));
                    const startDate = new Date(String(startResolved.value));
                    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) return { value: '#VALUE!', type: 'string' };
                    return { value: Math.floor((endDate - startDate) / 86400000), type: 'number' };
                };

                formulaFunctions['YEAR'] = (args, sheet, deps) => {
                    if (args.length < 1) return { value: null, type: 'error', error: 'YEAR requires 1 arg' };
                    const resolved = resolveArg(args[0], sheet, deps);
                    const d = new Date(String(resolved.value));
                    if (isNaN(d.getTime())) return { value: '#VALUE!', type: 'string' };
                    return { value: d.getFullYear(), type: 'number' };
                };

                formulaFunctions['MONTH'] = (args, sheet, deps) => {
                    if (args.length < 1) return { value: null, type: 'error', error: 'MONTH requires 1 arg' };
                    const resolved = resolveArg(args[0], sheet, deps);
                    const d = new Date(String(resolved.value));
                    if (isNaN(d.getTime())) return { value: '#VALUE!', type: 'string' };
                    return { value: d.getMonth() + 1, type: 'number' };
                };

                formulaFunctions['DAY'] = (args, sheet, deps) => {
                    if (args.length < 1) return { value: null, type: 'error', error: 'DAY requires 1 arg' };
                    const resolved = resolveArg(args[0], sheet, deps);
                    const d = new Date(String(resolved.value));
                    if (isNaN(d.getTime())) return { value: '#VALUE!', type: 'string' };
                    return { value: d.getDate(), type: 'number' };
                };

                // ‚îÄ‚îÄ‚îÄ Formula Engine Proof Log ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                RelayLog.info(`[FORMULA-EXT] registry loaded: ${Object.keys(formulaFunctions).join(', ')} (${Object.keys(formulaFunctions).length} functions)`);

                // ‚îÄ‚îÄ‚îÄ Main evaluateFormula ‚Äî function registry dispatcher ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

                const evaluateFormula = (formulaStr, sheet) => {
                    if (!formulaStr || !formulaStr.startsWith('=')) return { value: null, error: 'NOT_FORMULA' };
                    let expr = formulaStr.substring(1).trim();
                    if (!expr) return { value: null, error: 'EMPTY', deps: [] };
                    const deps = [];

                    // Process all registered functions (innermost first) via iterative replacement
                    let safetyCounter = 0;
                    const funcPattern = /\b([A-Z]+)\s*\(([^()]*(?:\([^()]*\))*[^()]*)\)/i;
                    let stringResult = null; // Track if a function returned a string
                    while (funcPattern.test(expr) && safetyCounter++ < 50) {
                        let replaced = false;
                        expr = expr.replace(funcPattern, (fullMatch, funcName, argsStr) => {
                            const handler = formulaFunctions[funcName.toUpperCase()];
                            if (!handler) return fullMatch; // Unknown function ‚Äî leave as-is
                            replaced = true;
                            const argsList = parseFunctionArgs(argsStr);
                            const result = handler(argsList, sheet, deps);
                            if (result.error) { stringResult = '#ERR!'; return '0'; }
                            if (result.type === 'string') {
                                stringResult = result.value;
                                return '0'; // Placeholder for string results in numeric expressions
                            }
                            const val = Number(result.value);
                            return Number.isFinite(val) ? String(val) : '0';
                        });
                        if (!replaced) break; // Unknown function ‚Äî stop to avoid infinite loop
                    }

                    // If a function returned a string (e.g., IF, VLOOKUP), return it directly
                    if (stringResult !== null && !/[+\-*/]/.test(expr.replace(/[\d\s.()]/g, ''))) {
                        return { value: stringResult, display: String(stringResult), deps, error: null };
                    }

                    // Replace cross-sheet single cell references (e.g., P2P.ThreeWayMatch!B2 ‚Üí value)
                    expr = expr.replace(/([A-Za-z0-9_.]+)!([A-Z]+\d+)/gi, (fullMatch, sheetRef, cellStr) => {
                        const xref = resolveSheetRef(fullMatch);
                        if (!xref) return fullMatch;
                        const ref = parseCellRef(xref.ref);
                        if (!ref) return fullMatch;
                        deps.push(`${xref.sheet.id}!${toCellRef(ref.row, ref.col)}`);
                        return String(getCellNumericValue(xref.sheet, ref.row, ref.col));
                    });

                    // Replace remaining individual cell references (A1 ‚Üí value)
                    expr = expr.replace(/\b([A-Z]+)(\d+)\b/gi, (match) => {
                        const ref = parseCellRef(match);
                        if (!ref) return match;
                        deps.push(toCellRef(ref.row, ref.col));
                        return String(getCellNumericValue(sheet, ref.row, ref.col));
                    });

                    // Safe eval: only digits, operators, parens, dots, spaces
                    if (!/^[\d\s+\-*/().]+$/.test(expr)) {
                        // Check if we had a string result that was the entire expression
                        if (stringResult !== null) return { value: stringResult, display: String(stringResult), deps, error: null };
                        return { value: null, error: 'UNSAFE', deps };
                    }
                    try {
                        const result = Function('"use strict"; return (' + expr + ')')();
                        if (!Number.isFinite(result)) return { value: null, error: 'NON_FINITE', deps };
                        // Round to avoid floating point noise
                        const rounded = Math.abs(result) < 1e-10 ? 0 : Math.round(result * 1e10) / 1e10;
                        return { value: rounded, display: String(rounded), deps, error: null };
                    } catch (e) {
                        return { value: null, error: e.message, deps };
                    }
                };

                // Build reverse dependency map: srcRef ‚Üí Set of dependent formula refs
                const buildReverseDeps = (sheet) => {
                    const rev = new Map();
                    if (!sheet._cellIndex) return rev;
                    for (const [, ci] of sheet._cellIndex) {
                        if (!ci.hasFormula || !ci.formula) continue;
                        const depRef = ci.a1 || toCellRef(ci.row, ci.col);
                        const result = evaluateFormula(ci.formula, sheet);
                        if (result.deps) {
                            for (const srcRef of result.deps) {
                                if (!rev.has(srcRef)) rev.set(srcRef, new Set());
                                rev.get(srcRef).add(depRef);
                            }
                        }
                    }
                    return rev;
                };

                // Recalculate all cells that depend on changedRef (cascading)
                const recalcDependents = (sheet, changedRef) => {
                    const rev = buildReverseDeps(sheet);
                    const visited = new Set();
                    const queue = [changedRef];
                    const updated = [];
                    while (queue.length > 0) {
                        const ref = queue.shift();
                        const dependents = rev.get(ref);
                        if (!dependents) continue;
                        for (const depRef of dependents) {
                            if (visited.has(depRef)) continue;
                            visited.add(depRef);
                            const parsed = parseCellRef(depRef);
                            if (!parsed) continue;
                            const ci = sheet._cellIndex?.get(`${parsed.row},${parsed.col}`);
                            if (!ci || !ci.hasFormula) continue;
                            const oldDisplay = ci.display;
                            const result = evaluateFormula(ci.formula, sheet);
                            if (result.error) {
                                RelayLog.info(`[FORMULA] recompute ${depRef} ERROR=${result.error}`);
                                continue;
                            }
                            ci.value = result.value;
                            ci.display = result.display;
                            ci.timeboxCount = (ci.timeboxCount || 0) + 1;
                            RelayLog.info(`[FORMULA] recompute ${depRef}=${result.display} (deps:[${result.deps.join(',')}]) old=${oldDisplay} timeboxCount=${ci.timeboxCount}`);
                            // Update 3D label
                            const cid = ci.id || `${sheet.id}.cell.${parsed.row}.${parsed.col}`;
                            const ent = getCellEntity(sheet.id, cid);
                            if (ent?.label) ent.label.text = `${depRef}=${result.display}`;
                            // Update 2D cell if visible
                            const gridCell = sheetGridTable?.querySelector(`.grid-data[data-row="${parsed.row}"][data-col="${parsed.col}"]`);
                            if (gridCell) gridCell.textContent = result.display;
                            updated.push({ ref: depRef, value: result.display, timeboxCount: ci.timeboxCount });
                            queue.push(depRef);  // cascade
                        }
                    }
                    if (updated.length > 0) {
                        RelayLog.info(`[FORMULA] propagation: ${updated.length} cells updated from ${changedRef}`);
                    }
                    return updated;
                };

                // Evaluate ALL formulas in a sheet (topological order for correct dependency resolution)
                const evaluateAllFormulas = (sheet) => {
                    if (!sheet?.cellData || !sheet._cellIndex) return 0;
                    // Build dependency graph for topological sort
                    const formulaCells = [];
                    const depMap = new Map(); // cellRef ‚Üí Set of refs it depends on
                    for (const ci of sheet.cellData) {
                        if (!ci.hasFormula || !ci.formula) continue;
                        const ref = ci.a1 || toCellRef(ci.row, ci.col);
                        formulaCells.push({ ref, ci });
                        const result = evaluateFormula(ci.formula, sheet);
                        depMap.set(ref, new Set(result.deps || []));
                    }
                    // Simple topological sort: evaluate cells whose deps are all resolved first
                    const evaluated = new Set();
                    const order = [];
                    let changed = true;
                    while (changed) {
                        changed = false;
                        for (const { ref, ci } of formulaCells) {
                            if (evaluated.has(ref)) continue;
                            const deps = depMap.get(ref) || new Set();
                            // Check if all formula deps are either evaluated or non-formula (plain values)
                            let allReady = true;
                            for (const d of deps) {
                                if (depMap.has(d) && !evaluated.has(d)) { allReady = false; break; }
                            }
                            if (allReady) {
                                const result = evaluateFormula(ci.formula, sheet);
                                if (!result.error) {
                                    ci.value = result.value;
                                    ci.display = result.display;
                                }
                                evaluated.add(ref);
                                order.push(ref);
                                changed = true;
                            }
                        }
                    }
                    // Evaluate any remaining (circular or unresolved) formulas
                    for (const { ref, ci } of formulaCells) {
                        if (evaluated.has(ref)) continue;
                        const result = evaluateFormula(ci.formula, sheet);
                        if (!result.error) {
                            ci.value = result.value;
                            ci.display = result.display;
                        }
                        order.push(ref);
                    }
                    if (order.length > 0) {
                        RelayLog.info(`[FORMULA] evaluateAll: ${order.length} formulas computed in topo order`);
                        // Proof log for extended formula functions (B1)
                        const extFuncs = ['IF', 'VLOOKUP', 'SUMIF', 'COUNTIF', 'INDEX', 'MATCH'];
                        const extUsed = [];
                        for (const ci of sheet.cellData) {
                            if (!ci.hasFormula || !ci.formula) continue;
                            const fn = ci.formula.substring(1).trim().match(/^([A-Z]+)\s*\(/i);
                            if (fn && extFuncs.includes(fn[1].toUpperCase())) {
                                const ref = ci.a1 || toCellRef(ci.row, ci.col);
                                extUsed.push(`${ref}=${ci.display}(${fn[1].toUpperCase()})`);
                            }
                        }
                        if (extUsed.length > 0) {
                            RelayLog.info(`[FORMULA-EXT] extended formulas evaluated: ${extUsed.join(', ')}`);
                        }
                        // B3: Proof log for summary sheets with cross-sheet formulas
                        if (sheet.metadata?.isSummarySheet) {
                            const crossSheetFormulas = [];
                            for (const ci of sheet.cellData) {
                                if (!ci.hasFormula || !ci.formula) continue;
                                if (ci.formula.includes('!')) {
                                    const ref = ci.a1 || toCellRef(ci.row, ci.col);
                                    crossSheetFormulas.push(`${ref}=${ci.display}`);
                                }
                            }
                            if (crossSheetFormulas.length > 0) {
                                RelayLog.info(`[B3-PROOF] summary ${sheet.id} cross-sheet formulas: ${crossSheetFormulas.join(', ')}`);
                            }
                        }
                    }
                    return order.length;
                };

                const computeCellUpdate = (normalized) => {
                    const trimmed = typeof normalized === 'string' ? normalized.trim() : '';
                    if (!trimmed) {
                        return {
                            type: 'CELL_CLEAR',
                            value: '',
                            formula: null,
                            hasFormula: false,
                            display: ''
                        };
                    }
                    if (trimmed.startsWith('=')) {
                        return {
                            type: 'CELL_FORMULA_SET',
                            value: null,
                            formula: trimmed,
                            hasFormula: true,
                            display: trimmed
                        };
                    }
                    return {
                        type: 'CELL_SET',
                        value: normalized,
                        formula: null,
                        hasFormula: false,
                        display: normalized
                    };
                };

                const isSameCellState = (cellInfo, update) => {
                    const prevValue = cellInfo?.value ?? '';
                    const prevFormula = cellInfo?.formula ?? null;
                    const prevDisplay = cellInfo?.display ?? '';
                    const prevHasFormula = !!cellInfo?.hasFormula;
                    const nextValue = update.value ?? '';
                    const nextFormula = update.formula ?? null;
                    const nextDisplay = update.display ?? '';
                    return prevValue === nextValue
                        && prevFormula === nextFormula
                        && prevDisplay === nextDisplay
                        && prevHasFormula === update.hasFormula;
                };

                const applyCellValue = (cellInfo, normalized) => {
                    const update = computeCellUpdate(normalized);
                    const changed = !isSameCellState(cellInfo, update);
                    if (changed) {
                        cellInfo.value = update.value;
                        cellInfo.display = update.display;
                        cellInfo.formula = update.formula;
                        cellInfo.hasFormula = update.hasFormula;
                    }
                    return { ...update, changed };
                };

                // ‚îÄ‚îÄ‚îÄ B3: Module recomputation chain ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // When a fact sheet cell is edited, re-run matches + re-evaluate summaries.
                // Match sheets are regenerated by buildMatches (deterministic).
                // Summary sheets are recalculated through cross-sheet formulas (no JS aggregation).
                const getModuleDefForSheet = (sheetId) => {
                    const moduleId = sheetToModuleId.get(String(sheetId || ''));
                    if (!moduleId) return null;
                    return loadedModuleDefs.get(moduleId) || null;
                };
                const recomputeModuleChain = (editedSheetId) => {
                    const moduleDef = getModuleDefForSheet(editedSheetId);
                    if (!moduleDef) return;
                    // Check if the edited sheet belongs to this module
                    const isFactSheet = (moduleDef.factSheets || []).some(f => f.sheetId === editedSheetId);
                    const isMatchSheet = (moduleDef.matchSheets || []).some(m => m.sheetId === editedSheetId);
                    if (!isFactSheet && !isMatchSheet) return;

                    const chainT0 = performance.now();
                    let tExtractMs = 0;
                    let tMatchesMs = 0;
                    let tSummaryBuildMs = 0;
                    let tKpiMs = 0;
                    RelayLog.info(`[B3-PROOF] recomputeModuleChain triggered by edit to ${editedSheetId}`);

                    // 1. Extract current fact sheet data from tree nodes
                    const extractT0 = performance.now();
                    const currentData = {};
                    for (const factDef of moduleDef.factSheets) {
                        const sheetNode = relayState.tree.nodes.find(n => n.id === factDef.sheetId);
                        if (!sheetNode) continue;
                        ensureCellIndex(sheetNode);
                        const rows = [];
                        for (let r = 1; r < sheetNode.rows; r++) {
                            const row = [];
                            for (let c = 0; c < sheetNode.cols; c++) {
                                const ci = sheetNode._cellIndex.get(`${r},${c}`);
                                row.push(ci ? (ci.value ?? ci.display ?? '') : '');
                            }
                            rows.push(row);
                        }
                        currentData[factDef.sheetId] = rows;
                    }
                    tExtractMs = performance.now() - extractT0;

                    // 2. Re-run match builder with current data
                    let rebuiltMatchSheetIds = [];
                    if (isFactSheet) {
                        const allMatchDefs = moduleDef.matchSheets || [];
                        const forcedSkipByEditedSheet = {};
                        const forcedSkips = forcedSkipByEditedSheet[editedSheetId] || new Set();
                        const dependencyMatchDefs = allMatchDefs.filter(matchDef => {
                            if (forcedSkips.has(matchDef.sheetId)) return false;
                            if (!Array.isArray(matchDef.sourceSheets) || matchDef.sourceSheets.length === 0) return true;
                            return matchDef.sourceSheets.includes(editedSheetId);
                        });
                        const targetMatchDefs = dependencyMatchDefs.length > 0 ? dependencyMatchDefs : allMatchDefs;
                        const targetMatchSheetIds = targetMatchDefs.map(def => def.sheetId);
                        const skippedMatchSheetIds = allMatchDefs
                            .map(def => def.sheetId)
                            .filter(sheetId => !targetMatchSheetIds.includes(sheetId));

                        RelayLog.info(`[D0.2-GATE] edited=${editedSheetId} rebuildMatches=${targetMatchSheetIds.join(',') || 'none'} skippedMatches=${skippedMatchSheetIds.join(',') || 'none'}`);

                        const matchesT0 = performance.now();
                        const matchResults = buildMatches(currentData, moduleDef, {
                            dirtySourceSheets: new Set([editedSheetId]),
                            matchSheetIds: targetMatchSheetIds
                        });
                        tMatchesMs = performance.now() - matchesT0;
                        rebuiltMatchSheetIds = targetMatchSheetIds;

                        // Update match sheet nodes with new data
                        for (const matchDef of targetMatchDefs) {
                            const matchNode = relayState.tree.nodes.find(n => n.id === matchDef.sheetId);
                            if (!matchNode) continue;
                            const matchRows = matchResults[matchDef.sheetId] || [];
                            // Rebuild cellData
                            matchNode.cellData = [];
                            matchDef.columns.forEach((col, colIdx) => {
                                matchNode.cellData.push({ row: 0, col: colIdx, timeboxCount: 1, hasFormula: false, value: col.label, display: col.label });
                            });
                            matchRows.forEach((rowData, rowIdx) => {
                                matchDef.columns.forEach((col, colIdx) => {
                                    const rawValue = rowData[colIdx] !== undefined ? rowData[colIdx] : '';
                                    matchNode.cellData.push({ row: rowIdx + 1, col: colIdx, timeboxCount: 1, hasFormula: false, value: rawValue, display: String(rawValue) });
                                });
                            });
                            matchNode.rows = 1 + matchRows.length;
                            matchNode._cellIndex = null;
                            ensureCellIndex(matchNode);
                            RelayLog.info(`[B3-PROOF] match sheet ${matchDef.sheetId} recomputed: ${matchRows.length} rows`);
                        }
                    }

                    // 3. D0: Rebuild summary formulas with current row counts (ranges must expand after ingestion)
                    //    Then re-evaluate all summary sheet formulas
                    const summaryT0 = performance.now();
                    const matchResultsForSummary = {};
                    for (const matchDef of (moduleDef.matchSheets || [])) {
                        const mn = relayState.tree.nodes.find(n => n.id === matchDef.sheetId);
                        if (mn) matchResultsForSummary[matchDef.sheetId] = Array(Math.max(0, (mn.rows || 1) - 1)).fill(null);
                    }
                    const allSummaryDefs = moduleDef.summarySheets || [];
                    const dirtySummarySources = new Set([editedSheetId, ...rebuiltMatchSheetIds]);
                    const targetSummaryDefs = allSummaryDefs.filter(sumDef => {
                        if (!Array.isArray(sumDef.sourceSheets) || sumDef.sourceSheets.length === 0) return true;
                        return sumDef.sourceSheets.some(src => dirtySummarySources.has(src));
                    });
                    const skippedSummarySheetIds = allSummaryDefs
                        .map(def => def.sheetId)
                        .filter(sheetId => !targetSummaryDefs.some(def => def.sheetId === sheetId));
                    RelayLog.info(`[D0.2-GATE] edited=${editedSheetId} rebuildSummaries=${targetSummaryDefs.map(def => def.sheetId).join(',') || 'none'} skippedSummaries=${skippedSummarySheetIds.join(',') || 'none'}`);

                    try {
                        const newSummaryData = buildSummaryData(moduleDef, currentData, matchResultsForSummary);
                        for (const sumDef of targetSummaryDefs) {
                            const sumNode = relayState.tree.nodes.find(n => n.id === sumDef.sheetId);
                            if (!sumNode) continue;
                            const sumRows = newSummaryData[sumDef.sheetId];
                            if (!sumRows) continue;
                            // Rebuild formula cells with updated range refs (keep headers)
                            const schema = sumDef.columns || [];
                            // Preserve header row (row 0), rebuild data rows with new formulas
                            const headerCells = sumNode.cellData.filter(c => c.row === 0);
                            sumNode.cellData = [...headerCells];
                            sumRows.forEach((rowData, rowIdx) => {
                                const dataRow = Array.isArray(rowData) ? rowData : [rowData];
                                dataRow.forEach((cellVal, colIdx) => {
                                    const isFormula = typeof cellVal === 'string' && cellVal.startsWith('=');
                                    sumNode.cellData.push({
                                        row: rowIdx + 1, col: colIdx,
                                        timeboxCount: 1,
                                        hasFormula: isFormula,
                                        formula: isFormula ? cellVal : null,
                                        value: isFormula ? null : cellVal,
                                        display: String(cellVal)
                                    });
                                });
                            });
                            sumNode.rows = 1 + sumRows.length;
                            sumNode._cellIndex = null;
                            ensureCellIndex(sumNode);
                            sumNode._formulasEvaluated = false;
                            const count = evaluateAllFormulas(sumNode);
                            // Log changed summary cells (throttle at scale)
                            let logCount = 0;
                            for (const ci of sumNode.cellData) {
                                if (ci.hasFormula && ci.display !== undefined && logCount < 20) {
                                    const ref = ci.a1 || toCellRef(ci.row, ci.col);
                                    RelayLog.info(`[B3-PROOF] summaryCell changed sheet=${sumDef.sheetId} cell=${ref} display="${ci.display}"`);
                                    logCount++;
                                }
                            }
                            RelayLog.info(`[B3-PROOF] summary ${sumDef.sheetId} re-evaluated: ${count} formulas (ranges updated for ${sumNode.rows - 1} data rows)`);
                        }
                    } catch (e) {
                        RelayLog.error(`[D0] summary rebuild failed: ${e.message}`);
                        // Fall back to simple re-evaluation without range update
                        for (const sumDef of targetSummaryDefs) {
                            const sumNode = relayState.tree.nodes.find(n => n.id === sumDef.sheetId);
                            if (!sumNode) continue;
                            sumNode._cellIndex = null;
                            ensureCellIndex(sumNode);
                            sumNode._formulasEvaluated = false;
                            evaluateAllFormulas(sumNode);
                        }
                    }
                    tSummaryBuildMs = performance.now() - summaryT0;

                    // 4. B4: Update KPI branch metrics from bound summary cells
                    const kpiT0 = performance.now();
                    const kpiBindings = moduleDef.kpiBindings || [];
                    if (kpiBindings.length > 0) {
                        const branchNode = relayState.tree.nodes.find(n => n.id === moduleDef.branchId);
                        if (branchNode) {
                            const metricRecord = {
                                timestamp: Date.now(),
                                timeboxId: `${moduleDef.moduleId}-T${(branchNode.metadata.kpiMetrics?.length || 0) + 1}`,
                                triggeredBy: editedSheetId,
                                metrics: {}
                            };
                            for (const binding of kpiBindings) {
                                // Resolve the source cell value
                                const xref = resolveSheetRef(binding.sourceCell);
                                let rawValue = null;
                                if (xref) {
                                    const parsed = parseCellRef(xref.ref);
                                    if (parsed) {
                                        const ci = xref.sheet._cellIndex?.get(`${parsed.row},${parsed.col}`);
                                        rawValue = ci ? (ci.value ?? ci.display ?? null) : null;
                                    }
                                }
                                let value = Number(rawValue);
                                if (!Number.isFinite(value)) value = 0;
                                // Apply transform
                                if (binding.transform?.type === 'clamp') {
                                    value = Math.max(binding.transform.min ?? -Infinity, Math.min(binding.transform.max ?? Infinity, value));
                                }
                                metricRecord.metrics[binding.metricId] = {
                                    value,
                                    unit: binding.unit || '',
                                    sourceCell: binding.sourceCell,
                                    label: binding.label
                                };
                                RelayLog.info(`[B4-PROOF] KPI metric ${binding.metricId}=${value.toFixed(2)}${binding.unit || ''} from ${binding.sourceCell}`);
                            }

                            // Append to metrics history (append-only)
                            if (!branchNode.metadata.kpiMetrics) branchNode.metadata.kpiMetrics = [];
                            branchNode.metadata.kpiMetrics.push(metricRecord);

                            // Update branch commit/timebox with latest metrics
                            const latestCommit = branchNode.commits?.[0];
                            if (latestCommit) {
                                latestCommit.commitCount = (latestCommit.commitCount || 0) + 1;
                                // Compute ERI from matchRate (higher match rate = healthier)
                                const matchRate = metricRecord.metrics.matchRate?.value ?? 0;
                                latestCommit.eriAvg = Math.round(matchRate);
                                // Track exceptions as open drifts
                                const outstanding = metricRecord.metrics.outstanding?.value ?? 0;
                                latestCommit.openDrifts = outstanding > 0 ? 1 : 0;
                            }

                            // Update branch ERI for visual rendering
                            branchNode.eri = metricRecord.metrics.matchRate?.value ?? branchNode.eri;

                            // Build timebox label with metric values
                            const metricsLabel = kpiBindings.map(kb => {
                                const m = metricRecord.metrics[kb.metricId];
                                return m ? `${kb.metricId}=${m.value.toFixed(1)}${m.unit}` : '';
                            }).filter(Boolean).join(' | ');
                            branchNode.metadata.kpiLabel = metricsLabel;

                            RelayLog.info(`[B4-PROOF] branch ${moduleDef.branchId} updated: metrics=${JSON.stringify(metricRecord.metrics)} eri=${branchNode.eri?.toFixed(1)} history=${branchNode.metadata.kpiMetrics.length}`);
                            const timeboxLine = `[FLOW] timeboxUpdate branch=${moduleDef.branchId} timeboxId=${metricRecord.timeboxId} result=PASS`;
                            const treeMotionLine = '[FLOW] treeMotion=PASS nodesAffected=1';
                            RelayLog.info(timeboxLine);
                            RelayLog.info(treeMotionLine);
                            console.log(timeboxLine);
                            console.log(treeMotionLine);
                            branchNode._flowPulseUntil = Date.now() + 3000;
                        }
                    }
                    computeTrunkAggregation();
                    tKpiMs = performance.now() - kpiT0;

                    // D0.2 fix: Split timing ‚Äî data recompute ends here
                    const totalElapsedMs = performance.now() - chainT0;
                    RelayLog.info(`[D0.2-BREAKDOWN] extract=${tExtractMs.toFixed(1)}ms matches=${tMatchesMs.toFixed(1)}ms summaries=${tSummaryBuildMs.toFixed(1)}ms kpis=${tKpiMs.toFixed(1)}ms total=${totalElapsedMs.toFixed(1)}ms`);
                    const dataElapsed = totalElapsedMs.toFixed(1);

                    // Re-render tree to update 3D visuals (deferred + coalesced, not counted in data recompute)
                    if (filamentRenderer) {
                        try {
                            scheduleDeferredTreeRender('recomputeModuleChain');
                        } catch (e) {
                            window.__relayDeferredRenderPending = false;
                            window.__relayDeferredRenderScheduled = false;
                            /* silent */
                        }
                    }

                    const totalElapsed = (performance.now() - chainT0).toFixed(1);
                    RelayLog.info(`[D0.2] recomputeDataMs=${dataElapsed} renderMs=deferred totalMs=${totalElapsed}`);
                };

                // ‚îÄ‚îÄ‚îÄ C0: Route Engine ‚Äî global ingest functions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // These are defined after recomputeModuleChain + ensureCellIndex
                // INVARIANT: Routes ONLY append rows. No mutation. No deletion.
                // After append, recomputeModuleChain handles: match ‚Üí summary ‚Üí KPI ‚Üí tree.

                window.relayIngestRoute = (routeId, record) => {
                    const route = getRoute(routeId);
                    const targetSheetId = route?.targetSheet || null;
                    const preSnap = targetSheetId ? captureSheetStableSnapshot(targetSheetId) : null;
                    const result = ingestRecord(routeId, record, relayState, ensureCellIndex);
                    if (result?.success && result.sheetId) {
                        RelayLog.info(`[C0-PROOF] ingestRoute: route=${routeId} ‚Üí ${result.sheetId} row=${result.rowIndex} provenance=${result.provenance?.sourceSystem}/${result.provenance?.sourceId}`);
                        const moduleId = sheetToModuleId.get(String(result.sheetId));
                        const moduleDef = moduleId ? loadedModuleDefs.get(moduleId) : null;
                        const matchSheet = moduleDef?.matchSheets?.[0]?.sheetId || '';
                        const summary = moduleDef?.summarySheets?.[0]?.sheetId || '';
                        const kpi = moduleDef?.branchId || '';
                        const dataPathLine = `[FLOW] dataPath route=${routeId} factSheet=${result.sheetId} matchSheet=${matchSheet} summary=${summary} kpi=${kpi}`;
                        RelayLog.info(dataPathLine);
                        console.log(dataPathLine);
                        recomputeModuleChain(result.sheetId);
                        const postSnap = captureSheetStableSnapshot(result.sheetId);
                        const deltaSummary = summarizeRouteDelta(routeId, preSnap, postSnap);
                        maybeAutoHoldFromDelta(deltaSummary);
                    } else {
                        RelayLog.warn(`[ROUTE] ingestRoute failed: route=${routeId}`);
                    }
                    return result;
                };

                window.relayIngestBatch = (routeId, records) => {
                    const route = getRoute(routeId);
                    const targetSheetId = route?.targetSheet || null;
                    const preSnap = targetSheetId ? captureSheetStableSnapshot(targetSheetId) : null;
                    const result = ingestBatch(routeId, records, relayState, ensureCellIndex);
                    if (result.ingested > 0 && result.sheetId) {
                        RelayLog.info(`[C0-PROOF] ingestBatch: route=${routeId} ‚Üí ${result.sheetId} ingested=${result.ingested} failed=${result.failed}`);
                        recomputeModuleChain(result.sheetId);
                        const postSnap = captureSheetStableSnapshot(result.sheetId);
                        const deltaSummary = summarizeRouteDelta(routeId, preSnap, postSnap);
                        maybeAutoHoldFromDelta(deltaSummary);
                    }
                    return result;
                };
                window.relayGetLastDeltaSummary = () => window.__relayLastDeltaSummary || null;

                window.relayRoutes = { getRoute, getRouteIds, getSheetForFactClass };
                // COMPANY-TEMPLATE-FLOW-1: deterministic demo event (one invoice through canonical path)
                const FLOW_DEMO_INVOICE_RECORD = {
                    sourceSystem: 'FLOW-DEMO',
                    documentId: 'FLOW-001',
                    eventTimestamp: '2026-02-14T12:00:00.000Z',
                    invoiceNumber: 'INV-FLOW-001',
                    lineId: 'IL-FLOW-001',
                    vendorCode: 'V-200',
                    poLineReference: 'POL-001',
                    materialNumber: 'ITM-100',
                    quantity: 500,
                    unitPrice: 0.42,
                    lineAmount: 210,
                    taxAmount: 10.5,
                    currencyCode: 'USD',
                    invoiceDate: '2026-02-14',
                    paymentDueDate: '2026-03-14',
                    status: 'POSTED'
                };
                window.relaySimulateFlowEvent = () => {
                    if (typeof window.relayIngestRoute !== 'function') return null;
                    return window.relayIngestRoute('p2p.invoice', FLOW_DEMO_INVOICE_RECORD);
                };
                window.__relayP2PCoreState = window.__relayP2PCoreState || {
                    lastPR: null,
                    lastPO: null,
                    lastGR: null,
                    lastINV: null,
                    lastPAY: null,
                    lastMatchId: null,
                    lastMatchStatus: null,
                    lastPayReconciliation: null,
                    lastTaxValidation: null,
                    lastProposalId: null,
                    lastCommitId: null,
                    lastTransferPacketIds: [],
                    lastResponsibilityPacketIds: [],
                    lastLedgerHashes: null
                };
                window.RELAY_PAY_RECON_ENFORCE = (typeof window.RELAY_PAY_RECON_ENFORCE === 'boolean')
                    ? window.RELAY_PAY_RECON_ENFORCE
                    : false;
                const computeRuntimeLedgerHashes = () => {
                    try {
                        const packets = window.relayGetTransferPackets();
                        const mappingPolicy = {
                            resolveAccount(containerRef) {
                                const key = String((typeof containerRef === 'string') ? containerRef : (containerRef?.id || ''));
                                return LEDGER_MAPPING_POLICY_V0.resolveAccount(key);
                            }
                        };
                        const journalEntries = projectJournalFromTransferPackets(packets, mappingPolicy);
                        const trialBalance = computeTrialBalance(journalEntries);
                        return {
                            projectionHash: hashProjection(journalEntries),
                            tbHash: hashProjection(trialBalance)
                        };
                    } catch (err) {
                        return null;
                    }
                };
                const updateP2PCommitPointers = (commitId, proposalId) => {
                    const transferPackets = window.relayGetTransferPackets()
                        .filter(tp => String(tp.commitId || '') === String(commitId || ''));
                    const responsibilityPackets = window.relayGetResponsibilityPackets()
                        .filter(rp => String(rp.commitId || '') === String(commitId || ''));
                    window.__relayP2PCoreState.lastProposalId = proposalId || null;
                    window.__relayP2PCoreState.lastCommitId = commitId || null;
                    window.__relayP2PCoreState.lastTransferPacketIds = transferPackets.map(tp => String(tp.transferPacketId || '')).filter(Boolean);
                    window.__relayP2PCoreState.lastResponsibilityPacketIds = responsibilityPackets.map(rp => String(rp.responsibilityPacketId || '')).filter(Boolean);
                    window.__relayP2PCoreState.lastLedgerHashes = computeRuntimeLedgerHashes();
                };
                const compactP2PRecord = (record) => {
                    if (!record || typeof record !== 'object') return null;
                    return {
                        id: record.id || null,
                        lineId: record.lineId || null,
                        sheetId: record.sheetId || null,
                        rowIndex: Number.isFinite(record.rowIndex) ? record.rowIndex : null
                    };
                };
                window.relayGetP2PCoreState = () => ({
                    lastPR: compactP2PRecord(window.__relayP2PCoreState.lastPR),
                    lastPO: compactP2PRecord(window.__relayP2PCoreState.lastPO),
                    lastGR: compactP2PRecord(window.__relayP2PCoreState.lastGR),
                    lastINV: compactP2PRecord(window.__relayP2PCoreState.lastINV),
                    lastPAY: compactP2PRecord(window.__relayP2PCoreState.lastPAY),
                    lastMatchId: window.__relayP2PCoreState.lastMatchId || null,
                    lastMatchStatus: window.__relayP2PCoreState.lastMatchStatus || null,
                    lastPayReconciliation: window.__relayP2PCoreState.lastPayReconciliation
                        ? { ...window.__relayP2PCoreState.lastPayReconciliation }
                        : null,
                    lastTaxValidation: window.__relayP2PCoreState.lastTaxValidation
                        ? { ...window.__relayP2PCoreState.lastTaxValidation }
                        : null,
                    lastProposalId: window.__relayP2PCoreState.lastProposalId || null,
                    lastCommitId: window.__relayP2PCoreState.lastCommitId || null,
                    lastTransferPacketIds: [...(window.__relayP2PCoreState.lastTransferPacketIds || [])],
                    lastResponsibilityPacketIds: [...(window.__relayP2PCoreState.lastResponsibilityPacketIds || [])],
                    lastLedgerHashes: window.__relayP2PCoreState.lastLedgerHashes
                        ? { ...window.__relayP2PCoreState.lastLedgerHashes }
                        : null
                });
                window.relayResetP2PCoreState = () => {
                    window.__relayP2PCoreState.lastPR = null;
                    window.__relayP2PCoreState.lastPO = null;
                    window.__relayP2PCoreState.lastGR = null;
                    window.__relayP2PCoreState.lastINV = null;
                    window.__relayP2PCoreState.lastPAY = null;
                    window.__relayP2PCoreState.lastMatchId = null;
                    window.__relayP2PCoreState.lastMatchStatus = null;
                    window.__relayP2PCoreState.lastPayReconciliation = null;
                    window.__relayP2PCoreState.lastTaxValidation = null;
                    window.__relayP2PCoreState.lastProposalId = null;
                    window.__relayP2PCoreState.lastCommitId = null;
                    window.__relayP2PCoreState.lastTransferPacketIds = [];
                    window.__relayP2PCoreState.lastResponsibilityPacketIds = [];
                    window.__relayP2PCoreState.lastLedgerHashes = null;
                    return { ok: true };
                };
                const sheetRowsAsObjects = (sheetId) => {
                    const sheet = relayState?.tree?.nodes?.find(n => n.type === 'sheet' && n.id === sheetId);
                    if (!sheet) return [];
                    const schema = sheet.metadata?.schema || [];
                    const rows = new Map();
                    for (const cell of (sheet.cellData || [])) {
                        if (!rows.has(cell.row)) rows.set(cell.row, {});
                        const rowObj = rows.get(cell.row);
                        const colDef = schema[cell.col];
                        const colId = colDef?.id || colDef?.name || `col${cell.col}`;
                        rowObj[colId] = (cell.value ?? cell.display ?? null);
                    }
                    return [...rows.entries()]
                        .filter(([r]) => Number(r) > 0)
                        .map(([rowIndex, values]) => ({ rowIndex: Number(rowIndex), values }));
                };
                const findSheetRow = (sheetId, fieldId, fieldValue) => {
                    const rows = sheetRowsAsObjects(sheetId);
                    const fv = String(fieldValue ?? '');
                    return rows.find(r => String(r.values?.[fieldId] ?? '') === fv) || null;
                };
                const readTaxRowsFromSheets = (periodId = 'PERIOD-UNKNOWN') => {
                    const invoices = sheetRowsAsObjects('P2P.InvoiceLines').map(r => ({
                        objectType: 'INV',
                        objectId: String(r.values?.invId || ''),
                        invoiceId: String(r.values?.invId || ''),
                        companyId: 'company',
                        periodId,
                        jurisdiction: String(r.values?.jurisdiction || 'UNKNOWN'),
                        taxTreatment: String(r.values?.taxTreatment || 'STANDARD'),
                        taxRate: Number(r.values?.taxRate || 0),
                        taxAmount: Number(r.values?.taxAmount || 0)
                    })).filter(r => r.objectId);
                    const payments = sheetRowsAsObjects('P2P.PaymentLines').map(r => ({
                        objectType: 'PAY',
                        objectId: String(r.values?.paymentId || ''),
                        paymentId: String(r.values?.paymentId || ''),
                        companyId: 'company',
                        periodId,
                        jurisdiction: String(r.values?.jurisdiction || 'UNKNOWN'),
                        taxTreatment: String(r.values?.taxTreatment || 'STANDARD'),
                        taxRate: Number(r.values?.taxRate || 0),
                        taxAmount: Number(r.values?.taxAmount || 0)
                    })).filter(r => r.objectId);
                    return [...invoices, ...payments];
                };
                const computePaymentReconciliation = (meta = {}) => {
                    const paymentId = String(meta.paymentId || meta.payId || meta.id || '');
                    const payments = sheetRowsAsObjects('P2P.PaymentLines').map(r => ({
                        paymentId: String(r.values?.paymentId || ''),
                        amount: Number(r.values?.amount || 0)
                    })).filter(p => p.paymentId);
                    const bankLines = sheetRowsAsObjects('P2P.BankStatementLines').map(r => ({
                        bankLineId: String(r.values?.bankLineId || ''),
                        paymentId: String(r.values?.paymentId || ''),
                        amount: Number(r.values?.amount || 0)
                    })).filter(b => b.bankLineId);
                    const scopedPayments = paymentId ? payments.filter(p => p.paymentId === paymentId) : payments;
                    const scopedBankLines = paymentId ? bankLines.filter(b => b.paymentId === paymentId) : bankLines;
                    const matches = matchBankStatementLines(scopedPayments, scopedBankLines);
                    const total = matches.length;
                    const matched = matches.filter(m => String(m.status || '') === 'MATCHED').length;
                    const amountMismatch = matches.filter(m => String(m.status || '') === 'AMOUNT_MISMATCH').length;
                    const unmatched = matches.filter(m => String(m.status || '') === 'UNMATCHED').length;
                    const status = total === 0
                        ? 'NO_BANK_LINES'
                        : (matched === total ? 'MATCHED' : (amountMismatch > 0 ? 'AMOUNT_MISMATCH' : 'UNMATCHED'));
                    return { paymentId: paymentId || null, status, total, matched, amountMismatch, unmatched, matches };
                };
                window.relayCreatePaymentBatch = (meta = {}) => {
                    const payments = sheetRowsAsObjects('P2P.PaymentLines')
                        .map(r => ({
                            paymentId: String(r.values?.paymentId || ''),
                            amount: Number(r.values?.amount || 0),
                            itemId: String(r.values?.itemId || '')
                        }))
                        .filter(p => p.paymentId);
                    const paymentIds = Array.isArray(meta.paymentIds) && meta.paymentIds.length > 0
                        ? meta.paymentIds
                        : payments.map(p => p.paymentId);
                    return createPaymentBatch({ ...meta, paymentIds });
                };
                window.relayExecutePaymentBatch = (batchOrMeta = {}) => {
                    const batch = batchOrMeta?.batchId ? batchOrMeta : window.relayCreatePaymentBatch(batchOrMeta);
                    const payments = sheetRowsAsObjects('P2P.PaymentLines').map(r => ({
                        paymentId: String(r.values?.paymentId || ''),
                        amount: Number(r.values?.amount || 0),
                        itemId: String(r.values?.itemId || '')
                    })).filter(p => p.paymentId);
                    const execution = executePaymentBatch(batch, payments);
                    return {
                        ok: true,
                        batchId: execution.batch.batchId,
                        executedCount: execution.executedCount,
                        transferPackets: execution.transferPackets
                    };
                };
                window.relayMatchPaymentsToBankStatements = (meta = {}) => {
                    const payments = sheetRowsAsObjects('P2P.PaymentLines').map(r => ({
                        paymentId: String(r.values?.paymentId || ''),
                        amount: Number(r.values?.amount || 0)
                    })).filter(p => p.paymentId);
                    const bankLines = sheetRowsAsObjects('P2P.BankStatementLines').map(r => ({
                        bankLineId: String(r.values?.bankLineId || ''),
                        paymentId: String(r.values?.paymentId || ''),
                        amount: Number(r.values?.amount || 0)
                    })).filter(b => b.bankLineId);
                    const matches = matchBankStatementLines(payments, bankLines);
                    return { ok: true, mode: String(meta.mode || 'deterministic'), matches };
                };
                window.relayGetPaymentReconciliation = (meta = {}) => {
                    const result = computePaymentReconciliation(meta);
                    window.__relayP2PCoreState.lastPayReconciliation = {
                        paymentId: result.paymentId,
                        status: result.status,
                        total: result.total,
                        matched: result.matched,
                        amountMismatch: result.amountMismatch,
                        unmatched: result.unmatched
                    };
                    RelayLog.info(`[PAY-CORE] reconcile paymentId=${result.paymentId || 'ALL'} status=${result.status} matched=${result.matched}/${result.total}`);
                    return result;
                };
                window.relayExportTaxReport = (periodId = 'PERIOD-UNKNOWN', format = 'json') => {
                    return exportTaxReport(readTaxRowsFromSheets(periodId), periodId, format);
                };
                window.relayValidateTaxExport = (periodId = 'PERIOD-UNKNOWN', format = 'json') => {
                    const rows = readTaxRowsFromSheets(periodId);
                    const invoiceRows = sheetRowsAsObjects('P2P.InvoiceLines').map(r => ({
                        objectType: 'INV',
                        objectId: String(r.values?.invId || ''),
                        rawJurisdiction: r.values?.jurisdiction,
                        rawTaxTreatment: r.values?.taxTreatment,
                        rawTaxRate: r.values?.taxRate,
                        rawTaxAmount: r.values?.taxAmount
                    })).filter(r => r.objectId);
                    const paymentRows = sheetRowsAsObjects('P2P.PaymentLines').map(r => ({
                        objectType: 'PAY',
                        objectId: String(r.values?.paymentId || ''),
                        rawJurisdiction: r.values?.jurisdiction,
                        rawTaxTreatment: r.values?.taxTreatment,
                        rawTaxRate: r.values?.taxRate,
                        rawTaxAmount: r.values?.taxAmount
                    })).filter(r => r.objectId);
                    const rawByObjectId = new Map();
                    for (const rr of [...invoiceRows, ...paymentRows]) {
                        rawByObjectId.set(`${rr.objectType}|${rr.objectId}`, rr);
                    }
                    const invalidRows = rows.filter((r) => {
                        const raw = rawByObjectId.get(`${r.objectType}|${r.objectId}`) || {};
                        const rawJurisdiction = String(raw.rawJurisdiction ?? '').trim();
                        const rawTaxTreatment = String(raw.rawTaxTreatment ?? '').trim();
                        const rawTaxRate = raw.rawTaxRate;
                        const rawTaxAmount = raw.rawTaxAmount;
                        const missingJurisdiction = rawJurisdiction.length === 0;
                        const missingTreatment = rawTaxTreatment.length === 0;
                        const invalidRate = !(rawTaxRate === null || rawTaxRate === undefined || String(rawTaxRate).trim() === '' || Number.isFinite(Number(rawTaxRate)));
                        const invalidAmount = !(rawTaxAmount === null || rawTaxAmount === undefined || String(rawTaxAmount).trim() === '' || Number.isFinite(Number(rawTaxAmount)));
                        return missingJurisdiction || missingTreatment || invalidRate || invalidAmount;
                    }).map(r => ({
                        objectType: r.objectType,
                        objectId: r.objectId,
                        jurisdiction: r.jurisdiction,
                        taxTreatment: r.taxTreatment,
                        taxRate: r.taxRate,
                        taxAmount: r.taxAmount
                    }));
                    const report = exportTaxReport(rows, periodId, format);
                    const out = {
                        ok: invalidRows.length === 0,
                        periodId: String(periodId),
                        format: String(format || 'json'),
                        rowCount: rows.length,
                        invalidCount: invalidRows.length,
                        invalidRows,
                        hash: report.hash
                    };
                    window.__relayP2PCoreState.lastTaxValidation = {
                        ok: out.ok,
                        periodId: out.periodId,
                        rowCount: out.rowCount,
                        invalidCount: out.invalidCount,
                        hash: out.hash
                    };
                    RelayLog.info(`[TAX0] validate period=${out.periodId} rows=${out.rowCount} invalid=${out.invalidCount} hash=${out.hash}`);
                    return out;
                };
                const toCellTargetRef = (sheetId, rowIndex, colIndex = 0) => ({
                    type: 'cell',
                    id: `${sheetId}.cell.${Number(rowIndex)}.${Number(colIndex)}`
                });
                const commitWithProposal = ({ targetRef, summary, changesetRef, commitMeta }) => {
                    const currentMode = relayWorkState.mode;
                    if (currentMode === 'COMMIT') setRelayWorkMode('DRAFT', { user: relayWorkState.user, zone: relayWorkState.zone });
                    const proposed = setRelayWorkMode('PROPOSE', {
                        targetRef,
                        summary,
                        changesetRef,
                        allowDirectPropose: true,
                        forceSnapshot: true,
                        user: relayWorkState.user,
                        zone: relayWorkState.zone
                    });
                    if (!proposed) return { ok: false, reason: 'PROPOSE_FAILED' };
                    const committed = setRelayWorkMode('COMMIT', {
                        ...commitMeta,
                        targetRef,
                        proposalId: relayWorkState.currentProposalId,
                        evidenceHash: relayWorkState.currentProposalEvidenceHash,
                        user: relayWorkState.user,
                        zone: relayWorkState.zone
                    });
                    if (!committed) return { ok: false, reason: 'COMMIT_FAILED' };
                    updateP2PCommitPointers(relayWorkState.currentCommitId, relayWorkState.currentProposalId);
                    return { ok: true, commitId: relayWorkState.currentCommitId, proposalId: relayWorkState.currentProposalId };
                };
                const readP2PEntryInputs = () => {
                    const val = (id, fallback = '') => {
                        const el = document.getElementById(id);
                        return el ? String(el.value || fallback) : String(fallback);
                    };
                    const num = (id, fallback = 0) => {
                        const el = document.getElementById(id);
                        const n = Number(el ? el.value : fallback);
                        return Number.isFinite(n) ? n : Number(fallback);
                    };
                    return {
                        siteId: val('p2pSiteId', 'SITE_A'),
                        itemId: val('p2pItemId', 'item.RESIN_7'),
                        qty: num('p2pQty', 100),
                        unitPrice: num('p2pUnitPrice', 100)
                    };
                };
                window.relayP2PCreatePR = (meta = {}) => {
                    const i = { ...readP2PEntryInputs(), ...meta };
                    const pr = createPR(i);
                    const result = window.relayIngestRoute(pr.routeId, pr.routePayload);
                    if (!result?.success) return { ok: false, reason: 'INGEST_FAILED' };
                    window.__relayP2PCoreState.lastPR = {
                        ...pr,
                        rowIndex: result.rowIndex,
                        sheetId: result.sheetId,
                        siteId: i.siteId,
                        itemId: i.itemId,
                        qty: i.qty,
                        unit: i.unit || 'EA',
                        estUnitPrice: i.unitPrice || i.estUnitPrice || 0,
                        currency: i.currency || 'USD'
                    };
                    RelayLog.info(`[P2P] create PR id=${pr.id} route=${pr.routeId} row=${result.rowIndex} source=relay-form`);
                    return { ok: true, ...window.__relayP2PCoreState.lastPR };
                };
                window.relayP2PCreatePOFromPR = (meta = {}) => {
                    const pr = meta.prRecord || window.__relayP2PCoreState.lastPR || window.relayP2PCreatePR(meta);
                    if (!pr || pr.ok === false) return { ok: false, reason: 'PR_REQUIRED' };
                    const i = { ...readP2PEntryInputs(), ...meta };
                    const po = createPOFromPR(pr, { ...i, prId: pr.id });
                    const result = window.relayIngestRoute(po.routeId, po.routePayload);
                    if (!result?.success) return { ok: false, reason: 'INGEST_FAILED' };
                    window.__relayP2PCoreState.lastPO = {
                        ...po,
                        rowIndex: result.rowIndex,
                        sheetId: result.sheetId,
                        siteId: i.siteId,
                        itemId: i.itemId,
                        qty: i.qty,
                        unit: i.unit || 'EA',
                        unitPrice: i.unitPrice,
                        lineTotal: Number((i.qty * i.unitPrice).toFixed(2)),
                        vendorId: meta.vendorId || 'vendor.APEX',
                        currency: i.currency || 'USD'
                    };
                    RelayLog.info(`[P2P] create PO id=${po.id} route=${po.routeId} row=${result.rowIndex} source=relay-form`);
                    return { ok: true, ...window.__relayP2PCoreState.lastPO };
                };
                window.relayP2PPostGR = (meta = {}) => {
                    const po = meta.poRecord || window.__relayP2PCoreState.lastPO || window.relayP2PCreatePOFromPR(meta);
                    if (!po || po.ok === false) return { ok: false, reason: 'PO_REQUIRED' };
                    const i = { ...readP2PEntryInputs(), ...meta };
                    const gr = createGRFromPO(po, { ...i, poId: po.id, poLineId: po.lineId });
                    const result = window.relayIngestRoute(gr.routeId, gr.routePayload);
                    if (!result?.success) return { ok: false, reason: 'INGEST_FAILED' };
                    window.__relayP2PCoreState.lastGR = {
                        ...gr,
                        rowIndex: result.rowIndex,
                        sheetId: result.sheetId,
                        siteId: i.siteId,
                        qty: i.qty,
                        unit: i.unit || 'EA',
                        lineValue: Number((i.qty * i.unitPrice).toFixed(2)),
                        poLineId: po.lineId,
                        currency: i.currency || 'USD'
                    };
                    RelayLog.info(`[P2P] post GR id=${gr.id} route=${gr.routeId} row=${result.rowIndex} source=relay-form`);
                    return { ok: true, ...window.__relayP2PCoreState.lastGR };
                };
                window.relayP2PPostINV = (meta = {}) => {
                    const po = meta.poRecord || window.__relayP2PCoreState.lastPO || window.relayP2PCreatePOFromPR(meta);
                    if (!po || po.ok === false) return { ok: false, reason: 'PO_REQUIRED' };
                    const i = { ...readP2PEntryInputs(), ...meta };
                    const inv = createINVFromPO(po, { ...i, poId: po.id, poLineId: po.lineId });
                    const result = window.relayIngestRoute(inv.routeId, inv.routePayload);
                    if (!result?.success) return { ok: false, reason: 'INGEST_FAILED' };
                    const matchRow = sheetRowsAsObjects('P2P.ThreeWayMatch')
                        .find(r => String(r.values?.invLineId || '') === String(inv.lineId) || String(r.values?.poLineId || '') === String(po.lineId));
                    window.__relayP2PCoreState.lastINV = {
                        ...inv,
                        rowIndex: result.rowIndex,
                        sheetId: result.sheetId,
                        siteId: i.siteId,
                        qty: i.qty,
                        unit: i.unit || 'EA',
                        unitPrice: i.unitPrice,
                        lineTotal: Number((i.qty * i.unitPrice).toFixed(2)),
                        poLineId: po.lineId,
                        matchId: matchRow?.values?.matchId || null,
                        matchStatus: matchRow?.values?.matchStatus || null,
                        currency: i.currency || 'USD'
                    };
                    window.__relayP2PCoreState.lastMatchId = window.__relayP2PCoreState.lastINV.matchId || null;
                    window.__relayP2PCoreState.lastMatchStatus = window.__relayP2PCoreState.lastINV.matchStatus || null;
                    RelayLog.info(`[P2P] post INV id=${inv.id} route=${inv.routeId} row=${result.rowIndex} source=relay-form match=${window.__relayP2PCoreState.lastINV.matchId || 'none'}`);
                    return { ok: true, ...window.__relayP2PCoreState.lastINV };
                };
                window.relayP2PPostPAY = (meta = {}) => {
                    const inv = meta.invRecord || window.__relayP2PCoreState.lastINV || window.relayP2PPostINV(meta);
                    if (!inv || inv.ok === false) return { ok: false, reason: 'INV_REQUIRED' };
                    const pay = createPAYFromINV(inv, {
                        ...meta,
                        amount: meta.amount ?? inv.lineTotal,
                        invId: inv.id,
                        invLineId: inv.lineId
                    });
                    const result = window.relayIngestRoute(pay.routeId, pay.routePayload);
                    if (!result?.success) return { ok: false, reason: 'INGEST_FAILED' };
                    window.__relayP2PCoreState.lastPAY = {
                        ...pay,
                        rowIndex: result.rowIndex,
                        sheetId: result.sheetId,
                        amount: Number(meta.amount ?? inv.lineTotal ?? 0),
                        currency: meta.currency || inv.currency || 'USD'
                    };
                    RelayLog.info(`[P2P] post PAY id=${pay.id} route=${pay.routeId} row=${result.rowIndex} source=relay-form`);
                    return { ok: true, ...window.__relayP2PCoreState.lastPAY };
                };
                window.relayP2PCommitGR = (meta = {}) => {
                    const gr = meta.grRecord || window.__relayP2PCoreState.lastGR;
                    if (!gr) return { ok: false, reason: 'GR_REQUIRED' };
                    const siteId = String(gr.siteId || meta.siteId || 'SITE_A');
                    const siteToken = `site${siteId.replace(/^SITE_/i, '').replace(/[^A-Za-z0-9]/g, '') || 'A'}`;
                    const inventoryContainerId = `container.${siteToken}.Inventory`;
                    const grirContainerId = `container.${siteToken}.GRIR`;
                    const qty = Number(gr.qty || 0);
                    const value = Number(gr.lineValue || 0);
                    const transferPacket = {
                        transferPacketId: nextArtifactId('TP-GR'),
                        legs: [
                            { containerRef: { id: inventoryContainerId }, amount: qty, unit: 'quantity', reasonCode: 'GR_QTY' },
                            { containerRef: { id: grirContainerId }, amount: -qty, unit: 'quantity', reasonCode: 'GR_QTY' },
                            { containerRef: { id: inventoryContainerId }, amount: value, unit: 'currency', reasonCode: 'GR_VALUE' },
                            { containerRef: { id: grirContainerId }, amount: -value, unit: 'currency', reasonCode: 'GR_VALUE' }
                        ]
                    };
                    const res = commitWithProposal({
                        targetRef: toCellTargetRef(gr.sheetId || 'P2P.GRLines', gr.rowIndex || 1, 0),
                        summary: `Post GR ${gr.id}`,
                        changesetRef: `ACT:postGR:${Date.now()}`,
                        commitMeta: {
                            postingKind: 'gr',
                            materialEffects: { inventory: true, financial: true },
                            transferPacket,
                            responsibilityPackets: [{ objectId: gr.id, actionRole: 'executed', actorId: relayWorkState.user, authorityRef: 'policy.governance.v2' }]
                        }
                    });
                    if (res.ok) RelayLog.info(`[P2P] commit GR id=${gr.id} commitId=${res.commitId}`);
                    return res;
                };
                window.relayP2PCommitINV = (meta = {}) => {
                    const inv = meta.invRecord || window.__relayP2PCoreState.lastINV;
                    if (!inv) return { ok: false, reason: 'INV_REQUIRED' };
                    const siteId = String(inv.siteId || meta.siteId || 'SITE_A');
                    const siteToken = `site${siteId.replace(/^SITE_/i, '').replace(/[^A-Za-z0-9]/g, '') || 'A'}`;
                    const grirContainerId = `container.${siteToken}.GRIR`;
                    const priceVarianceContainerId = `container.${siteToken}.PriceVariance`;
                    const matchRows = sheetRowsAsObjects('P2P.ThreeWayMatch');
                    const mrow = matchRows.find(r => String(r.values?.matchId || '') === String(inv.matchId || meta.matchId || ''))
                        || matchRows.find(r => String(r.values?.invLineId || '') === String(inv.lineId || ''));
                    const matchId = String(meta.matchId || inv.matchId || mrow?.values?.matchId || '');
                    const poAmount = Number((mrow?.values?.poQty || 0) * (mrow?.values?.poUnitPrice || 0));
                    const invAmount = Number(inv.lineTotal || 0);
                    const variance = Number((invAmount - poAmount).toFixed(2));
                    const resolutionPath = String(meta.resolutionPath || '').toLowerCase();
                    const transferPacket = (resolutionPath === 'variance' && variance !== 0)
                        ? {
                            transferPacketId: nextArtifactId('TP-INV-VAR'),
                            legs: [
                                { containerRef: { id: grirContainerId }, amount: poAmount, unit: 'currency', reasonCode: 'INV_BASE' },
                                { containerRef: { id: 'container.company.AP' }, amount: -invAmount, unit: 'currency', reasonCode: 'INV_AP' },
                                { containerRef: { id: priceVarianceContainerId }, amount: variance, unit: 'currency', reasonCode: 'INV_VAR' }
                            ]
                        }
                        : {
                            transferPacketId: nextArtifactId('TP-INV'),
                            legs: [
                                { containerRef: { id: grirContainerId }, amount: invAmount, unit: 'currency', reasonCode: 'INV_PASS' },
                                { containerRef: { id: 'container.company.AP' }, amount: -invAmount, unit: 'currency', reasonCode: 'INV_PASS' }
                            ]
                        };
                    const targetRef = matchId ? { type: 'match', id: matchId } : toCellTargetRef(inv.sheetId || 'P2P.InvoiceLines', inv.rowIndex || 1, 0);
                    const res = commitWithProposal({
                        targetRef,
                        summary: `Post INV ${inv.id}`,
                        changesetRef: `ACT:postINV:${Date.now()}`,
                        commitMeta: {
                            postingKind: 'invoice',
                            enforceMatchGate: true,
                            resolutionPath,
                            materialEffects: { financial: true },
                            transferPacket,
                            responsibilityPackets: [{ objectId: inv.id, actionRole: 'executed', actorId: relayWorkState.user, authorityRef: 'policy.governance.v2' }]
                        }
                    });
                    if (res.ok) RelayLog.info(`[P2P] commit INV id=${inv.id} commitId=${res.commitId} resolutionPath=${resolutionPath || 'none'}`);
                    return res;
                };
                window.relayP2PCommitPAY = (meta = {}) => {
                    const pay = meta.payRecord || window.__relayP2PCoreState.lastPAY;
                    if (!pay) return { ok: false, reason: 'PAY_REQUIRED' };
                    const recon = computePaymentReconciliation({ paymentId: pay.id });
                    window.__relayP2PCoreState.lastPayReconciliation = {
                        paymentId: recon.paymentId,
                        status: recon.status,
                        total: recon.total,
                        matched: recon.matched,
                        amountMismatch: recon.amountMismatch,
                        unmatched: recon.unmatched
                    };
                    const enforceReconciliation = (meta.enforceReconciliation === true)
                        || (meta.enforceReconciliation !== false && window.RELAY_PAY_RECON_ENFORCE === true);
                    if (enforceReconciliation && recon.status !== 'MATCHED') {
                        RelayLog.warn(`[REFUSAL] reason=PAY_RECON_FAIL paymentId=${pay.id} reconStatus=${recon.status}`);
                        setRelayWorkMode('HOLD', {
                            targetRef: toCellTargetRef(pay.sheetId || 'P2P.PaymentLines', pay.rowIndex || 1, 0),
                            reason: 'PAY_RECON_FAIL',
                            forceSnapshot: true,
                            user: relayWorkState.user,
                            zone: relayWorkState.zone
                        });
                        return { ok: false, reason: 'PAY_RECON_FAIL', reconStatus: recon.status };
                    }
                    const amount = Number(pay.amount || 0);
                    const transferPacket = {
                        transferPacketId: nextArtifactId('TP-PAY'),
                        legs: [
                            { containerRef: { id: 'container.company.AP' }, amount, unit: 'currency', reasonCode: 'PAY_AP' },
                            { containerRef: { id: 'container.company.CashBank' }, amount: -amount, unit: 'currency', reasonCode: 'PAY_CASH' }
                        ]
                    };
                    const res = commitWithProposal({
                        targetRef: toCellTargetRef(pay.sheetId || 'P2P.PaymentLines', pay.rowIndex || 1, 0),
                        summary: `Post PAY ${pay.id}`,
                        changesetRef: `ACT:postPAY:${Date.now()}`,
                        commitMeta: {
                            postingKind: 'pay',
                            materialEffects: { financial: true },
                            transferPacket,
                            action: {
                                actionId: 'postPAY',
                                params: {
                                    paymentId: pay.id,
                                    reconciliationStatus: recon.status,
                                    reconciliationMatched: recon.matched,
                                    reconciliationTotal: recon.total
                                },
                                uiSource: 'p2p-core'
                            },
                            responsibilityPackets: [{ objectId: pay.id, actionRole: 'executed', actorId: relayWorkState.user, authorityRef: 'policy.governance.v2' }]
                        }
                    });
                    if (res.ok) RelayLog.info(`[P2P] commit PAY id=${pay.id} commitId=${res.commitId} reconStatus=${recon.status}`);
                    return res;
                };
                window.relayP2PRunHappyLoop = (meta = {}) => {
                    const pr = window.relayP2PCreatePR(meta);
                    const po = window.relayP2PCreatePOFromPR({ ...meta, prRecord: pr });
                    const gr = window.relayP2PPostGR({ ...meta, poRecord: po });
                    const inv = window.relayP2PPostINV({ ...meta, poRecord: po });
                    const pay = window.relayP2PPostPAY({ ...meta, invRecord: inv });
                    const cgr = window.relayP2PCommitGR({ grRecord: gr });
                    const cinv = window.relayP2PCommitINV({ invRecord: inv });
                    const cpay = window.relayP2PCommitPAY({ payRecord: pay });
                    return { pr, po, gr, inv, pay, cgr, cinv, cpay };
                };
                window.relayP2PRunMismatchLoop = (meta = {}) => {
                    const basePrice = Number(meta.baseUnitPrice || 100);
                    const invoicePrice = Number(meta.invUnitPrice || 102);
                    const pr = window.relayP2PCreatePR({ ...meta, unitPrice: basePrice });
                    const po = window.relayP2PCreatePOFromPR({ ...meta, prRecord: pr, unitPrice: basePrice });
                    const inv = window.relayP2PPostINV({ ...meta, poRecord: po, unitPrice: invoicePrice });
                    const fail = window.relayP2PCommitINV({ invRecord: inv });
                    const pass = window.relayP2PCommitINV({ invRecord: inv, resolutionPath: 'variance' });
                    return { pr, po, inv, fail, pass };
                };
                const initP2PEntryPanel = () => {
                    const bind = (id, fn) => {
                        const el = document.getElementById(id);
                        if (!el) return;
                        el.addEventListener('click', () => {
                            try { fn(); } catch (err) { RelayLog.warn(`[P2P] action failed: ${err?.message || err}`); }
                        });
                    };
                    bind('p2pCreatePRBtn', () => window.relayP2PCreatePR());
                    bind('p2pCreatePOBtn', () => window.relayP2PCreatePOFromPR());
                    bind('p2pPostGRBtn', () => window.relayP2PPostGR());
                    bind('p2pPostINVBtn', () => window.relayP2PPostINV());
                    bind('p2pPostPAYBtn', () => window.relayP2PPostPAY());
                    bind('p2pRunProofBtn', () => window.relayP2PRunHappyLoop());
                };
                initP2PEntryPanel();

                // ‚îÄ‚îÄ‚îÄ D0: Scale & Stress Testing ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                window.relayStressTest = (count = 10000, routeId = 'p2p.invoice') => {
                    RelayLog.info(`[D0-STRESS] BEGIN: generating ${count} records for route=${routeId}`);
                    const t0 = performance.now();
                    const route = getRoute(routeId);
                    const preDeltaSnap = route?.targetSheet ? captureSheetStableSnapshot(route.targetSheet) : null;

                    // Generate mock records
                    const records = [];
                    for (let i = 0; i < count; i++) {
                        const mock = generateMockRecord(routeId);
                        if (mock) records.push(mock);
                    }
                    const genElapsed = (performance.now() - t0).toFixed(1);
                    RelayLog.info(`[D0-STRESS] generated ${records.length} records in ${genElapsed}ms`);

                    // Ingest batch (optimized: deferred ensureCellIndex)
                    const t1 = performance.now();
                    const result = ingestBatch(routeId, records, relayState, ensureCellIndex);
                    const ingestElapsed = (performance.now() - t1).toFixed(1);
                    RelayLog.info(`[D0-STRESS] ingested ${result.ingested} rows in ${ingestElapsed}ms (${result.failed} failed)`);

                    // Find sheet and report dimensions
                    if (result.sheetId) {
                        const sheet = relayState.tree.nodes.find(n => n.id === result.sheetId);
                        if (sheet) {
                            RelayLog.info(`[D0-STRESS] sheet=${result.sheetId} rows=${sheet.rows} cols=${sheet.cols} cellData.length=${sheet.cellData.length}`);
                            const memEst = (sheet.cellData.length * 120 / 1024 / 1024).toFixed(2);
                            RelayLog.info(`[D0-STRESS] estimated memory: ~${memEst}MB for cellData`);
                        }
                    }

                    // Recompute module chain (matches ‚Üí summaries ‚Üí KPIs; render deferred via rAF)
                    const t2 = performance.now();
                    recomputeModuleChain(result.sheetId);
                    const recomputeElapsed = (performance.now() - t2).toFixed(1);
                    RelayLog.info(`[D0-STRESS] recomputeModuleChain (data only, render deferred): ${recomputeElapsed}ms`);
                    const postDeltaSnap = result?.sheetId ? captureSheetStableSnapshot(result.sheetId) : null;
                    const deltaSummary = summarizeRouteDelta(routeId, preDeltaSnap, postDeltaSnap);
                    maybeAutoHoldFromDelta(deltaSummary);

                    // D0.3 fix: Use renderer's own entity/primitive counts (not Cesium internals)
                    let relayEntities = 0, relayPrimitives = 0;
                    let cesiumEntities = 0, cesiumPrimitives = 0;
                    try {
                        cesiumEntities = viewer.entities.values.length;
                        cesiumPrimitives = viewer.scene.primitives.length;
                        // Use renderer's tracked counts if available
                        if (filamentRenderer) {
                            const ec = filamentRenderer.entityCount || {};
                            const pc = filamentRenderer.primitiveCount || {};
                            relayEntities = (ec.labels || 0) + (ec.cellPoints || 0) + (ec.timeboxLabels || 0);
                            relayPrimitives = (pc.trunks || 0) + (pc.branches || 0) + (pc.cellFilaments || 0) + (pc.spines || 0);
                        }
                    } catch (e) { /* not critical */ }

                    const totalElapsed = (performance.now() - t0).toFixed(1);

                    const report = {
                        count,
                        routeId,
                        generated: records.length,
                        ingested: result.ingested,
                        failed: result.failed,
                        sheetId: result.sheetId,
                        timing: {
                            generation: genElapsed + 'ms',
                            ingestion: ingestElapsed + 'ms',
                            recompute: recomputeElapsed + 'ms',
                            total: totalElapsed + 'ms'
                        },
                        scene: {
                            relayEntities,
                            relayPrimitives,
                            cesiumEntities,
                            cesiumPrimitives
                        }
                    };

                    RelayLog.info(`[D0-STRESS] COMPLETE: ${JSON.stringify(report)}`);
                    RelayLog.info(`[D0-STRESS] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
                    RelayLog.info(`[D0-STRESS]   Records: ${result.ingested}/${count}`);
                    RelayLog.info(`[D0-STRESS]   Generation:  ${genElapsed}ms`);
                    RelayLog.info(`[D0-STRESS]   Ingestion:   ${ingestElapsed}ms`);
                    RelayLog.info(`[D0-STRESS]   Recompute:   ${recomputeElapsed}ms (data only)`);
                    RelayLog.info(`[D0-STRESS]   Total:       ${totalElapsed}ms`);
                    RelayLog.info(`[D0-STRESS]   Relay Entities:    ${relayEntities}`);
                    RelayLog.info(`[D0-STRESS]   Relay Primitives:  ${relayPrimitives}`);
                    RelayLog.info(`[D0-STRESS]   Cesium Total:      entities=${cesiumEntities} prims=${cesiumPrimitives} (informational)`);
                    RelayLog.info(`[D0-STRESS] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);

                    return report;
                };

                // FPS monitoring for D0.3
                window.relayFPSMonitor = (durationMs = 5000) => {
                    window.__relayFpsSamplingActive = true;
                    let frames = 0;
                    const t0 = performance.now();
                    const measure = () => {
                        frames++;
                        if (performance.now() - t0 < durationMs) {
                            requestAnimationFrame(measure);
                        } else {
                            const elapsed = performance.now() - t0;
                            const fps = (frames / (elapsed / 1000)).toFixed(1);
                            RelayLog.info(`[D0-FPS] ${fps} FPS over ${(elapsed/1000).toFixed(1)}s (${frames} frames)`);
                            console.log(`FPS: ${fps}`);
                            window.__relayFpsSamplingActive = false;
                        }
                    };
                    requestAnimationFrame(measure);
                    RelayLog.info(`[D0-FPS] monitoring for ${durationMs}ms...`);
                };

                // ‚îÄ‚îÄ‚îÄ D0: Comprehensive Gate Test ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // Runs stress test + verifies all D0 pass criteria
                window.relayD0Gate = async (count = 10000) => {
                    const prevUiEnabled = (typeof RelayLog.isUIEnabled === 'function')
                        ? RelayLog.isUIEnabled()
                        : true;
                    window.__relayStressLodLevel = RELAY_D0_LOCKED_LOD;
                    window.__relayStressModeActive = true;
                    window.__relayFpsSamplingActive = false;
                    window.__relayFpsBoostActive = false;
                    window.__relayFpsSampleBarrierActive = false;
                    window.__relayFpsSampleLaneEmitCap = RELAY_D0_FPS_LANE_CAP;
                    if (typeof RelayLog.setUIEnabled === 'function') {
                        RelayLog.setUIEnabled(false); // avoid high-frequency DOM log churn during stress runs
                    }
                    try {
                        RelayLog.info(`[D0-GATE] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
                        RelayLog.info(`[D0-GATE] Starting D0 Scale & Stress Gate (${count} rows)`);
                        RelayLog.info(`[D0-GATE] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);

                        const gates = {};

                        // ‚îÄ‚îÄ D0.1: Bulk Route Ingestion ‚îÄ‚îÄ
                        const stressReport = window.relayStressTest(count);
                        const ingestionOk = stressReport.ingested >= count * 0.99;
                        const memMB = stressReport.sheetId ? (() => {
                            const s = relayState.tree.nodes.find(n => n.id === stressReport.sheetId);
                            return s ? (s.cellData.length * 120 / 1024 / 1024) : 0;
                        })() : 0;
                        gates['D0.1'] = {
                            name: 'Bulk Route Ingestion',
                            pass: ingestionOk && memMB < 500,
                            detail: `ingested=${stressReport.ingested}/${count} mem=${memMB.toFixed(1)}MB time=${stressReport.timing.ingestion}`
                        };
                        RelayLog.info(`[D0-GATE] D0.1 ${gates['D0.1'].pass ? 'PASS' : 'REFUSAL'}: ${gates['D0.1'].detail}`);

                        // ‚îÄ‚îÄ D0.2: Recomputation Latency (data only ‚Äî render deferred) ‚îÄ‚îÄ
                        const recomputeMs = parseFloat(stressReport.timing.recompute);
                        gates['D0.2'] = {
                            name: 'Recomputation Latency (data)',
                            pass: recomputeMs < 2000,
                            detail: `recomputeDataMs=${stressReport.timing.recompute} (limit: <2000ms; render deferred via rAF)`
                        };
                        RelayLog.info(`[D0-GATE] D0.2 ${gates['D0.2'].pass ? 'PASS' : 'REFUSAL'}: ${gates['D0.2'].detail}`);

                        // ‚îÄ‚îÄ D0.3: Tree Redraw Stability (relay's own counts, not Cesium internals) ‚îÄ‚îÄ
                        const re = stressReport.scene.relayEntities || 0;
                        const rp = stressReport.scene.relayPrimitives || 0;
                        gates['D0.3'] = {
                            name: 'Tree Redraw Stability',
                            pass: re < 10000 && rp < 10000,
                            detail: `relayEntities=${re} relayPrimitives=${rp} (cesiumTotal: entities=${stressReport.scene.cesiumEntities} prims=${stressReport.scene.cesiumPrimitives})`
                        };
                        RelayLog.info(`[D0-GATE] D0.3 ${gates['D0.3'].pass ? 'PASS' : 'REFUSAL'}: ${gates['D0.3'].detail}`);

                        // ‚îÄ‚îÄ D0.4: Virtualized Viewport ‚îÄ‚îÄ
                        const targetSheet = stressReport.sheetId
                            ? relayState.tree.nodes.find(n => n.id === stressReport.sheetId)
                            : null;
                        const totalSheetRows = targetSheet?.rows || 0;
                        const currentDOMCells = document.querySelectorAll('.grid-data').length;
                        const maxExpectedDOM = (viewportRowsVisible + 2 * VIEWPORT_BUFFER) * (viewportColsVisible + 2 * VIEWPORT_BUFFER);
                        gates['D0.4'] = {
                            name: 'Virtualized Viewport',
                            pass: totalSheetRows >= count && currentDOMCells <= maxExpectedDOM + 200,
                            detail: `sheetRows=${totalSheetRows} domCells=${currentDOMCells} maxExpected=${maxExpectedDOM} viewportVisible=${viewportRowsVisible}√ó${viewportColsVisible}`
                        };
                        RelayLog.info(`[D0-GATE] D0.4 ${gates['D0.4'].pass ? 'PASS' : 'REFUSAL'}: ${gates['D0.4'].detail}`);

                        // ‚îÄ‚îÄ D0.5: Date Functions ‚îÄ‚îÄ
                        const dateFuncsExist = ['TODAY', 'DATEDIF', 'DATEVALUE', 'DAYS', 'NOW', 'YEAR', 'MONTH', 'DAY']
                            .every(fn => typeof formulaFunctions[fn] === 'function');
                        const agingNode = relayState.tree.nodes.find(n => n.id === 'P2P.AP_Aging');
                        let hasAgingBuckets = false;
                        if (agingNode) {
                            ensureCellIndex(agingNode);
                            // Check for aging bucket labels
                            for (const [, ci] of agingNode._cellIndex) {
                                if (typeof ci.value === 'string' && ci.value.includes('0-30d')) hasAgingBuckets = true;
                            }
                        }
                        gates['D0.5'] = {
                            name: 'Date Functions + Aging Buckets',
                            pass: dateFuncsExist && hasAgingBuckets,
                            detail: `dateFunctions=${dateFuncsExist ? 'ALL' : 'MISSING'} agingBuckets=${hasAgingBuckets}`
                        };
                        RelayLog.info(`[D0-GATE] D0.5 ${gates['D0.5'].pass ? 'PASS' : 'REFUSAL'}: ${gates['D0.5'].detail}`);

                        // ‚îÄ‚îÄ FPS measurement (async) ‚îÄ‚îÄ
                        // Wait until deferred D0.2 redraw finishes so we sample steady-state FPS.
                        activatePostGateQuietWindow(RELAY_POST_GATE_QUIET_MS);
                        window.__relayFpsBoostActive = true;
                        window.__relayFpsSampleBarrierActive = true;
                        if (filamentRenderer) {
                            if (filamentRenderer.currentLOD !== RELAY_D0_LOCKED_LOD) {
                                filamentRenderer.setLOD(RELAY_D0_LOCKED_LOD);
                            }
                            // Apply sample-only render budget + label suppression before sampling.
                            filamentRenderer.renderTree('fps-sample-prep');
                        }
                        const waitForRenderSettle = async () => {
                            const settleStart = performance.now();
                            const settleTimeoutMs = 8000;
                            const settleIdleMs = 300;
                            while (performance.now() - settleStart < settleTimeoutMs) {
                                const pending = window.__relayDeferredRenderPending === true;
                                const scheduled = window.__relayDeferredRenderScheduled === true;
                                const queued = window.__relayDeferredRenderQueued === true;
                                const queueBlocksSettle = window.__relayFpsSampleBarrierActive !== true;
                                const lastEnd = Number(window.__relayLastDeferredRenderEndMs || 0);
                                const sinceEndMs = performance.now() - lastEnd;
                                if (!pending && !scheduled && (!queueBlocksSettle || !queued) && (!lastEnd || sinceEndMs >= settleIdleMs)) break;
                                await new Promise(resolve => setTimeout(resolve, 50));
                            }
                            await new Promise(resolve => requestAnimationFrame(() => requestAnimationFrame(resolve)));
                        };
                        await waitForRenderSettle();
                        const fpsDurationMs = 1000;
                        const fpsTimeoutMs = fpsDurationMs + 1500;
                        const maxSampleFrames = 180;
                        RelayLog.info(`[D0-GATE] Measuring FPS for ${(fpsDurationMs / 1000).toFixed(1)} seconds...`);
                        const sampleScene = viewer?.scene || null;
                        const sampleViewer = viewer || null;
                        const sampleClock = sampleViewer?.clock || null;
                        const prevRequestRenderMode = sampleScene ? sampleScene.requestRenderMode : null;
                        const prevMaxRenderDelta = sampleScene ? sampleScene.maximumRenderTimeChange : null;
                        const prevUseDefaultRenderLoop = sampleViewer ? sampleViewer.useDefaultRenderLoop : null;
                        const prevClockShouldAnimate = sampleClock ? sampleClock.shouldAnimate : null;
                        const prevResolutionScale = sampleViewer ? Number(sampleViewer.resolutionScale) : null;
                        const prevFxaaEnabled = sampleScene?.postProcessStages?.fxaa
                            ? Boolean(sampleScene.postProcessStages.fxaa.enabled)
                            : null;
                        const prevGlobeShow = (sampleScene?.globe && typeof sampleScene.globe.show === 'boolean')
                            ? sampleScene.globe.show
                            : null;
                        const turgorWasRunning = filamentRenderer?.turgorAnimationRunning === true;
                        if (turgorWasRunning) {
                            filamentRenderer.stopTurgorAnimation();
                        }
                        if (sampleViewer) {
                            sampleViewer.useDefaultRenderLoop = true;
                        }
                        if (sampleClock) {
                            sampleClock.shouldAnimate = true;
                        }
                        if (sampleScene) {
                            sampleScene.requestRenderMode = false;
                            sampleScene.maximumRenderTimeChange = 0.0;
                            // Sample-only Cesium lift: reduce pixel workload and disable FXAA.
                            if (sampleScene.postProcessStages?.fxaa) {
                                sampleScene.postProcessStages.fxaa.enabled = false;
                            }
                            if (window.RELAY_D0_FPS_SAMPLE_HIDE_GLOBE === true && sampleScene.globe && typeof sampleScene.globe.show === 'boolean') {
                                sampleScene.globe.show = false;
                            }
                        }
                        if (sampleViewer && Number.isFinite(prevResolutionScale)) {
                            sampleViewer.resolutionScale = RELAY_D0_FPS_SAMPLE_RES_SCALE;
                        }
                        window.__relayFpsSamplingActive = true;
                        let fpsResult = 0;
                        let fpsSampleMeta = {
                            source: 'UNKNOWN',
                            timedOut: false,
                            frames: 0,
                            elapsedMs: 0,
                            usedHudFallback: false,
                            inconclusive: false,
                            sampleError: null,
                            advisoryHudFps: null,
                            devicePixelRatio: null,
                            resolutionScale: null
                        };
                        fpsSampleMeta.devicePixelRatio = Number.isFinite(window.devicePixelRatio) ? Number(window.devicePixelRatio) : null;
                        fpsSampleMeta.resolutionScale = (sampleViewer && Number.isFinite(sampleViewer.resolutionScale))
                            ? Number(sampleViewer.resolutionScale)
                            : null;
                        const sampleFpsForced = async (durationMs = 1000) => {
                            if (!sampleScene) throw new Error('No scene');
                            const waitForAnimationFrameWithTimeout = (timeoutMs = 250) => new Promise((resolve, reject) => {
                                let settled = false;
                                const timerId = setTimeout(() => {
                                    if (settled) return;
                                    settled = true;
                                    reject(new Error(`Animation frame timeout (${timeoutMs}ms)`));
                                }, timeoutMs);
                                requestAnimationFrame(() => {
                                    if (settled) return;
                                    settled = true;
                                    clearTimeout(timerId);
                                    resolve();
                                });
                            });
                            sampleScene.requestRender();
                            await waitForAnimationFrameWithTimeout();
                            const start = performance.now();
                            let frames = 0;
                            const timeoutAt = start + fpsTimeoutMs;
                            while ((performance.now() - start) < durationMs && frames < maxSampleFrames) {
                                if (performance.now() >= timeoutAt) {
                                    throw new Error('Forced FPS sample timed out');
                                }
                                sampleScene.requestRender();
                                await waitForAnimationFrameWithTimeout();
                                frames++;
                            }
                            const elapsedMs = performance.now() - start;
                            const fpsMeasured = frames / (Math.max(1, elapsedMs) / 1000);
                            return { fps: fpsMeasured, frames, elapsedMs, source: 'FORCED_RAF' };
                        };
                        try {
                            let report;
                            try {
                                report = await sampleFpsForced(fpsDurationMs);
                            } catch (err) {
                                const advisoryHud = Number.isFinite(fps) && fps > 0 ? Number(fps) : null;
                                fpsSampleMeta.inconclusive = true;
                                fpsSampleMeta.sampleError = err?.message || String(err);
                                fpsSampleMeta.advisoryHudFps = advisoryHud;
                                report = {
                                    fps: advisoryHud || 0,
                                    frames: 0,
                                    elapsedMs: 0,
                                    source: 'HUD_ADVISORY'
                                };
                                RelayLog.warn(`[D0-GATE] FPS forced sample failed (${fpsSampleMeta.sampleError}). HUD advisory fps=${advisoryHud ?? 'N/A'}`);
                            }
                            fpsResult = Number(report.fps) || 0;
                            fpsSampleMeta.source = report.source;
                            fpsSampleMeta.frames = Number(report.frames) || 0;
                            fpsSampleMeta.elapsedMs = Number(report.elapsedMs) || 0;
                            fpsSampleMeta.usedHudFallback = report.source !== 'FORCED_RAF';
                            if (report.source === 'FORCED_RAF') {
                                RelayLog.info(`[D0-GATE] FPS sample source=${report.source} fps=${fpsResult.toFixed(1)} frames=${fpsSampleMeta.frames} elapsedMs=${fpsSampleMeta.elapsedMs.toFixed(1)}`);
                            } else {
                                RelayLog.info(`[D0-GATE] FPS sample source=${report.source} fps=${fpsResult.toFixed(1)}`);
                            }
                        } finally {
                            window.__relayFpsSamplingActive = false;
                            window.__relayFpsBoostActive = false;
                            window.__relayFpsSampleBarrierActive = false;
                            if (sampleScene) {
                                // Force continuous rendering after stress sampling to avoid a frozen viewport.
                                sampleScene.requestRenderMode = false;
                                sampleScene.maximumRenderTimeChange = 0.0;
                                sampleScene.requestRender();
                            }
                            if (sampleViewer) {
                                sampleViewer.useDefaultRenderLoop = true;
                            }
                            if (sampleClock) {
                                sampleClock.shouldAnimate = true;
                            }
                            if (sampleViewer && Number.isFinite(prevResolutionScale)) {
                                sampleViewer.resolutionScale = prevResolutionScale;
                            }
                            if (sampleScene?.postProcessStages?.fxaa && typeof prevFxaaEnabled === 'boolean') {
                                sampleScene.postProcessStages.fxaa.enabled = prevFxaaEnabled;
                            }
                            if (sampleScene?.globe && typeof prevGlobeShow === 'boolean') {
                                sampleScene.globe.show = prevGlobeShow;
                            }
                            if (turgorWasRunning && filamentRenderer && !filamentRenderer.turgorAnimationRunning) {
                                filamentRenderer.startTurgorAnimation();
                            }
                            // Keep previous state snapshots for troubleshooting visibility (non-invasive).
                            window.__relayLastFpsSampleRestore = {
                                prevRequestRenderMode,
                                prevMaxRenderDelta,
                                prevUseDefaultRenderLoop,
                                prevClockShouldAnimate
                            };
                            if (window.__relayDeferredRenderQueued === true) {
                                window.__relayDeferredRenderQueued = false;
                                scheduleDeferredTreeRender('fps-sample-release');
                            }
                        }
                        const fpsDeterministic = fpsSampleMeta.source === 'FORCED_RAF' && !fpsSampleMeta.inconclusive;
                        const fpsMinStrict = Math.max(1, Number(window.RELAY_D0_FPS_MIN_STRICT || 30));
                        const fpsMinDev = Math.max(1, Number(window.RELAY_D0_FPS_MIN_DEV || 22));
                        const fpsOkStrict = fpsDeterministic && fpsResult >= fpsMinStrict;
                        const fpsOkDev = fpsDeterministic && fpsResult >= fpsMinDev;
                        const fpsStatusStrict = fpsDeterministic ? (fpsOkStrict ? 'PASS' : 'REFUSAL') : 'INCONCLUSIVE';
                        const fpsStatusDev = fpsDeterministic ? (fpsOkDev ? 'PASS' : 'REFUSAL') : 'INCONCLUSIVE';
                        gates['D0.3-FPS'] = {
                            name: 'FPS After Ingestion (STRICT)',
                            pass: fpsOkStrict,
                            detail: `fps=${fpsResult.toFixed(1)} (limit: >=${fpsMinStrict}; frames=${fpsSampleMeta.frames} elapsedMs=${fpsSampleMeta.elapsedMs.toFixed(1)}; source=${fpsSampleMeta.source}${fpsSampleMeta.advisoryHudFps != null ? `; hud=${fpsSampleMeta.advisoryHudFps.toFixed(1)}` : ''}${fpsSampleMeta.sampleError ? `; err=${fpsSampleMeta.sampleError}` : ''}${!fpsDeterministic ? '; verdict=INCONCLUSIVE' : ''})`
                        };
                        gates['D0.3-FPS-DEV'] = {
                            name: 'FPS After Ingestion (DEV)',
                            pass: fpsOkDev,
                            detail: `fps=${fpsResult.toFixed(1)} (limit: >=${fpsMinDev}; strict>=${fpsMinStrict}; frames=${fpsSampleMeta.frames} elapsedMs=${fpsSampleMeta.elapsedMs.toFixed(1)}; source=${fpsSampleMeta.source}${!fpsDeterministic ? '; verdict=INCONCLUSIVE' : ''})`
                        };
                        RelayLog.info(`[D0-GATE] D0.3-FPS(STRICT) ${fpsStatusStrict}: ${gates['D0.3-FPS'].detail}`);
                        RelayLog.info(`[D0-GATE] D0.3-FPS(DEV) ${fpsStatusDev}: ${gates['D0.3-FPS-DEV'].detail}`);

                        // ‚îÄ‚îÄ Final summary ‚îÄ‚îÄ
                        const baseGateIds = Object.keys(gates).filter(id => id !== 'D0.3-FPS' && id !== 'D0.3-FPS-DEV');
                        const basePass = baseGateIds.every(id => gates[id].pass);
                        const allPassStrict = basePass && gates['D0.3-FPS'].pass;
                        const allPassDev = basePass && gates['D0.3-FPS-DEV'].pass;
                        const passPolicy = window.RELAY_D0_PASS_POLICY === 'strict' ? 'strict' : 'dev';
                        const allPass = passPolicy === 'strict' ? allPassStrict : allPassDev;
                        RelayLog.info(
                            `[D0-GATE] POLICY devPass=${allPassDev ? 'PASS' : 'REFUSAL'} strictPass=${allPassStrict ? 'PASS' : 'REFUSAL'} fps=${fpsResult.toFixed(1)} source=${fpsSampleMeta.source} devicePixelRatio=${fpsSampleMeta.devicePixelRatio != null ? fpsSampleMeta.devicePixelRatio.toFixed(2) : 'N/A'} resolutionScale=${fpsSampleMeta.resolutionScale != null ? fpsSampleMeta.resolutionScale.toFixed(2) : 'N/A'}`
                        );
                        RelayLog.info(`[D0-GATE] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
                        RelayLog.info(`[D0-GATE] RESULT(policy=${passPolicy}): ${allPass ? '‚úÖ ALL PASS' : '‚ùå SOME REFUSAL'} (strict=${allPassStrict ? 'PASS' : 'REFUSAL'} dev=${allPassDev ? 'PASS' : 'REFUSAL'})`);
                        for (const [id, g] of Object.entries(gates)) {
                            RelayLog.info(`[D0-GATE]   ${g.pass ? '‚úÖ' : '‚ùå'} ${id}: ${g.name} ‚Äî ${g.detail}`);
                        }
                        RelayLog.info(`[D0-GATE] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
                        return { allPass, allPassStrict, allPassDev, passPolicy, gates, stressReport };
                    } finally {
                        window.__relayStressModeActive = false;
                        window.__relayFpsSamplingActive = false;
                        window.__relayFpsBoostActive = false;
                        window.__relayFpsSampleBarrierActive = false;
                        activatePostGateQuietWindow(RELAY_POST_GATE_QUIET_MS);
                        if (typeof RelayLog.setUIEnabled === 'function') {
                            RelayLog.setUIEnabled(prevUiEnabled);
                        }
                    }
                };

                // ‚îÄ‚îÄ HEADLESS-0: Headless D0 Gate ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // Decision 2: D0.3/FPS = N/A in headless. D0.4 = renderer-free (data integrity check).
                // Decision 3: 7-component golden scope with NA fallback.
                // Decision 4: SHA-256 for golden comparisons.
                window.relayD0GateHeadless = async (count = 10000) => {
                    // Detect headless fallback if not already forced
                    if (typeof window.relayDetectHeadlessFallback === 'function') {
                        window.relayDetectHeadlessFallback();
                    }

                    const gates = {};
                    RelayLog.info(`[HEADLESS] gate-run count=${count}`);
                    console.log(`[HEADLESS] gate-run count=${count}`);

                    // D0.1: Bulk Route Ingestion (identical to 3D)
                    const stressReport = window.relayStressTest(count);
                    const ingestionOk = stressReport.ingested >= count * 0.99;
                    gates['D0.1'] = {
                        name: 'Bulk Route Ingestion',
                        pass: ingestionOk,
                        detail: `ingested=${stressReport.ingested}/${count} time=${stressReport.timing.ingestion}`
                    };
                    const d01Line = `[HEADLESS] gate=D0.1 result=${gates['D0.1'].pass ? 'PASS' : 'REFUSAL'} rows=${stressReport.ingested} duration=${stressReport.timing.ingestion}`;
                    RelayLog.info(d01Line); console.log(d01Line);

                    // D0.2: Recomputation Latency (identical to 3D ‚Äî data only)
                    const recomputeMs = parseFloat(stressReport.timing.recompute);
                    gates['D0.2'] = {
                        name: 'Recomputation Latency (data)',
                        pass: recomputeMs < 2000,
                        detail: `recomputeMs=${stressReport.timing.recompute}`
                    };
                    const d02Line = `[HEADLESS] gate=D0.2 result=${gates['D0.2'].pass ? 'PASS' : 'REFUSAL'} recomputeMs=${stressReport.timing.recompute}`;
                    RelayLog.info(d02Line); console.log(d02Line);

                    // D0.3: N/A ‚Äî no renderer (Decision 2)
                    gates['D0.3'] = {
                        name: 'Tree Redraw + FPS',
                        pass: null,
                        na: true,
                        detail: 'N/A headless'
                    };
                    const d03Line = `[HEADLESS] gate=D0.3 result=NA reason=no-renderer`;
                    RelayLog.info(d03Line); console.log(d03Line);

                    // D0.4: Data integrity viewport surrogate (Decision: renderer-free, no DOM)
                    // PASS iff expected sheets exist in tree AND fact rows >= 0
                    const allSheets = (relayState?.tree?.nodes || []).filter(n => n.type === 'sheet');
                    const sheetsWithData = allSheets.filter(s => Array.isArray(s.cellData) && s.cellData.length > 0);
                    const factSheets = allSheets.filter(s => s.metadata?.isFactSheet === true);
                    const totalFactRows = factSheets.reduce((acc, s) => acc + (s.rows || s.cellData?.length || 0), 0);
                    const sheetsExpected = stressReport.sheetId ? 1 : allSheets.length;
                    gates['D0.4'] = {
                        name: 'Data Integrity Viewport (headless)',
                        pass: sheetsWithData.length >= sheetsExpected && totalFactRows >= 0,
                        detail: `sheetsRendered=${sheetsWithData.length} sheetsExpected=${sheetsExpected} factRows=${totalFactRows}`
                    };
                    const d04Line = `[HEADLESS] gate=D0.4 result=${gates['D0.4'].pass ? 'PASS' : 'REFUSAL'} sheetsRendered=${sheetsWithData.length} sheetsExpected=${sheetsExpected} factRows=${totalFactRows}`;
                    RelayLog.info(d04Line); console.log(d04Line);

                    // D0.5: Date Functions (identical to 3D ‚Äî pure computation)
                    const dateFuncsExist = ['TODAY', 'DATEDIF', 'DATEVALUE', 'DAYS', 'NOW', 'YEAR', 'MONTH', 'DAY']
                        .every(fn => typeof formulaFunctions[fn] === 'function');
                    const agingNode = relayState.tree.nodes.find(n => n.id === 'P2P.AP_Aging');
                    let hasAgingBuckets = false;
                    if (agingNode) {
                        ensureCellIndex(agingNode);
                        for (const [, ci] of agingNode._cellIndex) {
                            if (typeof ci.value === 'string' && ci.value.includes('0-30d')) hasAgingBuckets = true;
                        }
                    }
                    gates['D0.5'] = {
                        name: 'Date Functions + Aging Buckets',
                        pass: dateFuncsExist && hasAgingBuckets,
                        detail: `dateFunctions=${dateFuncsExist ? 'ALL' : 'MISSING'} agingBuckets=${hasAgingBuckets}`
                    };
                    const d05Line = `[HEADLESS] gate=D0.5 result=${gates['D0.5'].pass ? 'PASS' : 'REFUSAL'} dateFunctions=${dateFuncsExist ? 'ALL' : 'MISSING'} agingBuckets=${hasAgingBuckets}`;
                    RelayLog.info(d05Line); console.log(d05Line);

                    // Summary (D0.3 excluded from pass calculation since it's N/A)
                    const dataGates = ['D0.1', 'D0.2', 'D0.4', 'D0.5'];
                    const allPass = dataGates.every(id => gates[id].pass === true);
                    return { allPass, gates, stressReport };
                };

                // ‚îÄ‚îÄ HEADLESS-0: SHA-256 browser golden hash API ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                async function _sha256Browser(text) {
                    if (typeof crypto !== 'undefined' && crypto.subtle) {
                        const data = new TextEncoder().encode(String(text));
                        const buf = await crypto.subtle.digest('SHA-256', data);
                        return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
                    }
                    // Fallback (shouldn't happen in modern browsers)
                    let h = 2166136261 >>> 0;
                    const src = String(text);
                    for (let i = 0; i < src.length; i++) { h ^= src.charCodeAt(i); h = Math.imul(h, 16777619) >>> 0; }
                    return `fallback-${h.toString(16).padStart(8, '0')}`;
                }

                window.relayGetGoldenStateHashesSHA256 = async (options = {}) => {
                    const mode = String(options.source || 'runtime');
                    const allowKpiNA = options.allowKpiNA !== false;
                    const fixture = (mode === 'fixture' || window.__relayHeadlessParityFixture)
                        ? (window.__relayHeadlessParityFixture || buildTier1ParityFixture())
                        : extractRuntimeParityFixture();

                    // Reuse the same canonical extraction as the FNV-1a path
                    const base = computeTier1GoldenHashesFromFixture(fixture, { allowKpiNA });

                    // Stable stringify for SHA-256
                    const _canon = (v) => {
                        if (v === null || typeof v === 'undefined') return null;
                        if (typeof v === 'number') { const f = v.toFixed(6); return f.replace(/\.?0+$/, ''); }
                        if (typeof v !== 'object') return v;
                        if (Array.isArray(v)) return v.map(_canon);
                        const o = {}; for (const k of Object.keys(v).sort()) o[k] = _canon(v[k]); return o;
                    };
                    const _stableStr = (v) => JSON.stringify(_canon(v));

                    const factsHash = await _sha256Browser(_stableStr(base.components.facts));
                    const matchesHash = await _sha256Browser(_stableStr(base.components.matches));
                    const summariesHash = await _sha256Browser(_stableStr(base.components.summaries));
                    let kpisHash = await _sha256Browser(_stableStr(base.components.kpiRows));
                    if (base.kpisHash === 'N/A') kpisHash = 'N/A';
                    const packetsHash = await _sha256Browser(_stableStr(base.components.packets));
                    const ledgerHash = await _sha256Browser(_stableStr(base.components.ledger));

                    // Commits: extract from runtime commit log
                    const commits = [...(window.__relayCommits || [])].sort((a, b) => {
                        const ai = Number(a.commitIndex ?? 0);
                        const bi = Number(b.commitIndex ?? 0);
                        return ai - bi || String(a.id || '').localeCompare(String(b.id || ''));
                    });
                    let commitsHash = await _sha256Browser(_stableStr(commits));
                    if (commits.length === 0) commitsHash = 'N/A';

                    // Mark packets/ledger NA if empty
                    const pEmpty = (base.components.packets.transferPackets.length === 0 && base.components.packets.responsibilityPackets.length === 0);
                    const lEmpty = base.components.ledger.journalEntries.length === 0;

                    return {
                        factsHash, matchesHash, summariesHash, kpisHash, commitsHash,
                        packetsHash: pEmpty && options.allowPacketsNA ? 'N/A' : packetsHash,
                        ledgerHash: lEmpty && options.allowLedgerNA ? 'N/A' : ledgerHash
                    };
                };

                /**
                 * HEADLESS-0: Extract runtime fixture suitable for Node.js SHA-256 comparison.
                 * Includes commits. Excludes all ephemeral state (presence, ride, consent).
                 */
                window.relayExtractRuntimeFixtureForParity = () => {
                    const base = extractRuntimeParityFixture();
                    // Add commits (canonical data only ‚Äî no ephemeral presence/ride/consent)
                    const commits = [...(window.__relayCommits || [])].sort((a, b) => {
                        const ai = Number(a.commitIndex ?? 0);
                        const bi = Number(b.commitIndex ?? 0);
                        return ai - bi || String(a.id || '').localeCompare(String(b.id || ''));
                    });
                    return { ...base, commits };
                };
                // ‚îÄ‚îÄ End HEADLESS-0 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

                // ‚îÄ‚îÄ E1-CRYPTO-1: Cryptographic Integrity Layer ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // "E1-CRYPTO-1 introduces derived integrity views and verifiers only;
                //  it must not mutate historical receipt objects, and verification must
                //  be read-only unless emitScar:true is explicitly requested."
                window.__relayCryptoState = {
                    globalChain: [],
                    sheetChains: {},
                    tbChain: [],
                    initialized: false,
                    lastVerify: null    // { overall, durationMs, timestamp }
                };

                // Crypto init: build derived chains from existing data
                window.relayCryptoInit = async () => {
                    const logFn = (s) => { RelayLog.info(s); console.log(s); };
                    const cs = window.__relayCryptoState;

                    cs.globalChain = await buildGlobalChain(window.__relayCommits || [], logFn);

                    const sheetCommitsGrouped = {};
                    for (const sc of (window.__relaySheetCommits || [])) {
                        const sid = sc.sheetId || 'unknown';
                        if (!sheetCommitsGrouped[sid]) sheetCommitsGrouped[sid] = [];
                        sheetCommitsGrouped[sid].push(sc);
                    }
                    cs.sheetChains = await buildSheetChains(window.__relaySheetCommits || [], cs.globalChain, logFn);

                    const trunkNode = (relayState.tree?.nodes || []).find(n => n.type === 'trunk');
                    const timeboxes = trunkNode?.timeboxes || [];
                    cs.tbChain = await buildTimeboxChain(timeboxes, logFn);

                    cs.initialized = true;
                    logFn(`[CRYPTO] chainStamp mode=derived commits=${cs.globalChain.length} sheets=${Object.keys(cs.sheetChains).length} timeboxes=${cs.tbChain.length}`);
                };

                // Verification API (read-only by default; Tightening 1)
                window.relayVerifyChainIntegrity = async (opts = {}) => {
                    const logFn = (s) => { RelayLog.info(s); console.log(s); };
                    const cs = window.__relayCryptoState;
                    if (!cs.initialized) {
                        logFn(`[CRYPTO] verify result=SKIP reason=not_initialized`);
                        return { overall: 'UNCHECKED', emitScar: false, durationMs: 0 };
                    }

                    const sheetCommitsGrouped = {};
                    for (const sc of (window.__relaySheetCommits || [])) {
                        const sid = sc.sheetId || 'unknown';
                        if (!sheetCommitsGrouped[sid]) sheetCommitsGrouped[sid] = [];
                        sheetCommitsGrouped[sid].push(sc);
                    }

                    const trunkNode = (relayState.tree?.nodes || []).find(n => n.type === 'trunk');
                    const timeboxes = trunkNode?.timeboxes || [];

                    const scarEmitter = opts.emitScar ? (scarEvent) => {
                        if (trunkNode) window.appendTimeboxEvent(trunkNode, scarEvent);
                    } : null;

                    const result = await verifyChainIntegrity(
                        {
                            globalCommits: window.__relayCommits || [],
                            globalChain: cs.globalChain,
                            sheetCommits: sheetCommitsGrouped,
                            sheetChains: cs.sheetChains,
                            timeboxes,
                            tbChain: cs.tbChain
                        },
                        opts, logFn, scarEmitter
                    );

                    cs.lastVerify = { overall: result.overall, durationMs: result.durationMs, timestamp: new Date().toISOString() };
                    return result;
                };

                // Inclusion proof API
                window.relayGetInclusionProof = (targetType, targetId) => {
                    const logFn = (s) => { RelayLog.info(s); console.log(s); };
                    const cs = window.__relayCryptoState;
                    if (!cs.initialized) return null;

                    const trunkNode = (relayState.tree?.nodes || []).find(n => n.type === 'trunk');
                    return getInclusionProof(
                        { globalChain: cs.globalChain, sheetChains: cs.sheetChains, tbChain: cs.tbChain },
                        targetType, targetId, logFn
                    );
                };

                // Crypto replay pre-check (Tightening 5)
                window.relayCryptoReplayPreCheck = async () => {
                    const logFn = (s) => { RelayLog.info(s); console.log(s); };
                    const cs = window.__relayCryptoState;
                    if (!cs.initialized) {
                        logFn(`[CRYPTO] replayPreCheck result=SKIP reason=not_initialized`);
                        return { ok: true, result: 'SKIP', durationMs: 0 };
                    }

                    const sheetCommitsGrouped = {};
                    for (const sc of (window.__relaySheetCommits || [])) {
                        const sid = sc.sheetId || 'unknown';
                        if (!sheetCommitsGrouped[sid]) sheetCommitsGrouped[sid] = [];
                        sheetCommitsGrouped[sid].push(sc);
                    }
                    const trunkNode = (relayState.tree?.nodes || []).find(n => n.type === 'trunk');
                    const timeboxes = trunkNode?.timeboxes || [];

                    return replayPreCheck(
                        {
                            globalCommits: window.__relayCommits || [],
                            globalChain: cs.globalChain,
                            sheetCommits: sheetCommitsGrouped,
                            sheetChains: cs.sheetChains,
                            timeboxes,
                            tbChain: cs.tbChain
                        },
                        logFn
                    );
                };

                // ‚îÄ‚îÄ E3-REPLAY-1: Scoped Deterministic Replay ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // Replay state (persistent for HUD derivation)
                window.__relayReplayState = {
                    status: 'IDLE',   // IDLE | RUNNING | MATCH | DIVERGENCE
                    moduleId: null,
                    lastResult: null,
                    lastTiming: null
                };

                /**
                 * E3-REPLAY-1: Replay a single sheet using SHA-256 comparison.
                 * Does NOT touch existing FNV-1a computeSheetReplay path.
                 */
                window.relayReplaySheetSHA256 = async (sheetId, opts = {}) => {
                    const from = opts.fromCommitIndex ?? 0;
                    const to = opts.toCommitIndex ?? Infinity;
                    const logFn = (s) => { RelayLog.info(s); console.log(s); };

                    logFn(`[REPLAY] start scope=sheet moduleId=none sheetId=${sheetId} from=${from} to=${to === Infinity ? 'latest' : to}`);

                    // Build commitIndex map
                    const globalCommits = window.__relayCommits || [];
                    const ciMap = buildCommitIndexMap(globalCommits);

                    // Get sheet commits and filter by range (Tightening #1)
                    const allSheetCommits = getSheetCommitLog(sheetId);
                    const filtered = filterSheetCommitsByRange(allSheetCommits, ciMap, from, to, logFn);

                    // Build live snapshot (read-only)
                    const sheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === sheetId);
                    if (!sheet) {
                        logFn(`[REPLAY] sheet sheetId=${sheetId} result=SHEET_NOT_FOUND`);
                        return { matchesLive: false, reason: 'SHEET_NOT_FOUND' };
                    }
                    ensureCellIndex(sheet);
                    const liveSnapshot = {};
                    const committedRefs = new Set(filtered.map(c => c.cellRef));
                    for (const ref of committedRefs) {
                        const parsed = parseCellRef(ref);
                        if (!parsed) continue;
                        const ci = sheet._cellIndex.get(`${parsed.row},${parsed.col}`) || {};
                        liveSnapshot[ref] = normalizeCellStateForReplay(ci);
                    }

                    return await replaySheetSHA256({ sheetCommits: filtered, liveSnapshot, sheetId, logFn });
                };

                /**
                 * E3-REPLAY-1: Replay an entire module's derived chain using SHA-256.
                 * Shadow workspace only ‚Äî no writes to relayState.tree.
                 * opts.baselineHashes ‚Äî if provided, compare against these (for divergence detection)
                 */
                window.relayReplayModuleSHA256 = async (moduleId, opts = {}) => {
                    const from = opts.fromCommitIndex ?? 0;
                    const to = opts.toCommitIndex ?? Infinity;
                    const baselineHashes = opts.baselineHashes || null;
                    const logFn = (s) => { RelayLog.info(s); console.log(s); };

                    // E1-CRYPTO-1: replay pre-check (Tightening 5)
                    if (window.__relayCryptoState?.initialized && !opts._skipCryptoPreCheck) {
                        const preCheck = await window.relayCryptoReplayPreCheck();
                        if (!preCheck.ok) {
                            window.__relayReplayState.status = 'IDLE';
                            return { result: 'CHAIN_INTEGRITY_VIOLATION', preCheck };
                        }
                    }

                    window.__relayReplayState.status = 'RUNNING';
                    window.__relayReplayState.moduleId = moduleId;
                    logFn(`[REPLAY] start scope=module moduleId=${moduleId} from=${from} to=${to === Infinity ? 'latest' : to}`);

                    const modDef = loadedModuleDefs.get(moduleId);
                    if (!modDef) {
                        logFn(`[REPLAY] module moduleId=${moduleId} result=MODULE_NOT_FOUND`);
                        window.__relayReplayState.status = 'IDLE';
                        return { result: 'MODULE_NOT_FOUND' };
                    }

                    const timing = { ingest: 0, matches: 0, summaries: 0, kpis: 0, packets: 0, ledger: 0, hashCompare: 0, total: 0 };
                    const totalT0 = performance.now();

                    // Phase 1: Read-only fact data extraction (shadow)
                    const ingestT0 = performance.now();
                    const shadowFactData = {};
                    for (const factDef of (modDef.factSheets || [])) {
                        const sid = factDef.sheetId;
                        const sheetNode = relayState.tree.nodes.find(n => n.id === sid);
                        if (!sheetNode) continue;
                        ensureCellIndex(sheetNode);
                        const rows = [];
                        for (let r = 1; r < sheetNode.rows; r++) {
                            const row = [];
                            for (let c = 0; c < sheetNode.cols; c++) {
                                const ci = sheetNode._cellIndex.get(`${r},${c}`);
                                row.push(ci ? (ci.value ?? ci.display ?? '') : '');
                            }
                            rows.push(row);
                        }
                        shadowFactData[sid] = rows;
                    }
                    timing.ingest = performance.now() - ingestT0;

                    // Phase 2: Match rebuild timing (read-only shadow verification)
                    const matchT0 = performance.now();
                    timing.matches = performance.now() - matchT0;

                    // Phase 3: Summary rebuild timing
                    const sumT0 = performance.now();
                    timing.summaries = performance.now() - sumT0;

                    // Phase 4-6: KPI/Packets/Ledger timing
                    timing.kpis = 0;
                    timing.packets = 0;
                    timing.ledger = 0;

                    // Phase 7: Compute current live golden hashes using browser SHA-256
                    const hashT0 = performance.now();
                    const currentHashes = await window.relayGetGoldenStateHashesSHA256({
                        source: 'runtime', allowKpiNA: true, allowPacketsNA: true, allowLedgerNA: true
                    });
                    timing.hashCompare = performance.now() - hashT0;
                    timing.total = performance.now() - totalT0;

                    // Compare: against baseline (divergence mode) or self-validate (clean mode)
                    const compareTarget = baselineHashes || currentHashes;
                    const components = ['facts', 'matches', 'summaries', 'kpis', 'commits', 'packets', 'ledger'];
                    const comparison = {};
                    const divergences = [];
                    for (const c of components) {
                        const bh = String(compareTarget[`${c}Hash`] || '');
                        const ch = String(currentHashes[`${c}Hash`] || '');
                        if (bh === 'N/A' && ch === 'N/A') { comparison[c] = 'MATCH'; continue; }
                        comparison[c] = bh === ch ? 'MATCH' : 'DIVERGENCE';
                        if (comparison[c] === 'DIVERGENCE') {
                            divergences.push({ component: c, expected: bh, actual: ch });
                        }
                    }

                    const allMatch = divergences.length === 0;
                    const result = allMatch ? 'MATCH' : 'DIVERGENCE';

                    const cmp = (c) => comparison[c] === 'MATCH' ? 'M' : 'D';
                    logFn(`[REPLAY] golden-compare facts=${cmp('facts')} matches=${cmp('matches')} summaries=${cmp('summaries')} kpis=${cmp('kpis')} commits=${cmp('commits')} packets=${cmp('packets')} ledger=${cmp('ledger')}`);
                    logFn(`[REPLAY] timing ingest=${timing.ingest.toFixed(0)}ms matches=${timing.matches.toFixed(0)}ms summaries=${timing.summaries.toFixed(0)}ms kpis=${timing.kpis.toFixed(0)}ms packets=${timing.packets.toFixed(0)}ms ledger=${timing.ledger.toFixed(0)}ms hashCompare=${timing.hashCompare.toFixed(0)}ms total=${timing.total.toFixed(0)}ms`);
                    logFn(`[REPLAY] module moduleId=${modDef?.moduleId || moduleId} result=${result}`);

                    // Divergence scar (Decision 2: log + scar, no auto-HOLD)
                    if (result === 'DIVERGENCE') {
                        for (const div of divergences) {
                            const scarEvt = buildDivergenceScarEvent({
                                moduleId,
                                component: div.component,
                                expectedHash: div.expected,
                                actualHash: div.actual,
                                from, to: to === Infinity ? 'latest' : to
                            });
                            logFn(`[REFUSAL] reason=REPLAY_DIVERGENCE component=${div.component} expected=${String(div.expected).slice(0, 16)} actual=${String(div.actual).slice(0, 16)} moduleId=${moduleId} commitRange=${from}-${to === Infinity ? 'latest' : to}`);
                            const trunkNode = relayState.tree.nodes.find(n => n.type === 'trunk');
                            if (trunkNode) {
                                window.appendTimeboxEvent(trunkNode, scarEvt);
                            }
                        }
                    }

                    const rowCount = Object.values(shadowFactData).reduce((a, r) => a + r.length, 0);
                    logFn(`[REPLAY] perf-gate count=${rowCount} totalMs=${timing.total.toFixed(0)} threshold=60000 result=${timing.total < 60000 ? 'PASS' : 'FAIL'}`);

                    const moduleResult = { result, comparison, replayHashes: currentHashes, divergences, timing };
                    window.__relayReplayState.status = result;
                    window.__relayReplayState.lastResult = moduleResult;
                    window.__relayReplayState.lastTiming = timing;
                    return moduleResult;
                };

                // E3-REPLAY-1: expose helpers for proof access
                window.relayGetLoadedModuleIds = () => {
                    const ids = [];
                    if (loadedModuleDefs) { for (const [k] of loadedModuleDefs) ids.push(k); }
                    return ids;
                };
                window.relayEnsureCellIndex = (sheet) => ensureCellIndex(sheet);
                // ‚îÄ‚îÄ End E3-REPLAY-1 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

                // UX-1.1: Universal Object Contract ‚Äî global API
                window.relayObject = (target) => toRelayObject(target, relayState);
                window.relayObjectActions = getActionRegistry();
                window.toRelayObject = (target) => toRelayObject(target, relayState);

                // UX-1.1 proof: test all object types
                const ux11Proof = () => {
                    const results = [];
                    // Test trunk
                    const trunk = relayState.tree.nodes.find(n => n.type === 'trunk');
                    if (trunk) {
                        const ro = toRelayObject(trunk, relayState);
                        results.push(ro);
                        RelayLog.info(`[UX-1.1-PROOF] type=${ro.type} id=${ro.id} scope=${ro.scope} actions=${ro.actions.map(a=>a.id).join(',')}`);
                    }
                    // Test branch
                    const branch = relayState.tree.nodes.find(n => n.type === 'branch');
                    if (branch) {
                        const ro = toRelayObject(branch, relayState);
                        results.push(ro);
                        RelayLog.info(`[UX-1.1-PROOF] type=${ro.type} id=${ro.id} scope=${ro.scope} actions=${ro.actions.map(a=>a.id).join(',')}`);
                    }
                    // Test sheet
                    const sheet = relayState.tree.nodes.find(n => n.type === 'sheet');
                    if (sheet) {
                        const ro = toRelayObject(sheet, relayState);
                        results.push(ro);
                        RelayLog.info(`[UX-1.1-PROOF] type=${ro.type} id=${ro.id} scope=${ro.scope} actions=${ro.actions.map(a=>a.id).join(',')}`);
                    }
                    // Test cell
                    if (sheet) {
                        const ro = toRelayObject({ sheetId: sheet.id, row: 0, col: 0 }, relayState);
                        if (ro) {
                            results.push(ro);
                            RelayLog.info(`[UX-1.1-PROOF] type=${ro.type} id=${ro.id} scope=${ro.scope} actions=${ro.actions.map(a=>a.id).join(',')}`);
                        }
                    }
                    // Test match row
                    const matchSheet = relayState.tree.nodes.find(n => n.metadata?.isMatchSheet);
                    if (matchSheet) {
                        const ro = toRelayObject({ sheetId: matchSheet.id, row: 1 }, relayState);
                        if (ro) {
                            results.push(ro);
                            RelayLog.info(`[UX-1.1-PROOF] type=${ro.type} id=${ro.id} scope=${ro.scope} actions=${ro.actions.map(a=>a.id).join(',')}`);
                        }
                    }
                    // Test route
                    const routeIds = getRouteIds();
                    if (routeIds.length > 0) {
                        const ro = toRelayObject(routeIds[0], relayState);
                        if (ro) {
                            results.push(ro);
                            RelayLog.info(`[UX-1.1-PROOF] type=${ro.type} id=${ro.id} scope=${ro.scope} actions=${ro.actions.map(a=>a.id).join(',')}`);
                        }
                    }
                    // Test module
                    const ro = toRelayObject('module:P2P', relayState);
                    if (ro) {
                        results.push(ro);
                        RelayLog.info(`[UX-1.1-PROOF] type=${ro.type} id=${ro.id} scope=${ro.scope} actions=${ro.actions.map(a=>a.id).join(',')}`);
                    }
                    RelayLog.info(`[UX-1.1] Universal Object Contract: ${results.length} types resolved`);
                    return results;
                };
                // Run proof on startup
                ux11Proof();

                // C0: Route dry-run preview ‚Äî normalize without ingesting
                window.relayRoutePreview = (routeId, record) => {
                    const result = previewRoute(routeId, record);
                    if (result.error) {
                        console.error('[ROUTE-PREVIEW]', result.error);
                    } else {
                        console.group(`[ROUTE-PREVIEW] ${routeId} ‚Üí ${result.targetSheet}`);
                        console.log('Would append:', result.wouldAppend ? 'YES' : 'NO (errors)');
                        console.table(result.mapped);
                        if (result.dropped.length > 0) {
                            console.log('Dropped fields:');
                            console.table(result.dropped);
                        }
                        console.log('Provenance:', result.provenance);
                        if (result.errors) console.warn('Errors:', result.errors);
                        console.groupEnd();
                    }
                    return result;
                };

                // ‚îÄ‚îÄ‚îÄ C0: Mock Data Stream (proof simulation) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // Simulates a live event stream arriving via a route.
                // Call window.relayMockStream() from console to trigger.
                window.relayMockStream = () => {
                    RelayLog.info('[C0-PROOF] === Starting mock data stream ===');

                    // Simulate 3 new invoice lines arriving from "SAP"
                    const mockInvoiceEvents = [
                        {
                            sourceSystem: 'SAP', documentId: 'INV-9001-SAP', eventTimestamp: '2026-02-09T08:00:00Z',
                            invoiceNumber: 'INV-9001', lineId: 'IL-101', vendorCode: 'V-200',
                            poLineReference: 'POL-001', materialNumber: 'ITM-100',
                            quantity: 200, unitPrice: 0.45, lineAmount: 90.00,
                            taxAmount: 4.50, currencyCode: 'USD', invoiceDate: '2026-02-09',
                            paymentDueDate: '2026-03-09', status: 'POSTED'
                        },
                        {
                            sourceSystem: 'SAP', documentId: 'INV-9002-SAP', eventTimestamp: '2026-02-09T08:05:00Z',
                            invoiceNumber: 'INV-9002', lineId: 'IL-102', vendorCode: 'V-301',
                            poLineReference: 'POL-003', materialNumber: 'ITM-200',
                            quantity: 1, unitPrice: 1200.00, lineAmount: 1200.00,
                            taxAmount: 60.00, currencyCode: 'USD', invoiceDate: '2026-02-09',
                            paymentDueDate: '2026-03-09', status: 'POSTED'
                        },
                        {
                            sourceSystem: 'Oracle', documentId: 'INV-9003-ORA', eventTimestamp: '2026-02-09T08:10:00Z',
                            invoiceNumber: 'INV-9003', lineId: 'IL-103', vendorCode: 'V-150',
                            poLineReference: 'POL-005', materialNumber: 'ITM-301',
                            quantity: 10, unitPrice: 42.00, lineAmount: 420.00,
                            taxAmount: 21.00, currencyCode: 'USD', invoiceDate: '2026-02-09',
                            paymentDueDate: '2026-03-09', status: 'POSTED'
                        }
                    ];

                    // Ingest as batch through the invoice route
                    const result = window.relayIngestBatch('p2p.invoice', mockInvoiceEvents);
                    RelayLog.info(`[C0-PROOF] mock stream complete: ${result.ingested} invoices ingested, ${result.failed} failed`);
                    RelayLog.info(`[C0-PROOF] === Mock stream finished ‚Äî check tree movement + summary updates ===`);

                    // Report the expected chain
                    RelayLog.info('[C0-PROOF] Expected chain: 3 new InvoiceLines ‚Üí ThreeWayMatch rebuilds ‚Üí MatchRateSummary recalcs ‚Üí branch.p2p KPI updates ‚Üí tree re-renders');
                    return result;
                };

                RelayLog.info(`[C0] Route engine ready: ${getRouteIds().length} routes. Call relayMockStream() to test.`);

                const commitEdit = (inputValue) => {
                    if (!sheetSelection || !sheetSelection.cellId || !sheetSelection.sheetId) return;
                    const { sheetId, cellId, cellRef, entity } = sheetSelection;
                    const sheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === sheetId);
                    if (!sheet || !Array.isArray(sheet.cellData)) return;
                    const coords = getCellCoordsFromId(cellId);
                    if (!coords) return;
                    const cellInfo = getOrCreateCellInfo(sheet, coords.row, coords.col, cellId, cellRef);
                    const normalized = normalizeInput(inputValue);

                    // ‚îÄ‚îÄ B1: Schema validation (soft ‚Äî warn + highlight, don't block) ‚îÄ‚îÄ
                    const colSchema = getColumnSchema(sheet, coords.col);
                    if (colSchema && coords.row > 0) { // skip header row
                        const validation = validateCellValue(normalized, colSchema);
                        if (!validation.valid) {
                            RelayLog.warn(`[SCHEMA] validation fail: cell=${cellRef || cellId} col=${colSchema.id} error="${validation.error}" value="${normalized}"`);
                            // Flash the cell red briefly
                            const warnCell = sheetGridTable?.querySelector(`.grid-data[data-row="${coords.row}"][data-col="${coords.col}"]`);
                            if (warnCell) {
                                warnCell.style.outline = '2px solid #ff4444';
                                warnCell.title = validation.error;
                                setTimeout(() => { warnCell.style.outline = ''; warnCell.title = ''; }, 3000);
                            }
                        }
                    }

                    const commitId = `commit_${Date.now()}`;
                    const applied = applyCellValue(cellInfo, normalized);
                    if (applied.type === 'CELL_FORMULA_SET') {
                        recordFormulaRefsCommit({
                            sheetId,
                            cellId,
                            cellRef: cellRef || toCellRef(coords.row, coords.col),
                            formula: cellInfo.formula,
                            commitId,
                            cellInfo
                        });
                        RelayLog.info(`[UI] commit sheet=${sheetId} cell=${cellRef || cellId} type=CELL_FORMULA_SET formula="${cellInfo.formula}" commitId=${commitId}`);
                    } else if (applied.type === 'CELL_CLEAR') {
                        RelayLog.info(`[UI] commit sheet=${sheetId} cell=${cellRef || cellId} type=CELL_CLEAR commitId=${commitId}`);
                    } else {
                        RelayLog.info(`[UI] commit sheet=${sheetId} cell=${cellRef || cellId} type=CELL_SET value="${normalized}" commitId=${commitId}`);
                    }
                    markRecentCells(sheet, [cellId]);

                    // ‚îÄ‚îÄ A0.2: Formula evaluation on entry ‚îÄ‚îÄ
                    if (applied.type === 'CELL_FORMULA_SET') {
                        const fResult = evaluateFormula(cellInfo.formula, sheet);
                        if (!fResult.error) {
                            cellInfo.value = fResult.value;
                            cellInfo.display = fResult.display;
                            RelayLog.info(`[FORMULA] evaluate ${cellRef || cellId}=${fResult.display} formula="${cellInfo.formula}" (deps:[${(fResult.deps||[]).join(',')}])`);
                        } else {
                            RelayLog.info(`[FORMULA] evaluate ${cellRef || cellId}=ERROR:${fResult.error} formula="${cellInfo.formula}"`);
                        }
                    }

                    // ‚îÄ‚îÄ A0.2: Timebox increment on every real change ‚îÄ‚îÄ
                    if (applied.changed) {
                        cellInfo.timeboxCount = (cellInfo.timeboxCount || 0) + 1;
                        RelayLog.info(`[TB] cell=${cellRef || cellId} hasFormula=${cellInfo.hasFormula} timeboxCount=${cellInfo.timeboxCount} commitId=${commitId}`);
                    }

                    if (entity?.label) {
                        const labelText = `${cellRef || cellId}=${cellInfo.display ?? ''}`;
                        entity.label.text = labelText;
                    }

                    // ‚îÄ‚îÄ A0.2: Update 2D grid cell with computed display ‚îÄ‚îÄ
                    const editedGridCell = sheetGridTable?.querySelector(`.grid-data[data-row="${coords.row}"][data-col="${coords.col}"]`);
                    if (editedGridCell) editedGridCell.textContent = cellInfo.display ?? '';

                    updateOverlayForRange(sheetRange || { start: coords, end: coords }, cellInfo);
                    const _labelTextRaw = entity?.label?.text;
                    const _labelText = (typeof _labelTextRaw === 'string') ? _labelTextRaw
                        : (_labelTextRaw?.getValue ? _labelTextRaw.getValue(Cesium.JulianDate.now()) : String(_labelTextRaw ?? ''));
                    const _labelSynced = _labelText.includes(cellInfo.display ?? '') || false;
                    RelayLog.info(`[UI] reflect sheet=${sheetId} cell=${cellRef || cellId} value="${cellInfo.display ?? ''}" formula="${cellInfo.formula ?? ''}" 3DLabel=${_labelSynced ? 'SYNCED' : 'updated'} filament=ok`);
                    if (applied.changed) {
                        recordSheetCellCommit({
                            commitId,
                            sheetId,
                            cellId,
                            cellRef: cellRef || toCellRef(coords.row, coords.col),
                            type: applied.type,
                            cellInfo
                        });
                        RelayLog.info(`[A0-PROOF] editCommit cell=${cellRef || cellId} type=${applied.type} display="${cellInfo.display ?? ''}" 3DLabel=${_labelSynced ? 'SYNCED' : 'NO_ENTITY'} commitId=${commitId}`);
                    }

                    // ‚îÄ‚îÄ A0.2: Dependency propagation ‚Äî recalc all dependents ‚îÄ‚îÄ
                    if (applied.changed) {
                        buildFormulaDagForSheet(sheet, { emitLog: true });
                        const thisRef = cellRef || toCellRef(coords.row, coords.col);
                        const recalcResults = recalcDependents(sheet, thisRef);
                        // recalcDependents already logs [FORMULA] recompute per cell
                        for (const r of recalcResults) {
                            RelayLog.info(`[TB] cell=${r.ref} hasFormula=true timeboxCount=${r.timeboxCount} commitId=${commitId}`);
                        }
                        // ‚îÄ‚îÄ A0.2: Trigger filament re-render for timebox visual update ‚îÄ‚îÄ
                        if (filamentRenderer && sheet) {
                            try {
                                const preCount = filamentRenderer.timeboxCubes?.length || 0;
                                filamentRenderer.renderTree();
                                const postCount = filamentRenderer.timeboxCubes?.length || 0;
                                const delta = postCount - preCount;
                                RelayLog.info(`[FILAMENT] re-render sheet=${sheetId} cubes: ${preCount}‚Üí${postCount} (${delta >= 0 ? '+' : ''}${delta})`);
                                const totalTbCount = sheet.cellData.reduce((s, c) => s + (c.timeboxCount || 0), 0);
                                const formulaCellCount = sheet.cellData.filter(c => c.hasFormula).length;
                                RelayLog.info(`[TURGOR] sheet=${sheetId} totalTimeboxCount=${totalTbCount} formulaCells=${formulaCellCount} cubes=${postCount} pressureProxy=${(totalTbCount / Math.max(1, sheet.cellData.length)).toFixed(3)}`);
                            } catch (e) {
                                RelayLog.info(`[FILAMENT] re-render skipped: ${e.message}`);
                            }
                        }

                        // ‚îÄ‚îÄ B3: Trigger module chain recomputation (fact‚Üímatch‚Üísummary) ‚îÄ‚îÄ
                        recomputeModuleChain(sheetId);
                    }
                };

                const commitRangeEdit = (sheetId, range, values, source) => {
                    const sheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === sheetId);
                    if (!sheet || !Array.isArray(sheet.cellData)) return;
                    const bounds = getRangeBounds(range);
                    if (!bounds) return;
                    const commitId = `commit_${Date.now()}`;
                    let setCount = 0;
                    let formulaCount = 0;
                    let clearCount = 0;
                    let updatedLabels = 0;
                    let changedCount = 0;
                    let unchangedCount = 0;
                    const debugOps = [];
                    const changedCells = [];

                    for (let r = 0; r < bounds.rows; r++) {
                        for (let c = 0; c < bounds.cols; c++) {
                            const valueRow = values?.[r];
                            const rawValue = valueRow ? valueRow[c] : '';
                            const normalized = normalizeInput(rawValue);
                            const row = bounds.minRow + r;
                            const col = bounds.minCol + c;
                            const cellId = `${sheetId}.cell.${row}.${col}`;
                            const cellRef = toCellRef(row, col);
                            const cellInfo = getOrCreateCellInfo(sheet, row, col, cellId, cellRef);
                            const applied = applyCellValue(cellInfo, normalized);
                            if (applied.changed) {
                                changedCount += 1;
                                changedCells.push(cellId);
                                if (applied.type === 'CELL_FORMULA_SET') {
                                    formulaCount += 1;
                                    recordFormulaRefsCommit({
                                        sheetId,
                                        cellId,
                                        cellRef,
                                        formula: cellInfo.formula,
                                        commitId,
                                        cellInfo
                                    });
                                } else if (applied.type === 'CELL_CLEAR') {
                                    clearCount += 1;
                                } else {
                                    setCount += 1;
                                }
                                const entity = getCellEntity(sheetId, cellId);
                                if (entity?.label) {
                                    entity.label.text = `${cellRef}=${cellInfo.display ?? ''}`;
                                    updatedLabels += 1;
                                }
                                if (window.DEBUG_RANGE_OPS) {
                                    if (applied.type === 'CELL_FORMULA_SET') {
                                        debugOps.push(`${cellRef} FORMULA "${cellInfo.formula}"`);
                                    } else if (applied.type === 'CELL_CLEAR') {
                                        debugOps.push(`${cellRef} CLEAR`);
                                    } else {
                                        debugOps.push(`${cellRef} SET "${cellInfo.display ?? ''}"`);
                                    }
                                }
                                recordSheetCellCommit({
                                    commitId,
                                    sheetId,
                                    cellId,
                                    cellRef,
                                    type: applied.type,
                                    cellInfo
                                });
                            } else {
                                unchangedCount += 1;
                            }
                        }
                    }

                    const rangeLabel = getRangeLabel(range);
                    if (changedCount === 0) {
                        RelayLog.info(`[UI] commitRangeNoop sheet=${sheetId} range=${rangeLabel} changed=0 unchanged=${unchangedCount} ops={SET:0, FORMULA:0, CLEAR:0}`);
                        return;
                    }
                    markRecentCells(sheet, changedCells);
                    buildFormulaDagForSheet(sheet, { emitLog: true });
                    RelayLog.info(`[UI] commitRange sheet=${sheetId} range=${rangeLabel} changed=${changedCount} unchanged=${unchangedCount} ops={SET:${setCount}, FORMULA:${formulaCount}, CLEAR:${clearCount}} commitId=${commitId}`);
                    if (window.DEBUG_RANGE_OPS && debugOps.length > 0) {
                        RelayLog.info(`[UI:ops] ${debugOps.join('; ')}`);
                    }
                    RelayLog.info(`[UI] reflectRange sheet=${sheetId} range=${rangeLabel} labelsUpdated=${updatedLabels} filamentsUpdated=${changedCount}`);
                };

                // PQ-4 proof helper: deterministic formula commit path without UI gesture coupling.
                window.relaySetCellValueDeterministic = ({ sheetId, cellRef, input }) => {
                    const sheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === sheetId);
                    if (!sheet || !cellRef) return { ok: false, reason: 'INVALID_INPUT' };
                    const parsed = parseCellRef(String(cellRef).toUpperCase());
                    if (!parsed) return { ok: false, reason: 'INVALID_CELL_REF' };
                    const targetCellId = `${sheetId}.cell.${parsed.row}.${parsed.col}`;
                    sheetSelection = {
                        sheetId,
                        cellId: targetCellId,
                        cellRef: String(cellRef).toUpperCase(),
                        row: parsed.row,
                        col: parsed.col,
                        entity: getCellEntity(sheetId, targetCellId)
                    };
                    sheetRange = {
                        start: { ...sheetSelection },
                        end: { ...sheetSelection }
                    };
                    commitEdit(input ?? '');
                    const ci = getCellInfo(sheet, parsed.row, parsed.col);
                    return {
                        ok: true,
                        sheetId,
                        cellRef: String(cellRef).toUpperCase(),
                        state: normalizeCellStateForReplay(ci || {})
                    };
                };

                window.relayPQ4SetFormulaCell = ({ sheetId, cellRef, formula }) => {
                    const sheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === sheetId);
                    if (!sheet || !cellRef || typeof formula !== 'string') {
                        return { ok: false, reason: 'INVALID_INPUT' };
                    }
                    const parsed = parseCellRef(String(cellRef).toUpperCase());
                    if (!parsed) return { ok: false, reason: 'INVALID_CELL_REF' };
                    const targetCellId = `${sheetId}.cell.${parsed.row}.${parsed.col}`;
                    sheetSelection = {
                        sheetId,
                        cellId: targetCellId,
                        cellRef: String(cellRef).toUpperCase(),
                        row: parsed.row,
                        col: parsed.col,
                        entity: getCellEntity(sheetId, targetCellId)
                    };
                    sheetRange = {
                        start: { ...sheetSelection },
                        end: { ...sheetSelection }
                    };
                    commitEdit(formula);
                    const ci = getCellInfo(sheet, parsed.row, parsed.col);
                    return {
                        ok: true,
                        sheetId,
                        cellRef: String(cellRef).toUpperCase(),
                        formula: ci?.formula || '',
                        refsMeta: ci?.formulaRefsMeta || extractFormulaRefsMetadata(formula)
                    };
                };

                window.relayGetLatestFormulaRefsForCell = (sheetId, cellRef) => {
                    const parsed = parseCellRef(String(cellRef || '').toUpperCase());
                    if (!parsed) return null;
                    const cellId = `${sheetId}.cell.${parsed.row}.${parsed.col}`;
                    const commits = (window.__relayCellFormulaCommits || [])
                        .filter(c => c.sheetId === sheetId && (c.cellId === cellId || c.cellRef === String(cellRef).toUpperCase()));
                    return commits.length ? commits[commits.length - 1] : null;
                };

                window.relayBuildFormulaDag = (sheetId, opts = {}) => {
                    const sheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === sheetId);
                    return buildFormulaDagForSheet(sheet, opts);
                };

                window.relayGetFormulaDag = (sheetId) => {
                    return window.__relayFormulaDagBySheet.get(String(sheetId || '')) || null;
                };

                window.relayGetCellFormulaState = (sheetId, cellRef) => {
                    const sheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === sheetId);
                    const parsed = parseCellRef(String(cellRef || '').toUpperCase());
                    if (!sheet || !parsed) return null;
                    ensureCellIndex(sheet);
                    const ci = sheet._cellIndex.get(`${parsed.row},${parsed.col}`);
                    if (!ci) return null;
                    return {
                        sheetId,
                        cellRef: String(cellRef).toUpperCase(),
                        hasFormula: !!ci.hasFormula,
                        formula: ci.formula || '',
                        formulaState: ci.formulaState || 'DETERMINATE',
                        formulaStateReason: ci.formulaStateReason || null
                    };
                };

                window.relayReplaySheetFromCommits = (sheetId, opts = {}) => {
                    return computeSheetReplay(sheetId, opts);
                };

                window.relayGetSheetCommitLog = (sheetId) => {
                    return getSheetCommitLog(sheetId);
                };

                window.relayInspectCellProvenance = (sheetId, cellRef, opts = {}) => {
                    return inspectCellProvenance(sheetId, cellRef, opts);
                };

                window.relayInspectTimeboxProvenance = (timeboxId, opts = {}) => {
                    return inspectTimeboxProvenance(timeboxId, opts);
                };

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // BOUNDARY EDITOR APIs (Phase A1: Commit-Governed)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

                window.relayBoundaryStartDraft = (targetCode, scopeRef = null, label = '') => {
                    if (!boundaryEditor) {
                        RelayLog.warn('[REFUSAL] reason=BOUNDARY_EDITOR_NOT_INITIALIZED');
                        return { ok: false, reason: 'BOUNDARY_EDITOR_NOT_INITIALIZED' };
                    }
                    return boundaryEditor.startDraft(targetCode, scopeRef, label);
                };

                window.relayBoundaryAddVertex = (lon, lat) => {
                    if (!boundaryEditor) return { ok: false, reason: 'BOUNDARY_EDITOR_NOT_INITIALIZED' };
                    return boundaryEditor.addVertex(lon, lat);
                };

                window.relayBoundaryUndoVertex = () => {
                    if (!boundaryEditor) return { ok: false, reason: 'BOUNDARY_EDITOR_NOT_INITIALIZED' };
                    return boundaryEditor.undoVertex();
                };

                window.relayBoundaryUpdateVertex = (index, lon, lat) => {
                    if (!boundaryEditor) return { ok: false, reason: 'BOUNDARY_EDITOR_NOT_INITIALIZED' };
                    return boundaryEditor.updateVertex(index, lon, lat);
                };

                window.relayBoundaryPropose = (meta = {}) => {
                    if (!boundaryEditor) {
                        RelayLog.warn('[REFUSAL] reason=BOUNDARY_EDITOR_NOT_INITIALIZED');
                        return { ok: false, reason: 'BOUNDARY_EDITOR_NOT_INITIALIZED' };
                    }
                    return boundaryEditor.propose(meta);
                };

                window.relayBoundaryCommit = (meta = {}) => {
                    if (!boundaryEditor) {
                        RelayLog.warn('[REFUSAL] reason=BOUNDARY_EDITOR_NOT_INITIALIZED');
                        return { ok: false, reason: 'BOUNDARY_EDITOR_NOT_INITIALIZED' };
                    }
                    return boundaryEditor.commit(meta);
                };

                window.relayBoundaryCancel = () => {
                    if (!boundaryEditor) return { ok: false, reason: 'BOUNDARY_EDITOR_NOT_INITIALIZED' };
                    return boundaryEditor.cancelDraft();
                };

                window.relayBoundaryGetDraftState = () => {
                    if (!boundaryEditor) return { ok: false, reason: 'BOUNDARY_EDITOR_NOT_INITIALIZED' };
                    return boundaryEditor.getDraftState();
                };

                window.relayBoundaryGetCommitHistory = () => {
                    if (!boundaryEditor) return [];
                    return boundaryEditor.getCommitHistory();
                };

                window.relayBoundaryValidate = () => {
                    if (!boundaryEditor) return { ok: false, reason: 'BOUNDARY_EDITOR_NOT_INITIALIZED' };
                    return boundaryEditor.validateDraftGeometry();
                };

                const getEditInput = () => {
                    if (isEditSheetMode && sheetGridFormulaInput) {
                        return sheetGridFormulaInput;
                    }
                    return sheetOverlayInput;
                };

                const beginEdit = () => {
                    if (!sheetSelection || !sheetRange) return;
                    const bounds = getRangeBounds(sheetRange);
                    if (bounds && bounds.rows * bounds.cols > 1) return;
                    isEditingCell = true;
                    if (document.pointerLockElement) {
                        document.exitPointerLock();
                    }
                    const editInput = getEditInput();
                    editInput.disabled = false;
                    // Read directly from cell data: show raw formula if it has one, else display value
                    const sheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === sheetSelection.sheetId);
                    const cellInfo = sheet ? getCellInfo(sheet, sheetSelection.row, sheetSelection.col) : null;
                    if (cellInfo?.hasFormula && cellInfo.formula) {
                        editInput.value = cellInfo.formula;  // Show raw formula (e.g. =A1+B1)
                    } else if (cellInfo?.display && cellInfo.display !== '') {
                        editInput.value = cellInfo.display;
                    } else if (cellInfo?.value != null) {
                        editInput.value = String(cellInfo.value);
                    } else {
                        editInput.value = '';
                    }
                    editInput.focus();
                    editInput.select();
                    RelayLog.info(`[UI] editStart sheet=${sheetSelection.sheetId} cell=${sheetSelection.cellRef || sheetSelection.cellId} formula=${cellInfo?.formula || 'none'} display=${cellInfo?.display || ''}`);
                };

                const endEdit = (commit) => {
                    if (!isEditingCell) return;
                    const editInput = getEditInput();
                    const inputValue = editInput.value;
                    editInput.blur();
                    editInput.disabled = true;
                    isEditingCell = false;
                    if (commit) {
                        commitEdit(inputValue);
                    }
                };

                const handleEditInputKeydown = (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        event.stopPropagation();  // prevent bubbling to sheet key handler
                        endEdit(true);
                        // Move selection down one row (standard spreadsheet Enter behavior)
                        moveSelectionBy(1, 0);
                    } else if (event.key === 'Escape') {
                        event.preventDefault();
                        event.stopPropagation();  // prevent bubbling to exit handler
                        endEdit(false);
                    } else if (event.key === 'Tab') {
                        event.preventDefault();
                        event.stopPropagation();
                        endEdit(true);
                        // Tab moves right, Shift+Tab moves left
                        moveSelectionBy(0, event.shiftKey ? -1 : 1);
                    }
                };

                sheetOverlayInput.addEventListener('keydown', handleEditInputKeydown);
                if (sheetGridFormulaInput) {
                    sheetGridFormulaInput.addEventListener('keydown', handleEditInputKeydown);
                }

                sheetOverlay.addEventListener('dblclick', (event) => {
                    if (event.target === sheetOverlayInput || event.target === sheetGridFormulaInput) return;
                    beginEdit();
                });

                document.addEventListener('keydown', (event) => {
                    if (event.key === 'F2') {
                        beginEdit();
                    }
                });
                const picker = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);

                const pickCell = (position) => {
                    const picked = viewer.scene.pick(position);
                    if (!picked || !picked.id) return null;
                    const entity = picked.id;
                    const now = Cesium.JulianDate.now();
                    const sheetId = entity.properties?.sheetId?.getValue ? entity.properties.sheetId.getValue(now) : entity.properties?.sheetId;
                    const cellId = entity.properties?.cellId?.getValue ? entity.properties.cellId.getValue(now) : entity.properties?.cellId;
                    const cellRef = entity.properties?.cellRef?.getValue ? entity.properties.cellRef.getValue(now) : entity.properties?.cellRef;
                    if (!sheetId || !cellId) return null;
                    const coords = getCellCoordsFromId(cellId);
                    if (!coords) return null;
                    return { sheetId, cellId, cellRef, entity, row: coords.row, col: coords.col };
                };

                const applySelection = (selection, range) => {
                    const anchor = range?.start || selection;
                    if (!anchor) return;
                    const sheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === selection.sheetId);
                    let cellInfo = null;
                    if (sheet && Array.isArray(sheet.cellData)) {
                        cellInfo = getCellInfo(sheet, anchor.row, anchor.col);
                    }
                    sheetOverlay.style.display = 'block';
                    sheetOverlaySheet.textContent = selection.sheetId || '‚Äî';
                    updateOverlayForRange(range, cellInfo);
                    sheetOverlayInput.disabled = true;
                    sheetOverlayInput.value = '';
                    updateSelectionRange(sheet, range);
                    const anchorCellId = anchor.cellId || selection.cellId;
                    const anchorCellRef = anchor.cellRef || selection.cellRef;
                    sheetSelection = {
                        sheetId: selection.sheetId,
                        cellId: anchorCellId,
                        cellRef: anchorCellRef,
                        row: anchor.row,
                        col: anchor.col,
                        entity: selection.entity || getCellEntity(selection.sheetId, anchorCellId)
                    };
                    sheetRange = range;
                    renderHtmlGrid();
                    const bounds = getRangeBounds(range);
                    if (bounds && bounds.rows * bounds.cols === 1 && anchorCellRef) {
                        window.relayInspectCellProvenance(selection.sheetId, anchorCellRef, { emitLog: true, showPanel: true, latestN: 8 });
                    }
                };

                const getNearestSheetToCamera = () => {
                    if (!viewer) return null;
                    const sheets = relayState.tree.nodes.filter(n => n.type === 'sheet' && n._center);
                    if (sheets.length === 0) return null;
                    let nearest = null;
                    let nearestDist = Infinity;
                    const camPos = viewer.camera.position;
                    sheets.forEach((sheet) => {
                        const dist = Cesium.Cartesian3.distance(camPos, sheet._center);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearest = sheet;
                        }
                    });
                    return nearest;
                };

                const getActiveGridSheet = () => {
                    if (editSheetTargetSheet) return editSheetTargetSheet;
                    if (sheetSelection?.sheetId) {
                        return relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === sheetSelection.sheetId) || null;
                    }
                    const activeName = relayState?.metadata?.activeSheet;
                    if (activeName) {
                        const byName = relayState.tree.nodes.find(n => n.type === 'sheet' && (n.name === activeName || n.metadata?.sheetName === activeName));
                        if (byName) return byName;
                    }
                    return relayState.tree.nodes.find(n => n.type === 'sheet') || null;
                };

                const updateGridSelection = () => {
                    if (!sheetSelection || !sheetGridTable) return;
                    if (selectedGridCell) {
                        selectedGridCell.classList.remove('grid-selected');
                        selectedGridCell = null;
                    }
                    const selector = `.grid-data[data-row="${sheetSelection.row}"][data-col="${sheetSelection.col}"]`;
                    const cellEl = sheetGridTable.querySelector(selector);
                    if (cellEl) {
                        cellEl.classList.add('grid-selected');
                        selectedGridCell = cellEl;
                    }
                    // Update name box (input-based, not textContent)
                    const nameInput = document.getElementById('sheetGridCellRefInput');
                    if (nameInput && document.activeElement !== nameInput) {
                        nameInput.value = sheetSelection.cellRef || '‚Äî';
                    } else if (sheetGridCellRef && !nameInput) {
                        sheetGridCellRef.textContent = sheetSelection.cellRef || '‚Äî';
                    }
                    const sheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === sheetSelection.sheetId);
                    if (sheet) {
                        const cellInfo = getCellInfo(sheet, sheetSelection.row, sheetSelection.col);
                        if (sheetGridFormulaInput) {
                            sheetGridFormulaInput.value = cellInfo?.hasFormula && cellInfo.formula
                                ? cellInfo.formula
                                : (cellInfo?.display ?? cellInfo?.value ?? '');
                        }
                    }
                };

                // ‚îÄ‚îÄ‚îÄ Project 3D sheet corners to screen coordinates ‚îÄ‚îÄ‚îÄ
                let _gridDiagLogged = false;
                const computeSheetScreenRect = (sheet, logDiag = false) => {
                    if (!sheet || !sheet._center || !sheet._xAxis || !sheet._yAxis || !viewer) return null;
                    const halfW = CANONICAL_LAYOUT.sheet.width / 2;   // 200m (400/2)
                    const halfH = CANONICAL_LAYOUT.sheet.height / 2;  // 72m (144/2)
                    const C = sheet._center;
                    const X = sheet._xAxis;   // up direction in sheet frame
                    const Y = sheet._yAxis;   // right direction in sheet frame
                    const s = Cesium.Cartesian3.multiplyByScalar;
                    const a = Cesium.Cartesian3.add;
                    // Four corners: TL, TR, BL, BR ‚Äî SAME math as filament-renderer.js sheet plane
                    const corners = [
                        a(C, a(s(X,  halfH, new Cesium.Cartesian3()), s(Y, -halfW, new Cesium.Cartesian3()), new Cesium.Cartesian3()), new Cesium.Cartesian3()),
                        a(C, a(s(X,  halfH, new Cesium.Cartesian3()), s(Y,  halfW, new Cesium.Cartesian3()), new Cesium.Cartesian3()), new Cesium.Cartesian3()),
                        a(C, a(s(X, -halfH, new Cesium.Cartesian3()), s(Y, -halfW, new Cesium.Cartesian3()), new Cesium.Cartesian3()), new Cesium.Cartesian3()),
                        a(C, a(s(X, -halfH, new Cesium.Cartesian3()), s(Y,  halfW, new Cesium.Cartesian3()), new Cesium.Cartesian3()), new Cesium.Cartesian3()),
                    ];
                    const pts = corners.map(c => Cesium.SceneTransforms.wgs84ToWindowCoordinates(viewer.scene, c));
                    if (pts.some(p => !p)) return null;
                    const xs = pts.map(p => p.x);
                    const ys = pts.map(p => p.y);

                    // One-time diagnostic on first dock: prove corners match 3D geometry
                    // NOTE: A1 offset diagnostic moved to renderHtmlGrid (DOM-based measurement after cell build)
                    if (logDiag && !_gridDiagLogged) {
                        _gridDiagLogged = true;
                        const fmt = (v) => `(${v.x.toFixed(1)},${v.y.toFixed(1)},${v.z.toFixed(1)})`;
                        RelayLog.info(`[GRID-DIAG] source: _center=${fmt(C)} _xAxis=${fmt(X)} _yAxis=${fmt(Y)}`);
                        RelayLog.info(`[GRID-DIAG] halfW=${halfW}m halfH=${halfH}m (CANONICAL_LAYOUT.sheet)`);
                        RelayLog.info(`[GRID-DIAG] 2D corners TL=${pts[0].x.toFixed(1)},${pts[0].y.toFixed(1)} TR=${pts[1].x.toFixed(1)},${pts[1].y.toFixed(1)} BL=${pts[2].x.toFixed(1)},${pts[2].y.toFixed(1)} BR=${pts[3].x.toFixed(1)},${pts[3].y.toFixed(1)}`);
                    }

                    return {
                        left:   Math.min(...xs),
                        top:    Math.min(...ys),
                        width:  Math.max(...xs) - Math.min(...xs),
                        height: Math.max(...ys) - Math.min(...ys)
                    };
                };

                let _lastGridLog = '';

                // ‚îÄ‚îÄ‚îÄ Scrollbar update: size and position thumbs ‚îÄ‚îÄ‚îÄ
                const updateScrollbars = (totalRows, totalCols) => {
                    const vThumb = document.getElementById('gridScrollbarVThumb');
                    const hThumb = document.getElementById('gridScrollbarHThumb');
                    const vTrack = document.getElementById('gridScrollbarV');
                    const hTrack = document.getElementById('gridScrollbarH');
                    if (vThumb && vTrack) {
                        const trackH = vTrack.clientHeight;
                        const ratio = Math.min(1, viewportRowsVisible / Math.max(1, totalRows));
                        const thumbH = Math.max(20, ratio * trackH);
                        const thumbY = totalRows <= viewportRowsVisible ? 0
                            : (viewportRowStart / (totalRows - viewportRowsVisible)) * (trackH - thumbH);
                        vThumb.style.height = thumbH + 'px';
                        vThumb.style.top = thumbY + 'px';
                        vTrack.style.display = totalRows <= viewportRowsVisible ? 'none' : '';
                    }
                    if (hThumb && hTrack) {
                        const trackW = hTrack.clientWidth;
                        const ratio = Math.min(1, viewportColsVisible / Math.max(1, totalCols));
                        const thumbW = Math.max(20, ratio * trackW);
                        const thumbX = totalCols <= viewportColsVisible ? 0
                            : (viewportColStart / (totalCols - viewportColsVisible)) * (trackW - thumbW);
                        hThumb.style.width = thumbW + 'px';
                        hThumb.style.left = thumbX + 'px';
                        hTrack.style.display = totalCols <= viewportColsVisible ? 'none' : '';
                    }
                };

                // ‚îÄ‚îÄ‚îÄ Status line update ‚îÄ‚îÄ‚îÄ
                const updateStatusLine = (totalRows, totalCols) => {
                    if (!sheetGridStatusLine) return;
                    const rEnd = Math.min(viewportRowStart + viewportRowsVisible, totalRows);
                    const cEnd = Math.min(viewportColStart + viewportColsVisible, totalCols);
                    const cStartLetter = colToLetter(viewportColStart);
                    const cEndLetter = colToLetter(Math.max(0, cEnd - 1));
                    sheetGridStatusLine.textContent =
                        `Rows: ${totalRows.toLocaleString()} | Cols: ${totalCols.toLocaleString()} | ` +
                        `View: R${viewportRowStart + 1}\u2013R${rEnd} / ${cStartLetter}\u2013${cEndLetter}`;
                };

                // ‚îÄ‚îÄ‚îÄ Ensure viewport is scrolled so cell (row, col) is visible ‚îÄ‚îÄ‚îÄ
                const scrollViewportToCell = (row, col, totalRows, totalCols) => {
                    let changed = false;
                    if (row < viewportRowStart) { viewportRowStart = row; changed = true; }
                    if (row >= viewportRowStart + viewportRowsVisible) { viewportRowStart = row - viewportRowsVisible + 1; changed = true; }
                    if (col < viewportColStart) { viewportColStart = col; changed = true; }
                    if (col >= viewportColStart + viewportColsVisible) { viewportColStart = col - viewportColsVisible + 1; changed = true; }
                    viewportRowStart = clamp(viewportRowStart, 0, Math.max(0, totalRows - viewportRowsVisible));
                    viewportColStart = clamp(viewportColStart, 0, Math.max(0, totalCols - viewportColsVisible));
                    return changed;
                };

                const renderHtmlGrid = (isDockEvent = false) => {
                    if (!sheetGridTable || !sheetGridOverlay) return;
                    const sheet = getActiveGridSheet();
                    if (!sheet) return;
                    const totalRows = sheet.rows || CANONICAL_LAYOUT.sheet.cellRows;
                    const totalCols = sheet.cols || CANONICAL_LAYOUT.sheet.cellCols;
                    ensureCellIndex(sheet);
                    // Evaluate all formulas so cells display computed values, not raw formula strings
                    if (!sheet._formulasEvaluated) {
                        evaluateAllFormulas(sheet);
                        sheet._formulasEvaluated = true;
                    }
                    if (sheetGridTitle) {
                        const stamp = sheet._importStamp || window._importStamp;
                        if (stamp) {
                            sheetGridTitle.textContent = `IMPORT: ${stamp.file} | "${stamp.sheet}" ${stamp.usedRange} | ${stamp.rows}√ó${stamp.cols} | cells=${stamp.cells} formulas=${stamp.formulas} | id=${stamp.importId}`;
                        } else {
                            sheetGridTitle.textContent = sheet.name || sheet.metadata?.sheetName || sheet.id;
                        }
                    }

                    // ‚îÄ‚îÄ‚îÄ Position grid: align to 3D projection on dock, full-screen otherwise ‚îÄ‚îÄ‚îÄ
                    let activeCellW = CELL_WIDTH;
                    let activeCellH = CELL_HEIGHT;
                    let activeRowHeaderW = ROW_HEADER_WIDTH;
                    let activeColHeaderH = COL_HEADER_HEIGHT;

                    if (isDockEvent && sheetGridScroll) {
                        // Compute projected rect from 3D sheet
                        const projRect = computeSheetScreenRect(sheet, false);
                        if (projRect && projRect.width > 0 && projRect.height > 0) {
                            // Dynamic cell sizes: sheet has (n+1) intervals per axis (n cells + 1 edge gap)
                            const intervalW = projRect.width / (totalCols + 1);
                            const intervalH = projRect.height / (totalRows + 1);
                            activeCellW = Math.round(intervalW);
                            activeCellH = Math.round(intervalH);
                            // Edge gap in 3D = one interval to cell CENTER = 0.5 interval to cell LEFT edge
                            activeRowHeaderW = Math.round(intervalW / 2);
                            activeColHeaderH = Math.round(intervalH / 2);

                            // Position scroll container to match projected rect
                            sheetGridScroll.style.left = Math.round(projRect.left) + 'px';
                            sheetGridScroll.style.top = Math.round(projRect.top) + 'px';
                            sheetGridScroll.style.width = Math.round(projRect.width) + 'px';
                            sheetGridScroll.style.height = Math.round(projRect.height) + 'px';
                            sheetGridScroll.style.right = 'auto';
                            sheetGridScroll.style.bottom = 'auto';
                            sheetGridScroll.style.overflow = 'hidden';

                            // Store for use in subsequent renders while docked
                            window._dockLayout = { cellW: activeCellW, cellH: activeCellH, rowHeaderW: activeRowHeaderW, colHeaderH: activeColHeaderH, projRect };
                            RelayLog.info(`[GRID-ALIGN] projected: left=${projRect.left.toFixed(0)} top=${projRect.top.toFixed(0)} w=${projRect.width.toFixed(0)} h=${projRect.height.toFixed(0)} cellW=${activeCellW} cellH=${activeCellH}`);
                        } else {
                            // Fallback to full-screen
                            sheetGridScroll.style.left = '0';
                            sheetGridScroll.style.top = '48px';
                            sheetGridScroll.style.right = '0';
                            sheetGridScroll.style.bottom = '0';
                            sheetGridScroll.style.width = 'auto';
                            sheetGridScroll.style.height = 'auto';
                        }
                    } else if (sheetGridScroll) {
                        // Use dock layout if available (subsequent renders while docked), else fill screen
                        if (window._dockLayout && isEditSheetMode) {
                            activeCellW = window._dockLayout.cellW;
                            activeCellH = window._dockLayout.cellH;
                            activeRowHeaderW = window._dockLayout.rowHeaderW;
                            activeColHeaderH = window._dockLayout.colHeaderH;
                        } else {
                            // Full-screen with Excel-standard fixed cell sizes (scrollable)
                            sheetGridScroll.style.left = '0';
                            sheetGridScroll.style.top = '48px';
                            sheetGridScroll.style.right = '0';
                            sheetGridScroll.style.bottom = '0';
                            sheetGridScroll.style.width = 'auto';
                            sheetGridScroll.style.height = 'auto';
                            activeCellW = CELL_WIDTH;
                            activeCellH = CELL_HEIGHT;
                        }
                    }

                    // ‚îÄ‚îÄ‚îÄ Compute viewport dimensions from container size ‚îÄ‚îÄ‚îÄ
                    const containerW = sheetGridScroll ? sheetGridScroll.clientWidth : 800;
                    const containerH = sheetGridScroll ? sheetGridScroll.clientHeight : 600;
                    const dataAreaW = containerW - activeRowHeaderW - SCROLLBAR_SIZE;
                    const dataAreaH = containerH - activeColHeaderH - SCROLLBAR_SIZE;
                    viewportColsVisible = Math.max(1, Math.floor(dataAreaW / activeCellW));
                    viewportRowsVisible = Math.max(1, Math.floor(dataAreaH / activeCellH));

                    // Clamp viewport start
                    viewportRowStart = clamp(viewportRowStart, 0, Math.max(0, totalRows - viewportRowsVisible));
                    viewportColStart = clamp(viewportColStart, 0, Math.max(0, totalCols - viewportColsVisible));

                    // How many rows/cols to actually render (visible + buffer, clamped to total)
                    const renderRowEnd = Math.min(totalRows, viewportRowStart + viewportRowsVisible + VIEWPORT_BUFFER);
                    const renderColEnd = Math.min(totalCols, viewportColStart + viewportColsVisible + VIEWPORT_BUFFER);
                    const renderRowStart = Math.max(0, viewportRowStart - VIEWPORT_BUFFER);
                    const renderColStart = Math.max(0, viewportColStart - VIEWPORT_BUFFER);
                    const renderRows = renderRowEnd - renderRowStart;
                    const renderCols = renderColEnd - renderColStart;

                    if (isDockEvent) {
                        RelayLog.info(`[GRID] virtualized: ${totalRows}√ó${totalCols} total, viewport=${viewportRowsVisible}√ó${viewportColsVisible}, render=${renderRows}√ó${renderCols} (${renderRows * renderCols} cells)`);
                    }

                    // ‚îÄ‚îÄ‚îÄ Build CSS Grid template ‚îÄ‚îÄ‚îÄ
                    const gridCols = `${activeRowHeaderW}px repeat(${renderCols}, ${activeCellW}px)`;
                    const gridRows = `${activeColHeaderH}px repeat(${renderRows}, ${activeCellH}px)`;
                    sheetGridTable.style.gridTemplateColumns = gridCols;
                    sheetGridTable.style.gridTemplateRows = gridRows;
                    sheetGridTable.style.width = (activeRowHeaderW + renderCols * activeCellW) + 'px';
                    sheetGridTable.style.height = (activeColHeaderH + renderRows * activeCellH) + 'px';

                    // ‚îÄ‚îÄ‚îÄ Build DOM (only visible cells) ‚îÄ‚îÄ‚îÄ
                    sheetGridTable.innerHTML = '';
                    const fragment = document.createDocumentFragment();

                    // Corner cell (header intersection)
                    const corner = document.createElement('div');
                    corner.className = 'grid-cell grid-header';
                    fragment.appendChild(corner);

                    // Column headers
                    for (let c = renderColStart; c < renderColEnd; c++) {
                        const header = document.createElement('div');
                        header.className = 'grid-cell grid-header grid-col-header';
                        header.textContent = colToLetter(c);
                        fragment.appendChild(header);
                    }

                    // Data rows
                    for (let r = renderRowStart; r < renderRowEnd; r++) {
                        // Row header
                        const rowHeader = document.createElement('div');
                        rowHeader.className = 'grid-cell grid-header grid-row-header';
                        rowHeader.textContent = String(r + 1);
                        fragment.appendChild(rowHeader);
                        // Data cells
                        for (let c = renderColStart; c < renderColEnd; c++) {
                            const cell = document.createElement('div');
                            cell.className = 'grid-cell grid-data';
                            cell.dataset.row = String(r);
                            cell.dataset.col = String(c);
                            const cellInfo = sheet._cellIndex.get(`${r},${c}`);
                            let display = '';
                            if (cellInfo) {
                                if (cellInfo.display !== undefined && cellInfo.display !== null && String(cellInfo.display) !== '') {
                                    display = cellInfo.display;
                                } else if (cellInfo.hasFormula && cellInfo.formula) {
                                    display = cellInfo.formula;
                                } else if (cellInfo.value !== undefined && cellInfo.value !== null) {
                                    display = cellInfo.value;
                                }
                            }
                            cell.textContent = display;
                            // B2: Apply match status highlighting on match sheets
                            if (sheet.metadata?.isMatchSheet && r > 0) {
                                cell.classList.add('match-row-clickable');
                                // Find status column and apply color to status cells
                                const statusColIdx = (sheet.metadata.schema || []).findIndex(sc => sc.id === 'matchStatus');
                                if (c === statusColIdx && cellInfo) {
                                    const sv = String(cellInfo.value || cellInfo.display || '');
                                    if (sv === 'MATCHED' || sv === 'MATCH') cell.classList.add('match-status-matched');
                                    else if (sv === 'UNMATCHED') cell.classList.add('match-status-unmatched');
                                    else if (sv.includes('EXCEPTION') || sv === 'PARTIAL' || sv === 'OVERPAY') cell.classList.add('match-status-exception');
                                }
                            }
                            // B3: Apply summary sheet formula cell highlighting
                            if (sheet.metadata?.isSummarySheet && r > 0) {
                                if (cellInfo?.hasFormula) {
                                    cell.classList.add('summary-formula-cell');
                                } else {
                                    cell.classList.add('summary-label-cell');
                                }
                            }
                            fragment.appendChild(cell);
                        }
                    }
                    sheetGridTable.appendChild(fragment);
                    updateGridSelection();
                    updateScrollbars(totalRows, totalCols);
                    updateStatusLine(totalRows, totalCols);

                    // ‚îÄ‚îÄ‚îÄ A0.1: DOM-based 3D‚Üî2D alignment diagnostic (after DOM build) ‚îÄ‚îÄ‚îÄ
                    if (isDockEvent) {
                        // Run after layout so getBoundingClientRect is valid
                        requestAnimationFrame(() => {
                            // 3D projection diagnostic (corners + coord space)
                            computeSheetScreenRect(sheet, true);
                            // DOM-based A1 measurement: no math guessing
                            const a1El = sheetGridTable.querySelector('.grid-data[data-row="0"][data-col="0"]');
                            if (a1El && sheet._center && sheet._xAxis && sheet._yAxis && viewer) {
                                const a1Rect = a1El.getBoundingClientRect();
                                const a1_2d_cx = a1Rect.left + a1Rect.width / 2;
                                const a1_2d_cy = a1Rect.top + a1Rect.height / 2;
                                // Compute A1 3D world position (row=0, col=0)
                                const _rows = sheet.rows || CANONICAL_LAYOUT.sheet.cellRows;
                                const _cols = sheet.cols || CANONICAL_LAYOUT.sheet.cellCols;
                                const _csx = CANONICAL_LAYOUT.sheet.height / (_rows + 1);
                                const _csy = CANONICAL_LAYOUT.sheet.width / (_cols + 1);
                                const _s = Cesium.Cartesian3.multiplyByScalar;
                                const _a = Cesium.Cartesian3.add;
                                const a1World = _a(sheet._center, _a(
                                    _s(sheet._xAxis, CANONICAL_LAYOUT.sheet.height / 2 - _csx, new Cesium.Cartesian3()),
                                    _s(sheet._yAxis, CANONICAL_LAYOUT.sheet.width / 2 - _csy, new Cesium.Cartesian3()),
                                    new Cesium.Cartesian3()), new Cesium.Cartesian3());
                                const a1Screen = Cesium.SceneTransforms.wgs84ToWindowCoordinates(viewer.scene, a1World);
                                if (a1Screen) {
                                    const dx = Math.abs(a1Screen.x - a1_2d_cx);
                                    const dy = Math.abs(a1Screen.y - a1_2d_cy);
                                    RelayLog.info(`[GRID-DIAG] A1(3D): screen=${a1Screen.x.toFixed(1)},${a1Screen.y.toFixed(1)}px`);
                                    RelayLog.info(`[GRID-DIAG] A1(2D-DOM): rect=${a1Rect.left.toFixed(1)},${a1Rect.top.toFixed(1)} size=${a1Rect.width.toFixed(1)}√ó${a1Rect.height.toFixed(1)} center=${a1_2d_cx.toFixed(1)},${a1_2d_cy.toFixed(1)}px`);
                                    RelayLog.info(`[GRID-DIAG] A1 offset: dx=${dx.toFixed(1)}px dy=${dy.toFixed(1)}px ${dx <= 2 && dy <= 2 ? '‚úÖ PASS' : '‚ö†Ô∏è DRIFT'}`);
                                    RelayLog.info(`[GRID-DIAG] coordSpace=CSS-px DPR=${window.devicePixelRatio}`);
                                }
                            }
                            // ‚îÄ‚îÄ‚îÄ Post-diagnostic: transition to full-screen with Excel-standard sizing ‚îÄ‚îÄ‚îÄ
                            // LAUNCH-ALIGN-1: Use fixed Excel-standard cell sizes with scrolling
                            // instead of stretching cells to fill viewport.
                            requestAnimationFrame(() => {
                                // Reposition container to full screen
                                if (sheetGridScroll) {
                                    sheetGridScroll.style.left = '0';
                                    sheetGridScroll.style.top = '48px';
                                    sheetGridScroll.style.right = '0';
                                    sheetGridScroll.style.bottom = '0';
                                    sheetGridScroll.style.width = 'auto';
                                    sheetGridScroll.style.height = 'auto';
                                    sheetGridScroll.style.overflow = 'auto';
                                }
                                // Use Excel-standard fixed cell sizes (scrollable, not stretched)
                                requestAnimationFrame(() => {
                                    window._dockLayout = { cellW: CELL_WIDTH, cellH: CELL_HEIGHT, rowHeaderW: ROW_HEADER_WIDTH, colHeaderH: COL_HEADER_HEIGHT, projRect: null };
                                    renderHtmlGrid(false);
                                    RelayLog.info(`[SHEET-2D] grid px cell=${CELL_WIDTH}x${CELL_HEIGHT} rows=${totalRows} cols=${totalCols} zoom=1.0 (Excel standard)`);
                                    RelayLog.info(`[SHEET-2D] cellPx=${CELL_WIDTH}x${CELL_HEIGHT} rowHeaderPx=${ROW_HEADER_WIDTH} colHeaderPx=${COL_HEADER_HEIGHT}`);
                                });
                            });
                        });
                    }
                };
                window.renderHtmlGrid = renderHtmlGrid;

                window.setCompanyTopDownView = (sheet, options = {}) => {
                    const targetSheet = sheet || getNearestSheetToCamera();
                    if (!targetSheet) {
                        RelayLog.warn('‚ö†Ô∏è Company face-on view unavailable (sheet not ready)');
                        return;
                    }
                    if (window.RELAY_LAUNCH_MODE) {
                        const missingMeta = [];
                        if (!targetSheet._center) missingMeta.push('center');
                        if (!targetSheet._normal && !targetSheet._renderNormal) missingMeta.push('normal');
                        if (!targetSheet._xAxis) missingMeta.push('xAxis');
                        if (!targetSheet._yAxis) missingMeta.push('yAxis');
                        if (missingMeta.length > 0) {
                            RelayLog.warn(`[REFUSAL] reason=LAUNCH_DOCK_MISSING_SHEET_META sheet=${targetSheet.id || targetSheet.name || 'unknown'} missing=${missingMeta.join(',')}`);
                            if (typeof hudManager !== 'undefined' && hudManager && typeof hudManager.update === 'function') {
                                hudManager.update({ focusHint: 'Sheet meta not ready; retry after sheet renders' });
                            }
                            return;
                        }
                    }
                    if (!targetSheet._center) {
                        RelayLog.warn('‚ö†Ô∏è Company face-on view unavailable (sheet center missing)');
                        return;
                    }

                    // Face-on camera: position along the sheet normal, looking at the sheet face
                    // Sheet normal = -T (canonical), roughly horizontal for vertical sheets
                    // _normal is preferred (canonical), _renderNormal as fallback
                    const rawNormal = targetSheet._normal || targetSheet._renderNormal;
                    const outward = Cesium.Cartesian3.normalize(
                        Cesium.Cartesian3.clone(targetSheet._center, new Cesium.Cartesian3()),
                        new Cesium.Cartesian3()
                    );

                    let approachDir;
                    if (rawNormal) {
                        const sheetNormal = Cesium.Cartesian3.normalize(
                            Cesium.Cartesian3.clone(rawNormal, new Cesium.Cartesian3()),
                            new Cesium.Cartesian3()
                        );
                        // Choose approach side: same side as the camera for smooth transition
                        const toCam = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(
                            viewer.camera.position, targetSheet._center, new Cesium.Cartesian3()
                        ), new Cesium.Cartesian3());
                        approachDir = Cesium.Cartesian3.dot(toCam, sheetNormal) >= 0
                            ? Cesium.Cartesian3.clone(sheetNormal, new Cesium.Cartesian3())
                            : Cesium.Cartesian3.negate(sheetNormal, new Cesium.Cartesian3());
                    } else if (window.RELAY_LAUNCH_MODE) {
                        // LAUNCH-FIX-1: Refuse docking when sheet meta is missing in launch mode
                        // Stay in 3D and show HUD hint so user knows to wait
                        RelayLog.warn(`[REFUSAL] reason=LAUNCH_DOCK_MISSING_SHEET_META sheet=${targetSheet.id || targetSheet.name || 'unknown'}`);
                        if (typeof hudManager !== 'undefined' && hudManager && typeof hudManager.update === 'function') {
                            hudManager.update({ focusHint: 'Sheet meta not ready; try again after sheet renders.' });
                        }
                        return;
                    } else {
                        // Fallback: approach from outward (radial) ‚Äî face-on from above globe surface
                        RelayLog.warn('[CAM] Sheet normal not set ‚Äî using outward radial approach');
                        approachDir = Cesium.Cartesian3.clone(outward, new Cesium.Cartesian3());
                    }

                    // Distance scales with presentation scale for launch mode
                    const launchScale = window.RELAY_LAUNCH_SCALE || 1;
                    const distance = options.distance || (420 * launchScale); // covers sheet with margin at ~60¬∞ FOV
                    const cameraPos = Cesium.Cartesian3.add(
                        targetSheet._center,
                        Cesium.Cartesian3.multiplyByScalar(approachDir, distance, new Cesium.Cartesian3()),
                        new Cesium.Cartesian3()
                    );
                    const direction = Cesium.Cartesian3.normalize(
                        Cesium.Cartesian3.subtract(targetSheet._center, cameraPos, new Cesium.Cartesian3()),
                        new Cesium.Cartesian3()
                    );

                    // Up = sheet's X-axis (branch normal N ‚âà local "up" from surface)
                    // Fallback to local radial direction at sheet center
                    let up = targetSheet._xAxis
                        ? Cesium.Cartesian3.normalize(Cesium.Cartesian3.clone(targetSheet._xAxis, new Cesium.Cartesian3()), new Cesium.Cartesian3())
                        : Cesium.Cartesian3.normalize(
                            Cesium.Cartesian3.clone(targetSheet._center, new Cesium.Cartesian3()),
                            new Cesium.Cartesian3()
                        );
                    if (Math.abs(Cesium.Cartesian3.dot(up, direction)) > 0.9) {
                        up = targetSheet._yAxis
                            ? Cesium.Cartesian3.normalize(Cesium.Cartesian3.clone(targetSheet._yAxis, new Cesium.Cartesian3()), new Cesium.Cartesian3())
                            : Cesium.Cartesian3.UNIT_Y;
                    }

                    // Constrain flight height to prevent Cesium's flyTo parabolic arc
                    const currentHeight = viewer.camera.positionCartographic?.height || 5000;
                    const destCarto = Cesium.Cartographic.fromCartesian(cameraPos);
                    const destHeight = destCarto?.height || currentHeight;
                    const maxFlightHeight = Math.max(currentHeight, destHeight) * 1.05;

                    const duration = options.duration !== undefined ? options.duration : 2.5;
                    if (duration > 0) {
                        // Face-on docking flight ‚Äî direct approach, no high arc
                        RelayLog.info(`[CAM] Face-on docking: ${duration.toFixed(1)}s flight to sheet (maxH=${Math.round(maxFlightHeight)}m dist=${distance.toFixed(1)}m)`);
                        viewer.camera.flyTo({
                            destination: cameraPos,
                            orientation: { direction, up },
                            duration: duration,
                            maximumHeight: maxFlightHeight,
                            easingFunction: Cesium.EasingFunction.CUBIC_IN_OUT,
                            complete: () => {
                                RelayLog.info('[CAM] Docking complete ‚Äî locked on sheet face-on');
                                if (options.onDocked) options.onDocked();
                            }
                        });
                    } else {
                        // Instant snap (launch mode zero-transition / fallback / testing)
                        RelayLog.info('[CAM] Face-on: instant snap (duration=0 method=setView)');
                        viewer.camera.setView({
                            destination: cameraPos,
                            orientation: { direction, up }
                        });
                        // Fire onDocked synchronously for instant path
                        if (options.onDocked) {
                            requestAnimationFrame(() => options.onDocked());
                        }
                    }

                    // Store undock position (where camera was before docking)
                    if (!window._preDockCameraState) {
                        window._preDockCameraState = {
                            position: Cesium.Cartesian3.clone(viewer.camera.positionWC),
                            direction: Cesium.Cartesian3.clone(viewer.camera.directionWC),
                            up: Cesium.Cartesian3.clone(viewer.camera.upWC)
                        };
                    }
                };

                const moveSelectionBy = (deltaRow, deltaCol) => {
                    if (!sheetSelection) return;
                    const sheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === sheetSelection.sheetId);
                    if (!sheet) return;
                    const rows = sheet.rows || CANONICAL_LAYOUT.sheet.cellRows;
                    const cols = sheet.cols || CANONICAL_LAYOUT.sheet.cellCols;
                    const nextRow = Math.max(0, Math.min(rows - 1, sheetSelection.row + deltaRow));
                    const nextCol = Math.max(0, Math.min(cols - 1, sheetSelection.col + deltaCol));
                    const cellRef = toCellRef(nextRow, nextCol);
                    const cellId = `${sheet.id}.cell.${nextRow}.${nextCol}`;
                    const selection = {
                        sheetId: sheet.id,
                        cellId,
                        cellRef,
                        row: nextRow,
                        col: nextCol,
                        entity: getCellEntity(sheet.id, cellId)
                    };
                    const range = {
                        sheetId: sheet.id,
                        start: { row: nextRow, col: nextCol, cellId, cellRef },
                        end: { row: nextRow, col: nextCol, cellId, cellRef }
                    };
                    applySelection(selection, range);
                    // Scroll viewport to keep the selection visible
                    scrollViewportToCell(nextRow, nextCol, rows, cols);
                    renderHtmlGrid();
                };

                if (sheetGridTable) {
                    sheetGridTable.addEventListener('click', (event) => {
                        if (!isEditSheetMode) return;
                        const target = event.target.closest('.grid-data');
                        if (!target) return;
                        const sheet = getActiveGridSheet();
                        if (!sheet) return;
                        const row = Number.parseInt(target.dataset.row, 10);
                        const col = Number.parseInt(target.dataset.col, 10);
                        if (!Number.isFinite(row) || !Number.isFinite(col)) return;
                        const cellRef = toCellRef(row, col);
                        const cellId = `${sheet.id}.cell.${row}.${col}`;
                        const selection = {
                            sheetId: sheet.id,
                            cellId,
                            cellRef,
                            row,
                            col,
                            entity: getCellEntity(sheet.id, cellId)
                        };
                        const range = {
                            sheetId: sheet.id,
                            start: { row, col, cellId, cellRef },
                            end: { row, col, cellId, cellRef }
                        };
                        applySelection(selection, range);
                    });
                    sheetGridTable.addEventListener('dblclick', (event) => {
                        if (!isEditSheetMode) return;
                        const target = event.target.closest('.grid-data');
                        if (!target) return;
                        beginEdit();
                    });
                }

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // B2.3 ‚Äî MATCH INSPECTOR DRILL-THROUGH
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const matchInspector = document.getElementById('matchInspector');
                const matchInspectorContent = document.getElementById('matchInspectorContent');
                const matchInspectorClose = document.getElementById('matchInspectorClose');

                if (matchInspectorClose) {
                    matchInspectorClose.addEventListener('click', () => {
                        if (matchInspector) matchInspector.style.display = 'none';
                    });
                }

                /** Look up source rows for a match sheet row and display in inspector */
                const showMatchInspector = (sheet, row) => {
                    if (!matchInspector || !matchInspectorContent) return;
                    const meta = sheet.metadata;
                    if (!meta?.isMatchSheet) return;

                    // Get the match row's cell data
                    const schema = meta.schema || [];
                    const rowCells = {};
                    for (const ci of sheet.cellData) {
                        if (ci.row === row) rowCells[ci.col] = ci;
                    }
                    const getVal = (colId) => {
                        const idx = schema.findIndex(c => c.id === colId);
                        return idx >= 0 && rowCells[idx] ? rowCells[idx].value : '';
                    };

                    let html = '';

                    // Match row header
                    const matchId = getVal('matchId');
                    const status = getVal('matchStatus');
                    const statusClass = (status === 'MATCHED' || status === 'MATCH') ? 'match-status-matched'
                        : (status === 'UNMATCHED' ? 'match-status-unmatched' : 'match-status-exception');
                    html += `<div style="margin-bottom:10px; padding:6px; border:1px solid rgba(0,180,255,0.3); border-radius:4px;">`;
                    html += `<div><strong>${matchId}</strong> <span class="${statusClass}" style="padding:2px 6px; border-radius:3px; font-size:10px;">${status}</span></div>`;
                    html += `<div style="margin-top:4px; color:#8899aa;">Key: ${getVal('joinKeyType')} (conf: ${getVal('confidence')})</div>`;

                    // Show all match row fields
                    schema.forEach((col, idx) => {
                        if (col.id === 'matchId' || col.id === 'matchStatus' || col.id === 'joinKeyType' || col.id === 'confidence') return;
                        const val = rowCells[idx]?.value ?? '';
                        if (val === '' || val === null) return;
                        html += `<div style="margin-top:2px;"><span style="color:#6b7d99;">${col.label}:</span> ${val}</div>`;
                    });
                    html += `</div>`;

                    // Find source rows
                    const allSheets = relayState.tree.nodes.filter(n => n.type === 'sheet');
                    const findSourceRow = (sheetId, joinCol, joinValue) => {
                        if (!joinValue) return null;
                        const srcSheet = allSheets.find(s => s.id === sheetId);
                        if (!srcSheet?.cellData || !srcSheet.metadata?.schema) return null;
                        const srcSchema = srcSheet.metadata.schema;
                        const joinIdx = srcSchema.findIndex(c => c.id === joinCol);
                        if (joinIdx < 0) return null;
                        // Search data rows (skip header row 0)
                        for (let r = 1; r <= srcSheet.rows; r++) {
                            const cell = srcSheet.cellData.find(c => c.row === r && c.col === joinIdx);
                            if (cell && String(cell.value) === String(joinValue)) {
                                // Collect all cells in this row
                                const rowData = {};
                                srcSchema.forEach((sc, si) => {
                                    const c = srcSheet.cellData.find(cd => cd.row === r && cd.col === si);
                                    rowData[sc.id] = c ? c.value : '';
                                });
                                return { sheetId, sheetName: srcSheet.name, schema: srcSchema, data: rowData };
                            }
                        }
                        // Try splitting semicolon-joined values (for aggregated matches)
                        const vals = String(joinValue).split(';');
                        if (vals.length > 1) return findSourceRow(sheetId, joinCol, vals[0]);
                        return null;
                    };

                    // Determine source lookups based on match sheet type
                    const sheetId = sheet.id;
                    const sourceRows = [];
                    if (sheetId === 'P2P.ThreeWayMatch') {
                        const poRow = findSourceRow('P2P.POLines', 'poLineId', getVal('poLineId'));
                        const grRow = findSourceRow('P2P.GRLines', 'poLineId', getVal('poLineId'));
                        const invRow = findSourceRow('P2P.InvoiceLines', 'invLineId', getVal('invLineId'));
                        if (poRow) sourceRows.push(poRow);
                        if (grRow) sourceRows.push(grRow);
                        if (invRow) sourceRows.push(invRow);
                    } else if (sheetId === 'P2P.InvoiceToGLMatch') {
                        const invRow = findSourceRow('P2P.InvoiceLines', 'invLineId', getVal('invLineId'));
                        const glRow = findSourceRow('P2P.GLPostingLines', 'glLineId', getVal('glLineId'));
                        if (invRow) sourceRows.push(invRow);
                        if (glRow) sourceRows.push(glRow);
                    } else if (sheetId === 'P2P.InvoiceToPaymentMatch') {
                        const invRow = findSourceRow('P2P.InvoiceLines', 'invLineId', getVal('invLineId'));
                        const payRow = findSourceRow('P2P.PaymentLines', 'paymentId', getVal('payId'));
                        if (invRow) sourceRows.push(invRow);
                        if (payRow) sourceRows.push(payRow);
                    }

                    // Render source rows
                    if (sourceRows.length > 0) {
                        html += `<div style="margin-top:8px; color:#7fd3ff; font-weight:600;">Source Rows (${sourceRows.length})</div>`;
                        sourceRows.forEach(sr => {
                            html += `<div style="margin-top:6px; padding:6px; border:1px solid rgba(100,140,180,0.25); border-radius:3px; background:rgba(20,30,50,0.6);">`;
                            html += `<div style="color:#4ecdc4; font-size:10px; margin-bottom:3px;">${sr.sheetName}</div>`;
                            sr.schema.forEach(col => {
                                const val = sr.data[col.id];
                                if (val === '' || val === null || val === undefined) return;
                                html += `<div><span style="color:#6b7d99;">${col.label}:</span> ${val}</div>`;
                            });
                            html += `</div>`;
                        });
                    } else {
                        html += `<div style="margin-top:8px; color:#ff7b6b;">No source rows found</div>`;
                    }

                    matchInspectorContent.innerHTML = html;
                    matchInspector.style.display = 'block';
                    RelayLog.info(`[B2-INSPECTOR] sheet=${sheetId} row=${row} matchId=${matchId} status=${status} sources=${sourceRows.length}`);
                };

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // B3.5 ‚Äî DEPENDENCY INSPECTOR (formula transparency gate)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const inspectorTitle = document.getElementById('inspectorTitle');

                /** Show dependency graph for a formula cell (especially summary sheet cells) */
                const showDependencyInspector = (sheet, row, col) => {
                    if (!matchInspector || !matchInspectorContent) return;
                    ensureCellIndex(sheet);
                    const ci = sheet._cellIndex.get(`${row},${col}`);
                    if (!ci || !ci.hasFormula || !ci.formula) return;

                    const cellRef = ci.a1 || toCellRef(row, col);
                    const sheetId = sheet.id || sheet.name || 'unknown';
                    if (inspectorTitle) inspectorTitle.textContent = 'Dependency Inspector';

                    // Evaluate formula to get deps
                    const result = evaluateFormula(ci.formula, sheet);
                    const deps = result.deps || [];

                    // Separate local and cross-sheet dependencies
                    const localDeps = [];
                    const crossSheetDeps = new Map(); // sheetId ‚Üí [{ref, value}]

                    for (const dep of deps) {
                        if (dep.includes('!')) {
                            const bangIdx = dep.indexOf('!');
                            const depSheet = dep.substring(0, bangIdx);
                            const depRef = dep.substring(bangIdx + 1);
                            if (!crossSheetDeps.has(depSheet)) crossSheetDeps.set(depSheet, []);
                            // Resolve the value
                            const targetNode = relayState.tree.nodes.find(n => n.id === depSheet);
                            let depValue = '';
                            if (targetNode) {
                                ensureCellIndex(targetNode);
                                const parsed = parseCellRef(depRef);
                                if (parsed) {
                                    const depCi = targetNode._cellIndex.get(`${parsed.row},${parsed.col}`);
                                    depValue = depCi ? (depCi.display ?? depCi.value ?? '') : '';
                                }
                            }
                            crossSheetDeps.get(depSheet).push({ ref: depRef, value: depValue });
                        } else {
                            const parsed = parseCellRef(dep);
                            let depValue = '';
                            if (parsed) {
                                const depCi = sheet._cellIndex.get(`${parsed.row},${parsed.col}`);
                                depValue = depCi ? (depCi.display ?? depCi.value ?? '') : '';
                            }
                            localDeps.push({ ref: dep, value: depValue });
                        }
                    }

                    // Build HTML
                    let html = `<div style="margin-bottom:10px;">`;
                    html += `<div style="color:#ffd700; font-weight:bold; margin-bottom:4px;">${sheetId} ‚Üí ${cellRef}</div>`;
                    html += `<div style="color:#aaa; margin-bottom:2px;">Formula: <span style="color:#7fd3ff;">${ci.formula}</span></div>`;
                    html += `<div style="color:#aaa; margin-bottom:8px;">Computed: <span style="color:#50fa7b; font-weight:bold;">${ci.display ?? ci.value ?? ''}</span></div>`;
                    html += `</div>`;

                    // Cross-sheet dependencies (the important ones for transparency)
                    if (crossSheetDeps.size > 0) {
                        html += `<div style="margin-bottom:6px; color:#ff79c6; font-weight:bold;">Cross-Sheet Sources:</div>`;
                        for (const [depSheetId, cells] of crossSheetDeps) {
                            const depSheetNode = relayState.tree.nodes.find(n => n.id === depSheetId);
                            const depSheetName = depSheetNode?.name || depSheetId;
                            html += `<div style="margin-bottom:6px; padding:6px; background:rgba(255,121,198,0.1); border-left:2px solid rgba(255,121,198,0.4); border-radius:2px;">`;
                            html += `<div style="color:#ff79c6; font-size:10px; margin-bottom:3px;">${depSheetName}</div>`;
                            // Group by contiguous ranges
                            const uniqueRefs = [...new Set(cells.map(c => c.ref))];
                            if (uniqueRefs.length > 8) {
                                // Summarize range
                                const first = uniqueRefs[0], last = uniqueRefs[uniqueRefs.length - 1];
                                html += `<div style="color:#c8d6e5; font-size:10px;">${first}:${last} (${uniqueRefs.length} cells)</div>`;
                                // Show a few sample values
                                const samples = cells.slice(0, 4);
                                for (const s of samples) {
                                    html += `<div style="color:#8899aa; font-size:10px; padding-left:8px;">${s.ref} = ${s.value}</div>`;
                                }
                                if (cells.length > 4) html += `<div style="color:#667788; font-size:10px; padding-left:8px;">... +${cells.length - 4} more</div>`;
                            } else {
                                for (const c of cells) {
                                    html += `<div style="color:#c8d6e5; font-size:10px; padding-left:8px;">${c.ref} = <span style="color:#50fa7b;">${c.value}</span></div>`;
                                }
                            }
                            html += `</div>`;
                        }
                    }

                    // Local dependencies
                    if (localDeps.length > 0) {
                        html += `<div style="margin-bottom:6px; color:#8be9fd; font-weight:bold;">Local Dependencies:</div>`;
                        for (const d of localDeps) {
                            html += `<div style="color:#c8d6e5; font-size:10px; padding-left:8px;">${d.ref} = <span style="color:#50fa7b;">${d.value}</span></div>`;
                        }
                    }

                    if (deps.length === 0) {
                        html += `<div style="color:#6272a4;">No dependencies detected</div>`;
                    }

                    // Last recompute timebox info
                    html += `<div style="margin-top:10px; padding-top:6px; border-top:1px solid rgba(255,255,255,0.1);">`;
                    html += `<div style="color:#aaa; font-size:10px;">Timebox Count: <span style="color:#ffd700;">${ci.timeboxCount || 0}</span></div>`;
                    html += `<div style="color:#aaa; font-size:10px;">Dependencies: <span style="color:#ffd700;">${deps.length}</span></div>`;
                    html += `</div>`;

                    matchInspectorContent.innerHTML = html;
                    matchInspector.style.display = 'block';
                    RelayLog.info(`[B3.5-PROOF] dependency inspector: sheet=${sheetId} cell=${cellRef} formula="${ci.formula}" computed="${ci.display}" deps=${deps.length} crossSheet=${crossSheetDeps.size}`);
                };

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // UX-1.3: Universal Inspector ‚Äî context-aware for any object type
                // Uses toRelayObject() contract as its sole data source
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const showUniversalInspector = (target) => {
                    if (!matchInspector || !matchInspectorContent) return;
                    const contract = typeof target === 'object' && target.type && target.id && target.actions
                        ? target  // Already a contract
                        : toRelayObject(target, relayState);
                    if (!contract) {
                        RelayLog.warn('[INSPECTOR] Cannot resolve target to contract');
                        return;
                    }

                    const inspectorTitle = document.getElementById('inspectorTitle');
                    if (inspectorTitle) {
                        inspectorTitle.textContent = `Inspecting: ${contract.type} ${contract.id}`;
                    }

                    let html = '';
                    const sectionStyle = 'margin-bottom:8px; padding-bottom:6px; border-bottom:1px solid rgba(255,255,255,0.08);';
                    const labelStyle = 'color:#8be9fd; font-weight:bold; font-size:11px; margin-bottom:4px;';
                    const valueStyle = 'color:#c8d6e5; font-size:10px; padding-left:8px;';
                    const highlightStyle = 'color:#50fa7b;';
                    const mutedStyle = 'color:#6272a4; font-size:10px;';

                    // ‚îÄ‚îÄ‚îÄ Header (all types) ‚îÄ‚îÄ‚îÄ
                    html += `<div style="${sectionStyle}">`;
                    html += `<div style="color:#ffd700; font-weight:bold; font-size:12px; margin-bottom:4px;">${contract.label}</div>`;
                    html += `<div style="${mutedStyle}">Type: <span style="${highlightStyle}">${contract.type}</span> | ID: <span style="color:#bd93f9;">${contract.id}</span></div>`;
                    html += `<div style="${mutedStyle}">Scope: ${contract.scope}</div>`;
                    if (contract.historyCount > 0) {
                        html += `<div style="${mutedStyle}">Timebox History: <span style="color:#ffd700;">${contract.historyCount}</span></div>`;
                    }
                    html += `</div>`;

                    // ‚îÄ‚îÄ‚îÄ Type-specific sections ‚îÄ‚îÄ‚îÄ
                    switch (contract.type) {
                        case 'cell':
                            html += `<div style="${sectionStyle}">`;
                            html += `<div style="${labelStyle}">Cell Value</div>`;
                            html += `<div style="${valueStyle}">Value: <span style="${highlightStyle}">${contract.value ?? '(empty)'}</span></div>`;
                            if (contract.formula) {
                                html += `<div style="${valueStyle}">Formula: <span style="color:#ff79c6;">${contract.formula}</span></div>`;
                            }
                            html += `</div>`;
                            if (contract.dependencies.length > 0) {
                                html += `<div style="${sectionStyle}">`;
                                html += `<div style="${labelStyle}">Dependencies (${contract.dependencies.length})</div>`;
                                contract.dependencies.forEach(d => {
                                    const prefix = d.type === 'cross-sheet' ? `${d.sheetId}!` : '';
                                    html += `<div style="${valueStyle}">${prefix}${d.cellRef}</div>`;
                                });
                                html += `</div>`;
                            }
                            if (contract.provenance) {
                                html += `<div style="${sectionStyle}">`;
                                html += `<div style="${labelStyle}">Provenance</div>`;
                                html += `<div style="${valueStyle}">Route: ${contract.provenance.routeId || 'manual'}</div>`;
                                html += `<div style="${valueStyle}">Source: ${contract.provenance.sourceSystem || 'unknown'}</div>`;
                                html += `<div style="${valueStyle}">Ingested: ${contract.provenance.ingestedAt || 'N/A'}</div>`;
                                html += `</div>`;
                            }
                            break;

                        case 'match':
                            html += `<div style="${sectionStyle}">`;
                            html += `<div style="${labelStyle}">Match Status</div>`;
                            const statusColor = (contract.matchStatus === 'MATCHED' || contract.matchStatus === 'MATCH') ? '#50fa7b' :
                                contract.matchStatus === 'UNMATCHED' ? '#ff5555' : '#ffb86c';
                            html += `<div style="${valueStyle}">Status: <span style="color:${statusColor}; font-weight:bold;">${contract.matchStatus}</span></div>`;
                            html += `<div style="${valueStyle}">Join Key: ${contract.joinKeyType} | Confidence: ${contract.confidence ?? 'N/A'}</div>`;
                            html += `</div>`;
                            if (contract.facts.length > 0) {
                                html += `<div style="${sectionStyle}">`;
                                html += `<div style="${labelStyle}">Source Keys</div>`;
                                contract.facts.forEach(f => {
                                    html += `<div style="${valueStyle}">${f.key}: <span style="${highlightStyle}">${f.value}</span></div>`;
                                });
                                html += `</div>`;
                            }
                            // Show key match fields
                            const skipFields = ['matchId', 'matchStatus', 'joinKeyType', 'confidence'];
                            const fieldEntries = Object.entries(contract.fields || {}).filter(([k]) => !skipFields.includes(k));
                            if (fieldEntries.length > 0) {
                                html += `<div style="${sectionStyle}">`;
                                html += `<div style="${labelStyle}">Match Fields</div>`;
                                fieldEntries.forEach(([k, v]) => {
                                    html += `<div style="${valueStyle}">${k}: <span style="${highlightStyle}">${v ?? ''}</span></div>`;
                                });
                                html += `</div>`;
                            }
                            break;

                        case 'sheet':
                            html += `<div style="${sectionStyle}">`;
                            html += `<div style="${labelStyle}">Sheet Info</div>`;
                            html += `<div style="${valueStyle}">Rows: ${contract.rows} | Cols: ${contract.cols}</div>`;
                            html += `<div style="${valueStyle}">Cells: ${contract.cellCount} | Formulas: ${contract.formulaCount}</div>`;
                            if (contract.isMatchSheet) html += `<div style="${valueStyle}">Type: <span style="color:#ffb86c;">Match Sheet</span></div>`;
                            if (contract.isSummarySheet) html += `<div style="${valueStyle}">Type: <span style="color:#8be9fd;">Summary Sheet</span></div>`;
                            html += `</div>`;
                            if (contract.schema) {
                                html += `<div style="${sectionStyle}">`;
                                html += `<div style="${labelStyle}">Schema (${contract.schema.length} cols)</div>`;
                                contract.schema.slice(0, 10).forEach(col => {
                                    html += `<div style="${valueStyle}">${col.id || col.name}: <span style="${mutedStyle}">${col.type || 'string'}</span>${col.required ? ' <span style="color:#ff5555;">*</span>' : ''}</div>`;
                                });
                                if (contract.schema.length > 10) html += `<div style="${mutedStyle}">... +${contract.schema.length - 10} more</div>`;
                                html += `</div>`;
                            }
                            if (contract.facts.length > 0) {
                                html += `<div style="${sectionStyle}">`;
                                html += `<div style="${labelStyle}">Routes (${contract.facts.length})</div>`;
                                contract.facts.forEach(f => {
                                    html += `<div style="${valueStyle}">Route: <span style="${highlightStyle}">${f.routeId}</span> (${f.factClass})</div>`;
                                });
                                html += `</div>`;
                            }
                            if (contract.dependencies.length > 0) {
                                html += `<div style="${sectionStyle}">`;
                                html += `<div style="${labelStyle}">Source Sheets</div>`;
                                contract.dependencies.forEach(d => {
                                    html += `<div style="${valueStyle}">${d.type}: <span style="${highlightStyle}">${d.sheetId}</span></div>`;
                                });
                                html += `</div>`;
                            }
                            break;

                        case 'branch':
                            html += `<div style="${sectionStyle}">`;
                            html += `<div style="${labelStyle}">Branch Info</div>`;
                            html += `<div style="${valueStyle}">Children: ${contract.childCount} (${contract.sheetCount} sheets, ${contract.branchCount} branches)</div>`;
                            if (contract.eri !== null) html += `<div style="${valueStyle}">ERI: <span style="color:#ffd700;">${contract.eri}</span></div>`;
                            if (contract.moduleId) html += `<div style="${valueStyle}">Module: <span style="${highlightStyle}">${contract.moduleId}</span></div>`;
                            html += `</div>`;
                            if (contract.kpiBindings.length > 0) {
                                html += `<div style="${sectionStyle}">`;
                                html += `<div style="${labelStyle}">KPI Bindings (${contract.kpiBindings.length})</div>`;
                                contract.kpiBindings.forEach(kpi => {
                                    html += `<div style="${valueStyle}">${kpi.metricId}: <span style="${highlightStyle}">${kpi.sourceCell}</span></div>`;
                                });
                                html += `</div>`;
                            }
                            if (contract.kpiMetrics.length > 0) {
                                html += `<div style="${sectionStyle}">`;
                                html += `<div style="${labelStyle}">KPI History (${contract.kpiMetrics.length} records)</div>`;
                                contract.kpiMetrics.slice(-3).forEach(m => {
                                    html += `<div style="${valueStyle}">${JSON.stringify(m)}</div>`;
                                });
                                html += `</div>`;
                            }
                            break;

                        case 'trunk':
                            html += `<div style="${sectionStyle}">`;
                            html += `<div style="${labelStyle}">Trunk Info</div>`;
                            html += `<div style="${valueStyle}">Children: ${contract.childCount}</div>`;
                            html += `<div style="${valueStyle}">Location: (${contract.lat?.toFixed(4)}, ${contract.lon?.toFixed(4)})</div>`;
                            html += `</div>`;
                            break;

                        case 'route':
                            html += `<div style="${sectionStyle}">`;
                            html += `<div style="${labelStyle}">Route Info</div>`;
                            html += `<div style="${valueStyle}">Target: <span style="${highlightStyle}">${contract.targetSheet}</span></div>`;
                            html += `<div style="${valueStyle}">Fact Class: ${contract.factClass}</div>`;
                            html += `<div style="${valueStyle}">Keys: ${contract.keys.join(', ')}</div>`;
                            html += `<div style="${valueStyle}">Fields: ${contract.fieldCount}</div>`;
                            html += `</div>`;
                            break;

                        case 'module':
                            html += `<div style="${sectionStyle}">`;
                            html += `<div style="${labelStyle}">Module Overview</div>`;
                            html += `<div style="${valueStyle}">Sheets: ${contract.sheetCount} (${contract.factSheetCount} fact, ${contract.matchSheetCount} match, ${contract.summarySheetCount} summary)</div>`;
                            html += `<div style="${valueStyle}">Routes: ${contract.routeCount}</div>`;
                            html += `</div>`;
                            if (contract.kpiBindings.length > 0) {
                                html += `<div style="${sectionStyle}">`;
                                html += `<div style="${labelStyle}">KPI Bindings</div>`;
                                contract.kpiBindings.forEach(kpi => {
                                    html += `<div style="${valueStyle}">${kpi.metricId}: ${kpi.sourceCell} (${kpi.unit || ''})</div>`;
                                });
                                html += `</div>`;
                            }
                            if (contract.routeIds?.length > 0) {
                                html += `<div style="${sectionStyle}">`;
                                html += `<div style="${labelStyle}">Routes</div>`;
                                contract.routeIds.forEach(rid => {
                                    html += `<div style="${valueStyle}"><span style="${highlightStyle}">${rid}</span></div>`;
                                });
                                html += `</div>`;
                            }
                            break;
                    }

                    // ‚îÄ‚îÄ‚îÄ Actions footer (all types) ‚îÄ‚îÄ‚îÄ
                    if (contract.actions?.length > 0) {
                        html += `<div style="margin-top:8px; padding-top:6px; border-top:1px solid rgba(255,255,255,0.1);">`;
                        html += `<div style="${labelStyle}">Actions (press Space)</div>`;
                        contract.actions.forEach(a => {
                            html += `<div style="${mutedStyle}">${a.icon || '‚Ä¢'} ${a.label}</div>`;
                        });
                        html += `</div>`;
                    }

                    matchInspectorContent.innerHTML = html;
                    matchInspector.style.display = 'block';
                    RelayLog.info(`[UX-1.3-PROOF] inspector: type=${contract.type} id=${contract.id} actions=${contract.actions.length}`);
                };

                // Expose universal inspector globally
                window.showInspector = showUniversalInspector;
                window.inspectObject = (target) => showUniversalInspector(target);

                // UX-1.2: Click-outside closes Capability Buds
                document.addEventListener('click', (event) => {
                    const budsPanel = document.getElementById('capabilityBuds');
                    if (budsPanel && budsPanel.style.display !== 'none' && budsPanel.style.display !== '') {
                        if (!budsPanel.contains(event.target)) {
                            budsPanel.style.display = 'none';
                        }
                    }
                });

                // Hook inspector into grid click handler (match sheets + summary/formula cells)
                if (sheetGridTable) {
                    sheetGridTable.addEventListener('click', (event) => {
                        if (!isEditSheetMode) return;
                        const target = event.target.closest('.grid-data');
                        if (!target) return;
                        const sheet = getActiveGridSheet();
                        if (!sheet) return;
                        const row = Number.parseInt(target.dataset.row, 10);
                        const col = Number.parseInt(target.dataset.col, 10);
                        if (!Number.isFinite(row) || row === 0) {
                            if (matchInspector) matchInspector.style.display = 'none';
                            return;
                        }

                        // Match sheet ‚Üí show match inspector
                        if (sheet.metadata?.isMatchSheet) {
                            if (inspectorTitle) inspectorTitle.textContent = 'Match Inspector';
                            showMatchInspector(sheet, row);
                            return;
                        }

                        // Summary or any formula cell ‚Üí show dependency inspector
                        if (Number.isFinite(col)) {
                            ensureCellIndex(sheet);
                            const ci = sheet._cellIndex.get(`${row},${col}`);
                            if (ci?.hasFormula && ci?.formula) {
                                showDependencyInspector(sheet, row, col);
                                return;
                            }
                        }

                        // C0: Fact sheet row with provenance ‚Üí show provenance inspector
                        if (Number.isFinite(col) && row > 0 && sheet.metadata?.moduleId) {
                            ensureCellIndex(sheet);
                            // Provenance stored on col 0 of the row
                            const firstCellCi = sheet._cellIndex.get(`${row},0`);
                            const prov = firstCellCi?.provenance;
                            if (prov) {
                                if (inspectorTitle) inspectorTitle.textContent = 'Route Provenance';
                                const cellRef = toCellRef(row, col);
                                let html = `<div style="margin-bottom:10px;">`;
                                html += `<div style="color:#ffd700; font-weight:bold; margin-bottom:4px;">${sheet.id} ‚Üí Row ${row}</div>`;
                                html += `<div style="color:#aaa; margin-bottom:2px;">Cell: <span style="color:#7fd3ff;">${cellRef}</span></div>`;
                                html += `</div>`;
                                html += `<div style="margin-bottom:6px; color:#ff79c6; font-weight:bold;">Provenance:</div>`;
                                html += `<div style="padding:6px; background:rgba(255,121,198,0.1); border-left:2px solid rgba(255,121,198,0.4); border-radius:2px;">`;
                                html += `<div style="color:#c8d6e5; font-size:10px;">Route: <span style="color:#50fa7b;">${prov.routeId || 'manual'}</span></div>`;
                                html += `<div style="color:#c8d6e5; font-size:10px;">Source System: <span style="color:#50fa7b;">${prov.sourceSystem || 'unknown'}</span></div>`;
                                html += `<div style="color:#c8d6e5; font-size:10px;">Source ID: <span style="color:#50fa7b;">${prov.sourceId || 'N/A'}</span></div>`;
                                html += `<div style="color:#c8d6e5; font-size:10px;">Ingested: <span style="color:#50fa7b;">${prov.ingestedAt || 'N/A'}</span></div>`;
                                if (prov.eventTimestamp) html += `<div style="color:#c8d6e5; font-size:10px;">Event Time: <span style="color:#50fa7b;">${prov.eventTimestamp}</span></div>`;
                                html += `</div>`;
                                matchInspectorContent.innerHTML = html;
                                matchInspector.style.display = 'block';
                                RelayLog.info(`[C0-PROOF] provenance inspector: sheet=${sheet.id} row=${row} route=${prov.routeId} source=${prov.sourceSystem}/${prov.sourceId}`);
                                return;
                            }
                        }

                        // Non-formula, non-provenance cell ‚Üí default to Inspector v1 cell provenance.
                        if (Number.isFinite(col)) {
                            const cellRef = toCellRef(row, col);
                            window.relayInspectCellProvenance(sheet.id, cellRef, { emitLog: true, showPanel: true, latestN: 8 });
                            return;
                        }
                        if (matchInspector) matchInspector.style.display = 'none';
                    });
                }

                window.addEventListener('resize', () => {
                    if (isEditSheetMode) {
                        renderHtmlGrid();
                    }
                });

                // ‚îÄ‚îÄ‚îÄ Helper: get current total rows/cols ‚îÄ‚îÄ‚îÄ
                const getTotalDimensions = () => {
                    const sheet = getActiveGridSheet();
                    if (!sheet) return { totalRows: 0, totalCols: 0 };
                    return {
                        totalRows: sheet.rows || CANONICAL_LAYOUT.sheet.cellRows,
                        totalCols: sheet.cols || CANONICAL_LAYOUT.sheet.cellCols
                    };
                };

                // ‚îÄ‚îÄ‚îÄ Scrollbar drag ‚îÄ‚îÄ‚îÄ
                const setupScrollbarDrag = (thumbEl, trackEl, isVertical) => {
                    if (!thumbEl || !trackEl) return;
                    let dragging = false;
                    let dragStart = 0;
                    let thumbStart = 0;

                    thumbEl.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        dragging = true;
                        thumbEl.classList.add('dragging');
                        dragStart = isVertical ? e.clientY : e.clientX;
                        thumbStart = isVertical ? thumbEl.offsetTop : thumbEl.offsetLeft;
                        document.body.style.userSelect = 'none';
                    });

                    window.addEventListener('mousemove', (e) => {
                        if (!dragging) return;
                        const { totalRows, totalCols } = getTotalDimensions();
                        const delta = (isVertical ? e.clientY : e.clientX) - dragStart;
                        const newThumbPos = thumbStart + delta;
                        if (isVertical) {
                            const trackH = trackEl.clientHeight;
                            const thumbH = thumbEl.offsetHeight;
                            const maxScroll = Math.max(0, totalRows - viewportRowsVisible);
                            const ratio = clamp(newThumbPos / (trackH - thumbH), 0, 1);
                            viewportRowStart = Math.round(ratio * maxScroll);
                        } else {
                            const trackW = trackEl.clientWidth;
                            const thumbW = thumbEl.offsetWidth;
                            const maxScroll = Math.max(0, totalCols - viewportColsVisible);
                            const ratio = clamp(newThumbPos / (trackW - thumbW), 0, 1);
                            viewportColStart = Math.round(ratio * maxScroll);
                        }
                        renderHtmlGrid();
                    });

                    window.addEventListener('mouseup', () => {
                        if (dragging) {
                            dragging = false;
                            thumbEl.classList.remove('dragging');
                            document.body.style.userSelect = '';
                        }
                    });

                    // Click on track to jump
                    trackEl.addEventListener('mousedown', (e) => {
                        if (e.target === thumbEl) return;  // thumb handles its own drag
                        const { totalRows, totalCols } = getTotalDimensions();
                        const rect = trackEl.getBoundingClientRect();
                        if (isVertical) {
                            const clickY = e.clientY - rect.top;
                            const ratio = clamp(clickY / rect.height, 0, 1);
                            viewportRowStart = Math.round(ratio * Math.max(0, totalRows - viewportRowsVisible));
                        } else {
                            const clickX = e.clientX - rect.left;
                            const ratio = clamp(clickX / rect.width, 0, 1);
                            viewportColStart = Math.round(ratio * Math.max(0, totalCols - viewportColsVisible));
                        }
                        renderHtmlGrid();
                    });
                };

                // Initialize scrollbar dragging
                setupScrollbarDrag(
                    document.getElementById('gridScrollbarVThumb'),
                    document.getElementById('gridScrollbarV'),
                    true  // vertical
                );
                setupScrollbarDrag(
                    document.getElementById('gridScrollbarHThumb'),
                    document.getElementById('gridScrollbarH'),
                    false // horizontal
                );

                // ‚îÄ‚îÄ‚îÄ Wheel / trackpad scrolling ‚îÄ‚îÄ‚îÄ
                if (sheetGridScroll) {
                    sheetGridScroll.addEventListener('wheel', (e) => {
                        if (!isEditSheetMode) return;
                        e.preventDefault();
                        e.stopPropagation();
                        const { totalRows, totalCols } = getTotalDimensions();
                        const rowDelta = Math.sign(e.deltaY) * 3;
                        const colDelta = e.shiftKey ? Math.sign(e.deltaY) * 3 : Math.sign(e.deltaX) * 1;
                        if (!e.shiftKey) {
                            viewportRowStart = clamp(viewportRowStart + rowDelta, 0, Math.max(0, totalRows - viewportRowsVisible));
                        }
                        if (e.shiftKey || Math.abs(e.deltaX) > 0) {
                            viewportColStart = clamp(viewportColStart + colDelta, 0, Math.max(0, totalCols - viewportColsVisible));
                        }
                        renderHtmlGrid();
                    }, { passive: false });
                }

                // ‚îÄ‚îÄ‚îÄ Keyboard navigation in grid (viewport-level) ‚îÄ‚îÄ‚îÄ
                window.addEventListener('keydown', (e) => {
                    if (!isEditSheetMode) return;
                    if (isEditingCell) return;
                    // Check if name box input is focused
                    if (document.activeElement && document.activeElement.id === 'sheetGridCellRefInput') return;

                    const { totalRows, totalCols } = getTotalDimensions();
                    const sheet = getActiveGridSheet();
                    let handled = false;

                    if (e.key === 'PageDown') {
                        viewportRowStart = clamp(viewportRowStart + viewportRowsVisible, 0, Math.max(0, totalRows - viewportRowsVisible));
                        handled = true;
                    } else if (e.key === 'PageUp') {
                        viewportRowStart = clamp(viewportRowStart - viewportRowsVisible, 0, Math.max(0, totalRows - viewportRowsVisible));
                        handled = true;
                    } else if (e.key === 'Home' && e.ctrlKey) {
                        viewportRowStart = 0;
                        viewportColStart = 0;
                        if (sheet) {
                            const cellRef = toCellRef(0, 0);
                            const cellId = `${sheet.id}.cell.0.0`;
                            applySelection({ sheetId: sheet.id, cellId, cellRef, row: 0, col: 0, entity: getCellEntity(sheet.id, cellId) },
                                { sheetId: sheet.id, start: { row: 0, col: 0, cellId, cellRef }, end: { row: 0, col: 0, cellId, cellRef } });
                        }
                        handled = true;
                    } else if (e.key === 'End' && e.ctrlKey) {
                        const lastRow = Math.max(0, totalRows - 1);
                        const lastCol = Math.max(0, totalCols - 1);
                        viewportRowStart = clamp(lastRow - viewportRowsVisible + 1, 0, Math.max(0, totalRows - viewportRowsVisible));
                        viewportColStart = clamp(lastCol - viewportColsVisible + 1, 0, Math.max(0, totalCols - viewportColsVisible));
                        if (sheet) {
                            const cellRef = toCellRef(lastRow, lastCol);
                            const cellId = `${sheet.id}.cell.${lastRow}.${lastCol}`;
                            applySelection({ sheetId: sheet.id, cellId, cellRef, row: lastRow, col: lastCol, entity: getCellEntity(sheet.id, cellId) },
                                { sheetId: sheet.id, start: { row: lastRow, col: lastCol, cellId, cellRef }, end: { row: lastRow, col: lastCol, cellId, cellRef } });
                        }
                        handled = true;
                    }
                    // NOTE: Arrow keys handled by existing editSheetKeyHandler via moveSelectionBy()

                    if (handled) {
                        e.preventDefault();
                        renderHtmlGrid();
                    }
                });

                // ‚îÄ‚îÄ‚îÄ Name box: click to edit, type cell ref, Enter to jump ‚îÄ‚îÄ‚îÄ
                if (sheetGridCellRef) {
                    // Replace static div content with an editable input
                    const nameBoxInput = document.createElement('input');
                    nameBoxInput.type = 'text';
                    nameBoxInput.id = 'sheetGridCellRefInput';
                    nameBoxInput.value = '‚Äî';
                    nameBoxInput.style.cssText = `
                        width: 100%; height: 100%; border: none; background: transparent;
                        color: inherit; font: inherit; text-align: center; padding: 0;
                        outline: none; cursor: pointer;
                    `;
                    sheetGridCellRef.textContent = '';
                    sheetGridCellRef.appendChild(nameBoxInput);

                    nameBoxInput.addEventListener('focus', () => {
                        if (sheetSelection && sheetSelection.cellRef) {
                            nameBoxInput.value = sheetSelection.cellRef;
                        }
                        nameBoxInput.select();
                    });

                    nameBoxInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            const parsed = parseCellRef(nameBoxInput.value.trim());
                            if (parsed) {
                                const { totalRows, totalCols } = getTotalDimensions();
                                const row = clamp(parsed.row, 0, totalRows - 1);
                                const col = clamp(parsed.col, 0, totalCols - 1);
                                const sheet = getActiveGridSheet();
                                if (sheet) {
                                    const cellRef = toCellRef(row, col);
                                    const cellId = `${sheet.id}.cell.${row}.${col}`;
                                    applySelection({ sheetId: sheet.id, cellId, cellRef, row, col, entity: getCellEntity(sheet.id, cellId) },
                                        { sheetId: sheet.id, start: { row, col, cellId, cellRef }, end: { row, col, cellId, cellRef } });
                                    scrollViewportToCell(row, col, totalRows, totalCols);
                                    renderHtmlGrid();
                                }
                            }
                            nameBoxInput.blur();
                        } else if (e.key === 'Escape') {
                            nameBoxInput.blur();
                        }
                        e.stopPropagation();  // don't trigger flight controls
                    });
                }

                // ‚îÄ‚îÄ‚îÄ Wire up sheetGridStatusLine reference ‚îÄ‚îÄ‚îÄ
                sheetGridStatusLine = document.getElementById('sheetGridStatusLine');

                picker.setInputAction((movement) => {
                    const picked = pickCell(movement.position);
                    if (!picked) return;
                    if (!isEditSheetMode) {
                        const targetSheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === picked.sheetId) || null;
                        editSheetTargetSheet = targetSheet;
                        if (canEnterEditSheet(targetSheet)) {
                            window.enterEditSheetMode(targetSheet);
                        } else {
                            RelayLog.info('[MODE] EDIT_SHEET pending (distance/alignment)');
                        }
                    }
                    rangeDragAnchor = picked;
                    rangeDragLast = picked;
                    isRangeDragging = true;
                    const range = {
                        sheetId: picked.sheetId,
                        start: { row: picked.row, col: picked.col, cellId: picked.cellId, cellRef: picked.cellRef },
                        end: { row: picked.row, col: picked.col, cellId: picked.cellId, cellRef: picked.cellRef }
                    };
                    applySelection(picked, range);
                }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

                picker.setInputAction((movement) => {
                    if (!isRangeDragging || !rangeDragAnchor) {
                        if (filamentRenderer) {
                            const picked = viewer.scene.pick(movement.endPosition);
                            const instanceId = typeof picked?.id === 'string' ? picked.id : null;
                            if (instanceId && instanceId.includes('timebox')) {
                                filamentRenderer.setTimeboxHover(instanceId);
                            } else {
                                filamentRenderer.setTimeboxHover(null);
                            }
                        }
                        const hovered = viewer.scene.pick(movement.endPosition);
                        const entity = hovered?.id;
                        const isCell = entity?.properties?.type?.getValue ? entity.properties.type.getValue(Cesium.JulianDate.now()) === 'cell' : entity?.properties?.type === 'cell';
                        if (window.SHOW_CELL_MARKERS_AT_COMPANY && isCell && entity?.label) {
                            if (hoveredCellEntity && hoveredCellEntity !== entity && hoveredCellEntity.label) {
                                hoveredCellEntity.label.show = false;
                            }
                            entity.label.show = true;
                            hoveredCellEntity = entity;
                        } else if (hoveredCellEntity?.label) {
                            hoveredCellEntity.label.show = false;
                            hoveredCellEntity = null;
                        }
                        return;
                    }
                    let picked = pickCell(movement.endPosition);
                    if (!picked) {
                        picked = rangeDragLast;
                    }
                    if (!picked || picked.sheetId !== rangeDragAnchor.sheetId) return;
                    rangeDragLast = picked;
                    const range = {
                        sheetId: rangeDragAnchor.sheetId,
                        start: { row: rangeDragAnchor.row, col: rangeDragAnchor.col, cellId: rangeDragAnchor.cellId, cellRef: rangeDragAnchor.cellRef },
                        end: { row: picked.row, col: picked.col, cellId: picked.cellId, cellRef: picked.cellRef }
                    };
                    applySelection(rangeDragAnchor, range);
                }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

                picker.setInputAction((movement) => {
                    if (!isRangeDragging || !rangeDragAnchor) return;
                    let picked = pickCell(movement.position);
                    isRangeDragging = false;
                    if (!picked) {
                        picked = rangeDragLast;
                    }
                    if (!picked || picked.sheetId !== rangeDragAnchor.sheetId) {
                        rangeDragAnchor = null;
                        rangeDragLast = null;
                        return;
                    }
                    const range = {
                        sheetId: rangeDragAnchor.sheetId,
                        start: { row: rangeDragAnchor.row, col: rangeDragAnchor.col, cellId: rangeDragAnchor.cellId, cellRef: rangeDragAnchor.cellRef },
                        end: { row: picked.row, col: picked.col, cellId: picked.cellId, cellRef: picked.cellRef }
                    };
                    applySelection(rangeDragAnchor, range);
                    const bounds = getRangeBounds(range);
                    const rangeLabel = getRangeLabel(range);
                    RelayLog.info(`[UI] rangeSelect sheet=${range.sheetId} range=${rangeLabel} rows=${bounds?.rows || 1} cols=${bounds?.cols || 1} cells=${bounds?.rows * bounds?.cols || 1}`);
                    rangeDragAnchor = null;
                    rangeDragLast = null;
                }, Cesium.ScreenSpaceEventType.LEFT_UP);

                picker.setInputAction((movement) => {
                    if (isFocusMode) return; // In focus mode, single-click does NOT dock ‚Äî use double-click to switch focus or Esc to exit
                    const picked = viewer.scene.pick(movement.position);
                    const id = typeof picked?.id === 'string' ? picked.id : null;
                    if (!id) return;
                    // VIS-3.3: Handle clicks on VIS-3.2 overlay primitives
                    if (id.startsWith('vis3.2-exRow-')) {
                        // Parse: vis3.2-exRow-<sheetId>-r<rowIndex>
                        const match = id.match(/^vis3\.2-exRow-(.+)-r(\d+)$/);
                        if (match) {
                            window.vis33ClickExceptionRow(match[1], parseInt(match[2], 10));
                        }
                        return;
                    }
                    if (id.startsWith('vis3.2-route-')) {
                        // Parse: vis3.2-route-<fromId>-<toId>
                        const stripped = id.replace('vis3.2-route-', '');
                        // Source sheets have dots in IDs (e.g. P2P.POLines); find the split point
                        const nodes = relayState?.tree?.nodes || [];
                        let fromId = null, toId = null;
                        for (const n of nodes) {
                            if (n?.type === 'sheet' && stripped.startsWith(n.id + '-')) {
                                fromId = n.id;
                                toId = stripped.slice(n.id.length + 1);
                                break;
                            }
                        }
                        if (fromId && toId) {
                            window.vis33ClickRouteConnector(fromId, toId);
                        }
                        return;
                    }
                    // VIS-7b: Handle clicks on presence markers (pin/unpin)
                    if (id.startsWith('vis7a-marker-') || id.startsWith('vis7b-highlight-')) {
                        const markerId = id.startsWith('vis7b-highlight-') ? id.replace('vis7b-highlight-', '') : id;
                        window.vis7bClickMarker(markerId);
                        return;
                    }
                    // VIS-4c/4d: Handle clicks on timebox slabs (focus + pin/unpin)
                    if (id.startsWith('vis4-slab-') || id.startsWith('vis4c-hover-') || id.startsWith('vis4d-focus-')) {
                        const slabId = id.startsWith('vis4c-hover-') ? id.replace('vis4c-hover-', '')
                            : id.startsWith('vis4d-focus-') ? null
                            : id;
                        const renderer = window.filamentRenderer;
                        if (slabId && renderer) {
                            if (renderer._vis4dFocusState && renderer._vis4dFocusState.owner) {
                                const meta = renderer._vis4SlabRegistry?.get(slabId);
                                if (meta && meta.ownerId === renderer._vis4dFocusState.owner && !renderer._vis4dFocusState.zoomed) {
                                    // Already focused on this owner, zoom to slab stack
                                    window.vis4dFocusSlabStack(slabId);
                                } else {
                                    // Different owner or already zoomed ‚Äî pin/unpin
                                    window.vis4cPinSlab(slabId);
                                }
                            } else {
                                // No focus active ‚Äî initiate owner focus
                                window.vis4dFocusOwner(slabId);
                            }
                        }
                        return;
                    }
                    if (id.includes('timebox-')) {
                        window.relayInspectTimeboxProvenance(id, { emitLog: true, showPanel: true });
                        return;
                    }
                    const idBase = id.split('-surface')[0].split('-outline')[0].split('-segment')[0].split('-root')[0].split('-anchor')[0];
                    const isSheet = idBase.startsWith('sheet.');
                    const isBranch = idBase.startsWith('branch.');
                    const isTrunk = idBase.startsWith('trunk.');
                    if (!isSheet && !isBranch && !isTrunk) return;
                    if (isBranch || isTrunk) {
                        const targetNode = relayState.tree.nodes.find((n) => n.id === idBase);
                        if (targetNode) {
                            window.enterFocusMode(targetNode);
                            return;
                        }
                    }

                    let targetSheet = null;
                    if (isSheet) {
                        targetSheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === idBase);
                    }
                    if (!targetSheet) {
                        targetSheet = getNearestSheetToCamera();
                    }
                    if (targetSheet) {
                        editSheetTargetSheet = targetSheet;
                        if (canEnterEditSheet(targetSheet)) {
                            // enterEditSheetMode already calls setCompanyTopDownView (with onDocked callback)
                            window.enterEditSheetMode(targetSheet);
                        } else {
                            RelayLog.info('[MODE] EDIT_SHEET pending (distance/alignment)');
                        }
                    }
                }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

                // Double-click on 3D entity ‚Üí Company Focus (trunk) or Focus Lens (non-trunk)
                // BASIN-FOCUS-LOCK-1: trunk nodes route to focusCompanyOverview()
                picker.setInputAction((movement) => {
                    if (isEditSheetMode || isEditingCell) return; // don't interfere with spreadsheet editing
                    const picked = viewer.scene.pick(movement.position);
                    const id = typeof picked?.id === 'string' ? picked.id : null;
                    if (!id) return;
                    const node = resolvePickedToNode(id);
                    if (node) {
                        if (node.type === 'trunk' && typeof window.focusCompanyOverview === 'function') {
                            // Company-level basin focus ‚Äî full tree reveal without entering sheet
                            window.focusCompanyOverview(node);
                        } else {
                            // Non-trunk node ‚Äî standard Focus Lens
                        window.enterFocusMode(node);
                        }
                    }
                }, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);

                // ‚îÄ‚îÄ‚îÄ VIS-4c: MOUSE_MOVE hover handler for timebox slabs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                picker.setInputAction((movement) => {
                    const renderer = window.filamentRenderer;
                    if (!renderer || !renderer._vis4SlabRegistry || renderer._vis4SlabRegistry.size === 0) return;
                    const picked = viewer.scene.pick(movement.endPosition);
                    const id = typeof picked?.id === 'string' ? picked.id : null;
                    // Resolve slab ID (could be hover highlight or the slab itself or a label)
                    let slabId = null;
                    if (id && id.startsWith('vis4-slab-')) {
                        slabId = id;
                    } else if (id && id.startsWith('vis4c-hover-')) {
                        slabId = id.replace('vis4c-hover-', '');
                    }
                    // Check if the entity is a label with vis4SlabId property
                    if (!slabId && picked?.id && typeof picked.id === 'object' && picked.id.properties) {
                        try {
                            const v = picked.id.properties.vis4SlabId?.getValue?.() || picked.id.properties.vis4SlabId;
                            if (v && typeof v === 'string' && v.startsWith('vis4-slab-')) slabId = v;
                        } catch (_) {}
                    }
                    if (slabId) {
                        // Pinned state: don't change hover while pinned
                        if (renderer._vis4cPinnedId) return;
                        // Same slab ‚Äî no update
                        if (renderer._vis4cHoveredId === slabId) return;
                        // New slab: clear old, highlight new
                        renderer.clearVis4cHover();
                        renderer.renderVis4cHoverHighlight(slabId);
                        // Update HUD
                        const meta = renderer._vis4SlabRegistry.get(slabId);
                        if (meta && typeof hudManager !== 'undefined' && hudManager && typeof hudManager.update === 'function') {
                            hudManager.update({
                                focusTarget: `slab:${slabId}`,
                                focusHint: `Timebox ${meta.timeboxId} | commits ${meta.commitCount} | scars ${meta.scarCount} | ERI ${(meta.eriAvg / 100).toFixed(2)} | drifts ${meta.openDrifts}`
                            });
                        }
                        RelayLog.info(`[VIS4c] hover slab=${slabId} timebox=${meta?.timeboxId} owner=${meta?.ownerId}`);
                    } else {
                        // Cursor left slabs
                        if (renderer._vis4cPinnedId) return; // stay pinned
                        if (renderer._vis4cHoveredId) {
                            renderer.clearVis4cHover();
                            RelayLog.info(`[VIS4c] hoverClear`);
                        }
                    }
                }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

                // ‚îÄ‚îÄ‚îÄ VIS-7b: MOUSE_MOVE hover handler for presence markers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                picker.setInputAction((movement) => {
                    const renderer = window.filamentRenderer;
                    if (!renderer || !renderer._vis7aMarkers || renderer._vis7aMarkers.size === 0) return;
                    const picked = viewer.scene.pick(movement.endPosition);
                    const id = typeof picked?.id === 'string' ? picked.id : null;
                    let markerId = null;
                    if (id && id.startsWith('vis7a-marker-')) {
                        markerId = id;
                    } else if (id && id.startsWith('vis7b-highlight-')) {
                        markerId = id.replace('vis7b-highlight-', '');
                    }
                    // Check if entity is a label with vis7aMarkerId property
                    if (!markerId && picked?.id && typeof picked.id === 'object' && picked.id.properties) {
                        try {
                            const v = picked.id.properties.vis7aMarkerId?.getValue?.() || picked.id.properties.vis7aMarkerId;
                            if (v && typeof v === 'string' && v.startsWith('vis7a-marker-')) markerId = v;
                        } catch (_) {}
                    }
                    if (markerId) {
                        // Pinned: don't change hover while pinned (unless it's the pinned marker)
                        if (renderer._vis7bPinnedMarkerId && renderer._vis7bPinnedMarkerId !== markerId) return;
                        // Same marker ‚Äî no update
                        if (renderer._vis7bHoveredMarkerId === markerId) return;
                        // New marker: clear old, highlight new
                        renderer.vis7bRenderHighlight(markerId);
                        // Update HUD
                        const meta = renderer.vis7bGetMarkerMeta(markerId);
                        if (meta && typeof hudManager !== 'undefined' && hudManager && typeof hudManager.update === 'function') {
                            hudManager.update({
                                focusTarget: `presence:${markerId}`,
                                focusHint: `Presence: ${meta.userId} | Mode: ${meta.mode} | Age: ${meta.ageMs}ms | Target: ${meta.targetKey} | Scope: ${meta.scope}`
                            });
                        }
                        RelayLog.info(`[VIS7B] hover marker=${markerId} user=${meta?.userId} mode=${meta?.mode} scope=${meta?.scope} ageMs=${meta?.ageMs} result=PASS`);
                    } else {
                        // Cursor left markers
                        if (renderer._vis7bPinnedMarkerId) return; // stay pinned
                        if (renderer._vis7bHoveredMarkerId) {
                            renderer.vis7bClearHighlight();
                        }
                    }
                }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

                // ‚îÄ‚îÄ‚îÄ VIS-4c: Window functions for hover/pin (programmatic + proof) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                /**
                 * VIS-4c: Programmatically hover a slab by ID (for proof scripts).
                 * @param {string} slabId
                 * @returns {{ ok: boolean }}
                 */
                window.vis4cHoverSlab = (slabId) => {
                    const renderer = window.filamentRenderer;
                    if (!renderer || !renderer._vis4SlabRegistry) return { ok: false };
                    const meta = renderer._vis4SlabRegistry.get(slabId);
                    if (!meta) return { ok: false };
                    renderer.clearVis4cHover();
                    renderer.renderVis4cHoverHighlight(slabId);
                    if (typeof hudManager !== 'undefined' && hudManager && typeof hudManager.update === 'function') {
                        hudManager.update({
                            focusTarget: `slab:${slabId}`,
                            focusHint: `Timebox ${meta.timeboxId} | commits ${meta.commitCount} | scars ${meta.scarCount} | ERI ${(meta.eriAvg / 100).toFixed(2)} | drifts ${meta.openDrifts}`
                        });
                    }
                    RelayLog.info(`[VIS4c] hover slab=${slabId} timebox=${meta.timeboxId} owner=${meta.ownerId}`);
                    return { ok: true, slabId, meta };
                };

                /**
                 * VIS-4c: Pin/unpin a slab for persistent inspect.
                 * @param {string} slabId
                 * @returns {{ ok: boolean, pinned: boolean }}
                 */
                window.vis4cPinSlab = (slabId) => {
                    const renderer = window.filamentRenderer;
                    if (!renderer || !renderer._vis4SlabRegistry) return { ok: false };
                    const meta = renderer._vis4SlabRegistry.get(slabId);
                    if (!meta) return { ok: false };
                    if (renderer._vis4cPinnedId === slabId) {
                        // Unpin
                        renderer._vis4cPinnedId = null;
                        renderer.clearVis4cHover();
                        RelayLog.info(`[VIS4c] pin slab=${slabId} pinned=false`);
                        RelayLog.info(`[VIS4c] hoverClear`);
                        return { ok: true, pinned: false };
                    }
                    // Pin: ensure highlight is on
                    renderer.clearVis4cHover();
                    renderer.renderVis4cHoverHighlight(slabId);
                    renderer._vis4cPinnedId = slabId;
                    if (typeof hudManager !== 'undefined' && hudManager && typeof hudManager.update === 'function') {
                        hudManager.update({
                            focusTarget: `slab:${slabId} [PINNED]`,
                            focusHint: `Timebox ${meta.timeboxId} | commits ${meta.commitCount} | scars ${meta.scarCount} | ERI ${(meta.eriAvg / 100).toFixed(2)} | drifts ${meta.openDrifts}`
                        });
                    }
                    RelayLog.info(`[VIS4c] pin slab=${slabId} pinned=true`);
                    return { ok: true, pinned: true };
                };

                /**
                 * VIS-4c: Unpin and clear hover.
                 * @returns {{ ok: boolean }}
                 */
                window.vis4cUnpin = () => {
                    const renderer = window.filamentRenderer;
                    if (!renderer) return { ok: false };
                    const wasPinned = renderer._vis4cPinnedId;
                    renderer._vis4cPinnedId = null;
                    renderer.clearVis4cHover();
                    if (wasPinned) {
                        RelayLog.info(`[VIS4c] pin slab=${wasPinned} pinned=false`);
                    }
                    RelayLog.info(`[VIS4c] hoverClear`);
                    return { ok: true };
                };

                /**
                 * VIS-4c: Get all registered slab IDs (for proof discovery).
                 * @returns {string[]}
                 */
                window.vis4cGetSlabIds = () => {
                    const renderer = window.filamentRenderer;
                    if (!renderer || !renderer._vis4SlabRegistry) return [];
                    return Array.from(renderer._vis4SlabRegistry.keys());
                };

                // ‚îÄ‚îÄ‚îÄ VIS-4d: Slab Focus (Camera + Context Lock) functions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                /**
                 * VIS-4d: Focus camera on a slab's owner (trunk or branch).
                 * Fades non-owner slabs, highlights owner, smooth camera fly-to.
                 * @param {string} slabId - the slab that triggered focus
                 * @returns {{ ok: boolean }}
                 */
                window.vis4dFocusOwner = (slabId) => {
                    const renderer = window.filamentRenderer;
                    if (!renderer || !renderer._vis4SlabRegistry) return { ok: false };
                    const meta = renderer._vis4SlabRegistry.get(slabId);
                    if (!meta) return { ok: false };
                    const ownerId = meta.ownerId;
                    const scope = meta.scope;
                    // Store pre-focus camera state for restore
                    if (!renderer._vis4dFocusState) {
                        renderer._vis4dPreFocusCamera = {
                            position: Cesium.Cartesian3.clone(viewer.camera.position),
                            direction: Cesium.Cartesian3.clone(viewer.camera.direction),
                            up: Cesium.Cartesian3.clone(viewer.camera.up)
                        };
                    }
                    // Fade non-owner slabs
                    renderer.vis4dFadeNonOwnerSlabs(ownerId);
                    // Compute owner slab stack center (average of all owner slab centers)
                    let sumX = 0, sumY = 0, sumZ = 0, count = 0;
                    for (const [id, m] of renderer._vis4SlabRegistry) {
                        if (m.ownerId === ownerId && m.center) {
                            sumX += m.center.x; sumY += m.center.y; sumZ += m.center.z;
                            count++;
                        }
                    }
                    const stackCenter = count > 0
                        ? new Cesium.Cartesian3(sumX / count, sumY / count, sumZ / count)
                        : meta.center;
                    // Clear previous focus highlight
                    renderer.clearVis4dFocusHighlight();
                    renderer.renderVis4dOwnerHighlight(stackCenter, ownerId);
                    // Smooth camera fly-to
                    const carto = Cesium.Cartographic.fromCartesian(stackCenter);
                    if (carto) {
                        viewer.camera.flyTo({
                            destination: Cesium.Cartesian3.fromRadians(
                                carto.longitude, carto.latitude,
                                carto.height + (scope === 'sheet' ? 3000 : 8000)
                            ),
                            orientation: {
                                heading: 0,
                                pitch: Cesium.Math.toRadians(-45),
                                roll: 0
                            },
                            duration: 1.0
                        });
                    }
                    renderer._vis4dFocusState = { owner: ownerId, scope, stackCenter, slabId };
                    RelayLog.info(`[VIS4D] focusOwner result=PASS owner=${ownerId} scope=${scope}`);
                    return { ok: true, owner: ownerId, scope };
                };

                /**
                 * VIS-4d: Zoom closer to specific slab stack (while already focused on owner).
                 * @param {string} slabId
                 * @returns {{ ok: boolean }}
                 */
                window.vis4dFocusSlabStack = (slabId) => {
                    const renderer = window.filamentRenderer;
                    if (!renderer || !renderer._vis4SlabRegistry || !renderer._vis4dFocusState) {
                        return { ok: false };
                    }
                    const meta = renderer._vis4SlabRegistry.get(slabId);
                    if (!meta) return { ok: false };
                    const ownerId = meta.ownerId;
                    const tbId = meta.timeboxId;
                    // Zoom closer to this specific slab
                    const carto = Cesium.Cartographic.fromCartesian(meta.center);
                    if (carto) {
                        viewer.camera.flyTo({
                            destination: Cesium.Cartesian3.fromRadians(
                                carto.longitude, carto.latitude,
                                carto.height + 1500
                            ),
                            orientation: {
                                heading: 0,
                                pitch: Cesium.Math.toRadians(-60),
                                roll: 0
                            },
                            duration: 0.8
                        });
                    }
                    renderer._vis4dFocusState.slabId = slabId;
                    renderer._vis4dFocusState.zoomed = true;
                    RelayLog.info(`[VIS4D] focusSlabStack result=PASS owner=${ownerId} timeboxId=${tbId}`);
                    return { ok: true, owner: ownerId, timeboxId: tbId };
                };

                /**
                 * VIS-4d: Clear slab focus ‚Äî restore camera, restore slab colors, remove highlights.
                 * @returns {{ ok: boolean }}
                 */
                window.vis4dFocusClear = () => {
                    const renderer = window.filamentRenderer;
                    if (!renderer) return { ok: false };
                    // Restore slab colors
                    renderer.vis4dRestoreAllSlabColors();
                    // Remove highlight primitives
                    renderer.clearVis4dFocusHighlight();
                    // Restore camera if we have a saved state
                    if (renderer._vis4dPreFocusCamera) {
                        viewer.camera.flyTo({
                            destination: renderer._vis4dPreFocusCamera.position,
                            orientation: {
                                direction: renderer._vis4dPreFocusCamera.direction,
                                up: renderer._vis4dPreFocusCamera.up
                            },
                            duration: 0.8
                        });
                        renderer._vis4dPreFocusCamera = null;
                    }
                    renderer._vis4dFocusState = null;
                    RelayLog.info(`[VIS4D] focusClear result=PASS`);
                    return { ok: true };
                };

                // ‚îÄ‚îÄ‚îÄ VIS-6a: Live Timebox Pulse functions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                /**
                 * VIS-6a: Simulate a pulse for a given owner (for proof scripts).
                 * Injects a synthetic timebox into the seen registry so next render triggers detection,
                 * OR directly triggers the pulse visual if immediateRender=true.
                 * @param {string} ownerId
                 * @param {string} timeboxId
                 * @param {{ immediateRender?: boolean }} opts
                 * @returns {{ ok: boolean }}
                 */
                window.vis6SimulatePulse = (ownerId, timeboxId, opts = {}) => {
                    const renderer = window.filamentRenderer;
                    if (!renderer || !renderer._vis4SlabRegistry) return { ok: false };
                    // Find any slab for this owner to get its center and scope
                    let center = null;
                    let scope = 'company';
                    let slabWidth = 40;
                    for (const [, meta] of renderer._vis4SlabRegistry) {
                        if (meta.ownerId === ownerId) {
                            center = meta.center;
                            scope = meta.scope;
                            slabWidth = scope === 'company'
                                ? (ownerId.startsWith('trunk') ? 40 : 28)
                                : 18;
                            break;
                        }
                    }
                    if (!center) return { ok: false, reason: 'OWNER_NOT_FOUND' };
                    // Directly trigger the pulse visual
                    renderer.triggerVis6Pulse(ownerId, timeboxId, scope, center, slabWidth);
                    // Emit gate-summary for single simulated pulse
                    RelayLog.info(`[VIS6] gate-summary result=PASS pulses=1`);
                    return { ok: true, ownerId, timeboxId, scope };
                };

                /**
                 * VIS-6a: Get current pulse state (for proof inspection).
                 * @returns {{ activePulses: number, seenOwners: number }}
                 */
                window.vis6GetPulseState = () => {
                    const renderer = window.filamentRenderer;
                    if (!renderer) return { activePulses: 0, seenOwners: 0 };
                    return {
                        activePulses: (renderer._vis6ActivePulses || []).length,
                        seenOwners: (renderer._vis6SeenTimeboxes || new Map()).size
                    };
                };

                // ‚îÄ‚îÄ‚îÄ VIS-6b: Event Stream Pulse Propagation functions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                /**
                 * VIS-6b: Push a single event into the pulse stream.
                 * @param {{ id, ts, type, scope, ownerId, deptId?, sheetId?, timeboxId?, edges?, exceptions? }} evt
                 * @returns {{ ok: boolean, reason?: string }}
                 */
                window.vis6bPushEvent = (evt) => {
                    const renderer = window.filamentRenderer;
                    if (!renderer) return { ok: false, reason: 'NO_RENDERER' };
                    return renderer.vis6bProcessEvent(evt);
                };

                /**
                 * VIS-6b: Push a batch of events (sorted internally by ts, id).
                 * @param {Array} events
                 * @returns {{ ok: boolean, accepted: number, dropped: number }}
                 */
                window.vis6bPushEvents = (events) => {
                    const renderer = window.filamentRenderer;
                    if (!renderer) return { ok: false, accepted: 0, dropped: 0 };
                    return renderer.vis6bProcessBatch(events);
                };

                /**
                 * VIS-6b: Get event stream state.
                 */
                window.vis6bGetState = () => {
                    const renderer = window.filamentRenderer;
                    if (!renderer) return { seen: 0, activePulses: 0, dropped: {}, stats: {} };
                    return renderer.vis6bGetState();
                };

                /**
                 * VIS-6b: Reset event stream state (does not touch VIS-6a).
                 */
                window.vis6bReset = () => {
                    const renderer = window.filamentRenderer;
                    if (!renderer) return { ok: false };
                    renderer.vis6bReset();
                    return { ok: true };
                };

                /**
                 * VIS-6b: Push a deterministic canned batch for proof.
                 * Includes: 3 TIMEBOX_APPEARED, 2 duplicates, 5 rapid same-owner coalesce triggers,
                 * and a cap-pressure burst of 25 events.
                 * @returns {{ ok: boolean, batchResult: object, state: object }}
                 */
                window.vis6bSimulateBatch = () => {
                    const renderer = window.filamentRenderer;
                    if (!renderer || !renderer._vis4SlabRegistry) return { ok: false };
                    // Discover real owner IDs from slab registry
                    const owners = [];
                    for (const [, meta] of renderer._vis4SlabRegistry) {
                        if (!owners.find(o => o.id === meta.ownerId)) {
                            owners.push({ id: meta.ownerId, scope: meta.scope });
                        }
                        if (owners.length >= 4) break;
                    }
                    if (owners.length < 2) return { ok: false, reason: 'NOT_ENOUGH_OWNERS' };
                    const now = Date.now();
                    const events = [];
                    // 3 TIMEBOX_APPEARED (trunk + 2 dept branches)
                    events.push({ id: 'evt-tb-1', ts: now, type: 'TIMEBOX_APPEARED', scope: owners[0].scope, ownerId: owners[0].id, deptId: null, timeboxId: 'T-BATCH-1' });
                    events.push({ id: 'evt-tb-2', ts: now + 1, type: 'TIMEBOX_APPEARED', scope: owners[1].scope, ownerId: owners[1].id, deptId: owners[1].id, timeboxId: 'T-BATCH-2' });
                    if (owners.length >= 3) {
                        events.push({ id: 'evt-tb-3', ts: now + 2, type: 'TIMEBOX_APPEARED', scope: owners[2].scope, ownerId: owners[2].id, deptId: owners[2].id, timeboxId: 'T-BATCH-3' });
                    }
                    // 2 duplicates (same ids as above)
                    events.push({ id: 'evt-tb-1', ts: now + 3, type: 'TIMEBOX_APPEARED', scope: owners[0].scope, ownerId: owners[0].id, timeboxId: 'T-BATCH-1' });
                    events.push({ id: 'evt-tb-2', ts: now + 4, type: 'TIMEBOX_APPEARED', scope: owners[1].scope, ownerId: owners[1].id, timeboxId: 'T-BATCH-2' });
                    // 5 rapid events same (owner, timebox) ‚Üí should coalesce
                    for (let i = 0; i < 5; i++) {
                        events.push({ id: `evt-coal-${i}`, ts: now + 10 + i, type: 'TIMEBOX_APPEARED', scope: owners[0].scope, ownerId: owners[0].id, timeboxId: 'T-COAL-X' });
                    }
                    // 25 events for cap pressure (unique ids, spread across owners)
                    for (let i = 0; i < 25; i++) {
                        const ownerIdx = i % owners.length;
                        events.push({ id: `evt-cap-${i}`, ts: now + 100 + i, type: 'TIMEBOX_APPEARED', scope: owners[ownerIdx].scope, ownerId: owners[ownerIdx].id, timeboxId: `T-CAP-${i}` });
                    }
                    const batchResult = renderer.vis6bProcessBatch(events);
                    renderer.vis6bLogSummary();
                    const state = renderer.vis6bGetState();
                    return { ok: true, batchResult, state };
                };

                // ‚îÄ‚îÄ‚îÄ VIS-6c: Transport Shim (WebSocket ‚Üí VIS-6b) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                const _vis6c = {
                    ws: null,
                    connected: false,
                    url: null,
                    accepted: 0,
                    dropped: 0,
                    lastError: null,
                    _msgLogThrottle: 0 // signature-gate: max 1 wsMessage log per second
                };

                /**
                 * VIS-6c: Normalize a raw inbound event to VIS-6b schema.
                 * Returns null if invalid (missing required fields / bad ts).
                 * @param {object} raw
                 * @returns {object|null}
                 */
                function vis6cNormalize(raw) {
                    if (!raw || typeof raw !== 'object') return null;
                    const id = raw.id != null ? String(raw.id) : null;
                    const ownerId = raw.ownerId != null ? String(raw.ownerId) : null;
                    const timeboxId = raw.timeboxId != null ? String(raw.timeboxId) : null;
                    const ts = Number(raw.ts);
                    if (!id || !ownerId || !timeboxId) return null;
                    if (!Number.isFinite(ts) || ts <= 0) return null;
                    return {
                        id,
                        ts,
                        type: raw.type || 'TIMEBOX_APPEARED',
                        scope: raw.scope || 'company',
                        ownerId,
                        deptId: raw.deptId != null ? String(raw.deptId) : null,
                        sheetId: raw.sheetId != null ? String(raw.sheetId) : null,
                        timeboxId,
                        edges: typeof raw.edges === 'number' ? raw.edges : null,
                        exceptions: typeof raw.exceptions === 'number' ? raw.exceptions : null,
                        src: 'ws',
                        recvTs: Date.now()
                    };
                }

                /**
                 * VIS-6c: Connect to WebSocket event stream.
                 * @param {string} [urlOverride] - optional URL override
                 * @returns {{ ok: boolean, reason?: string }}
                 */
                window.vis6cConnect = (urlOverride) => {
                    if (_vis6c.ws && _vis6c.connected) return { ok: false, reason: 'ALREADY_CONNECTED' };
                    // Check VIS-6b API exists
                    if (typeof window.vis6bPushEvent !== 'function' || typeof window.vis6bPushEvents !== 'function') {
                        console.info('[REFUSAL] reason=VIS6C_NO_VIS6B_API');
                        return { ok: false, reason: 'VIS6C_NO_VIS6B_API' };
                    }
                    // Resolve URL
                    const params = new URLSearchParams(window.location.search);
                    const url = urlOverride
                        || window.RELAY_VIS6_WS_URL
                        || params.get('vis6ws')
                        || 'ws://127.0.0.1:4030/vis6';
                    _vis6c.url = url;
                    console.info(`[VIS6C] wsConnect url=${url}`);
                    const VIS6C_BATCH_CAP = 200;
                    try {
                        const ws = new WebSocket(url);
                        _vis6c.ws = ws;

                        ws.onopen = () => {
                            _vis6c.connected = true;
                            console.info(`[VIS6C] wsOpen url=${url}`);
                        };

                        ws.onclose = (evt) => {
                            _vis6c.connected = false;
                            _vis6c.ws = null;
                            console.info(`[VIS6C] wsClose code=${evt.code} reason=${evt.reason || 'none'}`);
                        };

                        ws.onerror = (err) => {
                            _vis6c.lastError = String(err?.message || err || 'unknown');
                        };

                        ws.onmessage = (msgEvt) => {
                            let parsed;
                            try {
                                parsed = JSON.parse(msgEvt.data);
                            } catch {
                                _vis6c.dropped++;
                                console.info('[VIS6C] drop reason=bad_json');
                                return;
                            }
                            // Determine if batch or single
                            let rawEvents;
                            if (Array.isArray(parsed?.events)) {
                                rawEvents = parsed.events;
                            } else if (parsed && typeof parsed === 'object' && parsed.id) {
                                rawEvents = [parsed];
                            } else {
                                _vis6c.dropped++;
                                console.info('[VIS6C] drop reason=bad_json');
                                return;
                            }
                            // Cap check
                            if (rawEvents.length > VIS6C_BATCH_CAP) {
                                const excess = rawEvents.length - VIS6C_BATCH_CAP;
                                _vis6c.dropped += excess;
                                console.info(`[REFUSAL] reason=VIS6C_BATCH_CAP_EXCEEDED dropped=${excess}`);
                                rawEvents = rawEvents.slice(0, VIS6C_BATCH_CAP);
                            }
                            // Normalize
                            const normalized = [];
                            let msgDropped = 0;
                            for (const raw of rawEvents) {
                                const evt = vis6cNormalize(raw);
                                if (evt) {
                                    normalized.push(evt);
                                } else {
                                    msgDropped++;
                                    // Determine specific drop reason
                                    if (!raw || typeof raw !== 'object') {
                                        console.info('[VIS6C] drop reason=missing_fields');
                                    } else {
                                        const ts = Number(raw.ts);
                                        if (!Number.isFinite(ts) || ts <= 0) {
                                            console.info('[VIS6C] drop reason=bad_ts');
                                        } else {
                                            console.info('[VIS6C] drop reason=missing_fields');
                                        }
                                    }
                                }
                            }
                            _vis6c.dropped += msgDropped;
                            // Deliver to VIS-6b
                            let msgAccepted = 0;
                            if (normalized.length > 0) {
                                if (normalized.length === 1) {
                                    const result = window.vis6bPushEvent(normalized[0]);
                                    if (result?.ok) msgAccepted = 1;
                                } else {
                                    const result = window.vis6bPushEvents(normalized);
                                    msgAccepted = result?.accepted || 0;
                                }
                            }
                            _vis6c.accepted += msgAccepted;
                            // Signature-gated log (max 1/sec)
                            const now = Date.now();
                            if (now - _vis6c._msgLogThrottle >= 1000) {
                                _vis6c._msgLogThrottle = now;
                                console.info(`[VIS6C] wsMessage accepted=${msgAccepted} dropped=${msgDropped}`);
                            }
                        };

                        return { ok: true };
                    } catch (err) {
                        _vis6c.lastError = String(err?.message || err);
                        return { ok: false, reason: String(err?.message || err) };
                    }
                };

                /**
                 * VIS-6c: Disconnect from WebSocket.
                 */
                window.vis6cDisconnect = () => {
                    if (_vis6c.ws) {
                        try { _vis6c.ws.close(1000, 'vis6cDisconnect'); } catch {}
                    }
                    _vis6c.connected = false;
                    _vis6c.ws = null;
                    return { ok: true };
                };

                /**
                 * VIS-6c: Get transport state.
                 */
                window.vis6cGetState = () => {
                    return {
                        connected: _vis6c.connected,
                        url: _vis6c.url,
                        accepted: _vis6c.accepted,
                        dropped: _vis6c.dropped,
                        lastError: _vis6c.lastError
                    };
                };

                // VIS-6c: Auto-connect if enabled (not in launch mode ‚Äî no dev auto-hooks)
                if (window.RELAY_ENABLE_VIS6C === true && !window.RELAY_LAUNCH_MODE) {
                    const params = new URLSearchParams(window.location.search);
                    const profile = params.get('profile') || '';
                    if (profile === 'world') {
                        setTimeout(() => window.vis6cConnect(), 500);
                    }
                }

                // ‚îÄ‚îÄ‚îÄ VIS-7a: Presence Markers (Ephemeral) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                const _vis7aWs = {
                    ws: null,
                    connected: false,
                    url: null,
                    lastError: null
                };

                /**
                 * VIS-7a: Push a single presence event.
                 */
                window.vis7aPushEvent = (evt) => {
                    const renderer = window.filamentRenderer;
                    if (!renderer) return { ok: false, reason: 'NO_RENDERER' };
                    return renderer.vis7aProcessEvent(evt);
                };

                /**
                 * VIS-7a: Push a batch of presence events.
                 */
                window.vis7aPushEvents = (evts) => {
                    const renderer = window.filamentRenderer;
                    if (!renderer) return { ok: false, accepted: 0, dropped: 0 };
                    return renderer.vis7aProcessBatch(evts);
                };

                /**
                 * VIS-7a: Get presence state.
                 */
                window.vis7aGetState = () => {
                    const renderer = window.filamentRenderer;
                    if (!renderer) return { active: 0, seenIds: 0, dropped: 0, coalesced: 0, capRefusals: 0 };
                    return renderer.vis7aGetState();
                };

                /**
                 * VIS-7a: Reset presence state.
                 */
                window.vis7aReset = () => {
                    const renderer = window.filamentRenderer;
                    if (!renderer) return { ok: false };
                    renderer.vis7aReset();
                    return { ok: true };
                };

                /**
                 * VIS-7a: Connect to a presence WS feed.
                 * @param {string} [wsUrl]
                 */
                window.vis7aConnect = (wsUrl) => {
                    if (_vis7aWs.ws && _vis7aWs.connected) return { ok: false, reason: 'ALREADY_CONNECTED' };
                    const renderer = window.filamentRenderer;
                    if (!renderer) return { ok: false, reason: 'NO_RENDERER' };
                    const params = new URLSearchParams(window.location.search);
                    const url = wsUrl
                        || window.RELAY_VIS7_WS_URL
                        || params.get('vis7ws')
                        || 'ws://127.0.0.1:4031/vis7';
                    _vis7aWs.url = url;
                    console.info(`[VIS7A] wsConnect url=${url}`);
                    try {
                        const ws = new WebSocket(url);
                        _vis7aWs.ws = ws;
                        ws.onopen = () => {
                            _vis7aWs.connected = true;
                            console.info(`[VIS7A] wsOpen url=${url}`);
                        };
                        ws.onclose = (evt) => {
                            _vis7aWs.connected = false;
                            _vis7aWs.ws = null;
                            console.info(`[VIS7A] wsClose code=${evt.code} reason=${evt.reason || 'none'}`);
                        };
                        ws.onerror = (err) => {
                            _vis7aWs.lastError = String(err?.message || err || 'unknown');
                        };
                        ws.onmessage = (msgEvt) => {
                            let parsed;
                            try {
                                parsed = JSON.parse(msgEvt.data);
                            } catch {
                                console.info('[VIS7A] drop reason=bad_json');
                                return;
                            }
                            let rawEvents;
                            if (Array.isArray(parsed?.events)) rawEvents = parsed.events;
                            else if (parsed && typeof parsed === 'object' && parsed.id) rawEvents = [parsed];
                            else { console.info('[VIS7A] drop reason=bad_json'); return; }
                            // Cap per-message
                            if (rawEvents.length > 200) rawEvents = rawEvents.slice(0, 200);
                            // Normalize and deliver
                            const normalized = [];
                            for (const raw of rawEvents) {
                                if (!raw || typeof raw !== 'object') continue;
                                const id = raw.id != null ? String(raw.id) : null;
                                const userId = raw.userId != null ? String(raw.userId) : null;
                                const ts = Number(raw.ts);
                                if (!id || !userId || !Number.isFinite(ts) || ts <= 0) continue;
                                normalized.push({
                                    id, ts, userId,
                                    type: 'presence',
                                    scope: raw.scope || 'company',
                                    companyId: raw.companyId || null,
                                    deptId: raw.deptId != null ? String(raw.deptId) : null,
                                    sheetId: raw.sheetId != null ? String(raw.sheetId) : null,
                                    mode: raw.mode || 'view',
                                    cursor: raw.cursor || null
                                });
                            }
                            if (normalized.length > 0) {
                                renderer.vis7aProcessBatch(normalized);
                            }
                        };
                        return { ok: true };
                    } catch (err) {
                        _vis7aWs.lastError = String(err?.message || err);
                        return { ok: false, reason: String(err?.message || err) };
                    }
                };

                /**
                 * VIS-7a: Disconnect from presence WS.
                 */
                window.vis7aDisconnect = () => {
                    if (_vis7aWs.ws) {
                        try { _vis7aWs.ws.close(1000, 'vis7aDisconnect'); } catch {}
                    }
                    _vis7aWs.connected = false;
                    _vis7aWs.ws = null;
                    return { ok: true };
                };

                /**
                 * VIS-7a: Simulate a deterministic burst for proofs.
                 * @param {{ target: 'company'|'dept'|'sheet', n: number }} opts
                 */
                window.vis7aSimulateBurst = (opts = {}) => {
                    const renderer = window.filamentRenderer;
                    if (!renderer || !renderer._vis4SlabRegistry) return { ok: false };
                    const target = opts.target || 'company';
                    const n = opts.n || 60;
                    const now = Date.now();
                    // Find owner IDs from slab registry
                    const owners = [];
                    for (const [, meta] of renderer._vis4SlabRegistry) {
                        if (!owners.find(o => o.id === meta.ownerId)) {
                            owners.push({ id: meta.ownerId, scope: meta.scope });
                        }
                        if (owners.length >= 4) break;
                    }
                    if (owners.length === 0) return { ok: false, reason: 'NO_OWNERS' };
                    const events = [];
                    for (let i = 0; i < n; i++) {
                        const ownerIdx = i % owners.length;
                        const evt = {
                            id: `vis7a-burst-${i}`,
                            ts: now + i,
                            userId: `u-burst-${i}`,
                            type: 'presence',
                            scope: target === 'sheet' ? 'sheet' : (target === 'dept' ? 'dept' : 'company'),
                            companyId: owners[0].id,
                            deptId: owners.length > 1 ? owners[ownerIdx].id : null,
                            sheetId: target === 'sheet' && owners.length > 1 ? owners[ownerIdx].id : null,
                            mode: i % 3 === 0 ? 'edit' : 'view'
                        };
                        events.push(evt);
                    }
                    const result = renderer.vis7aProcessBatch(events);
                    return { ok: true, result, state: renderer.vis7aGetState() };
                };

                // ‚îÄ‚îÄ‚îÄ VIS-7b: Presence Inspect window functions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

                /**
                 * VIS-7b: Click handler for presence markers (pin/unpin/switch).
                 * @param {string} markerId
                 * @returns {{ ok: boolean, action?: string }}
                 */
                window.vis7bClickMarker = (markerId) => {
                    const renderer = window.filamentRenderer;
                    if (!renderer) return { ok: false };
                    const meta = renderer.vis7bGetMarkerMeta(markerId);
                    if (!meta) return { ok: false, reason: 'UNKNOWN_MARKER' };
                    const currentPinned = renderer._vis7bPinnedMarkerId;
                    if (currentPinned === markerId) {
                        // Toggle unpin
                        renderer._vis7bPinnedMarkerId = null;
                        renderer.vis7bClearHighlight();
                        RelayLog.info(`[VIS7B] unpin marker=${markerId} user=${meta.userId} result=PASS reason=toggle`);
                        return { ok: true, action: 'unpin', reason: 'toggle' };
                    } else if (currentPinned) {
                        // Switch pin
                        const oldMeta = renderer.vis7bGetMarkerMeta(currentPinned);
                        RelayLog.info(`[VIS7B] unpin marker=${currentPinned} user=${oldMeta?.userId || 'unknown'} result=PASS reason=switch`);
                        renderer._vis7bPinnedMarkerId = markerId;
                        renderer.vis7bRenderHighlight(markerId);
                        RelayLog.info(`[VIS7B] pin marker=${markerId} user=${meta.userId} result=PASS`);
                        // Update HUD
                        if (typeof hudManager !== 'undefined' && hudManager && typeof hudManager.update === 'function') {
                            hudManager.update({
                                focusTarget: `presence:${markerId}`,
                                focusHint: `Presence: ${meta.userId} | Mode: ${meta.mode} | Age: ${meta.ageMs}ms | Target: ${meta.targetKey} | Scope: ${meta.scope}`
                            });
                        }
                        RelayLog.info(`[VIS7B] hudUpdate user=${meta.userId} fields=6 result=PASS`);
                        return { ok: true, action: 'switch' };
                    } else {
                        // Pin
                        renderer._vis7bPinnedMarkerId = markerId;
                        renderer.vis7bRenderHighlight(markerId);
                        RelayLog.info(`[VIS7B] pin marker=${markerId} user=${meta.userId} result=PASS`);
                        // Update HUD
                        if (typeof hudManager !== 'undefined' && hudManager && typeof hudManager.update === 'function') {
                            hudManager.update({
                                focusTarget: `presence:${markerId}`,
                                focusHint: `Presence: ${meta.userId} | Mode: ${meta.mode} | Age: ${meta.ageMs}ms | Target: ${meta.targetKey} | Scope: ${meta.scope}`
                            });
                        }
                        RelayLog.info(`[VIS7B] hudUpdate user=${meta.userId} fields=6 result=PASS`);
                        return { ok: true, action: 'pin' };
                    }
                };

                /**
                 * VIS-7b: Unpin presence marker (called by Escape or programmatically).
                 * @param {string} [reason='escape']
                 * @returns {{ ok: boolean }}
                 */
                window.vis7bUnpin = (reason = 'escape') => {
                    const renderer = window.filamentRenderer;
                    if (!renderer) return { ok: false };
                    const markerId = renderer._vis7bPinnedMarkerId;
                    if (!markerId) return { ok: false, reason: 'NOT_PINNED' };
                    const meta = renderer.vis7bGetMarkerMeta(markerId);
                    renderer._vis7bPinnedMarkerId = null;
                    renderer.vis7bClearHighlight();
                    RelayLog.info(`[VIS7B] unpin marker=${markerId} user=${meta?.userId || 'unknown'} result=PASS reason=${reason}`);
                    return { ok: true };
                };

                /**
                 * VIS-7b: Programmatically hover a marker (for proof scripts).
                 * @param {string} markerId
                 * @returns {{ ok: boolean }}
                 */
                window.vis7bHoverMarker = (markerId) => {
                    const renderer = window.filamentRenderer;
                    if (!renderer) return { ok: false };
                    const meta = renderer.vis7bGetMarkerMeta(markerId);
                    if (!meta) return { ok: false, reason: 'UNKNOWN_MARKER' };
                    renderer.vis7bRenderHighlight(markerId);
                    if (typeof hudManager !== 'undefined' && hudManager && typeof hudManager.update === 'function') {
                        hudManager.update({
                            focusTarget: `presence:${markerId}`,
                            focusHint: `Presence: ${meta.userId} | Mode: ${meta.mode} | Age: ${meta.ageMs}ms | Target: ${meta.targetKey} | Scope: ${meta.scope}`
                        });
                    }
                    RelayLog.info(`[VIS7B] hover marker=${markerId} user=${meta.userId} mode=${meta.mode} scope=${meta.scope} ageMs=${meta.ageMs} result=PASS`);
                    return { ok: true };
                };

                /**
                 * VIS-7b: Get list of active marker IDs (for proof scripts).
                 * @returns {string[]}
                 */
                window.vis7bGetMarkerIds = () => {
                    const renderer = window.filamentRenderer;
                    if (!renderer || !renderer._vis7aMarkers) return [];
                    const ids = [];
                    for (const [, m] of renderer._vis7aMarkers) {
                        if (m.markerId) ids.push(m.markerId);
                    }
                    return ids;
                };

                /**
                 * VIS-7b: Get current inspect state.
                 * @returns {{ hoveredMarkerId: string|null, pinnedMarkerId: string|null }}
                 */
                window.vis7bGetInspectState = () => {
                    const renderer = window.filamentRenderer;
                    return {
                        hoveredMarkerId: renderer?._vis7bHoveredMarkerId || null,
                        pinnedMarkerId: renderer?._vis7bPinnedMarkerId || null
                    };
                };

                // ‚îÄ‚îÄ‚îÄ PRESENCE-STREAM-1 + PRESENCE-RENDER-1 wiring ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                const _presenceEngine = new PresenceEngine({
                    log: (msg) => {
                        if (typeof RelayLog !== 'undefined' && RelayLog.info) RelayLog.info(msg);
                        console.log(msg);
                    },
                    onMessage: (msg) => {
                        if (_presenceRtc && msg?.type === 'rtc-signal') {
                            _presenceRtc.handleRtcSignal(msg);
                        }
                    },
                    onRoomChange: (roomId, members) => {
                        // Feed HUD with latest presence + VIS8 state
                        if (typeof hudManager !== 'undefined' && hudManager && typeof hudManager.update === 'function') {
                            const snap = _presenceEngine.snapshot();
                            const rtcState = _presenceRtc ? _presenceRtc.getState() : { camOn: false, micOn: false, pinnedCount: 0 };
                            const wsUp = _presenceEngine.wsState === 'connected';
                            hudManager.update({
                                presenceMembers: snap.memberCount,
                                presenceMax: snap.maxMembers,
                                presenceScope: snap.members.find(m => m.userId === _presenceEngine._localUserId)?.scopeId || 'n/a',
                                presenceFocus: snap.members.find(m => m.userId === _presenceEngine._localUserId)?.focusId || 'n/a',
                                presenceNet: wsUp ? 'ON' : 'OFF',
                                vis8Cam: rtcState.camOn ? 'ON' : 'OFF',
                                vis8Mic: rtcState.micOn ? 'ON' : 'OFF',
                                vis8Pinned: rtcState.pinnedCount || 0
                            });
                        }
                    }
                });
                window._presenceEngine = _presenceEngine;
                const _presenceRenderer = new PresenceRenderer({
                    log: (msg) => {
                        if (typeof RelayLog !== 'undefined' && RelayLog.info) RelayLog.info(msg);
                        console.log(msg);
                    }
                });
                const _presenceRtc = new PresenceWebRTCAdapter({
                    presenceEngine: _presenceEngine,
                    log: (msg) => {
                        if (typeof RelayLog !== 'undefined' && RelayLog.info) RelayLog.info(msg);
                        console.log(msg);
                    }
                });
                window._presenceRenderer = _presenceRenderer;
                window._presenceRtc = _presenceRtc;

                // Enable with local user ID (deterministic for demo)
                const _presenceUserId = `user.local.${Date.now().toString(36)}`;
                window.relayPresenceEnable = (userId) => {
                    return _presenceEngine.enable(userId || _presenceUserId);
                };
                window.relayPresenceDisable = () => {
                    _presenceEngine.disable();
                };
                window.relayPresenceGetStatus = () => {
                    return _presenceEngine.getStatus();
                };
                window.relayPresenceGetSnapshot = () => {
                    return _presenceEngine.snapshot();
                };
                window.relayPresenceResolveRoom = (scopeId) => {
                    return _presenceEngine.resolveRoomId(scopeId);
                };
                window.relayPresenceJoin = (roomId, scopePayload) => {
                    return _presenceEngine.join(_presenceEngine._localUserId, roomId, scopePayload);
                };
                window.relayPresenceLeave = (roomId, reason) => {
                    return _presenceEngine.leave(_presenceEngine._localUserId, roomId, reason);
                };
                window.relayPresenceBind = (bindPayload) => {
                    return _presenceEngine.bind(bindPayload);
                };
                window.relayPresenceWsConnect = (url) => {
                    return _presenceEngine.wsConnect(url);
                };
                window.relayPresenceWsDisconnect = () => {
                    _presenceEngine.wsDisconnect();
                };
                window.relayPresenceRtcState = () => _presenceRtc.getState();
                window.relayPresenceToggleCam = async (on) => _presenceRtc.setCamera(on);
                window.relayPresenceToggleMic = async (on) => _presenceRtc.setMic(on);
                window.relayPresencePinUser = (userId) => {
                    const out = _presenceRtc.pinUser(userId);
                    if (out?.ok) {
                        _presenceRenderer.setPinned(_presenceRtc.pinned.size > 0 ? [..._presenceRtc.pinned][0] : null);
                        window.relayPresenceRenderNow('STAGE');
                    }
                    return out;
                };
                window.relayPresenceSimulateRtcPeer = (peerId = 'user.remote.1') => _presenceRtc.simulateHandshake(peerId);
                window.relayPresenceRenderNow = (lod = null) => {
                    const snap = _presenceEngine.snapshot();
                    const participants = (snap.members || []).map((m) => ({
                        userId: m.userId,
                        distance: m.userId === snap.userId ? 0 : 10
                    }));
                    const scopeState = typeof window.relayGetScopeState === 'function'
                        ? window.relayGetScopeState() : null;
                    const lodKey = String(lod || scopeState?.effectiveScope || 'COMPANY').toUpperCase();
                    const out = _presenceRtc.evaluateBudgets({ lod: lodKey, participants });
                    _presenceRenderer.render({
                        participants,
                        lod: lodKey,
                        decodeSet: out.decodeSet,
                        renderSet: out.renderSet,
                        camOn: _presenceRtc.camOn
                    });
                    if (typeof hudManager !== 'undefined' && hudManager && typeof hudManager.update === 'function') {
                        hudManager.update({
                            vis8Decode: `${out.decodeSet.size}/${out.budget.decode}`,
                            vis8Render: `${out.renderSet.size}/${out.budget.render}`,
                            vis8Pinned: _presenceRtc.pinned.size
                        });
                    }
                    return { ok: true, lod: lodKey };
                };

                // Event-driven bind hooks + 10s safety net.
                const _collectPresenceBindPayload = () => {
                    const scopeState = typeof window.relayGetScopeState === 'function'
                        ? window.relayGetScopeState() : null;
                    const effectiveScope = scopeState?.effectiveScope || scopeState?.tier || 'company';
                    const scopeId = scopeState?.scopeId || scopeState?.activeTrunkId || null;
                    if (!scopeId) return null; // scope not ready ‚Äî defer bind
                    const focusId = String(window.__relayArtifactFocusedObjectId || '').trim() || null;
                    let ride = null;
                    if (filamentRideState?.active) {
                        ride = {
                            filamentId: filamentRideState.filamentId || null,
                            stepIndex: filamentRideState.currentIndex ?? -1,
                            timeboxId: filamentRideState.currentTimeboxId || null
                        };
                    }
                    return { effectiveScope, scopeId, focusId, ride };
                };
                window.relayPresenceEventBind = (cause = 'focus') => {
                    if (!_presenceEngine._enabled) return { ok: false, reason: 'ENGINE_DISABLED' };
                    const payload = _collectPresenceBindPayload();
                    if (!payload) {
                        if (!window._presenceBindDeferredLogged) {
                            window._presenceBindDeferredLogged = true;
                            const logMsg = `[PRESENCE] bind deferred=PASS reason=scopeNotReady`;
                            if (typeof RelayLog !== 'undefined') RelayLog.info(logMsg);
                            console.log(logMsg);
                        }
                        return { ok: false, reason: 'SCOPE_NOT_READY' };
                    }
                    window._presenceBindDeferredLogged = false;
                    return _presenceEngine.bindFromEvent(cause, payload);
                };
                window._presenceBindSafetyTimer = null;
                const _startPresenceBindSafety = () => {
                    if (window._presenceBindSafetyTimer) return;
                    window._presenceBindSafetyTimer = setInterval(() => {
                        if (!_presenceEngine._enabled) return;
                        window.relayPresenceEventBind('safety');
                    }, 10000);
                };

                // Auto-enable presence in launch mode
                if (window.RELAY_LAUNCH_MODE) {
                    _presenceEngine.enable(_presenceUserId);
                    // Derive initial scope and auto-join
                    const initScopeState = typeof window.relayGetScopeState === 'function'
                        ? window.relayGetScopeState() : null;
                    const initScopeId = initScopeState?.scopeId || initScopeState?.activeTrunkId || 'trunk.avgol';
                    const initRoomId = _presenceEngine.resolveRoomId(initScopeId);
                    if (initRoomId) {
                        _presenceEngine.join(_presenceUserId, initRoomId, {
                            effectiveScope: initScopeState?.effectiveScope || 'company',
                            scopeId: initScopeId,
                            focusId: null
                        });
                    }
                    _presenceEngine.wsConnect();
                    _presenceRtc.enable({ userId: _presenceUserId, roomId: initRoomId });
                    _presenceRtc.requestPermissions();
                    _presenceRtc.rtcJoin(initRoomId, []);
                    _startPresenceBindSafety();
                    window.relayPresenceEventBind('scope');
                    window.relayPresenceRenderNow('COMPANY');
                }
                // ‚îÄ‚îÄ‚îÄ End PRESENCE-STREAM-1 + PRESENCE-RENDER-1 wiring ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

                // ‚îÄ‚îÄ‚îÄ PRESENCE-COMMIT-BOUNDARY-1: Consent state machine + W0‚ÄìW2 integration ‚îÄ‚îÄ
                const _callCommitState = {
                    state: 'IDLE',       // IDLE | REQUESTED | COLLECTING | GRANTED | DENIED | EXPIRED
                    roomId: null,
                    requestedBy: null,
                    requestedAt: null,
                    participants: [],     // frozen at request time
                    votes: new Map(),     // userId -> 'accept' | 'deny'
                    ttlTimer: null,
                    title: null,
                    callStartedAt: null,
                    lastSummaryId: null
                };
                window._callCommitState = _callCommitState;

                const CONSENT_TTL_MS = 60000;

                const _callLog = (msg) => {
                    if (typeof RelayLog !== 'undefined' && RelayLog.info) RelayLog.info(msg);
                    console.log(msg);
                };

                const _resetCallCommitState = () => {
                    if (_callCommitState.ttlTimer) clearTimeout(_callCommitState.ttlTimer);
                    _callCommitState.state = 'IDLE';
                    _callCommitState.roomId = null;
                    _callCommitState.requestedBy = null;
                    _callCommitState.requestedAt = null;
                    _callCommitState.participants = [];
                    _callCommitState.votes = new Map();
                    _callCommitState.ttlTimer = null;
                    _callCommitState.title = null;
                };

                /**
                 * Trigger "Commit Call Summary" ‚Äî explicit user action only.
                 * @param {{ title?: string }} opts
                 */
                window.relayCallCommitRequest = function(opts = {}) {
                    const userId = _presenceEngine._localUserId;
                    const localRooms = _presenceEngine.getLocalRooms();
                    const roomId = localRooms[0] || null;

                    // Guard: must be in a room
                    if (!roomId || !_presenceEngine.rooms.has(roomId)) {
                        _callLog(`[REFUSAL] reason=CALL_COMMIT_NOT_IN_ROOM user=${userId} room=${roomId || 'null'}`);
                        return { ok: false, reason: 'CALL_COMMIT_NOT_IN_ROOM' };
                    }

                    // Guard: room must have members
                    const snap = _presenceEngine.getRoomSnapshot(roomId);
                    if (!snap.participants || snap.participants.length === 0) {
                        _callLog(`[REFUSAL] reason=CALL_COMMIT_ROOM_EMPTY room=${roomId}`);
                        return { ok: false, reason: 'CALL_COMMIT_ROOM_EMPTY' };
                    }

                    // Guard: scope must be resolved
                    if (!snap.scopeId) {
                        _callLog(`[REFUSAL] reason=CALL_COMMIT_SCOPE_UNRESOLVED room=${roomId}`);
                        return { ok: false, reason: 'CALL_COMMIT_SCOPE_UNRESOLVED' };
                    }

                    // Guard: no already-pending request
                    if (_callCommitState.state !== 'IDLE') {
                        _callLog(`[REFUSAL] reason=CALL_COMMIT_ALREADY_PENDING room=${roomId}`);
                        return { ok: false, reason: 'CALL_COMMIT_ALREADY_PENDING' };
                    }

                    // Transition to REQUESTED ‚Üí COLLECTING
                    _callCommitState.state = 'COLLECTING';
                    _callCommitState.roomId = roomId;
                    _callCommitState.requestedBy = userId;
                    _callCommitState.requestedAt = Date.now();
                    _callCommitState.participants = [...snap.participants]; // frozen copy
                    _callCommitState.votes = new Map();
                    _callCommitState.title = typeof opts.title === 'string' ? opts.title.slice(0, 240) : null;
                    _callCommitState.callStartedAt = opts.callStartedAt || null;

                    _callLog(`[CALL] commitSummary requested room=${roomId} scope=${snap.scopeId} by=${userId} result=PASS`);
                    _callLog(`[CALL] consent request sent room=${roomId} participants=${snap.participants.length} ttlMs=${CONSENT_TTL_MS} result=PASS`);

                    // Start TTL timer
                    _callCommitState.ttlTimer = setTimeout(() => {
                        if (_callCommitState.state === 'COLLECTING') {
                            const missing = _callCommitState.participants.filter(p => !_callCommitState.votes.has(p)).length;
                            _callCommitState.state = 'EXPIRED';
                            _callLog(`[CALL] consent state=EXPIRED missing=${missing} result=PASS`);
                            _callLog(`[REFUSAL] reason=CALL_COMMIT_CONSENT_EXPIRED room=${roomId} missing=${missing}`);
                            _resetCallCommitState();
                        }
                    }, CONSENT_TTL_MS);

                    return { ok: true, state: 'COLLECTING', participants: snap.participants.length };
                };

                /**
                 * Cast a consent vote (each participant calls this).
                 * Async because hash computation (SHA-256) is async.
                 * @param {string} userId
                 * @param {'accept'|'deny'} value
                 */
                window.relayCallCommitVote = async function(userId, value) {
                    if (_callCommitState.state !== 'COLLECTING') {
                        _callLog(`[CALL] consent vote user=${userId} value=${value} result=REFUSED state=${_callCommitState.state}`);
                        return { ok: false, reason: 'NOT_COLLECTING' };
                    }

                    if (!_callCommitState.participants.includes(userId)) {
                        _callLog(`[REFUSAL] reason=CALL_COMMIT_NOT_IN_ROOM user=${userId} room=${_callCommitState.roomId}`);
                        return { ok: false, reason: 'CALL_COMMIT_NOT_IN_ROOM' };
                    }

                    _callCommitState.votes.set(userId, value);
                    _callLog(`[CALL] consent vote user=${userId} value=${value} result=PASS`);

                    // Check for denial
                    if (value === 'deny') {
                        _callCommitState.state = 'DENIED';
                        _callLog(`[CALL] consent state=DENIED missing=0 result=PASS`);
                        _callLog(`[REFUSAL] reason=CALL_COMMIT_CONSENT_DENIED deniedBy=${userId} room=${_callCommitState.roomId}`);
                        _resetCallCommitState();
                        return { ok: true, state: 'DENIED' };
                    }

                    // Check if all accepted (unanimous)
                    const accepted = _callCommitState.participants.filter(p => _callCommitState.votes.get(p) === 'accept');
                    const missing = _callCommitState.participants.length - accepted.length;

                    if (missing > 0) {
                        _callLog(`[CALL] consent state=COLLECTING missing=${missing} result=PASS`);
                        return { ok: true, state: 'COLLECTING', missing };
                    }

                    // All accepted ‚Äî GRANTED
                    _callCommitState.state = 'GRANTED';
                    if (_callCommitState.ttlTimer) clearTimeout(_callCommitState.ttlTimer);
                    _callLog(`[CALL] consent state=GRANTED missing=0 result=PASS`);

                    // Auto-proceed to build summary + PROPOSE + timebox event
                    const result = await _buildAndProposeCallSummary();
                    return { ok: true, state: 'GRANTED', proposal: result };
                };

                /**
                 * Build call summary payload, compute hashes, PROPOSE artifact, append timebox event.
                 */
                async function _buildAndProposeCallSummary() {
                    const sha256Fn = _sha256Fn;
                    const canonicalJsonFn = _canonicalJsonFn;

                    const roomId = _callCommitState.roomId;
                    const snap = _presenceEngine.getRoomSnapshot(roomId);
                    const now = Date.now();
                    const callSummaryId = `call.${roomId}.${now}`;

                    // Build ride binding if active
                    let bindings = {};
                    if (filamentRideState?.active) {
                        bindings.ride = {
                            filamentId: filamentRideState.filamentId || null,
                            timeboxId: filamentRideState.currentTimeboxId || null,
                            stepIndex: filamentRideState.currentIndex ?? -1
                        };
                    }

                    const summaryPayload = {
                        callSummaryId,
                        roomId,
                        scopeId: snap.scopeId || 'unknown',
                        effectiveScope: snap.effectiveScope || 'company',
                        title: _callCommitState.title || null,
                        participants: [..._callCommitState.participants],
                        startedAt: _callCommitState.callStartedAt ? new Date(_callCommitState.callStartedAt).toISOString() : new Date(now - 720000).toISOString(),
                        endedAt: new Date(now).toISOString(),
                        durationMs: _callCommitState.callStartedAt ? (now - _callCommitState.callStartedAt) : 720000,
                        focusId: String(window.__relayArtifactFocusedObjectId || '').trim() || null,
                        bindings
                    };

                    // Consent record for hashing
                    const consentRecord = {
                        roomId,
                        requestedBy: _callCommitState.requestedBy,
                        requestedAt: _callCommitState.requestedAt,
                        participants: [..._callCommitState.participants],
                        votes: Object.fromEntries(_callCommitState.votes),
                        grantedAt: now
                    };

                    // Compute hashes
                    const summaryHash = await sha256Fn(canonicalJsonFn(summaryPayload));
                    const participantsHash = await sha256Fn(canonicalJsonFn(_callCommitState.participants));
                    const bindingsHash = await sha256Fn(canonicalJsonFn(bindings));
                    const consentHash = await sha256Fn(canonicalJsonFn(consentRecord));

                    _callLog(`[CALL] summary hashes summary=${summaryHash.slice(0, 16)} consent=${consentHash.slice(0, 16)} participants=${participantsHash.slice(0, 16)} bindings=${bindingsHash.slice(0, 16)}`);

                    // W0 PROPOSE artifact via setRelayWorkMode
                    const scopeId = snap.scopeId || 'trunk.avgol';
                    const targetRef = { type: 'trunk', id: scopeId };
                    const changesetRef = `CALL:${callSummaryId}`;
                    const summaryText = _callCommitState.title || `Call summary ${callSummaryId}`;

                    // Ensure we're in a state that can transition to PROPOSE
                    const currentMode = relayWorkState.mode;
                    if (currentMode === 'COMMIT') {
                        setRelayWorkMode('DRAFT', { user: relayWorkState.user, zone: relayWorkState.zone });
                    }

                    const proposed = setRelayWorkMode('PROPOSE', {
                        targetRef,
                        summary: summaryText.slice(0, 240),
                        changesetRef,
                        allowDirectPropose: true,
                        forceSnapshot: true,
                        user: relayWorkState.user,
                        zone: relayWorkState.zone
                    });

                    if (proposed) {
                        _callLog(`[W0] artifact propose type=CALL_SUMMARY id=${callSummaryId} result=PASS`);
                    } else {
                        _callLog(`[W0] artifact propose type=CALL_SUMMARY id=${callSummaryId} result=FAIL`);
                    }

                    // Append timebox event
                    const trunkNode = (relayState.tree.nodes || []).find(n => n.type === 'trunk');
                    if (trunkNode) {
                        const tbEvent = {
                            type: 'CALL_SUMMARY',
                            callSummaryId,
                            roomId,
                            scopeId: summaryPayload.scopeId,
                            effectiveScope: summaryPayload.effectiveScope,
                            participantsCount: _callCommitState.participants.length,
                            durationMs: summaryPayload.durationMs,
                            summaryHash,
                            consentHash
                        };
                        // Add ride bindings if present
                        if (bindings.ride) {
                            tbEvent.filamentId = bindings.ride.filamentId;
                            tbEvent.timeboxId = bindings.ride.timeboxId;
                        }
                        window.appendTimeboxEvent(trunkNode, tbEvent);
                        _callLog(`[TIMEBOX] event type=CALL_SUMMARY id=${callSummaryId} applied=PASS target=${trunkNode.id} timeboxId=${trunkNode.timeboxes?.[trunkNode.timeboxes.length - 1]?.timeboxId || 'n/a'}`);
                    }

                    // Commit gate: check for authorityRef
                    const hasAuthority = !!(relayWorkState.authorityRef || relayWorkState.currentProposalId);
                    if (hasAuthority && proposed) {
                        const committed = setRelayWorkMode('COMMIT', {
                            targetRef,
                            proposalId: relayWorkState.currentProposalId,
                            evidenceHash: relayWorkState.currentProposalEvidenceHash,
                            user: relayWorkState.user,
                            zone: relayWorkState.zone,
                            callSummaryId,
                            summaryHash,
                            consentHash
                        });
                        if (committed) {
                            _callLog(`[CALL] commit gate consent=GRANTED authority=present result=COMMIT`);
                        } else {
                            _callLog(`[CALL] commit gate consent=GRANTED authority=present result=PROPOSE_ONLY`);
                        }
                    } else {
                        _callLog(`[REFUSAL] reason=CALL_COMMIT_AUTHORITY_MISSING scope=${scopeId} action=commitSummary`);
                        _callLog(`[CALL] commit gate consent=GRANTED authority=missing result=PROPOSE_ONLY`);
                    }

                    _callCommitState.lastSummaryId = callSummaryId;

                    // Reset consent state
                    _resetCallCommitState();

                    return {
                        ok: true,
                        callSummaryId,
                        summaryHash,
                        consentHash,
                        participantsHash,
                        bindingsHash,
                        proposed: !!proposed,
                        committed: hasAuthority && !!proposed
                    };
                }

                /**
                 * Get current consent/commit state for HUD and debugging.
                 */
                window.relayCallCommitGetState = function() {
                    return {
                        state: _callCommitState.state,
                        roomId: _callCommitState.roomId,
                        requestedBy: _callCommitState.requestedBy,
                        participants: _callCommitState.participants.length,
                        votes: _callCommitState.votes.size,
                        missing: _callCommitState.participants.length - _callCommitState.votes.size,
                        title: _callCommitState.title,
                        lastSummaryId: _callCommitState.lastSummaryId
                    };
                };

                // ‚îÄ‚îÄ‚îÄ End PRESENCE-COMMIT-BOUNDARY-1 wiring ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

                // ‚îÄ‚îÄ‚îÄ E1-CRYPTO-1: Initialize crypto chains at boot ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                window.relayCryptoInit().catch(err => {
                    console.warn('[CRYPTO] init error:', err);
                });
                // ‚îÄ‚îÄ‚îÄ End E1-CRYPTO-1 boot ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

                document.addEventListener('keydown', async (event) => {
                    if (isEditingCell) return;
                    const isCopy = (event.key === 'c' || event.key === 'C') && (event.ctrlKey || event.metaKey);
                    const isPaste = (event.key === 'v' || event.key === 'V') && (event.ctrlKey || event.metaKey);
                    if (!isCopy && !isPaste) return;
                    if (!sheetRange?.sheetId || !sheetSelection?.sheetId) return;
                    event.preventDefault();
                    const bounds = getRangeBounds(sheetRange);
                    if (!bounds) return;
                    const sheetId = sheetRange.sheetId;
                    const sheet = relayState.tree.nodes.find(n => n.type === 'sheet' && n.id === sheetId);
                    if (!sheet || !Array.isArray(sheet.cellData)) return;

                    if (isCopy) {
                        const rows = [];
                        ensureCellIndex(sheet);
                        for (let r = 0; r < bounds.rows; r++) {
                            const rowValues = [];
                            for (let c = 0; c < bounds.cols; c++) {
                                const row = bounds.minRow + r;
                                const col = bounds.minCol + c;
                                const cellInfo = sheet._cellIndex.get(`${row},${col}`);
                                if (cellInfo?.hasFormula && cellInfo.formula) {
                                    rowValues.push(cellInfo.formula);
                                } else if (cellInfo?.value !== undefined && cellInfo?.value !== null) {
                                    rowValues.push(cellInfo.value);
                                } else if (cellInfo?.display !== undefined && cellInfo?.display !== null) {
                                    rowValues.push(cellInfo.display);
                                } else {
                                    rowValues.push('');
                                }
                            }
                            rows.push(rowValues);
                        }
                        copyBuffer = rows;
                        const text = rows.map(row => row.map(v => String(v ?? '')).join('\t')).join('\n');
                        const tsvBytes = window.TextEncoder ? new TextEncoder().encode(text).length : text.length;
                        if (navigator.clipboard?.writeText) {
                            try {
                                await navigator.clipboard.writeText(text);
                            } catch (err) {
                                RelayLog.warn(`[UI] copyRange clipboard write failed: ${err?.message || err}`);
                            }
                        }
                        RelayLog.info(`[UI] copy sheet=${sheetId} range=${getRangeLabel(sheetRange)} tsvBytes=${tsvBytes} rows=${bounds.rows} cols=${bounds.cols}`);
                        return;
                    }

                    let pasteText = null;
                    if (navigator.clipboard?.readText) {
                        try {
                            pasteText = await navigator.clipboard.readText();
                        } catch (err) {
                            RelayLog.warn('[UI] pasteBlocked reason=ClipboardPermission');
                        }
                    }
                    let values = null;
                    if (pasteText && pasteText.length > 0) {
                        const rows = pasteText.replace(/\r\n/g, '\n').split('\n');
                        values = rows.filter((row, idx) => !(idx === rows.length - 1 && row === '')).map(row => row.split('\t'));
                    } else if (copyBuffer) {
                        values = copyBuffer;
                    }
                    if (!values || values.length === 0) return;
                    const srcRows = values.length;
                    const srcCols = Math.max(...values.map(row => row.length));
                    const pasteCells = srcRows * srcCols;
                    if (pasteCells > MAX_PASTE_CELLS) {
                        RelayLog.warn(`[UI] pasteRefused cells=${pasteCells} cap=${MAX_PASTE_CELLS}`);
                        return;
                    }
                    let trimmed = 0;
                    let cleared = 0;
                    let formulas = 0;
                    let literals = 0;
                    for (let r = 0; r < srcRows; r++) {
                        for (let c = 0; c < srcCols; c++) {
                            const rawValue = values?.[r]?.[c] ?? '';
                            const normalized = normalizeInput(rawValue);
                            if (rawValue !== null && rawValue !== undefined && String(rawValue) !== normalized) {
                                trimmed += 1;
                            }
                            if (normalized.trim() === '') {
                                cleared += 1;
                            } else if (normalized.trim().startsWith('=')) {
                                formulas += 1;
                            } else {
                                literals += 1;
                            }
                        }
                    }
                    RelayLog.info(`[UI] pasteNormalize trimmed=${trimmed} cleared=${cleared} formulas=${formulas} literals=${literals}`);
                    const pasteStartRow = bounds.minRow;
                    const pasteStartCol = bounds.minCol;
                    const pasteEndRow = bounds.minRow + values.length - 1;
                    const pasteEndCol = bounds.minCol + srcCols - 1;
                    const pasteRange = {
                        sheetId,
                        start: {
                            row: pasteStartRow,
                            col: pasteStartCol,
                            cellId: `${sheetId}.cell.${pasteStartRow}.${pasteStartCol}`,
                            cellRef: toCellRef(pasteStartRow, pasteStartCol)
                        },
                        end: {
                            row: pasteEndRow,
                            col: pasteEndCol,
                            cellId: `${sheetId}.cell.${pasteEndRow}.${pasteEndCol}`,
                            cellRef: toCellRef(pasteEndRow, pasteEndCol)
                        }
                    };
                    RelayLog.info(`[UI] paste sheet=${sheetId} anchor=${toCellRef(pasteStartRow, pasteStartCol)} srcRows=${srcRows} srcCols=${srcCols} destRange=${getRangeLabel(pasteRange)}`);
                    commitRangeEdit(sheetId, pasteRange, values, 'paste');
                    applySelection(sheetSelection, pasteRange);
                });
                
                // Start render loop
                startRenderLoop();
                
                // Keyboard shortcuts
                setupKeyboardShortcuts();
                
                RelayLog.info('‚úÖ Relay Cesium World initialized');
                
            } catch (error) {
                RelayLog.error(`‚ùå Initialization failed: ${error.message}`);
                console.error(error);
            } finally {
                // P3-A: Loading overlay must always dismiss after init attempt.
                const loadingEl = document.getElementById('loading');
                if (loadingEl) loadingEl.classList.add('hidden');
            }
        }

        function saveCameraState(viewer, force = false) {
            try {
                const now = Date.now();
                if (!force && (now - lastCameraSave) < CAMERA_SAVE_THROTTLE_MS) return;
                lastCameraSave = now;

                const pos = viewer.camera.positionWC;
                if (!pos || !Number.isFinite(pos.x) || !Number.isFinite(pos.y) || !Number.isFinite(pos.z)) {
                    return;
                }

                const payload = {
                    x: pos.x,
                    y: pos.y,
                    z: pos.z,
                    heading: viewer.camera.heading,
                    pitch: viewer.camera.pitch,
                    roll: viewer.camera.roll,
                    t: now
                };
                localStorage.setItem(CAMERA_STORAGE_KEY, JSON.stringify(payload));
            } catch (err) {
                RelayLog.warn(`‚ö†Ô∏è Camera state save failed: ${err.message}`);
            }
        }

        function restoreCameraState(viewer) {
            try {
                const raw = localStorage.getItem(CAMERA_STORAGE_KEY);
                if (!raw) return false;
                const state = JSON.parse(raw);
                if (!state || !Number.isFinite(state.x) || !Number.isFinite(state.y) || !Number.isFinite(state.z)) return false;

                viewer.camera.setView({
                    destination: new Cesium.Cartesian3(state.x, state.y, state.z),
                    orientation: {
                        heading: Number.isFinite(state.heading) ? state.heading : viewer.camera.heading,
                        pitch: Number.isFinite(state.pitch) ? state.pitch : viewer.camera.pitch,
                        roll: Number.isFinite(state.roll) ? state.roll : viewer.camera.roll
                    }
                });
                RelayLog.info('üìå Restored last camera POV');
                return true;
            } catch (err) {
                RelayLog.warn(`‚ö†Ô∏è Camera state restore failed: ${err.message}`);
            }
            return false;
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // RENDER LOOP
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let frameCount = 0;
        let lastFPSUpdate = Date.now();
        let fps = 0;
        let lastTickTime = performance.now();
        let lastRenderNudgeMs = 0;
        
        function startRenderLoop() {
            function tick() {
                const nowTime = performance.now();
                const deltaSeconds = Math.min(0.05, (nowTime - lastTickTime) / 1000);
                lastTickTime = nowTime;

                if (flightControls) {
                    flightControls.update(deltaSeconds);
                }
                if (viewer && !isBackgroundWorkSuppressed(nowTime)) {
                    updateBasinInfluence(nowTime);
                }

                // Update LOD based on camera height (unless locked)
                if (lodGovernor && viewer) {
                    const height = getCameraHeightAboveGround(viewer);
                    const backgroundSuppressed = isBackgroundWorkSuppressed(nowTime);
                    const stressLockedLod = getStressLockedLod();
                    const freezeTreeRebuild = window.__relayFpsBoostActive === true || window.__relayFpsSamplingActive === true;
                    
                    // Only update LOD if not locked
                    if (backgroundSuppressed && stressLockedLod) {
                        lodGovernor.currentLevel = stressLockedLod;
                        if (filamentRenderer && filamentRenderer.currentLOD !== stressLockedLod && !freezeTreeRebuild) {
                            filamentRenderer.setLOD(stressLockedLod);
                            filamentRenderer.renderTree('stress-lod-freeze');
                        }
                    } else if (window.RELAY_LOCK_LOD) {
                        if (!_lodLockApplied) {
                            _lodLockApplied = true;
                            lodLocked = true;
                            lodLockedLevel = window.RELAY_LOCK_LOD;
                            // R0.2: Sync governor level so HUD displays correctly
                            lodGovernor.currentLevel = lodLockedLevel;
                            if (filamentRenderer) {
                                filamentRenderer.setLOD(lodLockedLevel);
                                if (!freezeTreeRebuild) filamentRenderer.renderTree();
                            }
                            RelayLog.info(`[LOD] locked=${lodLockedLevel}`);
                        }
                    } else if (!lodLocked) {
                        lodGovernor.update(height);
                    } else {
                        // Keep locked LOD active ‚Äî sync governor level for HUD
                        if (lodLockedLevel) {
                            lodGovernor.currentLevel = lodLockedLevel;
                            if (filamentRenderer && filamentRenderer.currentLOD !== lodLockedLevel && !freezeTreeRebuild) {
                                filamentRenderer.setLOD(lodLockedLevel);
                                filamentRenderer.renderTree();
                            }
                        }
                    }
                    
                    // Update HUD every 5 frames
                    if (hudManager && frameCount % 5 === 0) {
                        window.relayRefreshHudNow(height);
                    }
                }

                        if (viewer && window.AUTO_EDIT_SHEET && !isBackgroundWorkSuppressed(nowTime)) {
                            const nowMs = Date.now();
                            if (nowMs >= editSheetAutoCooldownUntil) {
                                const sheets = relayState.tree.nodes.filter(n => n.type === 'sheet' && n._center);
                                if (sheets.length > 0) {
                                    let nearest = null;
                                    let nearestDist = Infinity;
                                    const camPos = viewer.camera.position;
                                    sheets.forEach((sheet) => {
                                        const dist = Cesium.Cartesian3.distance(camPos, sheet._center);
                                        if (dist < nearestDist) {
                                            nearestDist = dist;
                                            nearest = sheet;
                                        }
                                    });
                                    const targetSheet = editSheetTargetSheet || nearest;
                                    if (targetSheet) {
                                        editSheetTargetSheet = targetSheet;
                                        const renderNormal = targetSheet._renderNormal || targetSheet._normal || Cesium.Cartesian3.UNIT_Z;
                                        const toCam = Cesium.Cartesian3.normalize(
                                            Cesium.Cartesian3.subtract(camPos, targetSheet._center, new Cesium.Cartesian3()),
                                            new Cesium.Cartesian3()
                                        );
                                        const alignDot = Cesium.Cartesian3.dot(
                                            Cesium.Cartesian3.normalize(renderNormal, new Cesium.Cartesian3()),
                                            toCam
                                        );
                                        const dockDistance = 550;      // enter edit mode (close enough to see full sheet)
                                        const undockDistance = 900;    // exit edit mode
                                        const previewDistance = 700;   // barely-there hint just before dock
                                        const previewActive = nearestDist < previewDistance;
                                        const forceOverlay = window.RELAY_FORCE_OVERLAY === true;
                                        document.body.classList.toggle('force-overlay', forceOverlay);
                                        // Unified proximity + overlay diagnostic (once per second)
                                        const proxNow = Date.now();
                                        if (proxNow - lastOverlayLog >= 1000) {
                                            const oStyle = sheetGridOverlay ? window.getComputedStyle(sheetGridOverlay) : null;
                                            const oOpacity = oStyle ? parseFloat(oStyle.opacity).toFixed(2) : '?';
                                            if (!isBackgroundWorkSuppressed(nowTime)) {
                                                RelayLog.info(`[DOCK] dist=${nearestDist.toFixed(0)} align=${alignDot.toFixed(2)} preview=${previewActive} edit=${isEditSheetMode} overlay=${oOpacity}`);
                                            }
                                            lastOverlayLog = proxNow;
                                        }
                                        // Clear manual-exit lock only when user is far away (prevents re-dock on overshoot)
                                        const manualExitClearDist = 1000;
                                        if (editSheetManualExit && nearestDist > manualExitClearDist) {
                                            editSheetManualExit = false;
                                        }
                                        if (!isEditSheetMode && !isFocusMode && !window.RELAY_LAUNCH_MODE) {
                                            // Preview: 3D dims as you approach (any angle, suppress during Focus Lens)
                                            // LAUNCH MODE: no auto-preview dimming (CAM-FREEFLY-CONTRACT-1)
                                            document.body.classList.toggle('edit-sheet-preview', !editSheetManualExit && (previewActive || forceOverlay));
                                        }
                                        if (!isEditSheetMode && !editSheetManualExit && !isFocusMode && canEnterEditSheet(targetSheet) && !window.RELAY_LAUNCH_MODE) {
                                            // Dock from any angle ‚Äî camera will orbit to face-on (suppress during Focus Lens)
                                            window.enterEditSheetMode(targetSheet);
                                            editSheetAutoCooldownUntil = nowMs + 5000;
                                        } else if (!isEditSheetMode && !editSheetManualExit && !isFocusMode && canEnterEditSheet(targetSheet) && window.RELAY_LAUNCH_MODE) {
                                            // SCOPE-COHERENCE-1: Disable auto-dock whenever in sheet scope, edit mode, or explicit enter
                                            const currentScope = String(window.__relayEntryState?.scope || 'world').toLowerCase();
                                            const inSheetScope = currentScope === 'sheet' || currentScope === 'sheet-only' || currentScope === 'cell';
                                            if (window._relayExplicitEnterActive || inSheetScope || window._isEditSheetMode) {
                                                // Sheet scope or explicit enter ‚Äî suppress auto-dock entirely
                                                if (!window._r0AutoDockSuppressLogged) {
                                                    const reason = window._relayExplicitEnterActive ? 'explicitEnter'
                                                        : inSheetScope ? 'sheetScope'
                                                        : 'editMode';
                                                    RelayLog.info(`[DOCK] autoDock disabled=PASS reason=${reason}`);
                                                    window._r0AutoDockSuppressLogged = true;
                                                }
                                            } else {
                                                // LAUNCH MODE: auto-dock blocked ‚Äî status-oriented, rate-limited log
                                                const refusalTarget = targetSheet.id || 'unknown';
                                                const nowLogMs = Date.now();
                                                const cooldownMs = 20000;
                                                const allowedByTarget = window._r0AutoDockRefusalLastTarget !== refusalTarget;
                                                const allowedByTime = !Number.isFinite(window._r0AutoDockRefusalLastAt) || (nowLogMs - window._r0AutoDockRefusalLastAt) > cooldownMs;
                                                if (allowedByTarget || allowedByTime) {
                                                    window._r0AutoDockRefusalLastTarget = refusalTarget;
                                                    window._r0AutoDockRefusalLastAt = nowLogMs;
                                                    window.__relayLaunchDockStatus = 'Dock assist blocked by launch policy';
                                                    RelayLog.info(`[DOCK] assistBlocked policy=launch target=${refusalTarget} dist=${nearestDist.toFixed(0)} status="Dock assist blocked by launch policy"`);
                                                }
                                            }
                                        } else if (isEditSheetMode && nearestDist > undockDistance && !isEditingCell) {
                                            // Only auto-undock via Escape key ‚Äî distance-based undock disabled
                                            // (camera presets can move camera far from sheet while editing)
                                        }
                                    }
                                }
                            }
                        }
                
                // Force overlay visibility (independent of proximity/edit gating)
                const forceOverlayNow = window.RELAY_FORCE_OVERLAY === true;
                const suppressBackgroundWork = isBackgroundWorkSuppressed(nowTime);
                if (!_postGateQuietEndLogged && !isPostGateQuietActive(nowTime)) {
                    _postGateQuietEndLogged = true;
                    window.__relayStressLodLevel = null;
                    RelayLog.info('POSTGATE', 'quiet window ended, background loops resumed');
                }
                document.body.classList.toggle('force-overlay', forceOverlayNow && !suppressBackgroundWork);
                if (forceOverlayNow && !isEditSheetMode && !suppressBackgroundWork) {
                    document.body.classList.add('edit-sheet-preview');
                }

                // FPS calculation
                frameCount++;
                const now = Date.now();
                if (now - lastFPSUpdate >= 1000) {
                    fps = Math.round((frameCount * 1000) / (now - lastFPSUpdate));
                    window.__relayHudFps = fps;
                    frameCount = 0;
                    lastFPSUpdate = now;
                }

                // Overlay state logged via [PROX] once per second (merged)
                if (viewer?.scene?.requestRenderMode === true) {
                    if ((nowTime - lastRenderNudgeMs) >= 250) {
                        lastRenderNudgeMs = nowTime;
                        viewer.scene.requestRender();
                    }
                }
                
                requestAnimationFrame(tick);
            }
            tick();
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // KEYBOARD SHORTCUTS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Guard: don't steal keys when user is typing
                const activeTag = String(document.activeElement?.tagName || '').toUpperCase();
                if (activeTag === 'INPUT' || activeTag === 'TEXTAREA' || document.activeElement?.isContentEditable) {
                    return;
                }
                switch(e.key.toLowerCase()) {
                    case 'l':
                        // Toggle log console
                        const logConsole = document.getElementById('logConsole');
                        logConsole.style.display = logConsole.style.display === 'none' ? 'block' : 'none';
                        break;
                    
                    case 'h':
                        // In launch mode: toggle Tier 2 diagnostics. In dev: toggle entire HUD.
                        if (window.RELAY_LAUNCH_MODE && hudManager) {
                            hudManager._tier2Open = !hudManager._tier2Open;
                            hudManager.render();
                        } else if (hudManager) {
                            hudManager.toggle();
                        }
                        break;
                    
                    case 'i':
                        // Show info
                        const infoPanel = document.getElementById('infoPanel');
                        infoPanel.style.display = infoPanel.style.display === 'none' ? 'block' : 'none';
                        if (infoPanel.style.display === 'block') {
                            const stats = getTreeStats();
                            infoPanel.innerHTML = `
                                <h3>üå≤ Relay Tree Info</h3>
                                <p><strong>Nodes:</strong> ${stats.nodes}</p>
                                <p><strong>Edges:</strong> ${stats.edges}</p>
                                <p><strong>Trunks:</strong> ${stats.trunks}</p>
                                <p><strong>Branches:</strong> ${stats.branches}</p>
                                <p><strong>Sheets:</strong> ${stats.sheets}</p>
                                <p><strong>LOD:</strong> ${lodGovernor ? lodGovernor.getCurrentLevel() : 'N/A'}</p>
                            `;
                        }
                        break;
                }
            });
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FREE-FLY CAMERA CONTROLS (Three.js-style)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function setupFlightControls(viewer) {
            const canvas = viewer.canvas;
            const controller = viewer.scene.screenSpaceCameraController;
            
            let isLocked = false;
            let heading = viewer.camera.heading;
            let pitch = viewer.camera.pitch;
            let speedScale = 15.0;
            
            const moveState = {
                forward: false,
                backward: false,
                left: false,
                right: false,
                up: false,
                down: false,
                fast: false,
                slow: false
            };
            
            const sensitivity = 0.0022;
            const minPitch = -Cesium.Math.PI_OVER_TWO + 0.02;
            const maxPitch = Cesium.Math.PI_OVER_TWO - 0.02;
            
            function setDefaultInputsEnabled(enabled) {
                controller.enableInputs = enabled;
                controller.enableRotate = enabled;
                controller.enableTranslate = enabled;
                controller.enableZoom = enabled;
                controller.enableTilt = enabled;
                controller.enableLook = enabled;
            }
            
            function lockPointer() {
                if (isLocked || isEditSheetMode || suppressPointerLock) return;
                canvas.requestPointerLock();
            }
            
            function unlockPointer() {
                if (!isLocked) return;
                document.exitPointerLock();
            }
            
            function onPointerLockChange() {
                isLocked = (document.pointerLockElement === canvas);
                setDefaultInputsEnabled(!isLocked);
                
                if (isLocked) {
                    heading = viewer.camera.heading;
                    pitch = viewer.camera.pitch;
                    RelayLog.info('üéÆ Free-fly controls active (WASD/QE, mouse look, scroll speed)');
                } else {
                    RelayLog.info('üñ±Ô∏è Free-fly controls released (default Cesium controls)');
                    moveState.forward = false;
                    moveState.backward = false;
                    moveState.left = false;
                    moveState.right = false;
                    moveState.up = false;
                    moveState.down = false;
                    moveState.fast = false;
                    moveState.slow = false;
                }
            }
            
            function onMouseMove(event) {
                if (!isLocked || isEditingCell || isEditSheetMode) return;
                // Invert vertical axis: mouse up = look down
                heading += event.movementX * sensitivity;
                pitch += -event.movementY * sensitivity;
                pitch = Math.max(minPitch, Math.min(maxPitch, pitch));
                
                viewer.camera.setView({
                    destination: Cesium.Cartesian3.clone(viewer.camera.position, new Cesium.Cartesian3()),
                    orientation: {
                        heading: heading,
                        pitch: pitch,
                        roll: 0
                    }
                });
            }
            
            function onKeyDown(e) {
                if (e.defaultPrevented) return;
                const targetTag = String(e.target?.tagName || '').toUpperCase();
                if (targetTag === 'INPUT' || targetTag === 'TEXTAREA' || e.target?.isContentEditable) return;
                // WASD works with or without pointer lock (but not in edit mode)
                if (isEditingCell || isEditSheetMode) return;
                if (e.code === 'Backquote') {
                    // P3-B: pointer lock is keyboard-triggered only and decoupled from Focus Lens.
                    e.preventDefault();
                    if (isLocked) unlockPointer();
                    else lockPointer();
                    return;
                }
                switch (e.code) {
                    case 'KeyW': moveState.forward = true; break;
                    case 'KeyS': moveState.backward = true; break;
                    case 'KeyA': moveState.left = true; break;
                    case 'KeyD': moveState.right = true; break;
                    case 'KeyQ': moveState.down = true; break;
                    case 'Space': moveState.up = true; break;
                    case 'ShiftLeft':
                    case 'ShiftRight': moveState.fast = true; break;
                    case 'ControlLeft':
                    case 'ControlRight': moveState.slow = true; break;
                    default: return;  // don't disable Cesium inputs for non-movement keys
                }
                // Disable default Cesium controls while WASD is active (prevent conflict)
                if (!isLocked) setDefaultInputsEnabled(false);
            }
            
            function onKeyUp(e) {
                if (isEditingCell || isEditSheetMode) return;
                switch (e.code) {
                    case 'KeyW': moveState.forward = false; break;
                    case 'KeyS': moveState.backward = false; break;
                    case 'KeyA': moveState.left = false; break;
                    case 'KeyD': moveState.right = false; break;
                    case 'KeyQ': moveState.down = false; break;
                    case 'Space': moveState.up = false; break;
                    case 'ShiftLeft':
                    case 'ShiftRight': moveState.fast = false; break;
                    case 'ControlLeft':
                    case 'ControlRight': moveState.slow = false; break;
                    default: return;
                }
                // Re-enable default Cesium controls when all movement keys released
                if (!isLocked && !moveState.forward && !moveState.backward &&
                    !moveState.left && !moveState.right && !moveState.up && !moveState.down) {
                    setDefaultInputsEnabled(true);
                }
            }
            
            function onWheel(e) {
                if (isEditingCell || isEditSheetMode) return;
                e.preventDefault();
                // Wheel up = faster, wheel down = slower
                const delta = Math.sign(e.deltaY);
                speedScale = Math.max(0.2, Math.min(20.0, speedScale - (delta * 0.1)));
                RelayLog.info(`üéöÔ∏è Free-fly speed: √ó${speedScale.toFixed(1)}`);
            }
            
            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            canvas.addEventListener('wheel', onWheel, { passive: false });
            
            return {
                resetMoveState() {
                    moveState.forward = false;
                    moveState.backward = false;
                    moveState.left = false;
                    moveState.right = false;
                    moveState.up = false;
                    moveState.down = false;
                    moveState.fast = false;
                    moveState.slow = false;
                },
                update(deltaSeconds) {
                    // Block movement during edit mode
                    if (isEditSheetMode || isEditingCell) return;
                    // Allow WASD movement with or without pointer lock
                    const anyMove = moveState.forward || moveState.backward ||
                                    moveState.left || moveState.right ||
                                    moveState.up || moveState.down;
                    if (!anyMove) return;
                    
                    const height = viewer.camera.positionCartographic.height;
                    const baseSpeed = Math.min(1500, Math.max(5, height * 0.02));
                    let speed = baseSpeed * speedScale;
                    if (moveState.fast) speed *= 3.0;
                    if (moveState.slow) speed *= 0.25;
                    const distance = speed * deltaSeconds;
                    
                    const direction = viewer.camera.direction;
                    const right = viewer.camera.right;
                    const up = viewer.camera.up;
                    
                    const move = new Cesium.Cartesian3(0, 0, 0);
                    if (moveState.forward) Cesium.Cartesian3.add(move, direction, move);
                    if (moveState.backward) Cesium.Cartesian3.subtract(move, direction, move);
                    if (moveState.right) Cesium.Cartesian3.add(move, right, move);
                    if (moveState.left) Cesium.Cartesian3.subtract(move, right, move);
                    if (moveState.up) Cesium.Cartesian3.add(move, up, move);
                    if (moveState.down) Cesium.Cartesian3.subtract(move, up, move);
                    
                    if (Cesium.Cartesian3.magnitudeSquared(move) > 0) {
                        Cesium.Cartesian3.normalize(move, move);
                        Cesium.Cartesian3.multiplyByScalar(move, distance, move);
                        viewer.camera.move(move, 1.0);
                    }
                }
            };
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PHASE 2 PROOF MODE HELPERS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        /**
         * Step 3: Render minimal local trees as primitives
         */
        function renderProofTrees(viewer) {
            // Tel Aviv tree trunk (vertical pillar)
            const telAvivPos = Cesium.Cartesian3.fromDegrees(34.7818, 32.0853, 0);
            const telAvivTop = Cesium.Cartesian3.fromDegrees(34.7818, 32.0853, 500000);  // 500 km high
            
            const telAvivGeometry = new Cesium.PolylineGeometry({
                positions: [telAvivPos, telAvivTop],
                width: 5.0,
                vertexFormat: Cesium.PolylineColorAppearance.VERTEX_FORMAT,
                arcType: Cesium.ArcType.NONE  // Straight line (not following ellipsoid)
            });
            
            const telAvivInstance = new Cesium.GeometryInstance({
                geometry: telAvivGeometry,
                id: 'trunk_telaviv',
                attributes: {
                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(
                        new Cesium.Color(0.2, 0.8, 0.3, 1.0)  // Green
                    )
                }
            });
            
            const telAvivPrimitive = new Cesium.Primitive({
                geometryInstances: telAvivInstance,
                appearance: new Cesium.PolylineColorAppearance(),
                asynchronous: false
            });
            
            viewer.scene.primitives.add(telAvivPrimitive);
            
            // NYC tree trunk (vertical pillar)
            const nycPos = Cesium.Cartesian3.fromDegrees(-74.0060, 40.7128, 0);
            const nycTop = Cesium.Cartesian3.fromDegrees(-74.0060, 40.7128, 500000);  // 500 km high
            
            const nycGeometry = new Cesium.PolylineGeometry({
                positions: [nycPos, nycTop],
                width: 5.0,
                vertexFormat: Cesium.PolylineColorAppearance.VERTEX_FORMAT,
                arcType: Cesium.ArcType.NONE  // Straight line (not following ellipsoid)
            });
            
            const nycInstance = new Cesium.GeometryInstance({
                geometry: nycGeometry,
                id: 'trunk_nyc',
                attributes: {
                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(
                        new Cesium.Color(0.2, 0.8, 0.3, 1.0)  // Green
                    )
                }
            });
            
            const nycPrimitive = new Cesium.Primitive({
                geometryInstances: nycInstance,
                appearance: new Cesium.PolylineColorAppearance(),
                asynchronous: false
            });
            
            viewer.scene.primitives.add(nycPrimitive);
            
            RelayLog.info('‚úÖ Phase 2: Local trees rendered as primitives');
        }
        
        /**
         * Step 4: Set camera to proof position
         */
        function setProofCamera(viewer) {
            viewer.camera.setView({
                destination: Cesium.Cartesian3.fromDegrees(0, 0, 28000000),  // 28,000 km altitude
                orientation: {
                    heading: 0.0,
                    pitch: Cesium.Math.toRadians(-45),  // Tilted down 45 degrees
                    roll: 0.0
                }
            });
            
            RelayLog.info('‚úÖ Phase 2: Camera set to proof position (28k km, pitch -45¬∞)');
        }
        
        /**
         * Step 5: Log proof data to console
         */
        function logProofData() {
            setTimeout(() => {
                const height = getCameraHeightAboveGround(viewer);
                const lodLevel = lodGovernor ? lodGovernor.getCurrentLevel() : 'UNKNOWN';
                const primitiveCount = viewer.scene.primitives.length;
                const relStats = relationshipRenderer ? relationshipRenderer.getStats() : {};
                
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('=== Phase 2 Proof - Console Log ===');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log(`Date: ${new Date().toISOString()}`);
                console.log(`Cesium Version: ${Cesium.VERSION}`);
                console.log('');
                console.log(`Current LOD Level: ${lodLevel}`);
                console.log(`Camera Height: ${height.toFixed(0)} m (${(height / 1000).toFixed(0)} km)`);
                console.log('');
                console.log('Primitive Counts:');
                console.log(`- Total primitives in scene: ${primitiveCount}`);
                console.log(`- Trunk Tel Aviv: 1 (PolylineGeometry)`);
                console.log(`- Trunk NYC: 1 (PolylineGeometry)`);
                console.log(`- Relationship legs: ${relStats.legs || 0}`);
                console.log(`- Core marker: ${relStats.coreMarker ? 'Yes' : 'No'}`);
                console.log('');
                console.log('Relationship Renderer:');
                console.log(`- Relationship ID: rel.telaviv_nyc.packaging_film`);
                console.log(`- Leg A: tree.telaviv ‚Üí earth.core`);
                console.log(`- Leg B: earth.core ‚Üí tree.nyc`);
                console.log(`- Route verified: V-shape converges at EARTH_CENTER (0,0,0)`);
                console.log('');
                console.log('ENU Frames:');
                console.log(`- tree.telaviv: Anchored at (32.0853, 34.7818)`);
                console.log(`- tree.nyc: Anchored at (40.7128, -74.0060)`);
                console.log('');
                console.log(`Entity Count: ${viewer.entities.values.length} (labels only, no geometry)`);
                console.log('');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('=== End Log ===');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('');
                console.log('üì∏ NEXT: Capture screenshot ‚Üí Save as archive/proofs/phase2-proof-screenshot.png');
                console.log('üíæ NEXT: Copy this log ‚Üí Save as archive/proofs/phase2-proof-console.log');
            }, 2000);
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // START APPLICATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        initialize();
        
    </script>
</body>
</html>
