<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relay Filament Spreadsheet - Canonical Model Prototype</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0a0e14;
            color: #e0e0e0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #1a1f2e;
            border-bottom: 2px solid #00ff88;
            padding: 1rem 2rem;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #00ff88;
        }

        .header .status {
            font-size: 0.875rem;
            color: #888;
            margin-top: 0.25rem;
        }

        .status .canonical {
            color: #00ff88;
            font-weight: 600;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 300px;
            background: #1a1f2e;
            border-right: 1px solid #2a2f3e;
            padding: 1.5rem;
            overflow-y: auto;
        }

        .sidebar h2 {
            font-size: 1rem;
            color: #00ff88;
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .enforcement-item {
            background: #0f1419;
            border: 1px solid #2a2f3e;
            border-radius: 4px;
            padding: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .enforcement-item.active {
            border-color: #00ff88;
        }

        .enforcement-item h3 {
            font-size: 0.875rem;
            color: #fff;
            margin-bottom: 0.5rem;
        }

        .enforcement-item .status {
            font-size: 0.75rem;
            color: #888;
        }

        .enforcement-item .status.pass {
            color: #00ff88;
        }

        .enforcement-item .status.fail {
            color: #ff4444;
        }

        .content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .drop-zone {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 3px dashed #2a2f3e;
            margin: 2rem;
            border-radius: 8px;
            background: #0f1419;
            transition: all 0.3s ease;
        }

        .drop-zone.dragover {
            border-color: #00ff88;
            background: #1a1f2e;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           RELAY ALIVE LOG HUD - Flash + Fade + Fly Effect
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #relayHud {
            position: fixed;
            left: 16px;
            bottom: 16px;
            width: 520px;
            max-width: calc(100vw - 32px);
            pointer-events: none;
            font-family: ui-monospace, 'Courier New', monospace;
            z-index: 9999;
        }
        
        #relayPreview {
            background: rgba(10, 14, 20, 0.85);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 8px;
            padding: 10px 14px;
            margin-bottom: 10px;
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        #relayPreview .label {
            color: #888;
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        #relayPreviewText {
            color: #00ff88;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        #relayLog {
            background: rgba(10, 14, 20, 0.75);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            padding: 10px 12px;
            max-height: 280px;
            overflow: hidden;
            backdrop-filter: blur(6px);
        }
        
        .relayLine {
            display: flex;
            gap: 10px;
            align-items: baseline;
            padding: 4px 0;
            opacity: 0.85;
            transform: translateY(0);
            will-change: transform, opacity, filter;
            font-size: 0.85rem;
        }
        
        .relayLine .ts {
            color: #666;
            font-size: 0.75rem;
        }
        
        .relayLine .icon {
            width: 16px;
            opacity: 0.9;
        }
        
        .relayLine .msg {
            flex: 1;
            color: #e0e0e0;
        }
        
        /* "Flies out of the log" effect */
        .relayLine.isNew {
            animation: relayFly 1200ms ease-out forwards;
            filter: brightness(1.25);
        }
        
        @keyframes relayFly {
            0% {
                opacity: 0;
                transform: translateY(10px);
                filter: brightness(1.8) drop-shadow(0 0 8px rgba(0, 255, 136, 0.6));
            }
            15% {
                opacity: 1;
                transform: translateY(0px);
                filter: brightness(1.4);
            }
            100% {
                opacity: 0.35;
                transform: translateY(-6px);
                filter: brightness(1.0);
            }
        }
        
        /* Preview pulse when changed */
        .previewPulse {
            animation: previewPulse 180ms ease-out;
        }
        
        @keyframes previewPulse {
            0% {
                filter: brightness(1.5) drop-shadow(0 0 4px rgba(0, 255, 136, 0.4));
            }
            100% {
                filter: brightness(1.0);
            }
        }

        .drop-zone-content {
            text-align: center;
            padding: 2rem;
        }

        .drop-zone-content .icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .drop-zone-content h2 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            color: #fff;
        }

        .drop-zone-content p {
            color: #888;
            margin-bottom: 1rem;
        }

        .spreadsheet-container {
            display: none;
            flex: 1;
            flex-direction: column;
            padding: 1rem;
            overflow: hidden;
            position: relative;
        }

        .spreadsheet-container.active {
            display: flex;
        }
        
        .view-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .toolbar {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            padding: 1rem;
            background: #1a1f2e;
            border-radius: 4px;
            align-items: center;
        }

        .view-toggle {
            display: flex;
            gap: 0.5rem;
            margin-left: auto;
        }

        .view-toggle .btn {
            padding: 0.5rem 1rem;
        }

        .view-toggle .btn.active {
            background: #00ff88;
            color: #0a0e14;
        }

        .canvas-container {
            position: absolute;
            inset: 0;
            background: #000;
            z-index: 5;
            display: none;
        }

        .canvas-container.active {
            display: block;
        }
        
        .canvas-container canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .canvas-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(26, 31, 46, 0.95);
            border: 1px solid #2a2f3e;
            border-radius: 4px;
            padding: 1rem;
            z-index: 10;
        }

        .canvas-controls h3 {
            font-size: 0.875rem;
            color: #00ff88;
            margin-bottom: 0.5rem;
        }

        .canvas-controls label {
            display: block;
            font-size: 0.75rem;
            color: #888;
            margin-bottom: 0.25rem;
        }

        .canvas-controls input[type="range"] {
            width: 100%;
            margin-bottom: 0.5rem;
        }

        .btn {
            padding: 0.5rem 1rem;
            background: #2a2f3e;
            border: 1px solid #3a3f4e;
            color: #e0e0e0;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s ease;
        }

        .btn:hover:not(:disabled) {
            background: #3a3f4e;
            border-color: #00ff88;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn.primary {
            background: #00ff88;
            color: #0a0e14;
            border-color: #00ff88;
        }

        .btn.primary:hover:not(:disabled) {
            background: #00dd77;
        }

        .grid-container {
            position: absolute;
            inset: 0;
            overflow: auto;
            background: #0f1419;
            border: 1px solid #2a2f3e;
            border-radius: 4px;
            z-index: 10;
        }
        
        .grid-container.hidden {
            display: none;
        }

        .grid {
            display: grid;
            grid-template-columns: 50px repeat(10, minmax(120px, 1fr));
        }

        .cell {
            border: 1px solid #2a2f3e;
            padding: 0.5rem;
            font-size: 0.875rem;
            position: relative;
        }

        .cell.header {
            background: #1a1f2e;
            font-weight: 600;
            text-align: center;
            color: #00ff88;
        }

        .cell.row-header {
            background: #1a1f2e;
            text-align: center;
            color: #888;
        }

        .cell.editable {
            cursor: pointer;
            background: #0f1419;
        }

        .cell.editable:hover {
            background: #1a1f2e;
        }

        .cell.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .cell.disabled:hover {
            background: #0f1419;
        }

        .cell .eri-badge {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .cell .eri-badge.high {
            background: #00ff88;
        }

        .cell .eri-badge.medium {
            background: #ffaa00;
        }

        .cell .eri-badge.low {
            background: #ff4444;
        }

        .cell .lock-icon {
            position: absolute;
            top: 4px;
            left: 4px;
            font-size: 0.75rem;
            opacity: 0.5;
        }

        .inspector {
            position: fixed;
            right: 2rem;
            top: 50%;
            transform: translateY(-50%);
            width: 350px;
            background: #1a1f2e;
            border: 1px solid #2a2f3e;
            border-radius: 8px;
            padding: 1.5rem;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
        }

        .inspector.active {
            display: block;
        }

        .inspector h2 {
            font-size: 1.125rem;
            margin-bottom: 1rem;
            color: #00ff88;
        }

        .inspector .section {
            margin-bottom: 1.5rem;
        }

        .inspector .section h3 {
            font-size: 0.875rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }

        .inspector .section .value {
            font-size: 1rem;
            margin-bottom: 0.5rem;
        }

        .inspector .commit-log {
            max-height: 200px;
            overflow-y: auto;
            background: #0f1419;
            border: 1px solid #2a2f3e;
            border-radius: 4px;
            padding: 0.75rem;
        }

        .inspector .commit-item {
            font-size: 0.75rem;
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #2a2f3e;
        }

        .inspector .commit-item:last-child {
            border-bottom: none;
        }

        .inspector .commit-item .timestamp {
            color: #888;
        }

        .refusal-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .refusal-modal.active {
            display: flex;
        }

        .refusal-content {
            background: #1a1f2e;
            border: 2px solid #ff4444;
            border-radius: 8px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
        }

        .refusal-content h2 {
            color: #ff4444;
            margin-bottom: 1rem;
        }

        .refusal-content .reasons {
            margin: 1rem 0;
        }

        .refusal-content .reason {
            background: #0f1419;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            border-radius: 4px;
            border-left: 3px solid #ff4444;
        }

        .refusal-content .next-steps {
            margin-top: 1.5rem;
        }

        .refusal-content .next-steps h3 {
            color: #00ff88;
            margin-bottom: 0.5rem;
        }

        .refusal-content .next-steps ol {
            margin-left: 1.5rem;
        }

        .refusal-content .next-steps li {
            margin-bottom: 0.5rem;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* FLIGHT HUD - Top-right flight status display */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .flight-hud {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            background: rgba(5, 8, 18, 0.85);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px 16px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #E0E0E0;
            transition: all 0.2s ease;
            box-shadow: 0 0 12px rgba(0, 0, 0, 0.5);
            display: none; /* Hidden until 3D view active */
        }

        .flight-hud.active {
            display: block;
        }

        .flight-hud.mode-hold {
            border-color: rgba(158, 158, 158, 0.3);
        }

        .flight-hud.mode-freefly {
            border-color: rgba(76, 175, 80, 0.4);
            box-shadow: 0 0 16px rgba(76, 175, 80, 0.3);
        }

        .flight-hud-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }

        .flight-hud-row:last-child {
            margin-bottom: 0;
        }

        .flight-hud-icon {
            font-size: 16px;
            filter: drop-shadow(0 0 4px currentColor);
        }

        .flight-hud-mode {
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 14px;
        }

        .flight-hud.mode-hold .flight-hud-mode {
            color: #9E9E9E;
        }

        .flight-hud.mode-freefly .flight-hud-mode {
            color: #4CAF50;
        }

        .flight-hud-label {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .flight-hud-value {
            font-weight: bold;
            color: #FFD700;
            font-size: 14px;
            min-width: 40px;
            text-align: right;
        }

        .flight-hud-lock {
            font-size: 14px;
        }

        .flight-hud-lock.locked {
            color: #4CAF50;
            animation: pulse-lock 2s ease-in-out infinite;
        }

        .flight-hud-lock.unlocked {
            color: #888;
        }

        @keyframes pulse-lock {
            0%, 100% { filter: drop-shadow(0 0 2px #4CAF50); }
            50% { filter: drop-shadow(0 0 6px #4CAF50); }
        }

        .flight-hud-help {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* CLICK-TO-FLY OVERLAY - Shows until pointer lock engages */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .click-to-fly-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(4px);
            z-index: 5000;
            pointer-events: none;  /* Allow clicks to pass through */
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .click-to-fly-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .overlay-content {
            text-align: center;
            color: #fff;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
        }

        .overlay-icon {
            font-size: 64px;
            margin-bottom: 16px;
            animation: pulse-click 2s ease-in-out infinite;
        }

        .overlay-text {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 8px;
            letter-spacing: 0.5px;
        }

        .overlay-hint {
            font-size: 14px;
            color: #aaa;
            font-family: 'Courier New', monospace;
        }

        @keyframes pulse-click {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        .flight-hud-help-line {
            font-size: 10px;
            color: #666;
            margin-bottom: 4px;
            line-height: 1.3;
        }
    </style>
</head>
<body>
    <!-- Flight HUD (top-right, only visible in 3D views) -->
    <div class="flight-hud" id="flightHUD">
        <div class="flight-hud-row">
            <span class="flight-hud-icon" id="flightIcon">â¸ï¸</span>
            <span class="flight-hud-mode" id="flightMode">HOLD</span>
        </div>
        <div class="flight-hud-row">
            <span class="flight-hud-label">Speed:</span>
            <span class="flight-hud-value" id="flightSpeed">6.0</span>
        </div>
        <div class="flight-hud-row">
            <span class="flight-hud-label">Pressure:</span>
            <span class="flight-hud-value" id="flightPressure">0%</span>
        </div>
        <div class="flight-hud-row">
            <span class="flight-hud-label">Lock:</span>
            <span class="flight-hud-lock unlocked" id="flightLock">ğŸ”“</span>
        </div>
        <div class="flight-hud-help" id="flightHelp">
            <div class="flight-hud-help-line">Click canvas to fly</div>
            <div class="flight-hud-help-line">WASD: move â€¢ Q/E: vertical</div>
            <div class="flight-hud-help-line">Shift: fast â€¢ Ctrl: slow â€¢ G: formula lens</div>
            <div class="flight-hud-help-line">H: HOLD â€¢ R: return â€¢ Esc: unlock</div>
        </div>
    </div>

    <div class="header">
        <h1>ğŸ”’ Relay Filament Spreadsheet</h1>
        <div class="status">
            <span class="canonical">CANONICAL MODEL</span> | 
            Commit: ee5146f | 
            Enforcement: ACTIVE
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <h2>Enforcement Status</h2>
            <div class="enforcement-item active" id="sac-status">
                <h3>1. State Anchoring</h3>
                <div class="status">No SAC required (local file)</div>
            </div>
            <div class="enforcement-item" id="drift-status">
                <h3>2. Drift Detection</h3>
                <div class="status">0 open drifts</div>
            </div>
            <div class="enforcement-item" id="authority-status">
                <h3>3. Authority Decay</h3>
                <div class="status">Local authority (expires in 30m)</div>
            </div>
            <div class="enforcement-item" id="learning-status">
                <h3>4. Learning Boundary</h3>
                <div class="status">No learning active</div>
            </div>
            <div class="enforcement-item" id="refusal-status">
                <h3>5. Refusal-First UX</h3>
                <div class="status pass">âœ… ACTIVE</div>
            </div>
            <div class="enforcement-item" id="pressure-status">
                <h3>6. Pressure Budget</h3>
                <div class="status pass">0/10 actions used</div>
            </div>
            <div class="enforcement-item" id="eri-status">
                <h3>7. ERI Calculation</h3>
                <div class="status">Ready</div>
            </div>
            <div class="enforcement-item" id="three-way-status">
                <h3>8. Three-Way Match</h3>
                <div class="status">Ready</div>
            </div>
        </div>

        <div class="content">
            <!-- RELAY ALIVE LOG HUD -->
            <div id="relayHud">
                <div id="relayPreview">
                    <span class="label">Next:</span>
                    <span id="relayPreviewText">â€”</span>
                </div>
                <div id="relayLog" aria-live="polite"></div>
            </div>
            
            <!-- ğŸ”’ PHASE 2A: Navigation HUD (keyboard shortcuts) -->
            <div id="navHud" style="position: absolute; top: 10px; right: 10px; 
                 background: rgba(0, 20, 40, 0.85); color: #00ddff; padding: 12px 16px; 
                 font-family: 'Courier New', monospace; font-size: 11px; 
                 border-radius: 8px; border: 1px solid rgba(0, 221, 255, 0.3);
                 box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
                 pointer-events: none; z-index: 1000; display: none;">
                <div style="font-weight: bold; margin-bottom: 8px; font-size: 12px; 
                     color: #00ffff; border-bottom: 1px solid rgba(0, 221, 255, 0.2); 
                     padding-bottom: 4px;">ğŸ® NAVIGATION</div>
                <div style="margin: 3px 0;"><span style="color: #00ff88; font-weight: bold;">G</span> : Toggle Grid Overlay</div>
                <div style="margin: 3px 0;"><span style="color: #00ff88; font-weight: bold;">H</span> : Toggle History Loop</div>
                <div style="margin: 3px 0;"><span style="color: #00ff88; font-weight: bold;">T</span> : Fly to Tree Anchor</div>
                <div style="margin: 3px 0;"><span style="color: #00ff88; font-weight: bold;">Z</span> : Zoom to Context</div>
                <div style="margin: 3px 0;"><span style="color: #00ff88; font-weight: bold;">M</span> : Macro View (altitude)</div>
                <div style="margin: 3px 0; color: #88aaff;">Click: Inspect Object</div>
            </div>
            
            <div class="drop-zone" id="dropZone">
                <div class="drop-zone-content">
                    <div class="icon">ğŸ“Š</div>
                    <h2>Drop Excel File Here</h2>
                    <p>Drag and drop an .xlsx or .csv file to launch the filament model</p>
                    <p style="font-size: 0.875rem; color: #666;">
                        Every row becomes a commit â€¢ Cells get ERI scores â€¢ Authority expires
                    </p>
                    <button class="btn primary" onclick="document.getElementById('fileInput').click()">
                        Or Click to Browse
                    </button>
                    <input type="file" id="fileInput" accept=".xlsx,.xls,.csv" style="display: none;">
                </div>
            </div>

            <div class="spreadsheet-container" id="spreadsheetContainer">
                <div class="toolbar">
                    <button class="btn" id="forkBtn" disabled>
                        ğŸŒ³ Fork (What-If)
                    </button>
                    <button class="btn" id="commitBtn" disabled>
                        ğŸ’¾ Commit Changes
                    </button>
                    <button class="btn" id="historyBtn">
                        ğŸ“œ View History
                    </button>
                    
                    <div class="view-toggle">
                        <!-- ğŸ”’ PHASE 2A: View buttons removed - unified navigation -->
                        <!-- Use keyboard shortcuts: G (grid), H (history), T (tree), Z (zoom), M (macro) -->
                    </div>
                    
                    <button class="btn" id="newFileBtn">
                        ğŸ“‚ Load New File
                    </button>
                </div>

                <div class="view-container">
                    <div class="grid-container" id="gridView">
                        <div class="grid" id="grid"></div>
                    </div>

                    <div class="canvas-container" id="filamentView">
                        <!-- Click-to-fly instruction overlay -->
                        <div id="clickToFlyOverlay" class="click-to-fly-overlay">
                            <div class="overlay-content">
                                <div class="overlay-icon">ğŸ–±ï¸</div>
                                <div class="overlay-text">Click canvas to engage flight</div>
                                <div class="overlay-hint">WASD: move | Q/E: vertical | Shift: fast</div>
                            </div>
                        </div>
                        <!-- Canvas will be dynamically created and appended here -->
                        <div class="canvas-controls">
                            <h3>3D Controls</h3>
                            <label>Zoom</label>
                            <input type="range" id="zoomControl" min="5" max="50" value="20" step="1">
                            <label>Auto-Rotation Speed</label>
                            <input type="range" id="rotationControl" min="0" max="2" value="0" step="0.1">
                            <button class="btn" style="width: 100%; margin-top: 0.5rem;" onclick="resetCamera()">
                                Reset Camera
                            </button>
                            <button class="btn" style="width: 100%; margin-top: 0.5rem; background: #00ff88;" onclick="setBranchSectionView()">
                                ğŸŒ³ Branch Section (Top-Down)
                            </button>
                            <button class="btn" style="width: 100%; margin-top: 0.5rem; background: #88aaff;" onclick="setTrunkWalkView()">
                                ğŸš¶ Trunk Walk (Side)
                            </button>
                            <button class="btn" style="width: 100%; margin-top: 0.5rem; background: #ffaa00;" onclick="setLeafInspectView()">
                                ğŸ” Leaf Inspect (Close-Up)
                            </button>
                            <div style="margin-top: 0.5rem; padding: 0.5rem; background: rgba(0,255,136,0.1); border: 1px solid #00ff88; border-radius: 4px; font-size: 0.75rem; color: #00ff88;">
                                ğŸ’¡ Tip: Use camera presets for cinematic views
                            </div>
                        </div>
                    </div>
                    
                    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
                    <!-- GRAPH LENS - Branch Trajectories Visualization -->
                    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
                    <div class="canvas-container" id="graphView" style="display: none; background: #0a0e14; padding: 20px; overflow-y: auto;">
                        <div style="color: #00ff88; font-family: 'Courier New', monospace; margin-bottom: 20px;">
                            <h2 style="margin: 0;">ğŸ“ˆ GRAPH LENS - Branch Trajectories</h2>
                            <p style="margin: 5px 0; color: #88aaff;">Each branch moves under mathematics: regression, heat, pressure, rain</p>
                        </div>
                        
                        <!-- Branch metrics display -->
                        <div id="branchMetricsDisplay" style="display: flex; gap: 20px; margin-bottom: 20px; flex-wrap: wrap;">
                            <!-- Will be populated with branch cards -->
                        </div>
                        
                        <!-- Graph canvas for trajectory plotting -->
                        <canvas id="trajectoryCanvas" width="1200" height="600" style="background: #151a20; border: 2px solid #00ff88; border-radius: 8px; width: 100%; max-width: 1200px;"></canvas>
                        
                        <!-- Dependency graph visualization -->
                        <div style="margin-top: 20px;">
                            <h3 style="color: #00ff88; font-family: 'Courier New', monospace;">ğŸ”— Formula Dependency Graph</h3>
                            <div id="dependencyGraphDisplay" style="background: #151a20; padding: 20px; border: 2px solid #88aaff; border-radius: 8px; color: #ffffff; font-family: 'Courier New', monospace; font-size: 12px; max-height: 300px; overflow-y: auto;">
                                <!-- Will be populated with dependency edges -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="inspector" id="inspector">
        <h2>Cell Inspector</h2>
        
        <div class="section">
            <h3>Cell ID</h3>
            <div class="value" id="cellId">-</div>
        </div>

        <div class="section">
            <h3>Value</h3>
            <div class="value" id="cellValue">-</div>
        </div>

        <div class="section">
            <h3>ERI Score</h3>
            <div class="value" id="cellERI">-</div>
        </div>

        <div class="section">
            <h3>Authority</h3>
            <div class="value" id="cellAuthority">-</div>
        </div>

        <div class="section">
            <h3>Commit History</h3>
            <div class="commit-log" id="commitLog">
                <div style="color: #888;">No commits yet</div>
            </div>
        </div>

        <button class="btn primary" style="width: 100%; margin-top: 1rem;" onclick="closeInspector()">
            Close
        </button>
    </div>

    <div class="refusal-modal" id="refusalModal">
        <div class="refusal-content">
            <h2>ğŸ”’ Action Refused</h2>
            <div class="reasons" id="refusalReasons"></div>
            <div class="next-steps">
                <h3>Next Steps:</h3>
                <ol id="refusalSteps"></ol>
            </div>
            <button class="btn primary" style="width: 100%; margin-top: 1.5rem;" onclick="closeRefusal()">
                Understood
            </button>
        </div>
    </div>

    <!-- Try local XLSX first, fallback to CDN -->
    <script src="./libs/xlsx.full.min.js" onerror="this.onerror=null; this.src='https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js'; console.log('[Relay] Using CDN XLSX fallback');"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <!-- ğŸ”’ PHASE 2B: earcut for polygon triangulation (boundary extrusion) -->
    <script src="https://unpkg.com/earcut@2.2.4/dist/earcut.min.js"></script>
    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TRUTH PROBES - Confirm script execution
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        console.log("[Relay] ğŸš€ Script booted");
        
        window.addEventListener("error", (e) => {
            console.error("[Relay] âŒ Window error:", e.error || e.message);
        });
        
        window.addEventListener("unhandledrejection", (e) => {
            console.error("[Relay] âŒ Promise rejection:", e.reason);
        });
        
        console.log("[Relay] ğŸ“š XLSX present?", typeof XLSX !== "undefined");
        console.log("[Relay] ğŸ“ THREE present?", typeof THREE !== "undefined");
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // RELAY ALIVE LOG - Continuous Feedback System
        // Shows hover previews + flash/fade action logs
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const relayUI = (() => {
            const previewEl = () => document.getElementById("relayPreviewText");
            const previewBox = () => document.getElementById("relayPreview");
            const logEl = () => document.getElementById("relayLog");

            function ts() {
                const d = new Date();
                return d.toLocaleTimeString([], { hour12: false });
            }

            function setPreview(text) {
                const el = previewEl();
                if (!el) return;
                if (el.textContent === text) return;

                el.textContent = text;

                // Quick pulse so it feels alive
                const box = previewBox();
                if (box) {
                    box.classList.remove("previewPulse");
                    void box.offsetWidth; // Force reflow
                    box.classList.add("previewPulse");
                }
            }

            function log(message, kind = "info") {
                const el = logEl();
                if (!el) return;

                const line = document.createElement("div");
                line.className = "relayLine isNew";

                const icon = kind === "ok" ? "âœ…" :
                             kind === "warn" ? "âš ï¸" :
                             kind === "err" ? "âŒ" :
                             kind === "info" ? "â–¶" : "â—";

                const msgColor = kind === "ok" ? "#00ff88" :
                                 kind === "warn" ? "#ffaa00" :
                                 kind === "err" ? "#ff4444" : "#e0e0e0";

                line.innerHTML = `
                    <span class="ts">[${ts()}]</span>
                    <span class="icon">${icon}</span>
                    <span class="msg" style="color: ${msgColor}">${escapeHtml(message)}</span>
                `;

                // Insert at top (newest first)
                el.prepend(line);

                // Keep last N lines
                const MAX = 18;
                while (el.children.length > MAX) {
                    el.removeChild(el.lastChild);
                }

                // Remove "isNew" after animation completes
                setTimeout(() => line.classList.remove("isNew"), 1300);
                
                // Also log to console
                console.log(`[Relay] ${icon} ${message}`);
            }

            function escapeHtml(s) {
                return String(s).replace(/[&<>"']/g, m => ({
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    '"': "&quot;",
                    "'": "&#039;"
                }[m]));
            }

            return { setPreview, log };
        })();
        
        // Canonical Filament Spreadsheet Model - Prototype Implementation
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TYPED COMMIT SYSTEM
        // Each commit has a TYPE that determines its payload structure
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const COMMIT_TYPES = {
            // File-level commits
            FILE_IMPORT: 'FILE_IMPORT',           // Import Excel file (creates bundle)
            FILE_DEFINE: 'FILE_DEFINE',           // Define file metadata
            
            // Sheet-level commits
            SHEET_DEFINE: 'SHEET_DEFINE',         // Define sheet metadata
            SHEET_RENAME: 'SHEET_RENAME',         // Rename sheet
            
            // Cell-level commits (actual data)
            CELL_SET: 'CELL_SET',                 // Set cell value (has cellId, value)
            CELL_FORMULA_SET: 'CELL_FORMULA_SET', // Set cell formula (has cellId, formula, deps[])
            CELL_CLEAR: 'CELL_CLEAR',             // Clear cell
            
            // Scenario/branching commits
            ASSUMPTION: 'ASSUMPTION',             // Scenario fork assumption (NO value)
            SCENARIO_DEFINE: 'SCENARIO_DEFINE',   // Define scenario metadata
            
            // Governance commits
            CANON_SELECT: 'CANON_SELECT',         // Select canonical branch
            MERGE: 'MERGE',                       // Merge branches
            SCAR: 'SCAR',                         // Reconciliation scar
            
            // Pressure/enforcement commits
            REFUSAL: 'REFUSAL',                   // Action refused
            HOLD: 'HOLD',                         // Action on hold
            DRIFT_DETECTED: 'DRIFT_DETECTED',     // Drift object created
            DRIFT_RESOLVED: 'DRIFT_RESOLVED'      // Drift object closed
        };
        
        // Commit factory function (ensures type safety)
        function createCommit(type, payload) {
            const commit = {
                id: `commit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                type: type,
                timestamp: Date.now(),
                authorityRef: state.authority.user,
                payload: payload || {}
            };
            
            // Type-specific validation
            if (type === COMMIT_TYPES.CELL_SET && !payload.cellId) {
                throw new Error('CELL_SET commit requires cellId in payload');
            }
            if (type === COMMIT_TYPES.CELL_FORMULA_SET && !payload.formula) {
                throw new Error('CELL_FORMULA_SET commit requires formula in payload');
            }
            if (type === COMMIT_TYPES.ASSUMPTION && payload.value !== undefined) {
                console.warn('ASSUMPTION commits should not have value (assumptions describe change, not data)');
            }
            
            return commit;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // FORMULA PARSER - Extract cell dependencies from formula
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function parseFormulaDeps(formula) {
            if (!formula || !formula.startsWith('=')) {
                return [];
            }
            
            // Simple regex to find cell references (A1, B2, etc.)
            // Pattern: Letter(s) followed by number(s)
            const cellRefPattern = /([A-Z]+[0-9]+)/g;
            const matches = formula.match(cellRefPattern) || [];
            
            // Return unique cell references
            return [...new Set(matches)];
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CYCLE DETECTION (MISSING LOCK A)
        // Detect circular dependencies: A1â†’B1â†’C1â†’A1
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function detectCycles(formulaGraph, dependencyIndex) {
            const cycles = [];
            const visited = new Set();
            const recursionStack = new Set();
            
            function dfs(node, path) {
                if (recursionStack.has(node)) {
                    // Found cycle!
                    const cycleStart = path.indexOf(node);
                    const cycle = path.slice(cycleStart).concat([node]);
                    cycles.push(cycle);
                    return true;
                }
                
                if (visited.has(node)) {
                    return false;
                }
                
                visited.add(node);
                recursionStack.add(node);
                path.push(node);
                
                const dependents = dependencyIndex[node] || [];
                for (const dependent of dependents) {
                    dfs(dependent, [...path]);
                }
                
                recursionStack.delete(node);
                return false;
            }
            
            // Check all nodes
            formulaGraph.nodes.forEach(node => {
                if (!visited.has(node)) {
                    dfs(node, []);
                }
            });
            
            return cycles;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TOPOLOGICAL SORT (MISSING LOCK A)
        // Deterministic recomputation order (same every time)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function topologicalSort(formulaGraph, dependencyIndex) {
            const inDegree = {};
            const sorted = [];
            const queue = [];
            
            // Calculate in-degree for each node
            formulaGraph.nodes.forEach(node => {
                inDegree[node] = 0;
            });
            
            formulaGraph.edges.forEach(edge => {
                inDegree[edge.to] = (inDegree[edge.to] || 0) + 1;
            });
            
            // Find nodes with no dependencies (in-degree = 0)
            Object.keys(inDegree).forEach(node => {
                if (inDegree[node] === 0) {
                    queue.push(node);
                }
            });
            
            // Sort lexicographically for determinism
            queue.sort();
            
            // Kahn's algorithm
            while (queue.length > 0) {
                const node = queue.shift();
                sorted.push(node);
                
                const dependents = dependencyIndex[node] || [];
                dependents.forEach(dependent => {
                    inDegree[dependent]--;
                    if (inDegree[dependent] === 0) {
                        queue.push(dependent);
                        queue.sort();  // Keep deterministic
                    }
                });
            }
            
            // If sorted length < nodes, there's a cycle
            if (sorted.length < formulaGraph.nodes.length) {
                return null;  // Cycle detected
            }
            
            return sorted;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DEPENDENCY GRAPH BUILDER (COMMIT-DERIVED)
        // Build formula graph + dependency index FROM COMMITS
        // + CYCLE DETECTION + TOPOLOGICAL ORDERING
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function buildDependencyGraphFromCommits(bundle) {
            Object.values(bundle.sheets || {}).forEach(sheet => {
                const formulaGraph = {
                    nodes: [],
                    edges: [],
                    rebuilt_at: Date.now(),
                    rebuild_from: 'commits'  // âœ… Marks this as commit-derived
                };
                const dependencyIndex = {};
                
                // Collect all cells from commits (not from import)
                const cellMap = {};
                state.commits.forEach(commit => {
                    if (commit.type === COMMIT_TYPES.CELL_SET || 
                        commit.type === COMMIT_TYPES.CELL_FORMULA_SET) {
                        if (commit.payload.sheetId === sheet.id) {
                            const cellId = commit.payload.cellId;
                            if (!cellMap[cellId]) {
                                cellMap[cellId] = [];
                            }
                            cellMap[cellId].push(commit);
                        }
                    }
                });
                
                // Build graph from CELL_FORMULA_SET commits only
                Object.keys(cellMap).forEach(cellId => {
                    formulaGraph.nodes.push(cellId);
                    
                    // Find latest CELL_FORMULA_SET commit for this cell
                    const formulaCommits = cellMap[cellId].filter(c => c.type === COMMIT_TYPES.CELL_FORMULA_SET);
                    if (formulaCommits.length > 0) {
                        const latestFormulaCommit = formulaCommits[formulaCommits.length - 1];
                        const deps = latestFormulaCommit.payload.deps || [];
                        
                        // âœ… SHEET SCOPE CHECK (FIX #2)
                        // Only add edges within same sheet unless explicit cross-sheet ref
                        deps.forEach(depCellId => {
                            // Check if depCellId is in same sheet (no Sheet2!A1 syntax for now)
                            if (!depCellId.includes('!')) {
                                formulaGraph.edges.push({
                                    from: depCellId,
                                    to: cellId,
                                    type: 'FORMULA_DEP',
                                    commit_ref: latestFormulaCommit.id  // âœ… Trace to commit
                                });
                                
                                // Build reverse index
                                if (!dependencyIndex[depCellId]) {
                                    dependencyIndex[depCellId] = [];
                                }
                                if (!dependencyIndex[depCellId].includes(cellId)) {
                                    dependencyIndex[depCellId].push(cellId);
                                }
                            }
                        });
                    }
                });
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // MISSING LOCK A: CYCLE DETECTION + TOPOLOGICAL ORDERING
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                // 1. Detect cycles
                const cycles = detectCycles(formulaGraph, dependencyIndex);
                if (cycles.length > 0) {
                    console.error('ğŸš¨ CIRCULAR DEPENDENCY DETECTED:', cycles);
                    
                    // Mark sheet as indeterminate
                    sheet.display_state = 'indeterminate';
                    sheet.cycles = cycles;
                    
                    // Create REFUSAL commit
                    const refusalCommit = createCommit(COMMIT_TYPES.REFUSAL, {
                        reason: 'circular_dependency',
                        cycles: cycles,
                        sheetId: sheet.id,
                        message: `Cannot compute: circular dependency detected in ${cycles.length} cycle(s)`
                    });
                    state.commits.push(refusalCommit);
                    
                    showNotification(`â›” Circular dependency detected in ${sheet.name}: ${cycles[0].join('â†’')}`, 'error');
                }
                
                // 2. Calculate deterministic topological order
                const topoOrder = topologicalSort(formulaGraph, dependencyIndex);
                if (topoOrder) {
                    sheet.recomputeOrder = topoOrder;  // âœ… Stable, deterministic order
                    console.log(`âœ… Topological order for ${sheet.name}:`, topoOrder.slice(0, 10), '...');
                } else {
                    console.error('ğŸš¨ TOPOLOGICAL SORT FAILED: Cycle detected');
                    sheet.recomputeOrder = null;
                    sheet.display_state = 'indeterminate';
                }
                
                sheet.formulaGraph = formulaGraph;
                sheet.dependencyIndex = dependencyIndex;
                
                console.log(`âœ… Rebuilt dependency graph from commits for ${sheet.name}:`, {
                    nodes: formulaGraph.nodes.length,
                    edges: formulaGraph.edges.length,
                    cycles: cycles.length,
                    topoOrder: topoOrder ? 'valid' : 'CYCLE_DETECTED',
                    dependencyIndex: Object.keys(dependencyIndex).length,
                    rebuilt_from: 'commits'
                });
            });
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DIRTY PROPAGATION - Mark all dependents as dirty
        // When cell changes, mark all cells that depend on it
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function propagateDirty(sheet, changedCellId) {
            const dependents = sheet.dependencyIndex[changedCellId] || [];
            const dirtySet = new Set();
            
            // BFS to mark all transitive dependents
            const queue = [...dependents];
            while (queue.length > 0) {
                const cellId = queue.shift();
                if (dirtySet.has(cellId)) continue;
                
                dirtySet.add(cellId);
                const cell = sheet.cells[cellId];
                if (cell) {
                    cell.isDirty = true;
                }
                
                // Add this cell's dependents to queue
                const transitiveDeps = sheet.dependencyIndex[cellId] || [];
                queue.push(...transitiveDeps);
            }
            
            console.log(`ğŸ“Š Propagated dirty flag from ${changedCellId} to:`, [...dirtySet]);
            return dirtySet;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // FIX #6: TRACE OBJECT - For AI Training on Structured Actions
        // + MISSING LOCK B: TRACE PRIVACY + MINIMIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const traces = {
            raw: [],        // Raw traces (opt-in, time-bounded)
            aggregated: []  // Aggregated traces (default, longer retention)
        };
        
        // Trace privacy settings
        const tracePrivacySettings = {
            mode: 'aggregated',  // Default: aggregated only
            raw_opt_in: false,  // User must opt-in for raw traces
            raw_retention_ms: 7 * 24 * 60 * 60 * 1000,  // 7 days max
            aggregated_retention_ms: 30 * 24 * 60 * 60 * 1000,  // 30 days max
            pseudonymize: true  // Anonymize user IDs by default
        };
        
        function emitTrace(actionType, context) {
            const now = Date.now();
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // MISSING LOCK B: PRIVACY + MINIMIZATION
            // Default aggregated, raw opt-in, time-bounded, pseudonymized
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // Pseudonymize user ID (if enabled)
            const userId = tracePrivacySettings.pseudonymize 
                ? hashUserId(state.authority.user)  // Pseudonym
                : state.authority.user;  // Raw (only if opt-in)
            
            // Aggregated trace (always collected, safe)
            const aggregatedTrace = {
                timestamp: now,
                action_type: actionType,
                result: context.result || 'allowed',
                
                // Aggregated stats (no individual cells/commits)
                affected_count: (context.affected_cells || []).length + (context.affected_commits || []).length,
                
                // Policy/state snapshot
                policy_ref: context.policy_ref || 'default_v1',
                commit_count: state.commits.length,
                pressure_budget_used: state.pressureBudget.used,
                
                // Retention
                retention_expires_at: now + tracePrivacySettings.aggregated_retention_ms,
                trace_mode: 'aggregated'
            };
            
            traces.aggregated.push(aggregatedTrace);
            
            // Raw trace (only if opt-in, time-bounded)
            if (tracePrivacySettings.raw_opt_in) {
                const rawTrace = {
                    timestamp: now,
                    action_type: actionType,
                    
                    // Context: what was selected
                    selected_cells: context.selected_cells || [],
                    active_lens: context.active_lens || currentViewMode,
                    
                    // Action details
                    action_taken: context.action_taken || null,
                    parameters: context.parameters || {},
                    
                    // Result: allowed or refused?
                    result: context.result || 'allowed',
                    refusal_reason: context.refusal_reason || null,
                    
                    // Authority/policy check (pseudonymized)
                    authority_ref: userId,  // âœ… Pseudonymized
                    policy_ref: context.policy_ref || 'default_v1',
                    
                    // Affected entities (full detail)
                    affected_commits: context.affected_commits || [],
                    affected_cells: context.affected_cells || [],
                    
                    // Reproducible state snapshot
                    commit_count: state.commits.length,
                    pressure_budget: state.pressureBudget.used,
                    drift_count: state.driftObjects.length,
                    
                    // Privacy metadata
                    user_id_pseudonym: userId,  // âœ… Not real ID
                    retention_expires_at: now + tracePrivacySettings.raw_retention_ms,  // âœ… 7 days max
                    trace_mode: 'raw',
                    consent_required: true
                };
                
                traces.raw.push(rawTrace);
            }
            
            // Clean up expired traces (privacy enforcement)
            cleanupExpiredTraces();
            
            console.log('ğŸ“Š TRACE (aggregated):', actionType, aggregatedTrace);
            if (tracePrivacySettings.raw_opt_in) {
                console.log('ğŸ“Š TRACE (raw, opt-in):', actionType, 'User:', userId);
            }
            
            return aggregatedTrace;
        }
        
        // Hash user ID for pseudonymization
        function hashUserId(userId) {
            // Simple hash for demo (use crypto.subtle.digest in production)
            let hash = 0;
            for (let i = 0; i < userId.length; i++) {
                hash = ((hash << 5) - hash) + userId.charCodeAt(i);
                hash = hash & hash;
            }
            return `user_${Math.abs(hash).toString(36)}`;
        }
        
        // Clean up expired traces (privacy enforcement)
        function cleanupExpiredTraces() {
            const now = Date.now();
            
            // Remove expired aggregated traces
            traces.aggregated = traces.aggregated.filter(t => t.retention_expires_at > now);
            
            // Remove expired raw traces
            traces.raw = traces.raw.filter(t => t.retention_expires_at > now);
            
            // Log cleanup if any removed
            if (traces.aggregated.length === 0 && traces.raw.length === 0) {
                console.log('ğŸ§¹ Cleaned up expired traces (privacy enforcement)');
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BRANCH METRICS - Calculate time-series metrics for a branch
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function calculateBranchMetrics(branchId, commits) {
            if (!state.branchMetrics[branchId]) {
                state.branchMetrics[branchId] = {
                    branchId: branchId,
                    timeSeries: [],
                    regression: { trend: 0, velocity: 0, acceleration: 0 },
                    currentState: { cost: 0, risk: 0, eri: 50, heat: 0, pressure: 0, rain: 1.0 }
                };
            }
            
            const metrics = state.branchMetrics[branchId];
            const timeSeries = metrics.timeSeries;
            
            // Calculate current metrics from commits
            let cost = 0;
            let risk = 0;
            let eriSum = 0;
            let eriCount = 0;
            let heat = 0;
            let pressure = state.pressureBudget.used / state.pressureBudget.max;
            let rain = 1.0; // Placeholder for incentive flow
            
            // Aggregate from commits and cells
            commits.forEach(commit => {
                if (commit.type === COMMIT_TYPES.CELL_SET && commit.payload.value) {
                    const val = parseFloat(commit.payload.value);
                    if (!isNaN(val)) {
                        cost += val; // Simplified: sum all numeric cells as "cost"
                    }
                }
            });
            
            // Calculate ERI average
            Object.values(state.bundles).forEach(bundle => {
                Object.values(bundle.sheets || {}).forEach(sheet => {
                    Object.values(sheet.cells || {}).forEach(cell => {
                        if (cell.eri) {
                            eriSum += cell.eri;
                            eriCount++;
                        }
                    });
                });
            });
            const eri = eriCount > 0 ? eriSum / eriCount : 50;
            
            // Risk = inverse of ERI (low ERI = high risk)
            risk = (100 - eri) / 100;
            
            // Heat = drift count + pressure
            heat = state.driftObjects.length * 0.1 + pressure;
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FIX #3: Add confidence + missing_inputs to every metric point
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // Calculate missing inputs (cells with low ERI or missing formulas)
            const missingInputs = [];
            Object.values(state.bundles).forEach(bundle => {
                Object.values(bundle.sheets || {}).forEach(sheet => {
                    Object.entries(sheet.cells || {}).forEach(([cellId, cell]) => {
                        if (cell.eri < 50) {
                            missingInputs.push(`${sheet.name}!${cellId} (ERI: ${cell.eri})`);
                        }
                        if (cell.formula && (!cell.deps || cell.deps.length === 0)) {
                            missingInputs.push(`${sheet.name}!${cellId} (no deps parsed)`);
                        }
                    });
                });
            });
            
            // Calculate confidence (based on ERI + missing inputs + drift count)
            const baseConfidence = eri / 100;  // ERI as base (0-1)
            const missingPenalty = Math.min(missingInputs.length * 0.05, 0.3);  // Max 30% penalty
            const driftPenalty = Math.min(state.driftObjects.length * 0.1, 0.2);  // Max 20% penalty
            const confidence = Math.max(0.1, Math.min(1.0, baseConfidence - missingPenalty - driftPenalty));
            
            // Determine display state (like ERI: verified / degraded / indeterminate)
            let displayState;
            if (confidence >= 0.8 && missingInputs.length === 0) {
                displayState = 'verified';
            } else if (confidence >= 0.5) {
                displayState = 'degraded';
            } else {
                displayState = 'indeterminate';
            }
            
            // Add time point with enhanced confidence tracking
            const timePoint = {
                t: timeSeries.length,
                commitIndex: commits.length,
                timeboxId: `2026-02-W${Math.floor(timeSeries.length / 7) + 1}`,
                cost: Math.round(cost),
                risk: Math.round(risk * 100) / 100,
                eri: Math.round(eri),
                heat: Math.round(heat * 100) / 100,
                pressure: Math.round(pressure * 100) / 100,
                rain: rain,
                confidence: Math.round(confidence * 100) / 100,  // âœ… Properly calculated
                missing_inputs: missingInputs,  // âœ… Actual missing data
                display_state: displayState  // âœ… verified/degraded/indeterminate
            };
            
            timeSeries.push(timePoint);
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FIX #4: Regression as PROJECTION (not truth)
            // Must carry: method, window, confidence, policy_ref
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (timeSeries.length >= 3) {
                const window = 3;  // Using last 3 points
                const last3 = timeSeries.slice(-window);
                const costs = last3.map(p => p.cost);
                
                // Simple linear regression slope
                const n = costs.length;
                const sumX = (n * (n - 1)) / 2; // 0 + 1 + 2
                const sumY = costs.reduce((a, b) => a + b, 0);
                const sumXY = costs.reduce((sum, y, i) => sum + i * y, 0);
                const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
                
                const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                const velocity = costs[n - 1] - costs[n - 2];
                const acceleration = (costs[n - 1] - costs[n - 2]) - (costs[n - 2] - costs[n - 3]);
                
                // Calculate regression confidence (based on data quality)
                const avgConfidence = last3.reduce((sum, p) => sum + p.confidence, 0) / n;
                const regressionConfidence = Math.round(avgConfidence * 100) / 100;
                
                // âœ… Regression as projection with full metadata
                metrics.regression = {
                    // Computed values
                    trend: Math.round(slope * 100) / 100,
                    velocity: Math.round(velocity),
                    acceleration: Math.round(acceleration),
                    
                    // âœ… Projection metadata (FIX #4)
                    method: 'linear',  // Algorithm used
                    window: window,  // Number of points used
                    confidence: regressionConfidence,  // Based on input data confidence
                    policy_ref: 'default_v1',  // Versioned parameters
                    computed_at: Date.now(),  // When calculated
                    is_projection: true  // âœ… NOT TRUTH!
                };
            }
            
            metrics.currentState = timePoint;
            
            console.log(`ğŸ“ˆ Branch metrics updated for ${branchId}:`, {
                cost: timePoint.cost,
                eri: timePoint.eri,
                heat: timePoint.heat,
                trend: metrics.regression.trend,
                velocity: metrics.regression.velocity
            });
            
            return metrics;
        }
        
        const state = {
            data: [],  // Legacy: will be replaced by bundles
            commits: [],
            forks: [], // Store forked filaments
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUNDLE-BASED FILE MODEL
            // Excel file = bundle of many filaments (one per cell)
            // Structure: bundle â†’ sheets â†’ cells â†’ commits
            // + FORMULA GRAPH (relationship physics)
            // + DEPENDENCY INDEX (propagation)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            bundles: {
                // Example structure (populated on FILE_IMPORT):
                // 'quotes_feb2026.xlsx': {
                //     id: 'bundle.quotes.feb2026',
                //     filename: 'quotes_feb2026.xlsx',
                //     imported_at: timestamp,
                //     sheets: {
                //         'Sheet1': {
                //             id: 'sheet.quotes.sheet1',
                //             name: 'Sheet1',
                //             cells: {
                //                 'A1': { 
                //                     filament: [...commits], 
                //                     eri: 85, 
                //                     authority: {...},
                //                     formula: null,        // âœ… NEW: formula if present
                //                     deps: [],            // âœ… NEW: cells this depends on
                //                     dependents: [],      // âœ… NEW: cells that depend on this
                //                     isDirty: false       // âœ… NEW: needs recomputation
                //                 },
                //                 'B1': { filament: [...], eri: 92, formula: '=A1*2', deps: ['A1'] },
                //                 ...
                //             },
                //             
                //             // âœ… NEW: FORMULA GRAPH
                //             formulaGraph: {
                //                 nodes: ['A1', 'B1', 'C1', ...],  // All cells
                //                 edges: [
                //                     { from: 'A1', to: 'B1', type: 'FORMULA_DEP' },
                //                     { from: 'A1', to: 'C1', type: 'FORMULA_DEP' },
                //                     ...
                //                 ]
                //             },
                //             
                //             // âœ… NEW: DEPENDENCY INDEX (reverse lookup for fast propagation)
                //             dependencyIndex: {
                //                 'A1': ['B1', 'C1'],  // A1 change affects B1 and C1
                //                 'B1': ['D1'],        // B1 change affects D1
                //                 ...
                //             }
                //         }
                //     }
                // }
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BRANCH DYNAMICS - EACH BRANCH MOVES UNDER MATHEMATICS
            // Each branch tip (MAIN, Scenario A, B) has time-series metrics
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            branchMetrics: {
                'MAIN': {
                    branchId: 'MAIN',
                    timeSeries: [],
                    regression: { trend: 0, velocity: 0, acceleration: 0 },
                    currentState: { cost: 0, risk: 0, eri: 50, heat: 0, pressure: 0, rain: 1.0 }
                }
                // Scenario A/B will be added when forks are created
            },
            
            authority: {
                user: 'local@prototype',
                issued_at: Date.now(),
                expires_at: Date.now() + (30 * 60 * 1000), // 30 minutes
                scope: 'full'
            },
            selectedCell: null,
            driftObjects: [],
            pressureBudget: { used: 0, max: 10 },
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // TREE SCAFFOLD DATA - BOTTOM-UP LAYOUT
            // UPGRADE #2: Roots below (Y=-8), trunk rises, sheets at top (Y=+6)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            tree: {
                nodes: [
                    {
                        id: 'company.nw',
                        type: 'root',
                        label: 'Northwind Tools',
                        parent: null,
                        position: { x: 0, y: -8, z: 0 },  // ROOT AT BOTTOM
                        pressureRings: [
                            { timeboxId: '2026-02-W1', commitCount: 45, openDrifts: 2, eriAvg: 82, scarCount: 1 },
                            { timeboxId: '2026-02-W2', commitCount: 38, openDrifts: 0, eriAvg: 88, scarCount: 0 },
                            { timeboxId: '2026-02-W3', commitCount: 52, openDrifts: 3, eriAvg: 76, scarCount: 2 },
                            { timeboxId: '2026-02-W4', commitCount: 41, openDrifts: 1, eriAvg: 85, scarCount: 1 }
                        ]
                    },
                    {
                        id: 'branch.nw.ta',
                        type: 'branch',
                        label: 'NW.TA (Tel Aviv)',
                        parent: 'company.nw',
                        position: { x: 0, y: -3, z: 0 },  // TRUNK MIDDLE
                        pressureRings: [
                            { timeboxId: '2026-02-W1', commitCount: 28, openDrifts: 1, eriAvg: 79, scarCount: 0 },
                            { timeboxId: '2026-02-W2', commitCount: 35, openDrifts: 2, eriAvg: 74, scarCount: 1 },
                            { timeboxId: '2026-02-W3', commitCount: 42, openDrifts: 3, eriAvg: 71, scarCount: 2 }
                        ]
                    },
                    {
                        id: 'dept.nw.ta.procurement',
                        type: 'department',
                        label: 'Procurement',
                        parent: 'branch.nw.ta',
                        position: { x: -5, y: 2, z: 0 },  // DEPARTMENTS HIGHER
                        pressureRings: [
                            { timeboxId: '2026-02-W1', commitCount: 15, openDrifts: 0, eriAvg: 85, scarCount: 0 },
                            { timeboxId: '2026-02-W2', commitCount: 22, openDrifts: 2, eriAvg: 72, scarCount: 1 }
                        ]
                    },
                    {
                        id: 'dept.nw.ta.finance',
                        type: 'department',
                        label: 'Finance',
                        parent: 'branch.nw.ta',
                        position: { x: 5, y: 2, z: 0 },  // DEPARTMENTS HIGHER
                        pressureRings: [
                            { timeboxId: '2026-02-W1', commitCount: 12, openDrifts: 0, eriAvg: 91, scarCount: 0 },
                            { timeboxId: '2026-02-W2', commitCount: 18, openDrifts: 0, eriAvg: 89, scarCount: 0 }
                        ]
                    },
                    {
                        id: 'sheet.quotes.feb2026',
                        type: 'sheet',
                        label: 'Vendor Quotes (Feb 2026)',
                        parent: 'dept.nw.ta.procurement',
                        position: { x: -7, y: 6, z: -2 },  // SHEETS AT TOP (outer tips)
                        eri: 85,
                        drift_count: 0,
                        file: 'quotes_feb2026.xlsx'
                    },
                    {
                        id: 'sheet.po.feb2026',
                        type: 'sheet',
                        label: 'Purchase Orders (Feb 2026)',
                        parent: 'dept.nw.ta.procurement',
                        position: { x: -3, y: 6, z: 2 },  // SHEETS AT TOP (outer tips)
                        eri: 72,
                        drift_count: 2,
                        file: 'po_feb2026.xlsx'
                    },
                    {
                        id: 'sheet.invoices.feb2026',
                        type: 'sheet',
                        label: 'Invoices (Feb 2026)',
                        parent: 'dept.nw.ta.finance',
                        position: { x: 5, y: 6, z: 0 },  // SHEETS AT TOP (outer tips)
                        eri: 91,
                        drift_count: 0,
                        file: 'invoices_feb2026.xlsx'
                    }
                ]
            },
            selectedSheetNode: null // Track which sheet endpoint is currently active
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GLOBAL DROP PROTECTION (prevents browser hijack)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // This guarantees drop works even with canvas overlays/pointer lock
        ["dragenter","dragover","dragleave","drop"].forEach(evt => {
            window.addEventListener(evt, (e) => {
                // Only prevent default if it's a file drag (not text/other)
                if (e.dataTransfer && e.dataTransfer.types.includes('Files')) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }, { passive: false });
        });

        console.log("[Relay] ğŸ›¡ï¸ Global drop protection enabled (window-level)");

        // Drop zone handling (ROBUST VERSION)
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        
        console.log("[Relay] ğŸ“¥ Setting up drag & drop handlers");
        console.log("[Relay] ğŸ“‚ Drop zone:", dropZone ? "found" : "NOT FOUND");
        console.log("[Relay] ğŸ¯ File input:", fileInput ? "found" : "NOT FOUND");

        // Prevent default for all drag events (prevents browser from opening file)
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach((evt) => {
            dropZone.addEventListener(evt, (e) => {
                e.preventDefault();
                e.stopPropagation();
            });
        });

        // Hover preview - continuous feedback
        dropZone.addEventListener('mousemove', (e) => {
            relayUI.setPreview("Drop .xlsx to import â†’ build Tree Scaffold");
        });

        dropZone.addEventListener('mouseleave', () => {
            relayUI.setPreview("â€”");
        });

        dropZone.addEventListener('dragenter', (e) => {
            dropZone.classList.add('dragover');
            relayUI.setPreview("Release to import Excel (no commit yet)");
            relayUI.log("File hovering over drop zone", "info");
        });

        dropZone.addEventListener('dragover', (e) => {
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
            relayUI.setPreview("Drop .xlsx to import â†’ build Tree Scaffold");
        });

        dropZone.addEventListener('drop', async (e) => {
            dropZone.classList.remove('dragover');
            const file = e.dataTransfer?.files?.[0];
            
            relayUI.log(`File dropped: ${file?.name || 'unknown'}`, "info");
            console.log("[Relay] ğŸ“‚ File dropped:", file?.name, file?.type, file?.size);
            
            if (!file) {
                console.error("[Relay] âŒ No file in drop event");
                relayUI.log("No file in drop event", "err");
                return;
            }
            
            if (!/\.(xlsx|xls|csv)$/i.test(file.name)) {
                console.error("[Relay] âŒ Not a supported file type:", file.name);
                relayUI.log(`Not a supported file type: ${file.name}`, "err");
                alert("Please drop an Excel file (.xlsx, .xls, or .csv)");
                return;
            }
            
            relayUI.setPreview("Reading Excel file...");
            handleFile(file);
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            console.log("[Relay] ğŸ“‚ File selected via browse:", file?.name);
            if (file) {
                relayUI.log(`File selected: ${file.name}`, "info");
                relayUI.setPreview("Reading Excel file...");
                handleFile(file);
            }
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GLOBAL WINDOW DROP HANDLER (failsafe for canvas overlays)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Catches drops anywhere on page, even if dropZone is obscured
        window.addEventListener("drop", async (e) => {
            const file = e.dataTransfer?.files?.[0];
            if (!file) return;

            console.log("[Relay] ğŸŒ Global window drop:", file.name, file.size);

            // Check file type
            if (!/\.(xlsx|xls|csv)$/i.test(file.name)) {
                console.warn("[Relay] âš ï¸ Not an Excel file:", file.name);
                relayUI.log(`Not an Excel file: ${file.name}`, "err");
                return;
            }

            // Check XLSX library
            if (typeof XLSX === "undefined") {
                console.error("[Relay] âŒ XLSX missing (library not loaded)");
                relayUI.log("XLSX library not loaded - refresh page", "err");
                alert('Error: Excel library not loaded. Please refresh the page and try again.');
                return;
            }

            relayUI.log(`File dropped (global): ${file.name}`, "info");
            relayUI.setPreview("Reading Excel file...");
            handleFile(file);
        });

        console.log("[Relay] ğŸŒ Global window drop handler registered");

        document.getElementById('newFileBtn').addEventListener('click', () => {
            document.getElementById('spreadsheetContainer').classList.remove('active');
            dropZone.style.display = 'flex';
            state.data = [];
            state.commits = [];
            state.forks = [];
        });

        document.getElementById('forkBtn').addEventListener('click', () => {
            createFork();
        });

        function handleFile(file) {
            console.log('ğŸ“‚ File selected:', file.name, file.type, file.size);
            relayUI.log(`Processing: ${file.name} (${Math.round(file.size/1024)}KB)`, "info");
            
            // Check if XLSX library is loaded
            if (typeof XLSX === 'undefined') {
                console.error('âŒ XLSX library not loaded!');
                relayUI.log("XLSX library not loaded - refresh page", "err");
                alert('Error: Excel library not loaded. Please refresh the page and try again.');
                return;
            }
            
            console.log('âœ… XLSX library loaded, version:', XLSX.version);
            relayUI.log(`XLSX library ready (v${XLSX.version})`, "ok");
            
            const reader = new FileReader();
            
            reader.onload = (e) => {
                try {
                    console.log('ğŸ“– File read complete, parsing...');
                    relayUI.log("File read complete, parsing workbook...", "info");
                    relayUI.setPreview("Parsing Excel workbook...");
                    
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    console.log('âœ… Workbook parsed:', workbook.SheetNames);
                    relayUI.log(`Workbook parsed: ${workbook.SheetNames.join(', ')}`, "ok");
                    
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
                    console.log('âœ… Data converted:', jsonData.length, 'rows');
                    relayUI.log(`Converted: ${jsonData.length} rows Ã— ${jsonData[0]?.length || 0} columns`, "ok");
                    
                    relayUI.setPreview("Building commit graph...");
                    
                    // Import as filament (each row = commit)
                    importAsFilament(jsonData, file.name);
                    
                    relayUI.log("Import complete - building 3D view", "ok");
                    
                    // ğŸ”’ PHASE 1 LOCK: Run topology lint after import
                    const lintResult = relayLintTopology(state);
                    if (!lintResult.pass) {
                        console.error('ğŸš¨ TOPOLOGY VIOLATION AFTER IMPORT');
                        relayUI.log("Topology violation detected", "err");
                        alert('Topology violation: ' + lintResult.errors.join(', '));
                    } else {
                        relayUI.log("Topology validated âœ“", "ok");
                    }
                    
                    // ğŸ”’ PHASE 2A: Auto-transition to 3D Tree View after import
                    console.log('[Relay] ğŸš€ Auto-transitioning to Tree Scaffold view...');
                    setTimeout(() => {
                        switchView('scaffold');  // Render tree scaffold
                        relayUI.log("Tree view active - use Z/M to zoom, G for grid", "ok");
                    }, 500);  // Small delay to ensure DOM is ready
                    
                    relayUI.setPreview("Loading 3D view...");
                    
                } catch (error) {
                    console.error('âŒ Error reading file:', error);
                    relayUI.log(`Error: ${error.message}`, "err");
                    alert('Error reading file: ' + error.message);
                    relayUI.setPreview("Error - try again");
                }
            };
            
            reader.onerror = (error) => {
                console.error('âŒ FileReader error:', error);
                relayUI.log("FileReader error - try again", "err");
                alert('Error loading file. Please try again.');
                relayUI.setPreview("Error - try again");
            };
            
            console.log('ğŸ“¥ Starting file read...');
            relayUI.setPreview("Reading file bytes...");
            reader.readAsArrayBuffer(file);
        }

        function importAsFilament(data, filename) {
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUNDLE-BASED IMPORT - TYPED COMMITS
            // Excel file â†’ bundle â†’ sheets â†’ cells â†’ commits
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // Clear legacy state (keep for backwards compat for now)
            state.data = [];
            state.commits = [];
            
            // 1. Create FILE_IMPORT commit (bundle root)
            const fileImportCommit = createCommit(COMMIT_TYPES.FILE_IMPORT, {
                filename: filename,
                rows: data.length,
                cols: data[0]?.length || 0,
                imported_at: Date.now()
            });
            state.commits.push(fileImportCommit);
            
            // 2. Create bundle structure
            const bundleId = `bundle.${filename.replace(/[^a-z0-9]/gi, '_').toLowerCase()}`;
            state.bundles[bundleId] = {
                id: bundleId,
                filename: filename,
                imported_at: Date.now(),
                sheets: {
                    'Sheet1': {
                        id: `sheet.${bundleId}.sheet1`,
                        name: 'Sheet1',
                        cells: {}
                    }
                }
            };
            
            const sheet = state.bundles[bundleId].sheets['Sheet1'];
            
            // 3. Create SHEET_DEFINE commit
            const sheetDefineCommit = createCommit(COMMIT_TYPES.SHEET_DEFINE, {
                bundleId: bundleId,
                sheetId: sheet.id,
                sheetName: 'Sheet1',
                rows: data.length,
                cols: data[0]?.length || 0
            });
            state.commits.push(sheetDefineCommit);
            
            // 4. Convert each cell to CELL_SET commits
            data.forEach((row, rowIndex) => {
                const rowData = row.map((cell, colIndex) => {
                    const cellId = `${String.fromCharCode(65 + colIndex)}${rowIndex + 1}`; // e.g., A1, B2
                    const cellValue = cell || '';
                    
                    // âœ… DETECT FORMULAS (starts with =)
                    const isFormula = typeof cellValue === 'string' && cellValue.startsWith('=');
                    
                    // Create appropriate commit type
                    let cellCommit;
                    if (isFormula) {
                        // CELL_FORMULA_SET commit
                        const deps = parseFormulaDeps(cellValue);
                        cellCommit = createCommit(COMMIT_TYPES.CELL_FORMULA_SET, {
                            bundleId: bundleId,
                            sheetId: sheet.id,
                            cellId: cellId,
                            formula: cellValue,  // âœ… Formulas have .formula, not .value
                            deps: deps,  // âœ… Normalized dependencies
                            parse_version: '1.0',  // âœ… Parser version for replay
                            row: rowIndex,
                            col: colIndex
                        });
                    } else {
                        // CELL_SET commit (regular value)
                        cellCommit = createCommit(COMMIT_TYPES.CELL_SET, {
                            bundleId: bundleId,
                            sheetId: sheet.id,
                            cellId: cellId,
                            value: cellValue,  // âœ… Only CELL_SET commits have .value
                            row: rowIndex,
                            col: colIndex
                        });
                    }
                    state.commits.push(cellCommit);
                    
                    // Store cell in bundle structure
                    sheet.cells[cellId] = {
                        filament: [cellCommit],  // Each cell has its own commit chain
                        eri: calculateERI(cellValue, rowIndex, colIndex),
                        authority: state.authority,
                        formula: isFormula ? cellValue : null,  // âœ… Store formula
                        deps: isFormula ? parseFormulaDeps(cellValue) : [],  // âœ… Store dependencies
                        dependents: [],  // Will be filled by dependency graph
                        isDirty: false
                    };
                    
                    return {
                        value: cellValue,
                        eri: calculateERI(cellValue, rowIndex, colIndex),
                        authority: null
                    };
                });
                
                state.data.push(rowData); // Keep legacy format for now
            });
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // 5. BUILD DEPENDENCY GRAPH (formula relationships)
            // âœ… FIX #1: Rebuild from commits (not import-time only)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            console.log('ğŸ”— Building dependency graph from commits...');
            buildDependencyGraphFromCommits(state.bundles[bundleId]);
            
            // ğŸ”’ PHASE 1 LOCK: Lock graph identity (enforce one-graph rule)
            if (!graphBuildId) {
                graphBuildId = `graph-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                console.log('[Relay] ğŸ”’ Graph identity locked:', graphBuildId);
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // 6. CALCULATE INITIAL BRANCH METRICS (MAIN branch)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            console.log('ğŸ“ˆ Calculating branch metrics...');
            calculateBranchMetrics('MAIN', state.commits);

            // Update UI
            renderGrid();
            dropZone.style.display = 'none';
            document.getElementById('spreadsheetContainer').classList.add('active');
            
            // Enable fork button
            document.getElementById('forkBtn').disabled = false;
            
            // Update enforcement status
            updateEnforcementStatus();
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FIX #6: Emit trace for FILE_IMPORT action
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            emitTrace('FILE_IMPORT', {
                action_taken: 'import_excel_file',
                parameters: {
                    filename: filename,
                    rows: data.length,
                    sheets: 1,
                    formula_edges: sheet.formulaGraph ? sheet.formulaGraph.edges.length : 0
                },
                result: 'allowed',
                affected_commits: state.commits.slice(-data.length).map(c => c.id),
                policy_ref: 'default_v1'
            });
            
            // Show success
            const graphStats = sheet.formulaGraph || { edges: [] };
            showNotification(
                `âœ… Imported ${data.length} rows | ${graphStats.edges.length} formula dependencies | Branch metrics initialized`, 
                'success'
            );
        }

        function calculateERI(value, row, col) {
            // Simple ERI calculation
            let score = 50; // Base score
            
            // Visibility: does cell have content?
            if (value && value.toString().trim()) score += 20;
            
            // Configuration: is it properly formatted?
            if (typeof value === 'number' || !isNaN(parseFloat(value))) score += 10;
            
            // Patch status: is it recent? (always yes for new import)
            score += 10;
            
            // Authority: do we have authority? (not yet)
            // score += 0;
            
            // Recovery: can it be restored? (yes, it's in commits)
            score += 10;
            
            return Math.min(100, score);
        }

        // âœ… createCommit function is defined above with typed commit system

        function createFork() {
            // FIX #3: Gate fork creation with pressure budget check
            if (state.pressureBudget.used >= state.pressureBudget.max) {
                showRefusal([
                    `Pressure budget exhausted (${state.pressureBudget.used}/${state.pressureBudget.max})`,
                    'Fork creation requires available capacity'
                ], [
                    'Resolve existing drifts to free capacity',
                    'Wait for budget reset',
                    'Close unused forks'
                ]);
                return;
            }
            
            // FIX #3: Fork creation modal for intent capture (simplified inline for now)
            const assumptions = [
                'Cost +10% (higher vendor quotes)',
                'Cost -15% (volume discount)',
                'Timeline +3mo (supply chain delay)',
                'Quality threshold +20% (stricter specs)'
            ];
            const assumption = assumptions[state.forks.length % assumptions.length];
            
            // Create fork from current main filament
            const forkPoint = Math.floor(state.commits.length * 0.5);
            const forkCommits = [];
            
            // FIX #2: Descriptive, not evaluative labels
            const forkLabel = `Scenario ${String.fromCharCode(65 + state.forks.length)}`;
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FIX #5: ASSUMPTION_SET - Explicit, Replayable Scenario Commits
            // Assumptions must be explicit commits with structured payload
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // Parse assumption into structured format
            // Example: "Cost +10% (higher vendor quotes)" â†’ {type: 'cost', parameter: 'cost', value: '+10%'}
            let assumptionType = 'cost';  // Default
            let parameter = 'cost_multiplier';
            let value = 1.0;
            let scope = 'bundle';  // Apply to whole bundle by default
            
            if (assumption.includes('Cost +')) {
                assumptionType = 'cost_increase';
                const match = assumption.match(/\+(\d+)%/);
                value = match ? 1 + (parseInt(match[1]) / 100) : 1.1;
            } else if (assumption.includes('Cost -')) {
                assumptionType = 'cost_decrease';
                const match = assumption.match(/-(\d+)%/);
                value = match ? 1 - (parseInt(match[1]) / 100) : 0.85;
            } else if (assumption.includes('Timeline')) {
                assumptionType = 'timeline_adjustment';
                parameter = 'timeline_months';
            } else if (assumption.includes('Quality')) {
                assumptionType = 'quality_threshold';
                parameter = 'quality_multiplier';
            }
            
            // Create ASSUMPTION_SET commit (fork root)
            const assumptionCommit = createCommit(COMMIT_TYPES.ASSUMPTION, {
                scenario: forkLabel,
                assumption: assumption,
                
                // âœ… FIX #5: Explicit assumption structure
                assumption_type: assumptionType,  // 'cost_increase', 'timeline_adjustment', etc.
                parameter: parameter,  // What changes
                value: value,  // How much it changes
                scope: scope,  // What it affects (bundle/sheet/range)
                
                forkPoint: forkPoint,
                description: `${forkLabel}: ${assumption}`,
                // âœ… NO .value property in root! This is structured metadata.
            });
            state.commits.push(assumptionCommit);
            
            // Create fork divergence commits (also ASSUMPTION type)
            for (let i = 0; i < 50; i++) {
                const divergenceCommit = createCommit(COMMIT_TYPES.ASSUMPTION, {
                    scenario: forkLabel,
                    assumption: assumption,
                    forkIndex: state.forks.length,
                    commitIndex: i,
                    description: `${forkLabel}: ${assumption} - projection ${i + 1}`,
                    // âœ… NO .value! This is just projection metadata.
                });
                forkCommits.push(divergenceCommit);
            }
            
            // Also push to main commits list for replay
            state.commits.push(...forkCommits);
            
            const fork = {
                id: `fork_${state.forks.length}`,
                name: `${forkLabel} (${assumption})`, // FIX #2: Descriptive label
                branchPoint: forkPoint,
                commits: forkCommits,
                assumption: assumption,
                assumptionCommit: assumptionCommit,  // âœ… Root ASSUMPTION commit
                color: [0xff6b6b, 0xffd93d, 0x6bcf7f, 0x4d96ff][state.forks.length % 4],
                created_at: Date.now()
            };
            
            state.forks.push(fork);
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // INITIALIZE BRANCH METRICS FOR NEW SCENARIO
            // Each fork is a new branch that moves under its own mathematics
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            state.branchMetrics[fork.name] = {
                branchId: fork.name,
                timeSeries: [],
                regression: { trend: 0, velocity: 0, acceleration: 0 },
                currentState: { cost: 0, risk: 0, eri: 50, heat: 0, pressure: 0, rain: 1.0 }
            };
            
            // Calculate initial metrics for this branch (with assumption applied)
            calculateBranchMetrics(fork.name, [...state.commits, ...forkCommits]);
            
            console.log(`ğŸ“ˆ Initialized branch metrics for ${fork.name}`);
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FIX #6: Emit trace for FORK_CREATE action
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            emitTrace('FORK_CREATE', {
                action_taken: 'create_scenario_fork',
                parameters: {
                    scenario_name: fork.name,
                    assumption: assumption,
                    assumption_type: assumptionCommit.payload.assumption_type,
                    fork_point: forkPoint
                },
                result: 'allowed',
                affected_commits: [assumptionCommit.id, ...forkCommits.map(c => c.id)],
                policy_ref: 'default_v1'
            });
            
            // FIX #3: Consume pressure budget
            state.pressureBudget.used += 1;
            updateEnforcementStatus();
            
            // Re-render 3D if in filament view
            if (renderer) {
                render3DFilament();
            }
            
            showNotification(`âœ… Created fork: ${fork.name} | Branch metrics initialized`, 'success');
            console.log(`Fork created with assumption: ${assumption}`);
            console.log(`Pressure budget: ${state.pressureBudget.used}/${state.pressureBudget.max}`);
            
            return fork;
        }

        function renderGrid() {
            const grid = document.getElementById('grid');
            grid.innerHTML = '';
            
            if (state.data.length === 0) return;
            
            const cols = state.data[0].length;
            
            // Header row
            const emptyHeader = document.createElement('div');
            emptyHeader.className = 'cell header';
            grid.appendChild(emptyHeader);
            
            for (let col = 0; col < cols; col++) {
                const header = document.createElement('div');
                header.className = 'cell header';
                header.textContent = String.fromCharCode(65 + col); // A, B, C...
                grid.appendChild(header);
            }
            
            // Data rows
            state.data.forEach((row, rowIndex) => {
                // Row header
                const rowHeader = document.createElement('div');
                rowHeader.className = 'cell row-header';
                rowHeader.textContent = rowIndex + 1;
                grid.appendChild(rowHeader);
                
                // Data cells
                row.forEach((cellData, colIndex) => {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.textContent = cellData.value;
                    cell.dataset.row = rowIndex;
                    cell.dataset.col = colIndex;
                    
                    // Authority check (refusal-first UX)
                    if (!hasAuthority()) {
                        cell.classList.add('disabled');
                        cell.innerHTML = `<span class="lock-icon">ğŸ”’</span>${cellData.value}`;
                        cell.title = 'Authority expired - click for details';
                    } else {
                        cell.classList.add('editable');
                    }
                    
                    // ERI badge
                    const eriBadge = document.createElement('div');
                    eriBadge.className = 'eri-badge';
                    if (cellData.eri >= 80) eriBadge.classList.add('high');
                    else if (cellData.eri >= 50) eriBadge.classList.add('medium');
                    else eriBadge.classList.add('low');
                    eriBadge.title = `ERI: ${cellData.eri}`;
                    cell.appendChild(eriBadge);
                    
                    // Click handler
                    cell.addEventListener('click', () => handleCellClick(rowIndex, colIndex));
                    
                    grid.appendChild(cell);
                });
            });
        }

        function handleCellClick(row, col) {
            const cellData = state.data[row][col];
            
            // Check authority (enforcement!)
            if (!hasAuthority()) {
                showRefusal([
                    'Authority expired (30 minutes elapsed)',
                    'Edits require valid authority'
                ], [
                    'Renew authority (requires governance approval)',
                    'Rotate to another user',
                    'View cell in read-only mode'
                ]);
                return;
            }
            
            // Check pressure budget
            if (state.pressureBudget.used >= state.pressureBudget.max) {
                showRefusal([
                    `Pressure budget exhausted (${state.pressureBudget.used}/${state.pressureBudget.max})`,
                    'Cannot perform more actions until budget resets'
                ], [
                    'Wait for budget reset (daily)',
                    'Batch multiple edits into single commit',
                    'Request budget increase (requires justification)'
                ]);
                return;
            }
            
            // Check for open drifts
            if (state.driftObjects.length > 0) {
                showRefusal([
                    `${state.driftObjects.length} open drift object(s) block edits`,
                    'Drift must be resolved before new changes'
                ], [
                    'Resolve drift objects',
                    'Investigate mismatch source',
                    'Dismiss drift with justification (requires authority)'
                ]);
                return;
            }
            
            // Show inspector
            showInspector(row, col);
        }

        function showInspector(row, col) {
            const cellData = state.data[row][col];
            const cellId = `${String.fromCharCode(65 + col)}${row + 1}`;
            
            document.getElementById('cellId').textContent = cellId;
            document.getElementById('cellValue').textContent = cellData.value || '(empty)';
            document.getElementById('cellERI').innerHTML = `
                ${cellData.eri}/100 
                <span style="color: ${cellData.eri >= 80 ? '#00ff88' : cellData.eri >= 50 ? '#ffaa00' : '#ff4444'}">
                    ${cellData.eri >= 80 ? 'â—' : cellData.eri >= 50 ? 'â—' : 'â—'}
                </span>
            `;
            
            const authExpiry = new Date(state.authority.expires_at);
            const timeLeft = Math.max(0, Math.floor((authExpiry - Date.now()) / 1000 / 60));
            document.getElementById('cellAuthority').innerHTML = `
                ${state.authority.user}<br>
                <span style="font-size: 0.875rem; color: ${timeLeft < 5 ? '#ff4444' : '#888'}">
                    Expires in ${timeLeft} minutes
                </span>
            `;
            
            // Show commits for this cell
            const cellCommits = state.commits.filter(c => 
                c.reality?.row === row || c.type === 'IMPORT'
            );
            
            const commitLog = document.getElementById('commitLog');
            if (cellCommits.length > 0) {
                commitLog.innerHTML = cellCommits.map(commit => `
                    <div class="commit-item">
                        <strong>${commit.type}</strong><br>
                        <span class="timestamp">${new Date(commit.timestamp).toLocaleString()}</span><br>
                        ${commit.intent || ''}
                    </div>
                `).join('');
            } else {
                commitLog.innerHTML = '<div style="color: #888;">No commits for this cell</div>';
            }
            
            document.getElementById('inspector').classList.add('active');
            state.selectedCell = { row, col };
        }

        function closeInspector() {
            document.getElementById('inspector').classList.remove('active');
            state.selectedCell = null;
        }

        function showRefusal(reasons, steps) {
            const reasonsDiv = document.getElementById('refusalReasons');
            reasonsDiv.innerHTML = reasons.map(r => `
                <div class="reason">âŒ ${r}</div>
            `).join('');
            
            const stepsDiv = document.getElementById('refusalSteps');
            stepsDiv.innerHTML = steps.map(s => `<li>${s}</li>`).join('');
            
            document.getElementById('refusalModal').classList.add('active');
        }

        function closeRefusal() {
            document.getElementById('refusalModal').classList.remove('active');
        }

        function hasAuthority() {
            return Date.now() < state.authority.expires_at;
        }

        function updateEnforcementStatus() {
            document.getElementById('drift-status').querySelector('.status').textContent = 
                `${state.driftObjects.length} open drifts`;
            
            const timeLeft = Math.max(0, Math.floor((state.authority.expires_at - Date.now()) / 1000 / 60));
            document.getElementById('authority-status').querySelector('.status').textContent = 
                `Local authority (expires in ${timeLeft}m)`;
            
            document.getElementById('pressure-status').querySelector('.status').textContent = 
                `${state.pressureBudget.used}/${state.pressureBudget.max} actions used`;
            
            document.getElementById('eri-status').querySelector('.status').innerHTML = 
                '<span class="pass">âœ… ACTIVE</span>';
            
            document.getElementById('three-way-status').querySelector('.status').innerHTML = 
                '<span class="pass">âœ… ACTIVE</span>';
        }

        function showNotification(message, type) {
            // Simple notification (you can enhance this)
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        // ========================================
        // 3D FILAMENT VISUALIZATION (Three.js)
        // ========================================

        let scene, camera, renderer, controls, orbitControls;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ”’ PHASE 1 LOCK: One Graph, Many Lenses - Graph Identity Locks
        // These must NEVER change after init (enforces no scene rebuilding)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let sceneRootUUID = null;  // Locked at scene creation
        let graphBuildId = null;   // Locked at graph build
        let commitNodes = [];
        let filamentEdges = [];
        let formulaEdges = [];
        let animationId;
        let controlMode = 'pointerlock';  // 'pointerlock' or 'orbit'
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸŒ PHASE 2: GLOBE SYSTEM (unified spatial foundation)
        // Per RELAY-FINAL-ARCHITECTURE-SPEC.md Section 6
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let globeMesh = null;      // Earth sphere (spatial truth layer)
        let globeRadius = 10;      // Base radius (Earth representation)
        let boundaryMeshes = [];   // Geopolitical boundaries (extruded shells)
        let companyAnchors = [];   // Company trees anchored to lat/lon

        function init3DView() {
            const container = document.getElementById('filamentView');
            
            if (!container) {
                console.error('[Relay] âŒ filamentView container not found!');
                relayUI.log("3D container missing - check HTML", "err");
                return;
            }
            
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            console.log('[Relay] ğŸ“ Container size:', width, 'x', height);
            
            if (width === 0 || height === 0) {
                console.error('[Relay] âŒ Container has zero size! Cannot initialize renderer.');
                console.log('[Relay] ğŸ“ Container style:', window.getComputedStyle(container).display);
                relayUI.log("3D container has zero size", "err");
                return;
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // AAA VISUAL UPGRADE - Per RELAY-RENDERSPEC-V1.json
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000510); // Deep blue-black (luminescent space)
            scene.fog = new THREE.Fog(0x000820, 60, 120); // Blue fog for depth
            
            // ğŸ”’ PHASE 1 LOCK: Lock scene identity (enforce one-graph rule)
            if (!sceneRootUUID) {
                sceneRootUUID = scene.uuid;
                console.log('[Relay] ğŸ”’ Scene identity locked:', sceneRootUUID);
            } else if (scene.uuid !== sceneRootUUID) {
                console.error('ğŸš¨ VIOLATION: Scene was replaced! One-graph rule broken.');
                throw new Error('Scene identity violation - cannot replace scene graph');
            }
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000); // FOV 75 (wider for FPS feel)
            // ğŸŒ PHASE 2A: START POSITION - View Globe from space (can see Earth + anchored trees)
            camera.position.set(0, 15, 30);  // Above and in front of Globe
            camera.lookAt(0, 0, 0);  // Look at Globe center
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // RENDERER SETUP - PBR & AAA QUALITY
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: false,
                powerPreference: "high-performance"
            });
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap at 2x for performance
            
            // PBR LIGHTING SETUP (Physically Based Rendering)
            renderer.physicallyCorrectLights = true;
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // Film-grade tone mapping
            renderer.toneMappingExposure = 1.0;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows
            renderer.outputEncoding = THREE.sRGBEncoding; // Correct color space
            
            // Append to DOM
            container.innerHTML = '';
            container.appendChild(renderer.domElement);
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // LIGHTING - PBR STANDARD (Per RenderSpec)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // LUMINESCENT LIGHTING (cool blue for translucent structures)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // Ambient base (cool blue tone)
            const ambientLight = new THREE.AmbientLight(0x3366AA, 0.5);
            scene.add(ambientLight);
            
            // Hemisphere light (blue sky / deep ground)
            const hemiLight = new THREE.HemisphereLight(
                0x00AAFF,  // Bright cyan sky
                0x001133,  // Deep blue-black ground
                0.6
            );
            scene.add(hemiLight);
            
            // MAIN KEY LIGHT (cool cyan)
            const directionalLight = new THREE.DirectionalLight(0x00DDFF, 1.6);  // Bright cyan
            directionalLight.position.set(20, 35, 15);
            directionalLight.castShadow = true;
            // High-quality shadows
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 120;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            directionalLight.shadow.bias = -0.0002;
            directionalLight.shadow.radius = 2;
            scene.add(directionalLight);
            
            // RIM LIGHT (bright blue back light)
            const rimLight = new THREE.DirectionalLight(0x0099FF, 0.8);  // Bright blue
            rimLight.position.set(-18, 15, -25);  // Back-left
            scene.add(rimLight);
            
            // FILL LIGHT (soft blue fill)
            const fillLight = new THREE.DirectionalLight(0x88BBFF, 0.4);  // Cool blue fill
            fillLight.position.set(8, 5, 30);  // Front-right low
            scene.add(fillLight);
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // GRID HELPER - STAGE REFERENCE (Nearly Invisible)
            // FIX #1: Grid should fade to 8% opacity (stage, not diagram)
            // UPGRADE #2: Position at bottom (below roots at Y=-8)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const gridHelper = new THREE.GridHelper(60, 60, 0x00ff88, 0x1a1f2e);
            gridHelper.material.opacity = 0.05;  // Nearly invisible (stage reference only)
            gridHelper.material.transparent = true;
            gridHelper.position.y = -12;  // Below roots (roots at Y=-8)
            scene.add(gridHelper);
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // GROUND PLANE - Spatial grounding (subtle, dark, organic)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const groundGeometry = new THREE.PlaneGeometry(100, 100, 32, 32);
            // Add subtle vertex displacement for organic feel
            const posAttr = groundGeometry.attributes.position;
            for (let i = 0; i < posAttr.count; i++) {
                const z = posAttr.getZ(i);
                posAttr.setZ(i, z + (Math.random() - 0.5) * 0.3);  // Subtle noise
            }
            groundGeometry.attributes.position.needsUpdate = true;
            groundGeometry.computeVertexNormals();
            
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1f2e,       // Dark blue-gray (matches scene background)
                roughness: 0.9,
                metalness: 0.0,
                transparent: true,
                opacity: 0.4           // Subtle, doesn't overpower tree
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;  // Horizontal
            ground.position.y = -12.5;         // Just below grid
            ground.receiveShadow = true;
            scene.add(ground);
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // RTS-FREEFLIGHT CONTROLS - CANONICAL FLIGHT PHYSICS
            // Option A: PointerLock + custom velocity (acceleration + damping)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // POINTER LOCK CONTROLS - DEBUG & INITIALIZATION
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            console.log('[Relay] ğŸ® Initializing PointerLockControls...');
            console.log('[Relay] ğŸ“ Camera:', camera);
            console.log('[Relay] ğŸ–¼ï¸ Renderer element:', renderer.domElement);
            
            try {
                controls = new THREE.PointerLockControls(camera, renderer.domElement);
                console.log('[Relay] âœ… PointerLockControls created successfully');
                console.log('[Relay] ğŸ” Controls object:', controls);
            } catch (err) {
                console.error('[Relay] âŒ PointerLockControls creation failed:', err);
                relayUI.log("Control initialization failed - check console", "err");
            }
            
            // OrbitControls as fallback (toggle with 'C' key)
            orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.05;
            orbitControls.minDistance = 2;
            orbitControls.maxDistance = 100;
            orbitControls.enabled = false;  // Start with PointerLock
            console.log('[Relay] âœ… OrbitControls created (fallback, disabled by default)');
            
            // ğŸ”’ PHASE 2A: Keyboard Navigation Shortcuts
            setupNavigationShortcuts();
            
            // Control mode toggle function
            window.toggleControlMode = () => {
                if (controlMode === 'pointerlock') {
                    // Switch to Orbit
                    controlMode = 'orbit';
                    if (controls.isLocked) controls.unlock();
                    orbitControls.enabled = true;
                    flightState.locked = false;
                    flightState.mode = 'HOLD';
                    console.log('[Relay] ğŸ”„ Switched to ORBIT controls (mouse drag to rotate)');
                    relayUI.log("ORBIT mode: drag to rotate, scroll to zoom", "ok");
                } else {
                    // Switch to PointerLock
                    controlMode = 'pointerlock';
                    orbitControls.enabled = false;
                    console.log('[Relay] ğŸ”„ Switched to POINTERLOCK controls (click to engage)');
                    relayUI.log("POINTERLOCK mode: click canvas to fly", "info");
                }
                updateFlightHUD();
            };
            
            // ğŸ”’ PHASE 2A: Navigation Shortcuts Setup
            function setupNavigationShortcuts() {
                window.addEventListener('keydown', (e) => {
                    // Don't interfere with flight controls when pointer is locked
                    if (controls && controls.isLocked) return;
                    
                    const key = e.key.toLowerCase();
                    
                    switch(key) {
                        case 'g':  // Toggle Grid Overlay
                            toggleGridOverlay();
                            e.preventDefault();
                            break;
                        case 'h':  // Toggle History Loop
                            toggleHistoryLoop();
                            e.preventDefault();
                            break;
                        case 't':  // Fly to Tree Anchor
                            flyToTreeAnchor();
                            e.preventDefault();
                            break;
                        case 'z':  // Zoom to Context
                            zoomToContext();
                            e.preventDefault();
                            break;
                        case 'm':  // Macro View
                            macroView();
                            e.preventDefault();
                            break;
                    }
                });
                
                console.log('[Relay] âŒ¨ï¸ Navigation shortcuts registered (G, H, T, Z, M)');
            }
            
            function toggleGridOverlay() {
                const grid = document.getElementById('gridContainer');
                if (!grid) {
                    relayUI.log('Grid not available', 'warn');
                    return;
                }
                
                if (grid.style.display === 'none' || !grid.style.display) {
                    grid.style.display = 'block';
                    grid.style.position = 'absolute';
                    grid.style.top = '0';
                    grid.style.left = '0';
                    grid.style.width = '40%';
                    grid.style.height = '100%';
                    grid.style.background = 'rgba(0, 0, 20, 0.9)';
                    grid.style.opacity = '0.95';
                    grid.style.pointerEvents = 'auto';
                    grid.style.zIndex = '10';
                    grid.style.overflowY = 'auto';
                    relayUI.log('Grid overlay visible', 'ok');
                } else {
                    grid.style.display = 'none';
                    relayUI.log('Grid overlay hidden', 'ok');
                }
            }
            
            function toggleHistoryLoop() {
                // TODO: Implement when history loop mesh exists
                relayUI.log('History loop toggle (not yet implemented)', 'info');
            }
            
            function flyToTreeAnchor() {
                if (!camera) return;
                relayUI.log('Flying to tree anchor...', 'ok');
                const targetPos = new THREE.Vector3(0, 5, 15);  // Front of tree
                animateCameraTo(targetPos, new THREE.Vector3(0, 0, 0));
            }
            
            function zoomToContext() {
                if (!camera) return;
                relayUI.log('Zooming to context view...', 'ok');
                const targetPos = new THREE.Vector3(0, 15, 30);  // See Globe + Tree
                animateCameraTo(targetPos, new THREE.Vector3(0, 0, 0));
            }
            
            function macroView() {
                if (!camera) return;
                relayUI.log('Macro view (high altitude)...', 'ok');
                const targetPos = new THREE.Vector3(0, 25, 50);  // High altitude
                animateCameraTo(targetPos, new THREE.Vector3(0, 0, 0));
            }
            
            function animateCameraTo(targetPos, lookAt, duration = 1000) {
                if (!camera) return;
                
                const startPos = camera.position.clone();
                const startTime = Date.now();
                
                function animate() {
                    const elapsed = Date.now() - startTime;
                    const t = Math.min(elapsed / duration, 1);
                    
                    // Ease in-out
                    const ease = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                    
                    camera.position.lerpVectors(startPos, targetPos, ease);
                    camera.lookAt(lookAt);
                    
                    if (t < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        console.log('[Relay] âœ… Camera animation complete');
                    }
                }
                
                animate();
            }
            
            // Movement state
            const moveState = {
                forward: false,
                backward: false,
                left: false,
                right: false,
                up: false,
                down: false,
                fast: false,    // Shift
                slow: false     // Ctrl
            };
            
            // Flight state (separate from pointer lock)
            const flightState = {
                mode: 'HOLD',          // 'HOLD' | 'FREE_FLY' | 'INSPECT'
                locked: false
            };
            
            // Physics state
            const velocity = new THREE.Vector3();
            const wishDirection = new THREE.Vector3();
            
            // Tunables (canonical settings)
            // UPGRADED: More responsive for better user control
            let flightBaseSpeed = 10.0;       // Faster base (was 6.0)
            const fastMult = 3.5;             // Slightly reduced for control (was 4.0)
            const slowMult = 0.2;             // Slower precision mode (was 0.25)
            const accel = 32.0;               // Snappier response (was 28.0)
            const damping = 9.0;              // Less "sticky" (was 12.0)
            const verticalSpeedMult = 1.2;    // Better Q/E response (was 1.0)
            
            // Mouse settings (FIX 3)
            // UPGRADED: Better sensitivity for smooth look control
            const mouse = {
                sensitivity: 1.5,                            // More responsive (was 1.0)
                pitchMin: THREE.MathUtils.degToRad(-85),     // Wider angle (was -80)
                pitchMax: THREE.MathUtils.degToRad(85)       // Wider angle (was 80)
            };
            
            // Anchor return state (FIX 5)
            const anchorReturn = {
                active: false,
                targetPos: new THREE.Vector3(),
                stopDistance: 1.6,      // stop this far from target
                collisionBuffer: 1.2    // stop early if ray hits
            };
            
            // Flight mode management functions
            function setMode(next) {
                flightState.mode = next;
                updateFlightHUD(flightState.locked, flightState.mode, flightBaseSpeed);
            }
            
            function enterHold(reason = 'manual') {
                velocity.set(0, 0, 0);
                setMode('HOLD');
                console.log(`â¸ï¸ HOLD (${reason}) - click to FREE-FLY`);
            }
            
            function enterFreeFly() {
                setMode('FREE_FLY');
                console.log('âœˆï¸ FREE-FLY - WASD/QE | Shift/Ctrl | Scroll speed | H=HOLD | R=return');
            }
            
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                // HOLD toggle (Relay-owned, separate from Esc)
                if (e.code === 'KeyH' || e.code === 'Tab') {
                    e.preventDefault();
                    if (flightState.mode === 'FREE_FLY') {
                        enterHold('hotkey');
                    } else {
                        console.log('â¸ï¸ HOLD - click canvas to FREE-FLY');
                    }
                    return;
                }
                
                // Toggle Formula Lens (FIX 3: lens-gated formula edges)
                if (e.code === 'KeyG' && currentViewMode === 'scaffold') {
                    e.preventDefault();
                    formulaLensEnabled = !formulaLensEnabled;
                    if (formulaLensEnabled) {
                        console.log('ğŸ“ Formula Lens: ENABLED - dependency edges visible');
                        renderFormulaEdges();
                    } else {
                        console.log('ğŸ“ Formula Lens: DISABLED - edges hidden');
                        formulaEdges.forEach(edge => scene.remove(edge));
                        formulaEdges.length = 0;
                    }
                    return;
                }
                
                // ğŸ“„ Focus on first sheet (DEBUG KEY)
                if (e.code === 'KeyF') {
                    e.preventDefault();
                    console.log('[Relay] ğŸ“„ F pressed - finding first sheet...');
                    
                    // Find first sheet object in scene
                    let firstSheet = null;
                    for (const obj of commitNodes) {
                        if (obj.userData?.nodeData?.type === 'sheet') {
                            firstSheet = obj;
                            break;
                        }
                    }
                    
                    if (!firstSheet) {
                        console.warn('[Relay] âš ï¸ No sheets found to focus on!');
                        console.log('[Relay] ğŸ“Š commitNodes:', commitNodes.length, 
                                    'sheets in commitNodes:', commitNodes.filter(n => n.userData?.nodeData?.type === 'sheet').length);
                        return;
                    }
                    
                    const target = firstSheet.position.clone();
                    console.log('[Relay] ğŸ¯ Focusing on sheet:', firstSheet.userData.nodeData.label, 'at', target.toArray().map(v => v.toFixed(2)));
                    
                    // Move camera to look at sheet from a good viewing angle
                    camera.position.copy(target.clone().add(new THREE.Vector3(0, 2, 6)));
                    camera.lookAt(target);
                    
                    // If in HOLD mode, set anchor to sheet position
                    if (flightState.mode === 'INSPECT' || flightState.mode === 'HOLD') {
                        anchorReturn.targetPos.copy(target);
                    }
                    
                    console.log('[Relay] âœ… Camera focused on sheet');
                    return;
                }
                
                // ğŸ“Š Scene summary (DEBUG KEY) - press I for "Info"
                if (e.code === 'KeyI') {
                    e.preventDefault();
                    console.log('[Relay] ğŸ“Š SCENE SUMMARY:');
                    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                    console.log('Total scene children:', scene?.children.length || 0);
                    console.log('commitNodes:', commitNodes.length);
                    console.log('filamentEdges:', filamentEdges.length);
                    console.log('formulaEdges:', formulaEdges.length);
                    
                    // Count by type
                    const typeCount = {};
                    commitNodes.forEach(node => {
                        const type = node.userData?.nodeData?.type || node.userData?.type || 'unknown';
                        typeCount[type] = (typeCount[type] || 0) + 1;
                    });
                    console.log('Node types:', typeCount);
                    
                    // Sheet details
                    const sheets = commitNodes.filter(n => n.userData?.nodeData?.type === 'sheet');
                    console.log('Sheets:', sheets.length);
                    sheets.forEach(sheet => {
                        const data = sheet.userData.nodeData;
                        console.log('  -', data.label, '| pos:', sheet.position.toArray().map(v => v.toFixed(2)), 
                                    '| visible:', sheet.visible, '| children:', sheet.children.length);
                    });
                    
                    // Cell anchors
                    const totalCellAnchors = Object.keys(window.cellAnchors || {}).reduce((sum, sheetId) => {
                        return sum + Object.keys(window.cellAnchors[sheetId]).length;
                    }, 0);
                    console.log('Cell anchors:', totalCellAnchors);
                    
                    // Camera info
                    console.log('Camera:', 'pos:', camera.position.toArray().map(v => v.toFixed(2)), 
                                'looking at:', camera.getWorldDirection(new THREE.Vector3()).toArray().map(v => v.toFixed(2)));
                    
                    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                    return;
                }
                
                // Anchor return (FIX 5)
                if (e.code === 'KeyR') {
                    const selected = state.selectedNode || { worldPosition: new THREE.Vector3(0, 0, 0) };
                    if (selected.worldPosition) {
                        anchorReturn.targetPos.copy(selected.worldPosition);
                    } else {
                        anchorReturn.targetPos.set(0, 0, 0); // default to origin
                    }
                    anchorReturn.active = true;
                    setMode('INSPECT');
                    console.log('ğŸ¯ Returning to anchor...');
                    return;
                }
                
                // Movement keys
                switch(e.code) {
                    case 'KeyW': 
                        moveState.forward = true; 
                        break;
                    case 'KeyS': 
                        moveState.backward = true; 
                        break;
                    case 'KeyA': 
                        moveState.left = true; 
                        break;
                    case 'KeyD': 
                        moveState.right = true; 
                        break;
                    case 'KeyQ': 
                        e.preventDefault(); // Prevent browser from capturing Q
                        moveState.down = true;
                        console.log('â¬‡ï¸ Q pressed - descending');
                        break;
                    case 'KeyE': 
                        e.preventDefault(); // Prevent browser from capturing E
                        moveState.up = true;
                        console.log('â¬†ï¸ E pressed - ascending');
                        break;
                    case 'Space': 
                        e.preventDefault(); // Prevent page scroll
                        moveState.up = true; 
                        break;
                    case 'ShiftLeft':
                    case 'ShiftRight': 
                        moveState.fast = true; 
                        break;
                    case 'ControlLeft':
                    case 'ControlRight': 
                        moveState.slow = true; 
                        break;
                }
            });
            
            document.addEventListener('keyup', (e) => {
                switch(e.code) {
                    case 'KeyW': moveState.forward = false; break;
                    case 'KeyS': moveState.backward = false; break;
                    case 'KeyA': moveState.left = false; break;
                    case 'KeyD': moveState.right = false; break;
                    case 'KeyQ': moveState.down = false; break;
                    case 'KeyE': moveState.up = false; break;
                    case 'Space': moveState.up = false; break;
                    case 'ShiftLeft':
                    case 'ShiftRight': moveState.fast = false; break;
                    case 'ControlLeft':
                    case 'ControlRight': moveState.slow = false; break;
                }
            });
            
            // Scroll changes baseSpeed (not zoom)
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -0.6 : 0.6;
                flightBaseSpeed = Math.max(0.5, Math.min(60, flightBaseSpeed + delta));
                updateFlightHUD();
                console.log(`âœˆï¸ Flight speed: ${flightBaseSpeed.toFixed(1)}`);
            }, { passive: false });
            
            // Click to lock pointer (with better logging)
            renderer.domElement.addEventListener('click', () => {
                console.log('[Relay] ğŸ–±ï¸ Canvas clicked - requesting pointer lock...');
                try {
                    controls.lock();
                    relayUI.log("Pointer lock requested", "info");
                } catch (err) {
                    console.error('[Relay] âŒ Pointer lock failed:', err);
                    relayUI.log("Pointer lock failed - try clicking canvas again", "err");
                }
            });
            
            // Pointer lock handling (Esc triggers unlock automatically - browser-owned)
            controls.addEventListener('lock', () => {
                console.log('[Relay] ğŸ”’ Pointer lock ENGAGED');
                flightState.locked = true;
                enterFreeFly();
                relayUI.log("FREE-FLY mode active (WASD to move)", "ok");
                
                // Hide click-to-fly overlay
                const overlay = document.getElementById('clickToFlyOverlay');
                if (overlay) overlay.classList.add('hidden');
            });
            
            controls.addEventListener('unlock', () => {
                console.log('[Relay] ğŸ”“ Pointer lock RELEASED');
                flightState.locked = false;
                enterHold('pointer_unlock'); // safe default
                relayUI.log("HOLD mode (click canvas to re-engage)", "info");
                
                // Show click-to-fly overlay
                const overlay = document.getElementById('clickToFlyOverlay');
                if (overlay) overlay.classList.remove('hidden');
            });
            
            // FlightHUD update function
            function updateFlightHUD(isLocked = flightState.locked, currentMode = flightState.mode, currentSpeed = flightBaseSpeed) {
                const hud = document.getElementById('flightHUD');
                const icon = document.getElementById('flightIcon');
                const modeEl = document.getElementById('flightMode');
                const speedEl = document.getElementById('flightSpeed');
                const lock = document.getElementById('flightLock');
                const help = document.getElementById('flightHelp');
                
                if (!hud) return;
                
                // Update mode and styling
                if (currentMode === 'FREE_FLY') {
                    hud.className = 'flight-hud active mode-freefly';
                    icon.textContent = 'âœˆï¸';
                    modeEl.textContent = 'FREE-FLY';
                    help.style.display = 'none';
                } else if (currentMode === 'INSPECT') {
                    hud.className = 'flight-hud active mode-inspect';
                    icon.textContent = 'ğŸ¯';
                    modeEl.textContent = 'INSPECT';
                    help.style.display = 'none';
                } else {
                    hud.className = 'flight-hud active mode-hold';
                    icon.textContent = 'â¸ï¸';
                    modeEl.textContent = 'HOLD';
                    help.style.display = 'block';
                }
                
                // Update lock status
                if (isLocked) {
                    lock.className = 'flight-hud-lock locked';
                    lock.textContent = 'ğŸ”’';
                } else {
                    lock.className = 'flight-hud-lock unlocked';
                    lock.textContent = 'ğŸ”“';
                }
                
                // Update speed
                speedEl.textContent = currentSpeed.toFixed(1);
            }
            
            // FIX 3: Pitch clamping function
            function clampPitch() {
                const yawObj = controls.getObject();
                if (!yawObj || !yawObj.children || yawObj.children.length === 0) return;
                
                const pitchObj = yawObj.children[0]; // camera is child of pitch object
                if (pitchObj && pitchObj.rotation) {
                    pitchObj.rotation.x = THREE.MathUtils.clamp(
                        pitchObj.rotation.x,
                        mouse.pitchMin,
                        mouse.pitchMax
                    );
                }
            }
            
            // FIX 5: Anchor return with collision detection
            const raycaster = new THREE.Raycaster();
            const tmpDir = new THREE.Vector3();
            
            function updateAnchorReturn(delta) {
                if (!anchorReturn.active) return;
                
                const pos = controls.getObject().position;
                const to = anchorReturn.targetPos.clone().sub(pos);
                const dist = to.length();
                
                if (dist <= anchorReturn.stopDistance) {
                    anchorReturn.active = false;
                    enterHold('anchor_arrived');
                    return;
                }
                
                // Desired glide speed (ease-out)
                const glideSpeed = Math.min(dist * 3.0, flightBaseSpeed * 2.0);
                
                // Collision check: raycast in movement direction
                tmpDir.copy(to).normalize();
                raycaster.set(pos, tmpDir);
                raycaster.far = Math.min(dist, anchorReturn.collisionBuffer + glideSpeed * delta);
                
                // Check collision with scene objects (trunk, branches, nodes)
                const hits = raycaster.intersectObjects(scene.children, true);
                
                if (hits.length > 0) {
                    anchorReturn.active = false;
                    enterHold('collision_stop');
                    setMode('INSPECT');
                    console.log('ğŸ§± Stopped early (collision).');
                    return;
                }
                
                // Move toward anchor
                pos.addScaledVector(tmpDir, glideSpeed * delta);
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PRESSURE PHYSICS: Camera resistance near high-pressure rings
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function calculatePressureInfluence(cameraPos) {
                if (!state.tree || !state.tree.nodes) return 0;
                
                let maxPressure = 0;
                const influenceRadius = 8.0;  // Pressure felt within 8 units
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // TURGOR STIFFNESS: Include branch operational load in pressure
                // High turgor = branches resist camera motion more strongly
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                // Check all nodes with pressure rings
                state.tree.nodes.forEach(node => {
                    const nodePos = new THREE.Vector3(
                        node.position.x,
                        node.position.y,
                        node.position.z
                    );
                    
                    const distance = cameraPos.distanceTo(nodePos);
                    
                    if (distance < influenceRadius) {
                        // Base pressure from rings
                        let nodePressure = 0;
                        if (node.pressureRings && node.pressureRings.length > 0) {
                            nodePressure = node.pressureRings.reduce((sum, ring) => 
                                sum + (ring.pressure || 0), 0) / node.pressureRings.length;
                        }
                        
                        // TURGOR AMPLIFICATION: Branch stiffness from unresolved work
                        const branchMetrics = state.branches?.[node.branchId] || {};
                        const unresolvedCount = branchMetrics.drift_count || 0;
                        const totalCells = branchMetrics.cell_count || 1;
                        const turgorPressure = Math.min(unresolvedCount / Math.max(totalCells * 0.1, 1), 1.0);
                        
                        // Combined pressure: timebox pressure + turgor stiffness
                        const combinedPressure = Math.max(nodePressure, turgorPressure * 0.8);
                        
                        // Falloff: closer = stronger influence
                        const falloff = 1 - (distance / influenceRadius);
                        const influence = combinedPressure * falloff;
                        
                        maxPressure = Math.max(maxPressure, influence);
                    }
                });
                
                return maxPressure;  // 0.0 (no pressure) to 1.0 (max pressure + turgor)
            }
            
            // Movement update function (canonical physics: acceleration + damping)
            window.updateFlight = (delta) => {
                // HOLD mode: damp velocity to zero
                if (flightState.mode === 'HOLD') {
                    velocity.multiplyScalar(Math.exp(-damping * delta));
                    return;
                }
                
                // Anchor return (INSPECT mode)
                if (flightState.mode === 'INSPECT') {
                    updateAnchorReturn(delta);
                    return;
                }
                
                // FREE-FLY mode: only if pointer locked
                if (!flightState.locked) return;
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // PRESSURE RESISTANCE: Movement feels heavier near high-pressure
                // CANONICAL: 5-10x amplification (pressure must HURT)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                const pressureLevel = calculatePressureInfluence(camera.position);
                // AMPLIFIED: Pressure creates strong resistance
                const pressureDampingMult = 1 + (pressureLevel * 12.0);  // 1x to 13x damping (STRONG)
                const pressureAccelMult = 1 / (1 + pressureLevel * 7.0);  // 1x to 0.125x accel (VERY SLOW)
                
                // Update pressure display in HUD
                const pressureEl = document.getElementById('flightPressure');
                if (pressureEl) {
                    const pressurePct = Math.round(pressureLevel * 100);
                    pressureEl.textContent = `${pressurePct}%`;
                    // Color feedback: green (low) â†’ yellow (medium) â†’ red (high)
                    if (pressurePct > 70) {
                        pressureEl.style.color = '#ff4444';
                    } else if (pressurePct > 40) {
                        pressureEl.style.color = '#ffaa00';
                    } else {
                        pressureEl.style.color = '#00ff88';
                    }
                }
                
                // Speed modifiers
                let speed = flightBaseSpeed;
                if (moveState.fast) speed *= fastMult;
                if (moveState.slow) speed *= slowMult;
                
                // Wish direction in local camera space
                wishDirection.set(0, 0, 0);
                if (moveState.forward) wishDirection.z += 1;   // Forward in camera space
                if (moveState.backward) wishDirection.z -= 1;  // Backward in camera space
                if (moveState.left) wishDirection.x -= 1;
                if (moveState.right) wishDirection.x += 1;
                if (moveState.up) wishDirection.y += 1;
                if (moveState.down) wishDirection.y -= 1;
                
                if (wishDirection.lengthSq() > 0) wishDirection.normalize();
                
                // Convert to world direction (camera-relative, MODE A: world-up)
                const forward = new THREE.Vector3();
                controls.getDirection(forward);  // forward in world space
                const right = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
                const up = new THREE.Vector3().copy(camera.up);  // world up (no roll)
                
                const desired = new THREE.Vector3()
                    .addScaledVector(right, wishDirection.x)              // strafe
                    .addScaledVector(up, wishDirection.y * verticalSpeedMult)  // vertical (world-space)
                    .addScaledVector(forward, wishDirection.z)            // forward/back
                    .normalize()
                    .multiplyScalar(speed);
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // PRESSURE PHYSICS APPLIED: Acceleration and damping modified
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Accelerate toward desired velocity (smooth lerp, slowed by pressure)
                velocity.lerp(desired, (1 - Math.exp(-accel * delta)) * pressureAccelMult);
                
                // Damping when no input (soft stop, amplified by pressure)
                if (wishDirection.lengthSq() === 0) {
                    velocity.multiplyScalar(Math.exp(-damping * pressureDampingMult * delta));
                }
                
                // Apply velocity to camera position (direct world-space movement)
                // Since velocity is already in world space, apply it directly
                camera.position.addScaledVector(velocity, delta);
            };
            
            // Render commits as 3D filament (after test sphere)
            render3DFilament();
            
            // STEP 5: Start animation loop
            animate3D();
            
            // Window resize handler
            window.addEventListener('resize', onWindowResize);
            
            console.log('âœ… 3D View Initialized - RTS-Freeflight controls ready (Mode A: world-up)');
            console.log('ğŸ® CONTROLS: Click canvas to lock â†’ WASD: move | Q/E: vertical | Shift: fast | Ctrl: slow | Scroll: speed | H: HOLD | R: return | ESC: unlock');
        }

        function renderSheetVolume() {
            // Clear existing nodes/edges
            commitNodes.forEach(node => scene.remove(node));
            filamentEdges.forEach(edge => scene.remove(edge));
            commitNodes = [];
            filamentEdges = [];
            
            if (state.data.length === 0) return;
            
            // Sheet Volume Mapping:
            // X = column index (normalized to -10 to +10)
            // Z = row index (normalized to -10 to +10)
            // Y = time/depth (0 = surface/now, negative = history)
            
            const maxCols = state.data[0].length;
            const maxRows = state.data.length;
            const cellSpacing = 0.8;
            
            // Render each cell as a positioned box in 3D space
            state.data.forEach((row, rowIndex) => {
                row.forEach((cellData, colIndex) => {
                    // Position mapping
                    const x = (colIndex - maxCols / 2) * cellSpacing;
                    const z = (rowIndex - maxRows / 2) * cellSpacing;
                    const y = 0; // Surface level (current state)
                    
                    // Create cell cube
                    const geometry = new THREE.BoxGeometry(0.6, 0.3, 0.6);
                    
                    // Color by ERI
                    let color;
                    if (cellData.eri >= 80) color = 0x00ff88; // High ERI = green
                    else if (cellData.eri >= 50) color = 0xffaa00; // Medium = yellow
                    else color = 0xff4444; // Low = red
                    
                    const material = new THREE.MeshPhongMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.2,
                        shininess: 50,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const cube = new THREE.Mesh(geometry, material);
                    cube.position.set(x, y, z);
                    cube.userData = { 
                        row: rowIndex, 
                        col: colIndex, 
                        cell: cellData,
                        type: 'cell'
                    };
                    
                    scene.add(cube);
                    commitNodes.push(cube);
                    
                    // Add commit history as stacked boxes below (Y-axis depth)
                    const cellCommits = state.commits.filter(c => 
                        c.reality?.row === rowIndex || c.type === 'IMPORT'
                    );
                    
                    cellCommits.forEach((commit, commitIndex) => {
                        if (commitIndex > 0) { // Skip surface (already rendered)
                            const historyY = -(commitIndex * 0.5); // Stack downward
                            
                            const histGeom = new THREE.BoxGeometry(0.5, 0.2, 0.5);
                            const histMat = new THREE.MeshPhongMaterial({
                                color: 0x88aaff,
                                emissive: 0x88aaff,
                                emissiveIntensity: 0.1,
                                transparent: true,
                                opacity: 0.4
                            });
                            
                            const histCube = new THREE.Mesh(histGeom, histMat);
                            histCube.position.set(x, historyY, z);
                            histCube.userData = { commit: commit, type: 'history' };
                            
                            scene.add(histCube);
                            commitNodes.push(histCube);
                        }
                    });
                });
            });
            
            // Add axis labels
            const axisLabel = (text, pos) => {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                context.fillStyle = '#00ff88';
                context.font = '32px Arial';
                context.fillText(text, 10, 40);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.copy(pos);
                sprite.scale.set(2, 0.5, 1);
                scene.add(sprite);
            };
            
            axisLabel('COLUMNS â†’', new THREE.Vector3(maxCols * cellSpacing / 2 + 2, 0, 0));
            axisLabel('ROWS â†’', new THREE.Vector3(0, 0, maxRows * cellSpacing / 2 + 2));
            axisLabel('â†“ HISTORY', new THREE.Vector3(0, -5, 0));
            
            console.log(`Rendered Sheet Volume: ${maxCols} cols Ã— ${maxRows} rows`);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CANONICAL TIMEBOX GENERATION (Data-Driven from Commits)
        // Timeboxes = discrete commit buckets (not continuous decoration)
        // These are "material slices of history" with timestamps, state, and boundaries
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function generateTimeboxesFromCommits(commits, bucketsPerSegment = 5) {
            // ğŸ”’ DEFENSIVE: Filter out null/undefined, fail-soft
            const safe = (commits || []).filter(Boolean);
            
            if (safe.length === 0) {
                console.log('[Relay] â° No valid commits â†’ 0 timeboxes (fail-soft)');
                return [];
            }
            
            const timeboxes = [];
            const commitsPerBox = Math.max(1, Math.floor(safe.length / bucketsPerSegment));
            
            // Base timestamp (fallback for commits without timestamps)
            const baseTime = Date.now() - (safe.length * 60000); // Assume 1min per commit
            
            // ğŸ”’ DEFENSIVE: Normalize timestamps (prevent undefined crashes)
            safe.forEach((c, i) => {
                if (c.timestamp_ms == null) {
                    c.timestamp_ms = baseTime + (i * 60000);
                }
            });
            
            for (let i = 0; i < safe.length; i += commitsPerBox) {
                const bucket = safe.slice(i, Math.min(i + commitsPerBox, safe.length));
                
                // Aggregate metrics from bucket
                const commitCount = bucket.length;
                const eriValues = bucket.map(c => {
                    // Extract ERI from commit payload if available
                    if (c.payload?.eri) return c.payload.eri;
                    if (c.payload?.cell?.eri) return c.payload.cell.eri;
                    return 75; // default
                });
                const eriAvg = eriValues.reduce((a, b) => a + b, 0) / eriValues.length;
                
                // Count drifts (commits with drift indicators)
                const openDrifts = bucket.filter(c => 
                    c.type === 'DRIFT_DETECTION' || c.payload?.drift
                ).length;
                
                // Count scars (REFUSAL commits)
                const scarCount = bucket.filter(c => c.type === 'REFUSAL').length;
                
                // Determine state transitions within this timebox
                const hasStateChanges = bucket.some(c => 
                    c.type === 'STATE_TRANSITION' || 
                    c.type === 'COMMIT' || 
                    c.type === 'PROPOSE'
                );
                
                // Calculate time range (safe - timestamps now guaranteed)
                const startCommit = bucket[0];
                const endCommit = bucket[bucket.length - 1];
                const startTime = startCommit.timestamp_ms;
                const endTime = endCommit.timestamp_ms;
                
                // Format time range for display
                const startDate = new Date(startTime);
                const endDate = new Date(endTime);
                const timeRange = `${startDate.getHours().toString().padStart(2, '0')}:${startDate.getMinutes().toString().padStart(2, '0')}â€“${endDate.getHours().toString().padStart(2, '0')}:${endDate.getMinutes().toString().padStart(2, '0')}`;
                
                // Determine boundary type (material vs. continuous)
                const boundaryType = hasStateChanges ? 'MATERIAL_BOUNDARY' : 'CONTINUOUS';
                
                timeboxes.push({
                    timeboxId: `T${i}-${i + commitsPerBox}`,
                    commitRange: [i, Math.min(i + commitsPerBox, commits.length)],
                    commitCount,
                    openDrifts,
                    eriAvg: Math.round(eriAvg),
                    scarCount,
                    startTime,
                    endTime,
                    timeRange,
                    boundaryType,
                    hasStateChanges,
                    metadata: {
                        policy_ref: 'timebox_generation_v1',
                        confidence: eriAvg,
                        bucket_size: commitsPerBox,
                        start_commit_id: startCommit.commit_id || `commit_${i}`,
                        end_commit_id: endCommit.commit_id || `commit_${i + commitCount - 1}`
                    }
                });
            }
            
            return timeboxes;
        }
        
        function renderRingStackBetween(parentNode, childNode, nodeObjects) {
            // Generate timeboxes from actual commits (data-driven)
            let timeboxes = parentNode.pressureRings || [];
            
            // If commits available, generate from commit data
            if (state.commits && state.commits.length > 0) {
                timeboxes = generateTimeboxesFromCommits(state.commits, 5);
            }
            
            if (timeboxes.length === 0) return;
            
            const startPos = parentNode.position;
            const endPos = childNode.position;
            const segmentLength = Math.sqrt(
                Math.pow(endPos.x - startPos.x, 2) +
                Math.pow(endPos.y - startPos.y, 2) +
                Math.pow(endPos.z - startPos.z, 2)
            );
            
            // Stack timeboxes along this trunk segment
            timeboxes.forEach((timebox, index) => {
                // Position along segment (interpolate between parent and child)
                const t = (index + 1) / (timeboxes.length + 1);
                const midX = startPos.x + (endPos.x - startPos.x) * t;
                const midY = startPos.y + (endPos.y - startPos.y) * t;
                const midZ = startPos.z + (endPos.z - startPos.z) * t;
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // TIMEBOX SIZING: Must fit WITHIN branch diameter (embedded)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Get trunk radius at this point (from parent node type)
                const trunkRadiusKey = `${parentNode.type}-${childNode.type}`;
                const trunkRadii = {
                    'root-branch': 0.65,
                    'branch-department': 0.45,
                    'department-sheet': 0.28
                };
                const localTrunkRadius = trunkRadii[trunkRadiusKey] || 0.4;
                
                // Timebox radius: 75% of trunk (fully embedded, visible margin)
                const baseRadius = localTrunkRadius * 0.75;  // Reduced from 0.85 to 0.75
                
                // Thickness: proportional to commit density
                let thickness = 0.12 + (timebox.commitCount / 100) * 0.08;
                
                // Material boundaries are thicker (more visible, more important)
                if (timebox.boundaryType === 'MATERIAL_BOUNDARY') {
                    thickness *= 1.5;
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // CANONICAL TIMEBOXES (Material Slices of History)
                // NOT decorative rings - these are BLOCKS with visible faces
                // Front face, back face, side wall = readable as "time slices"
                // Embedded in branch, slightly wider than trunk
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                // Create puck geometry (disc with visible faces)
                const geometry = new THREE.CylinderGeometry(
                    baseRadius,       // top radius
                    baseRadius,       // bottom radius
                    thickness,        // height (puck thickness)
                    32,               // radial segments (smooth)
                    1,                // height segments
                    false             // NOT open-ended (has caps/faces)
                );
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // FUTURISTIC LIGHT BLUE COLOR SCHEME (Sci-Fi Tech Aesthetic)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                let timeboxColor, emissiveIntensity, opacity;
                const confidence = timebox.metadata?.confidence || 75;
                
                // CANONICAL: Timeboxes as CUTTING PLANES (hard boundaries)
                if (confidence >= 80) {
                    // VERIFIED - bright cyan cutting plane
                    timeboxColor = 0x00FFEE;  // Bright cyan
                    emissiveIntensity = 0.8;
                    opacity = 0.9;  // Nearly opaque (hard boundary)
                } else if (confidence >= 60) {
                    // DEGRADED - medium blue (caution boundary)
                    timeboxColor = 0x0088FF;  // Medium blue
                    emissiveIntensity = 0.6;
                    opacity = 0.8;
                } else {
                    // INDETERMINATE - dim blue (uncertain boundary)
                    timeboxColor = 0x5566CC;  // Dim blue
                    emissiveIntensity = 0.4;
                    opacity = 0.6;
                }
                
                // If timebox has scars (refusals), add red alert tint
                if (timebox.scarCount > 0) {
                    timeboxColor = 0xFF0066; // Bright magenta-red (BLOCKED)
                    emissiveIntensity = 1.2;
                    opacity = 1.0;  // Completely opaque (cannot pass)
                }
                
                // Material boundaries are BRIGHTEST (irreversible gates)
                if (timebox.boundaryType === 'MATERIAL_BOUNDARY') {
                    timeboxColor = 0x00FFFF; // Pure cyan (critical boundary)
                    emissiveIntensity = 1.0;
                    opacity = 1.0;  // Solid wall
                }
                
                const material = new THREE.MeshStandardMaterial({
                    color: timeboxColor,
                    emissive: timeboxColor,
                    emissiveIntensity: emissiveIntensity,
                    roughness: 0.1,          // Smooth cutting plane
                    metalness: 0.3,          // Slight metallic sheen
                    transparent: opacity < 1.0,
                    opacity: opacity,
                    side: THREE.DoubleSide,  // Visible from both sides
                    depthWrite: true,        // Hard boundary (blocks view)
                    depthTest: true,
                    blending: THREE.AdditiveBlending  // Glowing effect
                });
                
                const timeboxMesh = new THREE.Mesh(geometry, material);
                timeboxMesh.position.set(midX, midY, midZ);
                
                // Align timebox perpendicular to trunk segment
                const segmentDir = new THREE.Vector3(
                    endPos.x - startPos.x,
                    endPos.y - startPos.y,
                    endPos.z - startPos.z
                ).normalize();
                
                // Rotate timebox to be perpendicular to trunk
                const upAxis = new THREE.Vector3(0, 1, 0);
                const rotAxis = new THREE.Vector3().crossVectors(upAxis, segmentDir);
                if (rotAxis.lengthSq() > 0.001) {
                    const angle = Math.acos(upAxis.dot(segmentDir));
                    timeboxMesh.setRotationFromAxisAngle(rotAxis.normalize(), angle);
                }
                
                // Store full timebox data for interaction
                timeboxMesh.userData = { 
                    timebox: timebox,  // Full timebox object (includes timeRange, boundaryType, etc.)
                    type: 'timebox',  // Changed from 'pressureRing' to 'timebox'
                    nodeId: parentNode.id,
                    commitRange: timebox.commitRange || [0, 0],
                    commitCount: timebox.commitCount,
                    confidence: confidence,
                    scarCount: timebox.scarCount || 0,
                    driftCount: timebox.openDrifts || 0,
                    timeboxId: timebox.timeboxId,
                    timeRange: timebox.timeRange,
                    boundaryType: timebox.boundaryType,
                    startTime: timebox.startTime,
                    endTime: timebox.endTime,
                    metadata: timebox.metadata || {}
                };
                
                timeboxMesh.castShadow = true;
                timeboxMesh.receiveShadow = true;
                
                scene.add(timeboxMesh);
                commitNodes.push(timeboxMesh);
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // SCARS: REFUSAL commits interrupt geometry (not just marks)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if (timebox.scarCount > 0) {
                    for (let s = 0; s < timebox.scarCount; s++) {
                        const angle = (s / timebox.scarCount) * Math.PI * 2;
                        const scarX = midX + Math.cos(angle) * (baseRadius + 0.15);
                        const scarY = midY;
                        const scarZ = midZ + Math.sin(angle) * (baseRadius + 0.15);
                        
                        // 1) SCAR MARKER: Jagged wood damage (organic wound)
                        const scarGeom = new THREE.OctahedronGeometry(0.18, 0);
                        const scarMat = new THREE.MeshStandardMaterial({ 
                            color: 0x3A2418,       // Dark burnt wood (charred/damaged)
                            emissive: 0x8B0000,    // Dark red glow (infection/rot)
                            emissiveIntensity: 0.3,  // Subtle organic glow
                            roughness: 0.95,       // Very rough damaged surface
                            metalness: 0.0         // No metallic (organic damage)
                        });
                        const scarMarker = new THREE.Mesh(scarGeom, scarMat);
                        scarMarker.position.set(scarX, scarY, scarZ);
                        scarMarker.rotation.set(
                            Math.random() * Math.PI,
                            Math.random() * Math.PI,
                            Math.random() * Math.PI
                        ); // Random jagged orientation
                        scene.add(scarMarker);
                        commitNodes.push(scarMarker);
                        
                        // 2) FRACTURE LINE: Extends down trunk from scar
                        const fractureLength = 1.5;  // Length of crack
                        const fractureStart = new THREE.Vector3(scarX, scarY, scarZ);
                        const fractureEnd = new THREE.Vector3(
                            midX + Math.cos(angle) * (baseRadius * 0.5),  // Pull toward trunk
                            midY - fractureLength,  // Extend downward
                            midZ + Math.sin(angle) * (baseRadius * 0.5)
                        );
                        
                        const fractureGeom = new THREE.BufferGeometry().setFromPoints([
                            fractureStart, fractureEnd
                        ]);
                        const fractureMat = new THREE.LineBasicMaterial({ 
                            color: 0xFF0088,  // Bright magenta crack (futuristic alert)
                            opacity: 0.8,
                            transparent: true,
                            linewidth: 3
                        });
                        const fractureLine = new THREE.Line(fractureGeom, fractureMat);
                        scene.add(fractureLine);
                        commitNodes.push(fractureLine);
                    }
                }
            });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PROCEDURAL BARK TEXTURE - Realistic organic wood surface
        // Natural bark colors with weathered, gnarled texture
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function createBarkTexture(width = 1024, height = 1024) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            // REALISTIC BARK COLORS (natural browns, grays)
            const baseColor = { r: 60, g: 45, b: 35 };          // Dark brown base
            const midColor = { r: 100, g: 75, b: 55 };          // Medium brown
            const highlightColor = { r: 140, g: 110, b: 85 };   // Light weathered brown
            
            // Perlin-like noise function for organic patterns
            function noise2D(x, y, scale) {
                return (Math.sin(x / scale) + Math.cos(y / scale) + Math.sin((x + y) / scale)) / 3;
            }
            
            // Fill with layered organic texture
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    // Multiple octaves of noise for detail
                    const largeNoise = noise2D(x, y, 50) * 30;
                    const mediumNoise = noise2D(x * 2, y * 2, 25) * 20;
                    const fineNoise = (Math.random() - 0.5) * 25;
                    
                    // Vertical grain (stronger)
                    const verticalGrain = Math.sin(y / 20 + noise2D(x, y, 100) * 5) * 20;
                    
                    // Bark ridges (horizontal cracks)
                    const ridges = Math.abs(Math.sin(y / 15 + noise2D(x, y, 60) * 3)) * 30;
                    
                    // Knots and blemishes (darker spots)
                    const knots = Math.max(0, -noise2D(x * 3, y * 3, 80)) * 40;
                    
                    // Combine layers
                    const totalNoise = largeNoise + mediumNoise + fineNoise + verticalGrain - knots;
                    const totalRidges = ridges;
                    
                    // Mix colors based on ridge/valley
                    let r, g, b;
                    if (totalRidges > 15) {
                        // Highlight (raised bark)
                        r = highlightColor.r + totalNoise;
                        g = highlightColor.g + totalNoise * 0.8;
                        b = highlightColor.b + totalNoise * 0.6;
                    } else if (totalRidges < 8) {
                        // Shadow (deep crevices)
                        r = baseColor.r + totalNoise * 0.5;
                        g = baseColor.g + totalNoise * 0.4;
                        b = baseColor.b + totalNoise * 0.3;
                    } else {
                        // Mid-tone (general bark)
                        r = midColor.r + totalNoise * 0.7;
                        g = midColor.g + totalNoise * 0.6;
                        b = midColor.b + totalNoise * 0.5;
                    }
                    
                    r = Math.max(0, Math.min(255, r));
                    g = Math.max(0, Math.min(255, g));
                    b = Math.max(0, Math.min(255, b));
                    
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(x, y, 1, 1);
                }
            }
            
            // Add deep cracks/fissures (darker, more organic)
            ctx.strokeStyle = 'rgba(25, 20, 15, 0.8)';
            ctx.lineWidth = 3;
            for (let i = 0; i < 40; i++) {
                ctx.beginPath();
                const startX = Math.random() * width;
                const startY = Math.random() * height;
                ctx.moveTo(startX, startY);
                
                // Wandering crack path (more organic)
                let currentX = startX;
                let currentY = startY;
                const segments = 5 + Math.floor(Math.random() * 10);
                for (let j = 0; j < segments; j++) {
                    currentX += (Math.random() - 0.5) * 60;
                    currentY += (Math.random() - 0.5) * 60;
                    ctx.lineTo(currentX, currentY);
                }
                ctx.stroke();
            }
            
            // Add smaller surface details (fine cracks)
            ctx.strokeStyle = 'rgba(35, 30, 25, 0.4)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 80; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random() * width, Math.random() * height);
                ctx.lineTo(
                    Math.random() * width,
                    Math.random() * height
                );
                ctx.stroke();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, 3);  // Less repetition for larger detail
            texture.anisotropy = 16;  // Better quality at angles
            
            return texture;
        }
        
        // Generate bark texture once (reuse for all branches)
        let barkTexture = null;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸŒ PHASE 2: GLOBE SYSTEM - Unified Spatial Foundation
        // Per RELAY-FINAL-ARCHITECTURE-SPEC.md Lock 1 & 2
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        /**
         * Convert lat/lon to 3D Cartesian coordinates (ECEF)
         * @param {number} lat - Latitude in degrees
         * @param {number} lon - Longitude in degrees
         * @param {number} radius - Globe radius
         * @returns {THREE.Vector3} 3D position on sphere surface
         */
        function latLonToVec3(lat, lon, radius = globeRadius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);
            
            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const z = (radius * Math.sin(phi) * Math.sin(theta));
            const y = (radius * Math.cos(phi));
            
            return new THREE.Vector3(x, y, z);
        }
        
        /**
         * Create Globe mesh (Earth sphere) - spatial truth layer
         * Shows all company locations, boundaries, and reality anchors
         */
        function createGlobeMesh() {
            if (globeMesh) {
                console.log('[Relay] ğŸŒ Globe already exists');
                return globeMesh;
            }
            
            console.log('[Relay] ğŸŒ Creating Globe mesh...');
            
            // ğŸ”’ CANONICAL: Earth globe with proper Earth colors (textured look)
            const geometry = new THREE.SphereGeometry(globeRadius, 96, 96);  // Higher resolution
            
            // Try to load Earth texture (will fail on file://, but works on localhost)
            const textureLoader = new THREE.TextureLoader();
            let earthTexture = null;
            try {
                // Standard Earth day texture path (user should add 8k_earth_daymap.jpg)
                earthTexture = textureLoader.load('textures/8k_earth_daymap.jpg', 
                    () => console.log('[Relay] âœ… Earth texture loaded'),
                    undefined,
                    (err) => console.log('[Relay] â„¹ï¸ Earth texture not available (using procedural colors)')
                );
            } catch(e) {
                console.log('[Relay] â„¹ï¸ Earth texture not available (using procedural colors)');
            }
            
            const material = new THREE.MeshStandardMaterial({
                map: earthTexture,      // Earth day texture (if available)
                color: earthTexture ? 0xffffff : 0x2a5f7f,  // If no texture: ocean blue-green
                roughness: 0.85,        // Slightly rough (land/water variation)
                metalness: 0.05,        // Very slight metallic (water specular)
                transparent: true,
                opacity: 0,  // ğŸ”’ PHASE 2A: Start invisible, fade in gradually
                side: THREE.DoubleSide,
                wireframe: false
            });
            
            globeMesh = new THREE.Mesh(geometry, material);
            globeMesh.userData = { 
                type: 'globe', 
                layer: 'spatial_truth',
                targetOpacity: 0.85  // Target opacity for fade-in
            };
            globeMesh.position.set(0, 0, 0);  // Origin = Earth center
            
            // Add wireframe overlay (latitude/longitude grid)
            const wireGeometry = new THREE.SphereGeometry(globeRadius + 0.01, 32, 32);
            const wireMaterial = new THREE.LineBasicMaterial({
                color: 0x4488cc,
                transparent: true,
                opacity: 0  // ğŸ”’ PHASE 2A: Start invisible
            });
            const wireframe = new THREE.WireframeGeometry(wireGeometry);
            const wireMesh = new THREE.LineSegments(wireframe, wireMaterial);
            wireMesh.userData = { 
                type: 'globe_grid',
                targetOpacity: 0.3  // Target opacity for fade-in
            };
            globeMesh.add(wireMesh);
            
            scene.add(globeMesh);
            
            // ğŸ”’ PHASE 2A: Fade in gradually (not instant pop)
            fadeInGlobe();
            console.log('[Relay] âœ… Globe mesh created and added to scene');
            
            return globeMesh;
        }
        
        /**
         * ğŸ”’ PHASE 2A: Fade in Globe gradually (not instant pop)
         * Animates opacity from 0 to target over 1 second
         */
        function fadeInGlobe() {
            if (!globeMesh) return;
            
            const duration = 1000;  // 1 second
            const startTime = Date.now();
            const targetOpacity = globeMesh.userData.targetOpacity || 0.85;
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const t = Math.min(elapsed / duration, 1);
                
                // Ease in-out
                const ease = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                
                // Fade in globe mesh
                if (globeMesh.material) {
                    globeMesh.material.opacity = targetOpacity * ease;
                }
                
                // Also fade in wireframe grid
                const wire = globeMesh.children.find(c => c.userData.type === 'globe_grid');
                if (wire && wire.material) {
                    const wireTarget = wire.userData.targetOpacity || 0.3;
                    wire.material.opacity = wireTarget * ease;
                }
                
                if (t < 1) {
                    requestAnimationFrame(animate);
                } else {
                    console.log('[Relay] âœ… Globe fade-in complete');
                }
            }
            
            animate();
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 2B: BOUNDARY LOADING & RENDERING (Stage-Gated)
        // Local region only (Israel for Tel Aviv anchor)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        let boundaryMesh = null;  // Global reference for stage-gated reveal
        
        /**
         * ğŸ”’ PHASE 2B: Load and render ONE local boundary region
         * Stage-gated: only loads at Stage â‰¥2
         * @param {number} lat - Anchor latitude (for clipping region)
         * @param {number} lon - Anchor longitude
         * @param {string} boundaryFile - Path to GeoJSON file (default: Israel)
         */
        async function loadLocalBoundary(lat, lon, boundaryFile = 'data/boundaries/countries/ISR-ADM0.geojson') {
            console.log('[Relay] ğŸ—ºï¸ Loading local boundary:', boundaryFile);
            
            try {
                const response = await fetch(boundaryFile);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const geojson = await response.json();
                console.log('[Relay] âœ… GeoJSON loaded:', geojson.features.length, 'features');
                
                // ğŸ”’ CRITICAL: Only load the polygon containing the anchor (no full world rendering)
                const localFeature = findContainingFeature(geojson, lat, lon) || geojson.features[0];
                
                if (!localFeature) {
                    console.warn('[Relay] âš ï¸ No boundary polygon found for anchor');
                    return null;
                }
                
                // Extrude boundary mesh
                boundaryMesh = createBoundaryMesh(localFeature, globeRadius);
                
                if (boundaryMesh) {
                    scene.add(boundaryMesh);
                    console.log('[Relay] âœ… Boundary mesh added (Stage â‰¥2 reveal)');
                    
                    // Start hidden (stage-gated visibility)
                    boundaryMesh.visible = false;
                    boundaryMesh.userData = { 
                        type: 'boundary', 
                        stageLevel: 2,  // Requires Stage 2+
                        feature: localFeature 
                    };
                }
                
                return boundaryMesh;
                
            } catch (error) {
                console.error('[Relay] âŒ Boundary load failed:', error);
                return null;
            }
        }
        
        /**
         * Find GeoJSON feature that contains the given lat/lon point
         * Uses simple point-in-polygon check
         */
        function findContainingFeature(geojson, lat, lon) {
            for (const feature of geojson.features) {
                if (feature.geometry.type === 'Polygon') {
                    if (pointInPolygon([lon, lat], feature.geometry.coordinates[0])) {
                        return feature;
                    }
                } else if (feature.geometry.type === 'MultiPolygon') {
                    for (const polygon of feature.geometry.coordinates) {
                        if (pointInPolygon([lon, lat], polygon[0])) {
                            return feature;
                        }
                    }
                }
            }
            return null;
        }
        
        /**
         * Simple point-in-polygon check (ray casting algorithm)
         * @param {Array} point - [lon, lat]
         * @param {Array} polygon - Array of [lon, lat] coordinates
         */
        function pointInPolygon(point, polygon) {
            const [x, y] = point;
            let inside = false;
            
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const [xi, yi] = polygon[i];
                const [xj, yj] = polygon[j];
                
                const intersect = ((yi > y) !== (yj > y)) &&
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    
                if (intersect) inside = !inside;
            }
            
            return inside;
        }
        
        /**
         * Create extruded 3D boundary mesh from GeoJSON feature
         * Uses earcut for triangulation, extrudes above Globe surface
         * @param {Object} feature - GeoJSON feature (Polygon or MultiPolygon)
         * @param {number} radius - Globe radius
         * @returns {THREE.Group} Boundary mesh (outline + fill)
         */
        function createBoundaryMesh(feature, radius) {
            const group = new THREE.Group();
            group.userData = { type: 'boundary_group', featureId: feature.id };
            
            const extrudeHeight = 0.05;  // Slight extrusion above Globe surface
            const geometry = feature.geometry;
            
            if (geometry.type === 'Polygon') {
                const mesh = createPolygonMesh(geometry.coordinates, radius, extrudeHeight);
                if (mesh) group.add(mesh);
            } else if (geometry.type === 'MultiPolygon') {
                for (const polygon of geometry.coordinates) {
                    const mesh = createPolygonMesh(polygon, radius, extrudeHeight);
                    if (mesh) group.add(mesh);
                }
            }
            
            return group.children.length > 0 ? group : null;
        }
        
        /**
         * Create extruded polygon mesh with outline + fill
         * @param {Array} coordinates - Polygon coordinates (outer ring + holes)
         * @param {number} radius - Globe radius
         * @param {number} height - Extrusion height
         */
        function createPolygonMesh(coordinates, radius, height) {
            const outerRing = coordinates[0];  // First array is outer boundary
            if (!outerRing || outerRing.length < 3) return null;
            
            // Convert lat/lon to 3D points on Globe surface
            const vertices = [];
            const vertices2D = [];  // For earcut triangulation
            
            for (const [lon, lat] of outerRing) {
                // Convert to radians
                const phi = (90 - lat) * (Math.PI / 180);
                const theta = (lon + 180) * (Math.PI / 180);
                
                // Spherical to Cartesian (on surface + extrusion)
                const r = radius + height;
                const x = -r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.cos(phi);
                const z = r * Math.sin(phi) * Math.sin(theta);
                
                vertices.push(new THREE.Vector3(x, y, z));
                vertices2D.push(lon, lat);  // For triangulation
            }
            
            // Triangulate using earcut
            const triangles = earcut(vertices2D, null, 2);
            
            // Create fill mesh
            const fillGeometry = new THREE.BufferGeometry();
            const positions = [];
            
            for (let i = 0; i < triangles.length; i++) {
                const v = vertices[triangles[i]];
                positions.push(v.x, v.y, v.z);
            }
            
            fillGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            fillGeometry.computeVertexNormals();
            
            const fillMaterial = new THREE.MeshBasicMaterial({
                color: 0x00aaff,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            const fillMesh = new THREE.Mesh(fillGeometry, fillMaterial);
            fillMesh.userData = { type: 'boundary_fill' };
            
            // Create outline
            const outlineGeometry = new THREE.BufferGeometry();
            const outlinePositions = [];
            
            for (let i = 0; i < vertices.length; i++) {
                const v = vertices[i];
                outlinePositions.push(v.x, v.y, v.z);
            }
            
            outlineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(outlinePositions, 3));
            
            const outlineMaterial = new THREE.LineBasicMaterial({
                color: 0x00ddff,
                linewidth: 2,
                transparent: true,
                opacity: 0.7
            });
            
            const outlineMesh = new THREE.LineLoop(outlineGeometry, outlineMaterial);
            outlineMesh.userData = { type: 'boundary_outline' };
            
            // Combine fill + outline
            const group = new THREE.Group();
            group.add(fillMesh);
            group.add(outlineMesh);
            
            return group;
        }
        
        /**
         * ğŸ”’ PHASE 2B: Update boundary visibility based on stage + camera altitude
         * Stage-gated reveal: only visible at Stage â‰¥2 AND zoomed out
         */
        function updateBoundaryVisibility() {
            if (!boundaryMesh) return;
            
            // ğŸ”’ Stage gate (prototype assumes Stage 2 - company level)
            const stageLevel = 2;  // TODO: Make dynamic based on user progress
            const minStage = boundaryMesh.userData.stageLevel || 2;
            
            if (stageLevel < minStage) {
                boundaryMesh.visible = false;
                return;
            }
            
            // ğŸ”’ Altitude/distance gate (reveal on zoom out)
            const cameraDistance = camera.position.length();
            const zoomOutThreshold = globeRadius * 1.8;  // ~18 units from origin
            
            // Fade in boundary as camera zooms out
            const shouldBeVisible = cameraDistance > zoomOutThreshold;
            
            if (shouldBeVisible !== boundaryMesh.visible) {
                boundaryMesh.visible = shouldBeVisible;
                console.log('[Relay] ğŸ—ºï¸ Boundary', shouldBeVisible ? 'revealed' : 'hidden', 
                           `(camera: ${cameraDistance.toFixed(1)}, threshold: ${zoomOutThreshold.toFixed(1)})`);
            }
        }
        
        /**
         * Anchor company tree at specific lat/lon location
         * @param {string} companyId - Company identifier
         * @param {number} lat - Latitude (e.g., 32.0853 for Tel Aviv)
         * @param {number} lon - Longitude (e.g., 34.7818 for Tel Aviv)
         * @param {THREE.Object3D} treeRoot - Root object of company tree
         */
        function anchorTreeAtLocation(companyId, lat, lon, treeRoot) {
            console.log(`[Relay] ğŸ“ Anchoring ${companyId} at (${lat}, ${lon})`);
            
            const surfacePos = latLonToVec3(lat, lon, globeRadius);
            
            // Calculate local "up" vector (normal to sphere surface)
            const localUp = surfacePos.clone().normalize();
            
            // Offset tree slightly above surface (so it doesn't intersect globe)
            const treeOffset = localUp.clone().multiplyScalar(0.5);
            treeRoot.position.copy(surfacePos).add(treeOffset);
            
            // Orient tree so it "grows" away from globe surface
            treeRoot.quaternion.setFromUnitVectors(
                new THREE.Vector3(0, 1, 0),  // Tree's "up" axis
                localUp                       // Globe surface normal
            );
            
            treeRoot.userData.geolocation = { lat, lon, company: companyId };
            companyAnchors.push({ companyId, lat, lon, treeRoot });
            
            console.log('[Relay] âœ… Tree anchored at surface position:', surfacePos);
        }

        function renderTreeScaffold() {
            try {
                console.log('[Relay] ğŸŒ³ renderTreeScaffold() START');
                console.log('[Relay] ğŸ“Š Scene exists?', !!scene);
                
                // ğŸ“„ SHEET PRESENCE PROOF - Track sheet building
                let sheetBuildCount = 0;
                
                // ğŸ”’ PHASE 2A: Stage-Gated Loading
                // Control what gets loaded, not just visibility!
                const stageLevel = 2;  // TODO: Make dynamic based on user progress
                
                // Stage 0-1: Tree only (no globe)
                if (stageLevel < 2) {
                    if (globeMesh) {
                        scene.remove(globeMesh);
                        globeMesh = null;
                        console.log('[Relay] ğŸŒ³ Stage 0-1: Tree only (globe removed)');
                    }
                }
                
                // Stage 2: Load globe + local boundary only
                if (stageLevel >= 2 && !globeMesh) {
                    console.log('[Relay] ğŸŒ Stage 2: Loading Globe + local boundary...');
                    // Globe will be created in the tree rendering (already exists below)
                }
                
                // Stage 3+: Progressive tile loading
                if (stageLevel >= 3) {
                    // TODO: Load neighborhood/city boundaries progressively
                    console.log('[Relay] ğŸ—ºï¸ Stage 3+: Progressive boundaries (not yet implemented)');
                }
                
                // Create bark texture if not already generated
                if (!barkTexture) {
                    console.log('[Relay] ğŸ¨ Generating procedural bark texture...');
                    barkTexture = createBarkTexture();
                    console.log('[Relay] âœ… Bark texture created');
                }
                console.log('[Relay] ğŸ“Š state.tree exists?', !!state.tree);
                console.log('[Relay] ğŸ“Š state.tree.nodes length:', state.tree?.nodes?.length || 0);
                
                if (!scene) {
                    console.error('[Relay] âŒ Scene not initialized! Cannot render tree.');
                    relayUI.log("3D scene not ready - initializing...", "err");
                    return;
                }
                
                if (!state.tree || !state.tree.nodes || state.tree.nodes.length === 0) {
                    console.error('[Relay] âŒ state.tree.nodes is empty or undefined!');
                    relayUI.log("No tree data to render", "err");
                    return;
                }
                
                // Clear existing nodes/edges (deterministic rebuild)
                commitNodes.forEach(node => scene.remove(node));
                filamentEdges.forEach(edge => scene.remove(edge));
                formulaEdges.forEach(edge => scene.remove(edge));
                commitNodes = [];
                filamentEdges = [];
                formulaEdges = [];
                
                // ğŸ”’ CRITICAL: Clear spine map and cell anchors (prevent stale references)
                state.sheetSpines = {};
                window.cellAnchors = {};
                
                // Clear warning sets (for fresh rebuild logging)
                window.warnedMissingSpines = new Set();
                window.warnedMissingAnchors = new Set();
                
                console.log('[Relay] ğŸ§¹ Cleared existing geometry + state maps');
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // ğŸŒ PHASE 2A: Create Globe (unified spatial foundation)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if (!globeMesh) {
                    createGlobeMesh();
                    console.log('[Relay] ğŸŒ Globe added as spatial foundation');
                    
                    // ğŸ”’ PHASE 2B: Load local boundary (Stage â‰¥2, async, FAIL-SOFT)
                    // Tel Aviv anchor: 32.0853Â°N, 34.7818Â°E
                    // CRITICAL: Boundary failure must NOT crash tree rendering
                    loadLocalBoundary(32.0853, 34.7818)
                        .then(() => {
                            console.log('[Relay] ğŸ—ºï¸ Boundary loaded (hidden until Stage 2 + zoom out)');
                        })
                        .catch(err => {
                            console.log('[Relay] ğŸ—ºï¸ Boundary not available (expected with file:// protocol) - tree still renders');
                            // Silently degrade - tree continues without boundary
                        });
                }
                
                const treeNodes = state.tree.nodes;
                console.log('[Relay] ğŸ“Š Rendering', treeNodes.length, 'tree nodes');
            const nodeObjects = {}; // Map node ID to Three.js object
            
            // RENDER NODES (root â†’ branch â†’ department â†’ sheet endpoints)
            treeNodes.forEach(node => {
                const pos = node.position;
                let geometry, material, nodeObj;
                
                if (node.type === 'root') {
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // ROOT NODE - LUMINESCENT GOVERNANCE ANCHOR
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    geometry = new THREE.CylinderGeometry(2.2, 2.8, 3.5, 32, 16);
                    material = new THREE.MeshStandardMaterial({
                        color: 0x0088DD,           // Deep luminescent blue
                        emissive: 0x0066AA,        // Blue glow
                        emissiveIntensity: 0.6,    // Strong anchor glow
                        transparent: true,
                        opacity: 0.4,              // Slightly more opaque (anchor)
                        roughness: 0.2,
                        metalness: 0.1,
                        side: THREE.DoubleSide,
                        depthWrite: false,
                        blending: THREE.AdditiveBlending
                    });
                    nodeObj = new THREE.Mesh(geometry, material);
                    nodeObj.castShadow = true;
                    nodeObj.receiveShadow = true;
                    nodeObj.rotation.x = Math.PI;  // Orient vertically
                    
                    // Root is grounded (tree base)
                    // Root represents governance anchor, not operating state
                    
                } else if (node.type === 'branch' || node.type === 'department') {
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // BRANCH/DEPT NODES - LUMINESCENT JUNCTION NODES
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    const size = node.type === 'branch' ? 1.1 : 0.75;
                    const nodeColor = node.type === 'branch' ? 0x00BBFF : 0x00DDFF;
                    const glowColor = node.type === 'branch' ? 0x0088CC : 0x00AADD;
                    
                    // Slightly irregular sphere (convergence point)
                    geometry = new THREE.SphereGeometry(size, 24, 18);
                    
                    // Luminescent translucent material
                    material = new THREE.MeshStandardMaterial({
                        color: nodeColor,          // Blue-cyan gradients
                        emissive: glowColor,       // Glowing junction
                        emissiveIntensity: 0.5,
                        transparent: true,
                        opacity: 0.35,             // See-through
                        roughness: 0.2,
                        metalness: 0.1,
                        side: THREE.DoubleSide,
                        depthWrite: false,
                        blending: THREE.AdditiveBlending
                    });
                    nodeObj = new THREE.Mesh(geometry, material);
                    nodeObj.castShadow = true;
                    nodeObj.receiveShadow = true;
                    
                    // Add random scale variation (organic irregularity)
                    nodeObj.scale.set(
                        1.0 + (Math.random() - 0.5) * 0.35,
                        1.0 + (Math.random() - 0.5) * 0.35,
                        1.0 + (Math.random() - 0.5) * 0.35
                    );
                    
                } else if (node.type === 'sheet') {
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // CANONICAL SHEET RENDERING (per reference Image 2)
                    // 1. Sheet PERPENDICULAR to branch direction
                    // 2. Looking down branch = looking at sheet front
                    // 3. Individual cells as 3D boxes within sheet
                    // 4. Each cell has INTERNAL filament visible through branch
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // ğŸ“„ SHEET PRESENCE PROOF
                    console.log('[Relay] ğŸ“„ Sheet build START', node.label, 'at position:', [pos.x.toFixed(2), pos.y.toFixed(2), pos.z.toFixed(2)]);
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // SHEET COLORS: Luminescent scheme (internal causality visible)
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    let eriColor;
                    if (node.eri >= 80) eriColor = 0x00FFAA;      // High ERI: bright cyan-green
                    else if (node.eri >= 50) eriColor = 0x00DDFF; // Medium ERI: cyan
                    else eriColor = 0x0099CC;                     // Low ERI: dim blue
                    
                    // Create sheet surface group
                    const sheetGroup = new THREE.Group();
                    
                    // Calculate branch direction (from parent to this sheet)
                    const parentNode = treeNodes.find(n => n.id === node.parent);
                    let branchDir = new THREE.Vector3(0, -1, 0); // default down
                    if (parentNode) {
                        branchDir = new THREE.Vector3(
                            pos.x - parentNode.position.x,
                            pos.y - parentNode.position.y,
                            pos.z - parentNode.position.z
                        ).normalize();
                    }
                    
                    // ğŸ”’ CANONICAL: Sheet dimensions scale with branch size (not fixed)
                    // Branch junction size is ~1.1, so sheet should be proportionate
                    const branchSize = parentNode.type === 'branch' ? 1.1 : 0.75;
                    const sheetWidth = branchSize * 1.8;   // ~2.0 (was 3.0 - too big!)
                    const sheetHeight = branchSize * 2.3;  // ~2.5 (was 3.75 - too big!)
                    const sheetDepth = branchSize * 0.12;  // ~0.13 (was 0.15)
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // CANONICAL SHEET MATERIAL: Soft translucent shell
                    // A) Sheet fill: low opacity (readable but doesn't dominate)
                    // B) Sheet outline: thin bright edge
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    const sheetBoxGeom = new THREE.BoxGeometry(sheetWidth, sheetHeight, sheetDepth);
                    
                    // Sheet fill: soft translucent shell
                    const sheetBoxMat = new THREE.MeshStandardMaterial({
                        color: eriColor,            // ERI-based color (subtle)
                        emissive: eriColor,         // Soft glow
                        emissiveIntensity: 0.15,    // Reduced from 1.5 (not neon)
                        transparent: true,
                        opacity: 0.20,              // Low opacity (was 1.0 debug)
                        roughness: 0.6,
                        metalness: 0.1,
                        depthWrite: false,          // Translucent rendering
                        depthTest: true,
                        side: THREE.DoubleSide
                    });
                    const sheetBox = new THREE.Mesh(sheetBoxGeom, sheetBoxMat);
                    sheetBox.renderOrder = 180;
                    sheetGroup.add(sheetBox);
                    
                    // Store reference for proximity reveal
                    sheetBox.userData.isSheetFill = true;
                    
                    console.log('[Relay] ğŸ“„ Sheet box created:', sheetWidth, 'x', sheetHeight, 'x', sheetDepth);
                    
                    // Frame: thin bright edge (more prominent than fill)
                    const frameGeom = new THREE.EdgesGeometry(sheetBoxGeom);
                    const frameMat = new THREE.LineBasicMaterial({ 
                        color: eriColor, 
                        transparent: true,
                        opacity: 0.8,               // Brighter than fill
                        linewidth: 2
                    });
                    const frame = new THREE.LineSegments(frameGeom, frameMat);
                    frame.renderOrder = 181;        // Draw after fill
                    sheetGroup.add(frame);
                    
                    // Store reference for proximity reveal
                    frame.userData.isSheetFrame = true;
                    
                    // CANONICAL: Render individual CELLS within sheet
                    // ğŸ”’ CRITICAL: Grid must match ACTUAL data dimensions (not arbitrary clamp)
                    const actualRows = state.data?.length || 8;
                    const actualCols = state.data?.[0]?.length || 6;
                    const cellRows = Math.min(actualRows, 20);     // Reasonable render limit
                    const cellCols = Math.min(actualCols, 16);     // Increased from 8 to support wider sheets
                    
                    console.log('[Relay] ğŸ“Š Cell grid:', cellRows, 'rows Ã—', cellCols, 'cols', '(actual data:', actualRows, 'Ã—', actualCols, ')');
                    
                    // ğŸ”’ CANONICAL: Cell size scales with sheet (proportionate to branch)
                    const cellSize = branchSize * 0.08;     // ~0.088 (was 0.12 - too big!)
                    const cellThickness = cellSize * 0.3;   // Thin tile (not cube!)
                    const cellSpacing = cellSize * 0.4;     // ~0.035
                    const cellStepX = cellSize + cellSpacing;
                    const cellStepY = cellSize + cellSpacing;
                    
                    // Center cells within sheet
                    const gridWidth = cellCols * cellStepX;
                    const gridHeight = cellRows * cellStepY;
                    const startX = -gridWidth / 2 + cellSize / 2;
                    const startY = gridHeight / 2 - cellSize / 2;
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // CANONICAL BUNDLING STAGE: SheetBundleSpine
                    // ğŸ”’ CRITICAL: Each sheet owns EXACTLY ONE spine
                    // Cell â†’ (short local) â†’ SheetBundleSpine â†’ (thick conduit) â†’ Branch
                    // This prevents hub topology and enforces aggregation along length
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    
                    // Create SheetBundleSpine anchor (behind sheet, local -Z)
                    const spineZ = -sheetDepth * 0.6;  // Slightly behind sheet
                    const spineLocalPos = new THREE.Vector3(0, 0, spineZ);
                    
                    // Spine anchor (small visible node, NOT a hub)
                    const spineGeom = new THREE.SphereGeometry(0.06, 12, 12);
                    const spineMat = new THREE.MeshStandardMaterial({
                        color: eriColor,
                        emissive: eriColor,
                        emissiveIntensity: 0.4,
                        roughness: 0.4,
                        metalness: 0.1,
                        transparent: true,
                        opacity: 0.6
                    });
                    const spineMesh = new THREE.Mesh(spineGeom, spineMat);
                    spineMesh.position.copy(spineLocalPos);
                    spineMesh.userData = { type: 'sheetBundleSpine', sheetId: node.id };
                    sheetGroup.add(spineMesh);
                    
                    // ğŸ”’ CRITICAL: Store spine in persistent state map (not just scene traverse)
                    if (!state.sheetSpines) state.sheetSpines = {};
                    state.sheetSpines[node.id] = {
                        mesh: spineMesh,
                        localPos: spineLocalPos.clone(),
                        sheetGroup: sheetGroup
                    };
                    
                    // Also store in sheetGroup for backward compat
                    sheetGroup.userData.spineLocalPos = spineLocalPos.clone();
                    sheetGroup.userData.spineMesh = spineMesh;
                    
                    console.log('[Relay] ğŸ”— SheetBundleSpine created for:', node.id);
                    
                    // ğŸ“„ CRITICAL: Store cell anchors for filament endpoints
                    if (!window.cellAnchors) window.cellAnchors = {};
                    const sheetCellAnchors = {};
                    
                    // Render cells + row bundles â†’ spine
                    for (let row = 0; row < cellRows; row++) {
                        // Row bundle collection point (aggregates cells in this row)
                        const rowBundleX = 0; // center of sheet
                        const rowBundleY = startY - row * cellStepY;
                        const rowBundleZ = -sheetDepth * 0.5;
                        const rowBundlePos = new THREE.Vector3(rowBundleX, rowBundleY, rowBundleZ);
                        
                        for (let col = 0; col < cellCols; col++) {
                            // Cell position within sheet (local coordinates)
                            // Cells sit ON the sheet face (positive Z face)
                            const cellX = startX + col * cellStepX;
                            const cellY = startY - row * cellStepY;
                            const cellZ = (sheetDepth / 2) + (cellThickness / 2) + 0.01; // Thin tiles sit on face
                            
                            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            // CELL COLORS: Futuristic light blue scheme (confidence-based)
                            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            const cellData = state.data?.[row]?.[col];
                            let cellColor = 0x4499DD;  // Default: medium blue
                            if (cellData && cellData.eri !== undefined) {
                                if (cellData.eri >= 80) cellColor = 0x00DDFF;      // High confidence: bright cyan
                                else if (cellData.eri >= 50) cellColor = 0x4488EE; // Medium: mid blue
                                else cellColor = 0x6655CC;                        // Low: purple-blue
                            }
                            
                            // ğŸ”’ CANONICAL: Cells are THIN TILES (not bulky cubes)
                            const cellGeom = new THREE.BoxGeometry(cellSize, cellSize, cellThickness);
                            const cellMat = new THREE.MeshStandardMaterial({
                                color: cellColor,
                                emissive: cellColor,
                                emissiveIntensity: 0.35,    // Slightly brighter (thin tiles need more glow)
                                roughness: 0.3,             // Smoother (less rough)
                                metalness: 0.15,            // Slightly metallic
                                transparent: true,
                                opacity: 0.6,               // Slightly more opaque (thinner = needs more presence)
                                depthWrite: false,          // Better translucency
                                blending: THREE.AdditiveBlending  // Additive glow
                            });
                            const cellMesh = new THREE.Mesh(cellGeom, cellMat);
                            cellMesh.position.set(cellX, cellY, cellZ);
                            cellMesh.userData = { row, col, hasFormula: cellData?.formula, isCell: true };
                            cellMesh.renderOrder = 182;     // Draw after frame
                            sheetGroup.add(cellMesh);
                            
                            // ğŸ“„ CRITICAL: Store cell anchor for filament endpoints
                            // Cell reference (e.g., "A1", "B2")
                            const cellRef = `${String.fromCharCode(65 + col)}${row + 1}`;
                            sheetCellAnchors[cellRef] = cellMesh; // Store mesh reference
                            
                            // STAGE 1: Cell â†’ Row Bundle (short, thin filament)
                            const cellFilamentStart = new THREE.Vector3(cellX, cellY, cellZ);
                            const cellFilamentGeom = new THREE.BufferGeometry().setFromPoints([
                                cellFilamentStart,
                                rowBundlePos
                            ]);
                            const cellFilamentMat = new THREE.LineBasicMaterial({
                                color: cellColor,
                                opacity: 0.3,
                                transparent: true,
                                linewidth: 1
                            });
                            const cellFilament = new THREE.Line(cellFilamentGeom, cellFilamentMat);
                            sheetGroup.add(cellFilament);
                        }
                        
                        // STAGE 2: Row Bundle â†’ Sheet Spine (medium thickness)
                        const rowFilamentGeom = new THREE.BufferGeometry().setFromPoints([
                            rowBundlePos,
                            spineLocalPos
                        ]);
                        const rowFilamentMat = new THREE.LineBasicMaterial({
                            color: eriColor,
                            opacity: 0.5,
                            transparent: true,
                            linewidth: 2
                        });
                        const rowFilament = new THREE.Line(rowFilamentGeom, rowFilamentMat);
                        sheetGroup.add(rowFilament);
                    }
                    
                    // STAGE 3: Sheet Spine â†’ Branch (thick main conduit)
                    // This will be rendered after rotation as a connection to parent branch
                    sheetGroup.userData.spineLocalPos = spineLocalPos.clone();
                    sheetGroup.userData.eriColor = eriColor;
                    
                    // Position sheet group
                    sheetGroup.position.copy(pos);
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // CANONICAL ROTATION FIX: Sheet normal âˆ¥ filament flow direction
                    // Filaments flow FROM cells TO branch (toward root)
                    // Sheet face must be âŸ‚ to this flow (sheet normal âˆ¥ flow)
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    
                    // Flow direction = from sheet toward parent (where filaments go)
                    // branchDir points FROM parent TO sheet, so negate it
                    const flowDir = branchDir.clone().multiplyScalar(-1); // toward parent/root
                    
                    // Sheet default normal is +Z
                    const defaultNormal = new THREE.Vector3(0, 0, 1);
                    
                    // Rotate sheet so its normal aligns with flow direction
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(defaultNormal, flowDir);
                    sheetGroup.quaternion.copy(quaternion);
                    
                    // Move sheet back slightly along its normal (so filaments land on face)
                    const embed = 0.4; // distance behind cell anchors
                    const sheetNormal = new THREE.Vector3(0, 0, 1).applyQuaternion(quaternion);
                    const embedOffset = sheetNormal.clone().multiplyScalar(-embed);
                    sheetGroup.position.add(embedOffset);
                    
                    // ğŸ” DEBUG: Draw flow direction arrow
                    const arrowHelper = new THREE.ArrowHelper(flowDir, pos, 2.5, 0xff00ff, 0.5, 0.3);
                    scene.add(arrowHelper);
                    commitNodes.push(arrowHelper);
                    console.log('[Relay] ğŸ“ Sheet flow direction:', flowDir.toArray().map(v => v.toFixed(2)));
                    
                    nodeObj = sheetGroup;
                    
                    // ğŸ“„ CRITICAL: Store cell anchors globally by sheet ID
                    window.cellAnchors[node.id] = sheetCellAnchors;
                    
                    // ğŸ“„ SHEET PRESENCE PROOF - Log sheet completion
                    console.log('[Relay] ğŸ“„ Sheet created:', node.label, 
                        'position:', sheetGroup.position.toArray().map(v => v.toFixed(2)),
                        'scale:', sheetGroup.scale.toArray().map(v => v.toFixed(2)),
                        'children:', sheetGroup.children.length,
                        'cell anchors:', Object.keys(sheetCellAnchors).length);
                    sheetBuildCount++;
                    
                    // Add drift badge if present
                    if (node.drift_count > 0) {
                        const driftGeom = new THREE.SphereGeometry(0.2, 16, 16);
                        const driftMat = new THREE.MeshStandardMaterial({ 
                            color: 0xFF0099,       // Magenta alert
                            emissive: 0xFF00FF,
                            emissiveIntensity: 0.5,
                            roughness: 0.3,
                            metalness: 0.2
                        });
                        const driftBadge = new THREE.Mesh(driftGeom, driftMat);
                        driftBadge.position.set(pos.x + 0.6, pos.y + 0.6, pos.z);
                        scene.add(driftBadge);
                        commitNodes.push(driftBadge);
                    }
                }
                
                nodeObj.position.set(pos.x, pos.y, pos.z);
                nodeObj.userData = { nodeData: node, type: 'treeNode' };
                scene.add(nodeObj);
                commitNodes.push(nodeObj);
                nodeObjects[node.id] = nodeObj;
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // PHASE 2A: Internal filaments now rendered centrally (see line ~4567)
                // REMOVED: Old per-sheet rendering to prevent 3Ã— overcounting
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // DISTANCE-AWARE LABEL: Stage-gated readability
                // Far: category name only | Mid: + ERI | Close: + details
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 512;
                canvas.height = 128;
                context.fillStyle = node.type === 'sheet' ? '#ffffff' : '#00ff88';
                context.font = 'bold 32px Arial';
                context.textAlign = 'center';
                context.fillText(node.label, 256, 64);  // Always show name
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true,
                    opacity: 0.9
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(pos.x, pos.y + 1.5, pos.z);
                sprite.scale.set(4, 1, 1);
                sprite.userData = { 
                    isLabel: true, 
                    nodeType: node.type,
                    nodeLabel: node.label,
                    eri: node.eri || null,
                    driftCount: node.drift_count || 0
                };
                scene.add(sprite);
                commitNodes.push(sprite);
                
                // Add ERI badge for sheets
                if (node.type === 'sheet') {
                    const eriCanvas = document.createElement('canvas');
                    const eriCtx = eriCanvas.getContext('2d');
                    eriCanvas.width = 128;
                    eriCanvas.height = 64;
                    eriCtx.fillStyle = '#ffffff';
                    eriCtx.font = 'bold 32px Arial';
                    eriCtx.textAlign = 'center';
                    eriCtx.fillText(`ERI ${node.eri}`, 64, 40);
                    
                    const eriTexture = new THREE.CanvasTexture(eriCanvas);
                    const eriSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: eriTexture }));
                    eriSprite.position.set(pos.x, pos.y - 1.2, pos.z);
                    eriSprite.scale.set(1.5, 0.4, 1);
                    scene.add(eriSprite);
                    commitNodes.push(eriSprite);
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // NOW POINTER - PER-SHEET OPERATING STATE BEACON
                    // FIX #2: NOW pointer ONLY at sheet endpoints (each sheet has its own "now")
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    const nowGeom = new THREE.SphereGeometry(0.15, 32, 32); // Smaller, cleaner beacon
                    const nowMat = new THREE.MeshStandardMaterial({
                        color: 0x00ff88,
                        emissive: 0x00ff88,
                        emissiveIntensity: 1.0,  // Bright beacon
                        roughness: 0.05,          // Very glossy
                        metalness: 0.0
                    });
                    const nowPointer = new THREE.Mesh(nowGeom, nowMat);
                    nowPointer.position.set(pos.x, pos.y + 0.4, pos.z);  // Just above sheet
                    nowPointer.userData = { type: 'nowPointer', bloomTarget: true };
                    nowPointer.castShadow = false;
                    
                    // Subtle glow
                    const glowGeom = new THREE.SphereGeometry(0.22, 32, 32);
                    const glowMat = new THREE.MeshBasicMaterial({
                        color: 0x00ff88,
                        transparent: true,
                        opacity: 0.3,
                        depthWrite: false
                    });
                    const glow = new THREE.Mesh(glowGeom, glowMat);
                    glow.position.set(pos.x, pos.y + 0.4, pos.z);
                    
                    scene.add(nowPointer);
                    scene.add(glow);
                    commitNodes.push(nowPointer);
                    commitNodes.push(glow);
                }
            });
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // RENDER TAPERED TRUNK TUBES + PRESSURE RINGS
            // FIX #4: Replace wire lines with tapered tubes (biomechanics)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // Hierarchical trunk radii (thick â†’ thin)
            // UPGRADED: Thicker, more substantial like organic trees
            const TRUNK_RADII = {
                'root-branch': { start: 0.65, end: 0.45 },      // Much thicker main trunk
                'branch-department': { start: 0.45, end: 0.28 }, // Substantial mid-branches
                'department-sheet': { start: 0.28, end: 0.15 }   // Still visible at endpoints
            };
            
            function getTrunkRadius(parentType, childType) {
                const key = `${parentType}-${childType}`;
                return TRUNK_RADII[key] || { start: 0.2, end: 0.1 };
            }
            
            treeNodes.forEach(node => {
                if (node.parent && nodeObjects[node.parent]) {
                    const parentObj = nodeObjects[node.parent];
                    const childObj = nodeObjects[node.id];
                    const parentNode = treeNodes.find(n => n.id === node.parent);
                    
                    // STAGE 3: Sheet Spine â†’ Parent Branch (thick main conduit)
                    // For sheet nodes, connect spine to parent (not sheet center to parent)
                    let startPoint = parentObj.position.clone();
                    let endPoint = childObj.position.clone();
                    
                    if (node.type === 'sheet' && childObj.userData?.spineLocalPos) {
                        // Get spine position in world space
                        const spineWorld = childObj.userData.spineLocalPos.clone();
                        spineWorld.applyMatrix4(childObj.matrixWorld);
                        endPoint = spineWorld;
                        
                        // Draw thicker spine â†’ branch filament
                        const spineFilamentGeom = new THREE.BufferGeometry().setFromPoints([
                            spineWorld,
                            parentObj.position.clone()
                        ]);
                        const spineFilamentMat = new THREE.LineBasicMaterial({
                            color: childObj.userData.eriColor || 0x00ff88,
                            opacity: 0.7,
                            transparent: true,
                            linewidth: 3  // Thicker than cell filaments
                        });
                        const spineFilament = new THREE.Line(spineFilamentGeom, spineFilamentMat);
                        scene.add(spineFilament);
                        filamentEdges.push(spineFilament);
                    }
                    
                    // Get appropriate trunk radius for this connection
                    const radii = getTrunkRadius(parentNode.type, node.type);
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // PRESSURE PHYSICS: Branch tension (thickness varies with pressure)
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // Calculate pressure level from this node's rings
                    let nodePressure = 0;
                    if (node.pressureRings && node.pressureRings.length > 0) {
                        nodePressure = node.pressureRings.reduce((sum, ring) => 
                            sum + (ring.pressure || 0), 0) / node.pressureRings.length;
                    }
                    // Apply pressure scaling to trunk radius (subtle swelling)
                    const pressureScale = 1 + (nodePressure * 0.15);  // Up to +15% thickness
                    const scaledRadii = {
                        start: radii.start * pressureScale,
                        end: radii.end * pressureScale
                    };
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // ORGANIC BRANCH CURVES (not straight lines)
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // Create natural curve with slight deviation (like real tree growth)
                    const midPoint = new THREE.Vector3()
                        .addVectors(startPoint, endPoint)
                        .multiplyScalar(0.5);
                    
                    // Add organic deviation (perpendicular to branch direction)
                    // UPGRADED: More dramatic curves for gnarled, twisted appearance
                    const branchDir = new THREE.Vector3().subVectors(endPoint, startPoint).normalize();
                    const perpendicular = new THREE.Vector3(
                        -branchDir.y,
                        branchDir.x,
                        0
                    ).normalize();
                    
                    // Random perpendicular in 3D (not just XY plane)
                    const randomPerp = new THREE.Vector3(
                        Math.random() - 0.5,
                        Math.random() - 0.5,
                        Math.random() - 0.5
                    ).normalize();
                    
                    const curvature = 0.8 + Math.random() * 0.6;  // Much stronger organic twist
                    midPoint.addScaledVector(perpendicular, curvature * 0.6);
                    midPoint.addScaledVector(randomPerp, curvature * 0.4);  // 3D twist
                    
                    // Quadratic curve (natural tree growth)
                    const curve = new THREE.QuadraticBezierCurve3(
                        startPoint,
                        midPoint,
                        endPoint
                    );
                    
                    // Tapered tube with organic curve (pressure-scaled radius)
                    // UPGRADED: More segments for ultra-smooth organic curves
                    const tubeGeometry = new THREE.TubeGeometry(
                        curve,
                        48,             // DOUBLED: Ultra-smooth curves (was 24)
                        scaledRadii.start,  // Pressure-scaled thickness
                        24,             // More radial segments for perfect roundness (was 16)
                        false
                    );
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // LUMINESCENT TRANSLUCENT MATERIAL (reveal internal structure)
                    // CANONICAL: Must be see-through to show internal filaments
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // PHASE 1 LOCK: Translucency ordering (depthWrite + renderOrder)
                    // Branch = translucent shell, draws EARLY (renderOrder 100)
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    const tubeMaterial = new THREE.MeshStandardMaterial({
                        color: 0x00DDFF,           // Luminescent blue-cyan
                        emissive: 0x0099CC,        // Blue glow
                        emissiveIntensity: 0.8,    // Visible glow
                        transparent: true,         // CRITICAL: Must be transparent
                        opacity: 0.6,              // Translucent shell
                        roughness: 0.2,            // Smooth glassy surface
                        metalness: 0.1,            // Slight shine
                        side: THREE.DoubleSide,    // Visible from both sides
                        depthWrite: false,         // ğŸ”’ LOCK: false for translucent shell
                        depthTest: true,           // ğŸ”’ LOCK: true for proper depth ordering
                        blending: THREE.NormalBlending,  // Normal for branches
                        flatShading: false
                    });
                    
                    const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                    tube.castShadow = true;
                    tube.receiveShadow = true;
                    tube.renderOrder = 100;  // ğŸ”’ LOCK: Draw branches EARLY (before filaments)
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // TURGOR PRESSURE: Branch stiffness from operational load
                    // CANONICAL: Branches resist motion proportional to unresolved work
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    const branchMetrics = state.branches?.[node.branchId] || {};
                    const unresolvedCount = branchMetrics.divergence_count || branchMetrics.drift_count || 0;  // ğŸ”’ LOCK 7: Prefer divergence
                    const totalCells = branchMetrics.cell_count || 1;
                    const turgorPressure = Math.min(unresolvedCount / Math.max(totalCells * 0.1, 1), 1.0);
                    
                    tube.userData = {
                        type: 'branchTube',
                        nodeId: node.id,
                        branchId: node.branchId,
                        turgorPressure: turgorPressure,           // 0-1, drives stiffness
                        stiffnessMultiplier: 1 + turgorPressure * 4,  // 1x-5x resistance
                        pressureState: turgorPressure > 0.7 ? 'HIGH' : 
                                      turgorPressure > 0.3 ? 'MEDIUM' : 'LOW'
                    };
                    
                    // Visual indication of high pressure (intensify glow)
                    if (turgorPressure > 0.5) {
                        tubeMaterial.emissiveIntensity = 0.4 + (turgorPressure * 0.3);
                        tubeMaterial.opacity = 0.3 + (turgorPressure * 0.15);
                    }
                    
                    scene.add(tube);
                    filamentEdges.push(tube);
                    
                    // RENDER PRESSURE RING STACK along this trunk segment
                    if (node.type !== 'sheet') {
                        if (parentNode && parentNode.pressureRings) {
                            renderRingStackBetween(parentNode, node, nodeObjects);
                        }
                    }
                }
            });
                
                console.log('[Relay] âœ… Tree Scaffold rendered successfully');
                console.log('[Relay] ğŸ“Š Stats:', {
                    nodes: Object.keys(nodeObjects).length,
                    commitNodes: commitNodes.length,
                    filamentEdges: filamentEdges.length,
                    formulaEdges: formulaEdges.length,
                    sceneChildren: scene.children.length,
                    meshCount: scene.children.filter(c => c.type === 'Mesh').length
                });
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // ğŸŒ PHASE 2A: Anchor tree at Tel Aviv (32.0853Â°N, 34.7818Â°E)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                const rootNode = treeNodes.find(n => n.type === 'root');
                if (rootNode && nodeObjects[rootNode.id]) {
                    const rootObj = nodeObjects[rootNode.id];
                    // Tel Aviv coordinates
                    const TEL_AVIV_LAT = 32.0853;
                    const TEL_AVIV_LON = 34.7818;
                    anchorTreeAtLocation('Northwind', TEL_AVIV_LAT, TEL_AVIV_LON, rootObj);
                    console.log('[Relay] ğŸŒ Tree anchored at Tel Aviv');
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // DEBUG: Add test sphere to verify rendering works
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                const testSphere = new THREE.Mesh(
                    new THREE.SphereGeometry(1, 32, 32),
                    new THREE.MeshStandardMaterial({
                        color: 0x00ff00,
                        emissive: 0x00ff00,
                        emissiveIntensity: 0.8,
                        roughness: 0.3,
                        metalness: 0.1
                    })
                );
                testSphere.position.set(0, 0, 0);
                scene.add(testSphere);
                commitNodes.push(testSphere);
                console.log('[Relay] ğŸŸ¢ Test sphere added at origin for visibility check');
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // PHASE 2A: RENDER INTERNAL FILAMENTS (cell-level causality)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                renderInternalFilaments(treeNodes, nodeObjects);
                
                relayUI.log(`Tree Scaffold: ${treeNodes.length} nodes + internal filaments`, "ok");
                
                // ğŸ“„ SHEET PRESENCE PROOF - Final count
                console.log('[Relay] ğŸ“„ Sheets in scene:', sheetBuildCount, '/', treeNodes.filter(n => n.type === 'sheet').length);
                console.log('[Relay] ğŸ“„ Total scene objects:', scene.children.length);
                
            } catch (error) {
                console.error('[Relay] âŒ renderTreeScaffold() ERROR:', error);
                console.error('[Relay] âŒ Stack:', error.stack);
                relayUI.log(`Tree render failed: ${error.message}`, "err");
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // FORMULA EDGES - LENS-GATED (FIX 3)
        // Only visible when: formula lens enabled OR formula cell selected
        // Renders thin edges between cells on sheet plane (lifted above cells)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function renderFormulaEdges() {
            // Clear existing formula edges
            formulaEdges.forEach(edge => scene.remove(edge));
            formulaEdges.length = 0;
            
            // Only render if formula lens enabled or cell selected
            if (!formulaLensEnabled && !selectedCellForFormula) return;
            
            // Get dependency graph for current sheet
            const currentSheet = state.sheets[state.currentSheet];
            if (!currentSheet || !currentSheet.formulaGraph) return;
            
            const graph = currentSheet.formulaGraph;
            const dependencyIndex = currentSheet.dependencyIndex || {};
            
            // For each cell with formula, draw edges to its dependencies
            Object.keys(dependencyIndex).forEach(cellRef => {
                const deps = dependencyIndex[cellRef] || [];
                if (deps.length === 0) return;
                
                // Parse cell reference (e.g., "A1" â†’ row 0, col 0)
                const sourcePos = parseCellRefTo3D(cellRef);
                if (!sourcePos) return;
                
                deps.forEach(depRef => {
                    const targetPos = parseCellRefTo3D(depRef);
                    if (!targetPos) return;
                    
                    // CANONICAL: Thin edge on sheet plane, lifted slightly above cells
                    const liftAmount = 0.05;  // Lift above cell surfaces
                    const startPt = new THREE.Vector3(
                        sourcePos.x,
                        sourcePos.y,
                        sourcePos.z + liftAmount
                    );
                    const endPt = new THREE.Vector3(
                        targetPos.x,
                        targetPos.y,
                        targetPos.z + liftAmount
                    );
                    
                    // Curved edge (slight arc for readability)
                    const midPt = new THREE.Vector3()
                        .addVectors(startPt, endPt)
                        .multiplyScalar(0.5);
                    midPt.z += 0.1; // Arc upward slightly
                    
                    const curve = new THREE.QuadraticBezierCurve3(startPt, midPt, endPt);
                    const points = curve.getPoints(20);
                    const edgeGeom = new THREE.BufferGeometry().setFromPoints(points);
                    const edgeMat = new THREE.LineBasicMaterial({
                        color: 0xD4A574,  // Warm amber/golden (natural vine color)
                        opacity: 0.5,
                        transparent: true,
                        linewidth: 1
                    });
                    const edge = new THREE.Line(edgeGeom, edgeMat);
                    
                    // If in sheet group, add to that group; otherwise add to scene
                    scene.add(edge);
                    formulaEdges.push(edge);
                });
            });
            
            console.log(`ğŸ“ Formula edges rendered: ${formulaEdges.length} dependencies visible`);
        }
        
        function parseCellRefTo3D(cellRef) {
            // Parse "A1" â†’ col A (0), row 1 (0) â†’ 3D position within sheet
            const match = cellRef.match(/^([A-Z]+)(\d+)$/);
            if (!match) return null;
            
            const colLetter = match[1];
            const rowNum = parseInt(match[2]) - 1; // 1-indexed in formula, 0-indexed here
            
            // Convert column letter to index (A=0, B=1, ...)
            let colIndex = 0;
            for (let i = 0; i < colLetter.length; i++) {
                colIndex = colIndex * 26 + (colLetter.charCodeAt(i) - 65 + 1);
            }
            colIndex -= 1; // 1-indexed to 0-indexed
            
            // Map to sheet local coordinates (match cell rendering)
            const cellSize = 0.12;
            const cellSpacing = 0.05;
            const cellStepX = cellSize + cellSpacing;
            const cellStepY = cellSize + cellSpacing;
            const cellCols = Math.min(state.data?.[0]?.length || 6, 8);
            const cellRows = Math.min(state.data?.length || 8, 12);
            const gridWidth = cellCols * cellStepX;
            const gridHeight = cellRows * cellStepY;
            const startX = -gridWidth / 2 + cellSize / 2;
            const startY = gridHeight / 2 - cellSize / 2;
            
            return {
                x: startX + colIndex * cellStepX,
                y: startY - rowNum * cellStepY,
                z: 0.15 / 2 + cellSize / 2  // sheetDepth / 2 + cellSize / 2
            };
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // OLD FUNCTION REMOVED: Duplicate renderInternalFilaments deleted
        // Using centralized version below (line ~4815) to prevent 3Ã— overcounting
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 2A: INTERNAL FILAMENTS (cell-level causality)
        // CRITICAL: Renders filaments inside translucent branches
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function renderInternalFilaments(treeNodes, nodeObjects) {
            console.log('[Relay] ğŸ§¬ Rendering DIRECT filaments (Cell â†’ Branch, NO HUB)...');
            
            // ğŸ”’ CRITICAL FIX: Only render filaments for ACTIVE imported sheet
            // Prevents overcounting (3 sheets Ã— 68 cells = 204 filaments instead of 68)
            let filamentsRendered = false;
            
            treeNodes.forEach(node => {
                if (node.type !== 'sheet') return;
                
                // ğŸ”’ LOCK: Skip if filaments already rendered for another sheet
                if (filamentsRendered) {
                    console.log('[Relay] â© Skipping duplicate filament render for sheet:', node.id);
                    return;
                }
                
                const sheetObj = nodeObjects[node.id];
                if (!sheetObj) return;
                
                // Get parent branch
                const parentNode = treeNodes.find(n => n.id === node.parent);
                if (!parentNode) return;
                
                const parentObj = nodeObjects[parentNode.id];
                if (!parentObj) return;
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // CANONICAL TOPOLOGY: No sheet hub!
                // Each filament goes DIRECTLY from cell â†’ branch bundle spine
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Branch bundle spine position (where filaments converge at branch)
                const branchBundleSpinePos = parentObj.position.clone();
                branchBundleSpinePos.y += 0.5;  // Slight offset above branch center
                
                // ğŸ“„ CRITICAL: Use REAL cell anchors, not computed positions
                const sheetCellAnchors = window.cellAnchors?.[node.id];
                if (!sheetCellAnchors) {
                    console.warn('[Relay] âš ï¸ No cell anchors found for sheet:', node.id);
                    return;
                }
                
                console.log('[Relay] ğŸ§¬ Using', Object.keys(sheetCellAnchors).length, 'REAL cell anchors for sheet:', node.label);
                
                // Render filament for each cell
                const cellData = state.data || [];
                const cellRows = cellData.length;
                const cellCols = cellData[0]?.length || 0;
                
                for (let row = 0; row < Math.min(cellRows, 20); row++) {
                    for (let col = 0; col < Math.min(cellCols, 12); col++) {
                        const cell = cellData[row]?.[col];
                        if (!cell) continue;
                        
                        // ğŸ“„ CRITICAL: Get REAL cell mesh position from anchors
                        const cellRef = `${String.fromCharCode(65 + col)}${row + 1}`;
                        const cellMesh = sheetCellAnchors[cellRef];
                        if (!cellMesh) {
                            // Only warn once per missing anchor (use Set to track)
                            if (!window.warnedMissingAnchors) window.warnedMissingAnchors = new Set();
                            const warnKey = `${node.id}:${cellRef}`;
                            if (!window.warnedMissingAnchors.has(warnKey)) {
                                console.warn('[Relay] âš ï¸ No cell anchor for:', cellRef, '(sheet renders', cellCols, 'cols, data has more)');
                                window.warnedMissingAnchors.add(warnKey);
                            }
                            continue; // Skip this cell gracefully
                        }
                        
                        // Get world position from actual cell mesh
                        const cellWorld = new THREE.Vector3();
                        cellMesh.getWorldPosition(cellWorld);
                        
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        // CANONICAL BUNDLING: Thickness from REUSE COUNT (not just formula)
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        const hasFormula = cell.formula !== null && cell.formula !== undefined;
                        const deps = hasFormula ? (cell.formula.match(/[A-Z]+\d+/g) || []).length : 0;
                        
                        // Calculate downstream reuse (cellRef already declared above)
                        let reuseCount = 0;
                        cellData.forEach(r => {
                            if (Array.isArray(r)) {
                                r.forEach(c => {
                                    if (c && c.formula && c.formula.includes(cellRef)) reuseCount++;
                                });
                            }
                        });
                        
                        // ğŸ”’ CANONICAL: Filament thickness scales with branch size (not fixed)
                        const baseThickness = branchSize * 0.008;  // ~0.0088 (was 0.006 - too thin!)
                        const thicknessFactor = 1 + (reuseCount * 0.8);  // REUSE = thickness
                        const filamentRadius = baseThickness * thicknessFactor;
                        
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        // COLOR & BRIGHTNESS: Formula = brightness, Reuse = thickness
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        let filamentColor = 0x00DDFF;  // Cyan (input)
                        let emissiveIntensity = 0.3;
                        
                        if (hasFormula) {
                            filamentColor = 0x00FFAA;  // Bright cyan-green (formula = converged)
                            emissiveIntensity = 0.6;
                        }
                        
                        if (cell.eri && cell.eri < 50) {
                            emissiveIntensity *= 0.4;  // Dim for low confidence
                        }
                        
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        // FRACTAL FILAMENT: Organic curved path with micro-timeboxes
                        // RULE: Filaments are miniature branches, not straight wires
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        // CANONICAL TOPOLOGY: Cell â†’ SheetSpine â†’ Branch (STAGED)
                        // ğŸ”’ LOCK: Two-stage bundling (not direct hub)
                        // Stage 1: Cell â†’ SheetBundleSpine (short, local, thin)
                        // Stage 2: SheetBundleSpine â†’ Branch (thick conduit)
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        
                        // ğŸ”’ CRITICAL: Get spine from persistent state map (not scene traverse)
                        const spineData = state.sheetSpines?.[node.id];
                        if (!spineData) {
                            // Only warn once per sheet (use Set to track)
                            if (!window.warnedMissingSpines) window.warnedMissingSpines = new Set();
                            if (!window.warnedMissingSpines.has(node.id)) {
                                console.warn('[Relay] âš ï¸ No spine found for sheet:', node.id, '- skipping filaments');
                                window.warnedMissingSpines.add(node.id);
                            }
                            continue;
                        }
                        
                        // Get spine world position
                        const sheetSpineWorld = new THREE.Vector3();
                        spineData.sheetGroup.localToWorld(sheetSpineWorld.copy(spineData.localPos));
                        
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        // STAGE 1: Cell â†’ SheetBundleSpine (short local filament)
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        const localPathPoints = [];
                        const localSegments = 3;  // Short path
                        
                        for (let i = 0; i <= localSegments; i++) {
                            const t = i / localSegments;
                            
                            // Interpolation: cellWorld â†’ sheetSpineWorld
                            const point = new THREE.Vector3().lerpVectors(
                                cellWorld, 
                                sheetSpineWorld, 
                                t
                            );
                            
                            // Small organic deviation (local filament is mostly straight)
                            const deviationStrength = Math.sin(t * Math.PI) * 0.03;
                            point.x += (Math.random() - 0.5) * deviationStrength;
                            point.y += (Math.random() - 0.5) * deviationStrength;
                            point.z += (Math.random() - 0.5) * deviationStrength;
                            
                            localPathPoints.push(point);
                        }
                        
                        const localCurve = new THREE.CatmullRomCurve3(localPathPoints, false, 'catmullrom', 0.3);
                        
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        // LOCAL FILAMENT: Thin, short (Cell â†’ SheetSpine)
                        // ğŸ”’ CANONICAL: Smooth like spiral (organic brush)
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        const localTubeGeom = new THREE.TubeGeometry(
                            localCurve, 
                            12,                     // Smoother (was 8)
                            filamentRadius * 0.7,   // thin (local)
                            6,                      // More radial segments (was 4)
                            false                   // not closed
                        );
                        
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        // LOCAL FILAMENT MATERIAL: Thin, subtle
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        const localMat = new THREE.MeshStandardMaterial({
                            color: filamentColor,
                            emissive: filamentColor,
                            emissiveIntensity: emissiveIntensity * 0.7,  // Dimmer (local)
                            transparent: true,
                            opacity: 0.5,
                            roughness: 0.3,
                            metalness: 0.1,
                            depthWrite: false,
                            depthTest: true,
                            blending: THREE.AdditiveBlending
                        });
                        
                        const localFilament = new THREE.Mesh(localTubeGeom, localMat);
                        localFilament.renderOrder = 200;
                        localFilament.userData = {
                            type: 'localFilament',
                            cell: cellRef,
                            stage: 'cell-to-spine'
                        };
                        
                        scene.add(localFilament);
                        filamentEdges.push(localFilament);
                        
                        // Store local filament for timebox rendering
                        localFilament.userData.cellRef = cellRef;
                        localFilament.userData.curve = localCurve;
                        localFilament.userData.filamentRadius = filamentRadius * 0.7;
                    }
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // STAGE 2: SheetBundleSpine â†’ Branch (ONE thick conduit per sheet)
                // ğŸ”’ CANONICAL: This is NOT per-cell, it's per-sheet
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                // Get sheet spine world position (from persistent state map)
                // ğŸ”’ Re-fetch spine data (was declared in cell loop scope above)
                const conduitSpineData = state.sheetSpines?.[node.id];
                if (conduitSpineData) {
                    const sheetSpineWorld = new THREE.Vector3();
                    conduitSpineData.sheetGroup.localToWorld(sheetSpineWorld.copy(conduitSpineData.localPos));
                    
                    // Build conduit path: SheetSpine â†’ Branch
                    const conduitPoints = [];
                    const conduitSegments = 8;  // Longer than local filaments
                    
                    for (let i = 0; i <= conduitSegments; i++) {
                        const t = i / conduitSegments;
                        const point = new THREE.Vector3().lerpVectors(
                            sheetSpineWorld,
                            branchBundleSpinePos,
                            t
                        );
                        
                        // More organic deviation for longer path
                        const deviationStrength = Math.sin(t * Math.PI) * 0.15;
                        point.x += (Math.random() - 0.5) * deviationStrength;
                        point.y += (Math.random() - 0.5) * deviationStrength;
                        point.z += (Math.random() - 0.5) * deviationStrength;
                        
                        conduitPoints.push(point);
                    }
                    
                    const conduitCurve = new THREE.CatmullRomCurve3(conduitPoints, false, 'catmullrom', 0.3);
                    
                    // ğŸ”’ CANONICAL: Thick conduit with taper (scales with branch)
                    const conduitBaseRadius = branchSize * 0.035;  // ~0.0385 (proportionate)
                    const conduitRadiusFunction = (u) => {
                        // Taper from spine (thinner) to branch (thicker)
                        const taperFactor = 0.8 + (u * 0.4);  // 0.8 â†’ 1.2
                        return conduitBaseRadius * taperFactor;
                    };
                    
                    // ğŸ”’ CANONICAL: Smooth conduit (like spiral brush)
                    const conduitGeom = new THREE.TubeGeometry(
                        conduitCurve,
                        32,                     // DOUBLED: Smoother curves (was 16)
                        conduitBaseRadius,      // Scaled base radius (was 0.025 fixed)
                        8,                      // More radial segments for roundness (was 6)
                        false,
                        conduitRadiusFunction
                    );
                    
                    // Brighter, more prominent
                    const eriColor = node.eri >= 80 ? 0x00FFAA : node.eri >= 50 ? 0x00DDFF : 0x0099CC;
                    const conduitMat = new THREE.MeshStandardMaterial({
                        color: eriColor,
                        emissive: eriColor,
                        emissiveIntensity: 0.6,  // Brighter (main conduit)
                        transparent: true,
                        opacity: 0.75,
                        roughness: 0.2,
                        metalness: 0.2,
                        depthWrite: false,
                        depthTest: true,
                        blending: THREE.AdditiveBlending
                    });
                    
                    const conduitFilament = new THREE.Mesh(conduitGeom, conduitMat);
                    conduitFilament.renderOrder = 195;  // Between local (200) and branches (100)
                    conduitFilament.userData = {
                        type: 'conduitFilament',
                        sheetId: node.id,
                        stage: 'spine-to-branch'
                    };
                    
                    scene.add(conduitFilament);
                    filamentEdges.push(conduitFilament);
                    
                    console.log('[Relay] ğŸ”— Conduit filament: SheetSpine â†’ Branch for', node.label);
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // CANONICAL TIMEBOX SEGMENTATION: Filaments ARE segments, not continuous
                // ğŸ”’ RELAY PHYSICS: Time is discrete, history advances at commit boundaries
                // Each timebox OWNS a filament segment (material slices, not ornaments)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                // Generate canonical timebox list for this sheet (ONE list for alignment)
                const sheetTimeboxes = generateTimeboxesFromCommits(state.commits || [], {
                    mode: 'FIXED_COMMIT_BUCKET',
                    bucketSize: 10,
                    minPerFile: 3
                });
                
                console.log('[Relay] â° Segmenting filaments by timeboxes:', sheetTimeboxes.length, 'segments per filament');
                
                // ğŸ”’ CANONICAL RULE: No commits = no timeboxes (don't fake)
                if (sheetTimeboxes.length === 0) {
                    console.log('[Relay] â° No commits â†’ no segmentation (filaments remain whole)');
                } else {
                    // Helper: Slice curve by parameter t
                    function sliceCurve(curve, t0, t1) {
                        const points = [];
                        const samples = 8;  // Points in segment
                        for (let i = 0; i <= samples; i++) {
                            const t = t0 + (t1 - t0) * (i / samples);
                            points.push(curve.getPoint(t));
                        }
                        return new THREE.CatmullRomCurve3(points, false, 'catmullrom', 0.3);
                    }
                    
                    // Re-render LOCAL filaments as segmented (Cell â†’ SheetSpine)
                    filamentEdges.forEach(filament => {
                        if (filament.userData?.type !== 'localFilament') return;
                        if (!filament.userData.curve) return;
                        
                        const curve = filament.userData.curve;
                        const cellRef = filament.userData.cellRef;
                        const baseRadius = filament.userData.filamentRadius || 0.005;
                        
                        // Remove original continuous filament
                        scene.remove(filament);
                        const idx = filamentEdges.indexOf(filament);
                        if (idx > -1) filamentEdges.splice(idx, 1);
                        
                        // Calculate t boundaries for timeboxes
                        const numSegments = sheetTimeboxes.length;
                        
                        sheetTimeboxes.forEach((timebox, tbIndex) => {
                            // Normalized position along filament (evenly spaced)
                            const t = (tbIndex + 1) / (sheetTimeboxes.length + 1);
                            const pos = curve.getPoint(t);
                            const tangent = curve.getTangent(t).normalize();
                            
                            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            // CANONICAL MICRO-TIMEBOX: Thinner, more embedded in glow
                            // Goal: segmentation markers, not jewelry
                            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            const puckRadius = filamentRadius * 2.2;   // Reduced from 2.8
                            const puckThickness = 0.012;               // Thinner (was 0.018)
                            const puckGeom = new THREE.CylinderGeometry(
                                puckRadius, 
                                puckRadius, 
                                puckThickness, 
                                12,              // Fewer segments (was 16)
                                1, 
                                false
                            );
                            
                            // State-aware color (dimmer by default, brighten on hover)
                            let puckColor, puckEmissive, puckOpacity;
                            if (timebox.state === 'VERIFIED') {
                                puckColor = 0xD4A574;     // Golden amber
                                puckEmissive = 0.15;      // Reduced from 0.4
                                puckOpacity = 0.4;        // Reduced from 0.7
                            } else if (timebox.state === 'DEGRADED') {
                                puckColor = 0x9A7B5A;     // Dim amber
                                puckEmissive = 0.08;      // Reduced from 0.2
                                puckOpacity = 0.25;       // Reduced from 0.5
                            } else {  // INDETERMINATE
                                puckColor = 0x6B5545;     // Faint brown
                                puckEmissive = 0.05;      // Reduced from 0.1
                                puckOpacity = 0.15;       // Reduced from 0.3
                            }
                            
                            const puckMat = new THREE.MeshStandardMaterial({
                                color: puckColor,
                                emissive: puckColor,
                                emissiveIntensity: puckEmissive,
                                transparent: true,
                                opacity: puckOpacity,
                                roughness: 0.5,
                                metalness: 0.2,
                                side: THREE.DoubleSide
                            });
                            
                            const microPuck = new THREE.Mesh(puckGeom, puckMat);
                            microPuck.position.copy(pos);
                            microPuck.renderOrder = 190;  // Between sheet (180) and filaments (200)
                            
                            // Orient perpendicular to filament tangent
                            const defaultUp = new THREE.Vector3(0, 1, 0);
                            const quaternion = new THREE.Quaternion().setFromUnitVectors(defaultUp, tangent);
                            microPuck.quaternion.copy(quaternion);
                            
                            // Store metadata for interaction
                            microPuck.userData = { 
                                type: 'microTimebox', 
                                timeboxId: timebox.timeboxId,
                                commitRange: timebox.commitRange,
                                commitCount: timebox.commitCount,
                                confidence: timebox.confidence,
                                state: timebox.state,
                                parentCell: cellRef,
                                curveT: t,  // ğŸ”’ LOCK: Record t for validation
                                timestampRange: timebox.timestampRange
                            };
                            
                            scene.add(microPuck);
                            commitNodes.push(microPuck);
                        });
                    });
                    
                    const microTimeboxTotal = sheetTimeboxes.length * filamentEdges.filter(f => f.userData?.type === 'internalFilament').length;
                    console.log('[Relay] â° Micro-timeboxes rendered:', microTimeboxTotal, 'pucks (', sheetTimeboxes.length, 'timeboxes Ã—', filamentEdges.filter(f => f.userData?.type === 'internalFilament').length, 'filaments)');
                }
                
                // ğŸ”’ LOCK: Mark filaments as rendered (prevents duplicate rendering for other sheets)
                filamentsRendered = true;
                console.log('[Relay] âœ… Filaments + micro-timeboxes rendered for sheet:', node.id);
            });
            
            console.log('[Relay] ğŸ§¬ Internal filaments complete - DIRECT TOPOLOGY (no hub), timeboxed strings visible');
        }

        // Helper functions for Tree Scaffold complete
        // (renderTreeScaffold function properly closed earlier at line ~3638)
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 1 TOPOLOGY LINT: Auto-fail hub regressions
        // ğŸ”’ LOCK 6: Runs on import, view switch, LOD change, boundary load
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function relayLintTopology(state) {
            const errors = [];
            
            // ğŸ”’ SAFETY: Check if scene exists (may be called before 3D init)
            if (typeof scene === 'undefined' || !scene) {
                console.log('[Relay] â© Topology lint skipped (scene not yet initialized)');
                return { pass: true, errors: [], skipped: true };
            }
            
            // Collect all filaments from scene
            const filaments = [];
            scene.traverse(obj => {
                if (obj.userData?.type === 'internalFilament') {
                    filaments.push(obj);
                }
            });
            
            if (filaments.length === 0) {
                // No filaments yet, pass (early in lifecycle)
                return { pass: true, errors: [] };
            }
            
            // CHECK 1: Unique top anchors (no shared cell tips)
            const topAnchors = new Map();
            filaments.forEach(f => {
                const cellId = f.userData.cell;
                if (topAnchors.has(cellId)) {
                    errors.push(`FAIL: Shared top anchor ${cellId} (hub at cell!)`);
                }
                topAnchors.set(cellId, f);
            });
            
            // CHECK 2: Sheet object never an endpoint (filaments go to cells, not sheets)
            scene.traverse(obj => {
                if (obj.userData?.type === 'sheet') {
                    filaments.forEach(f => {
                        // Filament should NOT point directly at sheet object
                        const filamentTop = f.geometry.parameters.path.points[f.geometry.parameters.path.points.length - 1];
                        const distToSheet = filamentTop.distanceTo(obj.position);
                        if (distToSheet < 0.1) {
                            errors.push(`FAIL: Filament terminates at sheet object ${obj.userData.sheetId}, not cell`);
                        }
                    });
                }
            });
            
            // CHECK 3: 1 cell = 1 filament (per sheet)
            const sheets = state.tree?.nodes?.filter(n => n.type === 'sheet') || [];
            sheets.forEach(sheet => {
                const cellData = state.data || [];
                const populatedCells = [];
                for (let row = 0; row < Math.min(cellData.length, 20); row++) {
                    for (let col = 0; col < Math.min((cellData[0]?.length || 0), 12); col++) {
                        if (cellData[row]?.[col]) {
                            populatedCells.push(`${String.fromCharCode(65 + col)}${row + 1}`);
                        }
                    }
                }
                
                const sheetFilaments = filaments.filter(f => 
                    f.userData.cell && populatedCells.includes(f.userData.cell)
                );
                
                if (populatedCells.length > 0 && sheetFilaments.length !== populatedCells.length) {
                    errors.push(`FAIL: Sheet ${sheet.id} has ${populatedCells.length} cells but ${sheetFilaments.length} filaments`);
                }
            });
            
            // CHECK 4: No hub clustering near sheets (spatial test)
            sheets.forEach(sheet => {
                const sheetObj = scene.getObjectByName(sheet.id);
                if (!sheetObj) return;
                
                // Get all filament top positions
                const topPositions = filaments.map(f => {
                    const points = f.geometry.parameters.path.points;
                    return points[points.length - 1];  // Last point = top
                });
                
                if (topPositions.length < 2) return;  // Need at least 2 for clustering test
                
                // Calculate centroid
                const centroid = new THREE.Vector3();
                topPositions.forEach(p => centroid.add(p));
                centroid.divideScalar(topPositions.length);
                
                // Check max distance from centroid
                const maxDist = Math.max(...topPositions.map(p => p.distanceTo(centroid)));
                
                // If all tops within 1.0 units = hub clustering!
                if (maxDist < 1.0 && topPositions.length > 5) {
                    errors.push(`FAIL: Sheet ${sheet.id} has hub-like clustering (maxDist: ${maxDist.toFixed(2)})`);
                }
            });
            
            // Result
            const pass = errors.length === 0;
            if (!pass) {
                console.error('ğŸš¨ TOPOLOGY LINT FAILED:');
                errors.forEach(e => console.error('  ', e));
            } else {
                console.log('âœ… Topology lint passed');
            }
            
            return { pass, errors };
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ”’ PHASE 1 NOTE: Additional topology lint triggers (Phase 2/3)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TODO Phase 3: LOD change trigger
        // lodGov.subscribe({ onLODChange: (level) => relayLintTopology(state) });
        //
        // TODO Phase 2: Globe/boundary load trigger
        // function loadBoundaryFromGit(commit) {
        //     // ... load boundary ...
        //     relayLintTopology(state);
        // }

        function render3DFilament() {
            // Clear existing nodes/edges
            commitNodes.forEach(node => scene.remove(node));
            filamentEdges.forEach(edge => scene.remove(edge));
            commitNodes = [];
            filamentEdges = [];
            
            if (state.commits.length === 0) return;
            
            // RENDER MAIN FILAMENT (original commits)
            const mainNodes = [];
            state.commits.forEach((commit, index) => {
                // Position commits in a helix (space-time filament)
                const angle = (index / state.commits.length) * Math.PI * 4;
                const radius = 5;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const y = (index / state.commits.length) * 15 - 7.5; // Vertical spread
                
                // Node appearance based on commit type
                let color, size;
                if (commit.type === 'IMPORT') {
                    color = 0x00ff88; // Green for import
                    size = 0.5;
                } else if (commit.type === 'ROW_CREATE') {
                    color = 0x88aaff; // Blue for row creates
                    size = 0.3;
                } else {
                    color = 0xffaa00; // Orange for other
                    size = 0.25;
                }
                
                // Create node geometry
                const geometry = new THREE.SphereGeometry(size, 16, 16);
                const material = new THREE.MeshPhongMaterial({ 
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3,
                    shininess: 100
                });
                const node = new THREE.Mesh(geometry, material);
                node.position.set(x, y, z);
                node.userData = { commit: commit, index: index, filament: 'main' };
                
                // Add glow effect
                const glowGeometry = new THREE.SphereGeometry(size * 1.5, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.2
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                node.add(glow);
                
                scene.add(node);
                commitNodes.push(node);
                mainNodes.push(node);
                
                // Create edge to previous commit (filament strand)
                if (index > 0) {
                    const prevNode = mainNodes[index - 1];
                    const points = [];
                    points.push(prevNode.position);
                    points.push(node.position);
                    
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                    const lineMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x00ff88,
                        opacity: 0.6,
                        transparent: true,
                        linewidth: 2
                    });
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    scene.add(line);
                    filamentEdges.push(line);
                }
            });
            
            // RENDER FORK FILAMENTS
            state.forks.forEach((fork, forkIndex) => {
                const branchNode = mainNodes[fork.branchPoint];
                if (!branchNode) return;
                
                const forkNodes = [];
                
                fork.commits.forEach((commit, index) => {
                    // Fork diverges from branch point with different trajectory
                    const baseAngle = (fork.branchPoint / state.commits.length) * Math.PI * 4;
                    const forkOffset = (forkIndex + 1) * Math.PI * 0.5; // Offset each fork
                    const angle = baseAngle + forkOffset + (index / fork.commits.length) * Math.PI * 2;
                    const radius = 5 + (forkIndex + 1) * 2; // Each fork has wider radius
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    const yStart = branchNode.position.y;
                    const y = yStart + (index / fork.commits.length) * 10; // Vertical progression
                    
                    // FIX #1: Fork nodes are TRANSLUCENT (projections, not reality)
                    const geometry = new THREE.SphereGeometry(0.25, 16, 16);
                    const material = new THREE.MeshPhongMaterial({ 
                        color: fork.color,
                        emissive: fork.color,
                        emissiveIntensity: 0.2, // FIX #1: Softer glow (was 0.4)
                        shininess: 50,          // FIX #1: Less shiny
                        transparent: true,       // FIX #1: TRANSLUCENT
                        opacity: 0.6             // FIX #1: Only canonical is fully opaque
                    });
                    const node = new THREE.Mesh(geometry, material);
                    node.position.set(x, y, z);
                    node.userData = { commit: commit, fork: fork, filament: 'fork' };
                    
                    // FIX #1: Softer glow on forks
                    const glowGeometry = new THREE.SphereGeometry(0.35, 16, 16);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: fork.color,
                        transparent: true,
                        opacity: 0.15  // FIX #1: Much softer than main (was 0.3)
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    node.add(glow);
                    
                    scene.add(node);
                    commitNodes.push(node);
                    forkNodes.push(node);
                    
                    // Connect to previous fork node or branch point
                    if (index === 0) {
                        // FIX #1: Branch connection is dashed (projection, not reality)
                        const points = [branchNode.position.clone(), node.position];
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                        const lineMaterial = new THREE.LineDashedMaterial({ 
                            color: fork.color,
                            opacity: 0.4,          // FIX #1: More transparent
                            transparent: true,
                            linewidth: 2,          // FIX #1: Thinner
                            dashSize: 0.3,         // FIX #1: Dashed pattern
                            gapSize: 0.2
                        });
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        line.computeLineDistances(); // Required for dashed lines
                        scene.add(line);
                        filamentEdges.push(line);
                    } else {
                        // FIX #1: Fork strands are dashed/thinner
                        const prevNode = forkNodes[index - 1];
                        const points = [prevNode.position, node.position];
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                        const lineMaterial = new THREE.LineDashedMaterial({ 
                            color: fork.color,
                            opacity: 0.4,          // FIX #1: More transparent
                            transparent: true,
                            linewidth: 1,          // FIX #1: Thinner
                            dashSize: 0.2,         // FIX #1: Dashed pattern
                            gapSize: 0.15
                        });
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        line.computeLineDistances(); // Required for dashed lines
                        scene.add(line);
                        filamentEdges.push(line);
                    }
                });
                
                // Add fork label
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 512;
                canvas.height = 128;
                context.fillStyle = '#' + fork.color.toString(16).padStart(6, '0');
                context.font = 'Bold 48px Arial';
                context.fillText(fork.name, 10, 64);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.copy(forkNodes[Math.floor(forkNodes.length / 2)].position);
                sprite.position.x += 2;
                sprite.scale.set(4, 1, 1);
                scene.add(sprite);
            });
            
            // Add main filament label
            const importCommit = state.commits.find(c => c.type === 'IMPORT');
            if (importCommit) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 512;
                canvas.height = 128;
                context.fillStyle = '#00ff88';
                context.font = 'Bold 48px Arial';
                context.fillText('MAIN', 10, 64);
                context.font = '32px Arial';
                context.fillText(`${state.commits.length} commits`, 10, 108);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.copy(commitNodes[0].position);
                sprite.position.y += 1.5;
                sprite.scale.set(4, 1, 1);
                scene.add(sprite);
            }
            
            console.log(`Rendered: 1 main filament + ${state.forks.length} fork(s)`);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PROXIMITY REVEAL SYSTEM: Replace view buttons with distance-based lenses
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const proximityAnchors = {
            activeSheet: null,      // Nearest sheet position
            history: null,          // History spiral center
            tree: new THREE.Vector3(0, -8, 0)  // Tree root
        };
        
        const proximityThresholds = {
            sheetLens: { near: 10, far: 25 },
            gridOverlay: { near: 8, far: 18 },
            historyLens: { near: 20, far: 45 }
        };
        
        // Smoothstep helper for smooth fades
        function smoothstep(edge0, edge1, x) {
            const t = THREE.MathUtils.clamp((x - edge0) / (edge1 - edge0), 0, 1);
            return t * t * (3 - 2 * t);
        }
        
        // Apply proximity reveal (called every frame)
        function applyProximityReveal() {
            if (!camera) return;
            
            // Find nearest sheet anchor
            let nearestSheet = null;
            let nearestSheetDist = Infinity;
            
            commitNodes.forEach(node => {
                if (node.userData?.nodeData?.type === 'sheet') {
                    const dist = camera.position.distanceTo(node.position);
                    if (dist < nearestSheetDist) {
                        nearestSheetDist = dist;
                        nearestSheet = node;
                    }
                }
            });
            
            // Update active sheet anchor
            if (nearestSheet) {
                proximityAnchors.activeSheet = nearestSheet.position;
                
                // Calculate sheet reveal factor (0 = far, 1 = near)
                const dSheet = nearestSheetDist;
                const sheetReveal = 1 - smoothstep(
                    proximityThresholds.sheetLens.near, 
                    proximityThresholds.sheetLens.far, 
                    dSheet
                );
                
                // Apply to sheet elements
                nearestSheet.traverse((child) => {
                    // Sheet fill: becomes more opaque when near
                    if (child.userData?.isSheetFill && child.material) {
                        child.material.opacity = 0.20 + (sheetReveal * 0.40);  // 0.20 â†’ 0.60
                    }
                    
                    // Cells: scale up slightly when near
                    if (child.userData?.isCell) {
                        const baseScale = 1.0;
                        const targetScale = baseScale + (sheetReveal * 0.3);  // 1.0 â†’ 1.3
                        child.scale.setScalar(targetScale);
                        
                        // Also increase opacity
                        if (child.material) {
                            child.material.opacity = 0.5 + (sheetReveal * 0.3);  // 0.5 â†’ 0.8
                        }
                    }
                });
                
                // TODO: Grid overlay (2D HTML) - requires DOM element
                // const gridOverlay = document.getElementById('gridOverlay');
                // if (gridOverlay) {
                //     gridOverlay.style.opacity = sheetReveal * 0.9;
                //     gridOverlay.style.pointerEvents = sheetReveal > 0.6 ? 'auto' : 'none';
                // }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // DISTANCE-AWARE LABELS: Update text based on camera distance
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                const labelDist = camera.position.distanceTo(nearestSheet.position);
                
                // Find label sprite for this sheet
                const labelSprite = commitNodes.find(node => 
                    node.userData?.isLabel && 
                    node.userData?.nodeLabel === nearestSheet.userData.nodeData?.label
                );
                
                if (labelSprite && labelSprite.material?.map) {
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 512;
                    canvas.height = 128;
                    context.fillStyle = '#ffffff';
                    context.textAlign = 'center';
                    
                    // Far distance (> 20): Name only
                    if (labelDist > 20) {
                        context.font = 'bold 32px Arial';
                        context.fillText(labelSprite.userData.nodeLabel, 256, 64);
                    }
                    // Mid distance (10-20): Name + ERI
                    else if (labelDist > 10) {
                        context.font = 'bold 32px Arial';
                        context.fillText(labelSprite.userData.nodeLabel, 256, 44);
                        if (labelSprite.userData.eri !== null) {
                            context.font = 'normal 24px Arial';
                            context.fillText(`ERI ${labelSprite.userData.eri}`, 256, 80);
                        }
                    }
                    // Close distance (< 10): Name + ERI + Details
                    else {
                        context.font = 'bold 28px Arial';
                        context.fillText(labelSprite.userData.nodeLabel, 256, 35);
                        if (labelSprite.userData.eri !== null) {
                            context.font = 'normal 22px Arial';
                            context.fillText(`ERI ${labelSprite.userData.eri}`, 256, 65);
                        }
                        if (labelSprite.userData.driftCount > 0) {
                            context.font = 'normal 18px Arial';
                            context.fillStyle = '#ff6666';
                            context.fillText(`${labelSprite.userData.driftCount} drifts`, 256, 95);
                        }
                    }
                    
                    // Update texture
                    labelSprite.material.map.image = canvas;
                    labelSprite.material.map.needsUpdate = true;
                }
            }
            
            // TODO: History spiral reveal (when history is implemented)
            // const dHistory = camera.position.distanceTo(proximityAnchors.history);
            // const historyReveal = 1 - smoothstep(
            //     proximityThresholds.historyLens.near,
            //     proximityThresholds.historyLens.far,
            //     dHistory
            // );
        }
        
        let lastTime = performance.now();
        
        function animate3D() {
            animationId = requestAnimationFrame(animate3D);
            
            const now = performance.now();
            let dt = (now - lastTime) / 1000;  // Convert to seconds
            lastTime = now;
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PROXIMITY REVEAL: Apply distance-based lenses every frame
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            applyProximityReveal();
            
            // FIX 4: Clamp dt (prevents jumps after tab switch or frame drops)
            dt = Math.min(dt, 1 / 30);  // max 33ms
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // CANONICAL FLIGHT UPDATE (Mode A: world-up, no roll)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (window.updateFlight) {
                window.updateFlight(dt);
            }
            
            // FIX 3: Clamp pitch every frame (prevents extreme flipping)
            if (typeof clampPitch === 'function') {
                clampPitch();
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸ”’ PHASE 2B: Update boundary visibility (stage-gated + altitude check)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            updateBoundaryVisibility();
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // CANONICAL: Sheets are perpendicular to branch (no billboard)
            // Looking down branch = looking at sheet front (per reference model)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('filamentView');
            if (container && renderer) {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
        }

        function resetCamera() {
            camera.position.set(0, 5, 20);
            camera.lookAt(0, 0, 0);
            if (controls) {
                controls.target.set(0, 0, 0);
                controls.update();
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CAMERA PRESETS - CINEMATIC TRANSITIONS (Per RenderSpec)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function setBranchSectionView() {
            // Top-down view to see branch cross-section (pressure rings)
            animateCameraTo(
                new THREE.Vector3(0, 30, 0),  // position
                new THREE.Vector3(0, 0, 0),   // target
                800                            // duration ms
            );
            console.log('ğŸŒ³ Branch Section View - Pressure rings visible from above');
        }
        
        function setTrunkWalkView() {
            // Slow dolly down the branch (cinematic)
            animateCameraTo(
                new THREE.Vector3(2, 0, 15),  // Side view along trunk
                new THREE.Vector3(0, -5, 0),  // Looking down trunk
                1200                           // slower transition
            );
            console.log('ğŸš¶ Trunk Walk View - Cinematic dolly along branch');
        }
        
        function setLeafInspectView() {
            // Sheet endpoint close-up
            if (state.selectedSheetNode) {
                const pos = state.selectedSheetNode.position;
                animateCameraTo(
                    new THREE.Vector3(pos.x + 3, pos.y + 1, pos.z + 3),
                    new THREE.Vector3(pos.x, pos.y, pos.z),
                    800
                );
                console.log('ğŸ” Leaf Inspect View - Sheet endpoint close-up');
            } else {
                animateCameraTo(
                    new THREE.Vector3(3, -8, 8),
                    new THREE.Vector3(0, -9, 0),
                    800
                );
            }
        }
        
        // Smooth camera animation helper
        function animateCameraTo(targetPosition, targetLookAt, durationMs) {
            if (!camera || !controls) return;
            
            const startPosition = camera.position.clone();
            const startTarget = controls.target.clone();
            const startTime = performance.now();
            
            function easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }
            
            function animate() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / durationMs, 1);
                const eased = easeOutCubic(progress);
                
                camera.position.lerpVectors(startPosition, targetPosition, eased);
                controls.target.lerpVectors(startTarget, targetLookAt, eased);
                controls.update();
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }
            
            animate();
        }

        let currentViewMode = 'grid';
        let formulaLensEnabled = false;  // FIX 3: Formula edges only visible in lens mode
        let selectedCellForFormula = null;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // RENDER GRAPH LENS - Branch Trajectories + Dependency Graph
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function renderGraphLens() {
            console.log('ğŸ“ˆ Rendering Graph Lens...');
            
            // 1. RENDER BRANCH METRICS CARDS
            const metricsDisplay = document.getElementById('branchMetricsDisplay');
            metricsDisplay.innerHTML = '';
            
            Object.keys(state.branchMetrics).forEach(branchId => {
                const metrics = state.branchMetrics[branchId];
                const current = metrics.currentState;
                const regression = metrics.regression;
                
                const card = document.createElement('div');
                card.style.cssText = `
                    background: #151a20;
                    border: 2px solid ${branchId === 'MAIN' ? '#00ff88' : '#88aaff'};
                    border-radius: 8px;
                    padding: 15px;
                    min-width: 250px;
                    font-family: 'Courier New', monospace;
                    color: #ffffff;
                `;
                
                card.innerHTML = `
                    <h3 style="margin: 0 0 10px 0; color: ${branchId === 'MAIN' ? '#00ff88' : '#88aaff'};">
                        ${branchId === 'MAIN' ? 'ğŸŒ³' : 'ğŸ”€'} ${branchId}
                    </h3>
                    <div style="font-size: 12px; line-height: 1.6;">
                        <div><strong>Cost:</strong> $${current.cost.toLocaleString()}</div>
                        <div><strong>ERI:</strong> ${current.eri} ${current.eri >= 80 ? 'ğŸŸ¢' : current.eri >= 50 ? 'ğŸŸ¡' : 'ğŸ”´'}</div>
                        <div><strong>Risk:</strong> ${(current.risk * 100).toFixed(1)}%</div>
                        <div><strong>Heat:</strong> ${current.heat.toFixed(2)}</div>
                        <div><strong>Pressure:</strong> ${current.pressure.toFixed(2)}</div>
                        <div><strong>Rain:</strong> ${current.rain.toFixed(2)}</div>
                        <hr style="border-color: rgba(255,255,255,0.2); margin: 10px 0;">
                        <div style="color: #ffaa00;"><strong>Trend:</strong> ${regression.trend > 0 ? 'ğŸ“ˆ' : 'ğŸ“‰'} ${regression.trend.toFixed(2)}</div>
                        <div><strong>Velocity:</strong> ${regression.velocity > 0 ? '+' : ''}${regression.velocity}</div>
                        <div><strong>Acceleration:</strong> ${regression.acceleration > 0 ? '+' : ''}${regression.acceleration}</div>
                        <div style="margin-top: 8px; font-size: 10px; color: #888;">
                            Time points: ${metrics.timeSeries.length}
                        </div>
                    </div>
                `;
                
                metricsDisplay.appendChild(card);
            });
            
            // 2. PLOT BRANCH TRAJECTORIES ON CANVAS
            const canvas = document.getElementById('trajectoryCanvas');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.fillStyle = '#151a20';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = 'rgba(136, 170, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(50, canvas.height - 50);
            ctx.lineTo(canvas.width - 50, canvas.height - 50);
            ctx.moveTo(50, canvas.height - 50);
            ctx.lineTo(50, 50);
            ctx.stroke();
            
            // Axis labels
            ctx.fillStyle = '#ffffff';
            ctx.font = '14px Courier New';
            ctx.fillText('Time (commits)', canvas.width / 2 - 50, canvas.height - 10);
            ctx.save();
            ctx.translate(20, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Cost ($)', 0, 0);
            ctx.restore();
            
            // Plot each branch trajectory
            const branchColors = {
                'MAIN': '#00ff88',
                'Scenario A': '#ff6b6b',
                'Scenario B': '#ffd93d'
            };
            
            Object.keys(state.branchMetrics).forEach(branchId => {
                const metrics = state.branchMetrics[branchId];
                const timeSeries = metrics.timeSeries;
                
                if (timeSeries.length < 2) return;
                
                const color = branchColors[branchId] || '#88aaff';
                
                // Find max cost for scaling
                const maxCost = Math.max(...timeSeries.map(p => p.cost), 1);
                const scaleX = (canvas.width - 100) / Math.max(timeSeries.length - 1, 1);
                const scaleY = (canvas.height - 100) / maxCost;
                
                // Draw line
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                timeSeries.forEach((point, i) => {
                    const x = 50 + i * scaleX;
                    const y = canvas.height - 50 - (point.cost * scaleY);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                
                // Draw points
                timeSeries.forEach((point, i) => {
                    const x = 50 + i * scaleX;
                    const y = canvas.height - 50 - (point.cost * scaleY);
                    
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Draw legend
                const legendY = 80 + Object.keys(state.branchMetrics).indexOf(branchId) * 25;
                ctx.fillStyle = color;
                ctx.fillRect(canvas.width - 200, legendY, 20, 3);
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Courier New';
                ctx.fillText(branchId, canvas.width - 170, legendY + 5);
            });
            
            // 3. RENDER DEPENDENCY GRAPH
            const depGraphDisplay = document.getElementById('dependencyGraphDisplay');
            depGraphDisplay.innerHTML = '<h4 style="margin: 0 0 10px 0; color: #88aaff;">Formula Dependencies:</h4>';
            
            let hasGraphData = false;
            
            // Iterate through all bundles/sheets to find dependency graphs
            Object.values(state.bundles).forEach(bundle => {
                Object.values(bundle.sheets || {}).forEach(sheet => {
                    if (sheet.formulaGraph && sheet.formulaGraph.edges.length > 0) {
                        hasGraphData = true;
                        
                        depGraphDisplay.innerHTML += `<div style="margin-bottom: 10px;"><strong>${sheet.name}:</strong></div>`;
                        
                        sheet.formulaGraph.edges.forEach(edge => {
                            const fromCell = sheet.cells[edge.from];
                            const toCell = sheet.cells[edge.to];
                            
                            const edgeDiv = document.createElement('div');
                            edgeDiv.style.cssText = `
                                padding: 5px;
                                margin: 3px 0;
                                background: rgba(0, 255, 136, 0.1);
                                border-left: 3px solid #00ff88;
                                font-size: 11px;
                            `;
                            
                            edgeDiv.innerHTML = `
                                <span style="color: #88aaff;">${edge.from}</span>
                                â†’
                                <span style="color: #ffaa00;">${edge.to}</span>
                                ${toCell && toCell.formula ? `<span style="color: #888;"> (${toCell.formula})</span>` : ''}
                            `;
                            
                            depGraphDisplay.appendChild(edgeDiv);
                        });
                    }
                });
            });
            
            if (!hasGraphData) {
                depGraphDisplay.innerHTML += '<div style="color: #888; font-style: italic;">No formula dependencies detected yet. Import a file with formulas to see relationships.</div>';
            }
            
            console.log('âœ… Graph Lens rendered');
        }
        
        function switchView(view) {
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸ”’ PHASE 1 LOCK: Verify graph identity (no scene replacement)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (scene && sceneRootUUID && scene.uuid !== sceneRootUUID) {
                console.error('ğŸš¨ VIOLATION: Scene UUID changed!');
                console.error('   Expected:', sceneRootUUID);
                console.error('   Actual:', scene.uuid);
                throw new Error('One-graph rule violated: scene was replaced');
            }
            
            console.log('[Relay] âœ… View switch to:', view, '| graphBuildId:', graphBuildId, '(unchanged)');
            
            const gridView = document.getElementById('gridView');
            const filamentView = document.getElementById('filamentView');
            const graphView = document.getElementById('graphView');
            const gridBtn = document.getElementById('gridViewBtn');
            const sheetVolumeBtn = document.getElementById('sheetVolumeBtn');
            const filamentBtn = document.getElementById('filamentViewBtn');
            const scaffoldBtn = document.getElementById('scaffoldViewBtn');
            const graphBtn = document.getElementById('graphLensBtn');
            
            // Reset all buttons (if they exist - removed in Phase 2A)
            if (gridBtn) gridBtn.classList.remove('active');
            if (sheetVolumeBtn) sheetVolumeBtn.classList.remove('active');
            if (filamentBtn) filamentBtn.classList.remove('active');
            if (scaffoldBtn) scaffoldBtn.classList.remove('active');
            if (graphBtn) graphBtn.classList.remove('active');
            
            if (view === 'grid') {
                // Show 2D grid, hide 3D
                gridView.style.display = 'block';
                filamentView.style.display = 'none';
                filamentView.classList.remove('active');
                if (gridBtn) gridBtn.classList.add('active');
                currentViewMode = 'grid';
                
                // Hide FlightHUD in grid view
                const hud = document.getElementById('flightHUD');
                if (hud) hud.classList.remove('active');
                
                console.log('Switched to Grid View');
                
            } else if (view === 'volume') {
                // Show 3D sheet volume
                gridView.style.display = 'none';
                filamentView.style.display = 'block';
                filamentView.classList.add('active');
                if (sheetVolumeBtn) sheetVolumeBtn.classList.add('active');
                currentViewMode = 'volume';
                
                // Show FlightHUD in 3D view
                const hud = document.getElementById('flightHUD');
                if (hud) {
                    hud.classList.add('active');
                    if (typeof updateFlightHUD === 'function') updateFlightHUD();
                }
                
                console.log('Switching to Sheet Volume View...');
                
                // Initialize 3D view if not already done
                if (!renderer) {
                    console.log('Initializing 3D renderer...');
                    init3DView();
                } else {
                    console.log('Rendering sheet volume...');
                    renderSheetVolume();
                    onWindowResize();
                }
                
            } else if (view === 'filament') {
                // Show 3D filament helix
                gridView.style.display = 'none';
                filamentView.style.display = 'block';
                filamentView.classList.add('active');
                if (filamentBtn) filamentBtn.classList.add('active');
                currentViewMode = 'filament';
                
                // Show FlightHUD in 3D view
                const hud = document.getElementById('flightHUD');
                if (hud) {
                    hud.classList.add('active');
                    if (typeof updateFlightHUD === 'function') updateFlightHUD();
                }
                
                console.log('Switching to Filament View...');
                
                // Initialize 3D view if not already done
                if (!renderer) {
                    console.log('Initializing 3D renderer...');
                    init3DView();
                } else {
                    console.log('Re-rendering existing 3D scene...');
                    render3DFilament();
                    onWindowResize();
                }
                
            } else if (view === 'scaffold') {
                // Show Tree Scaffold (organizational structure)
                gridView.style.display = 'none';
                filamentView.style.display = 'block';
                filamentView.classList.add('active');
                if (scaffoldBtn) scaffoldBtn.classList.add('active');
                currentViewMode = 'scaffold';
                
                // Show FlightHUD in 3D view
                const hud2 = document.getElementById('flightHUD');
                if (hud2) {
                    hud2.classList.add('active');
                    if (typeof updateFlightHUD === 'function') updateFlightHUD();
                }
                
                console.log('Switching to Tree Scaffold View...');
                
                // Initialize 3D view if not already done
                if (!renderer) {
                    console.log('Initializing 3D renderer...');
                    init3DView();
                    
                    // ğŸ”’ CRITICAL FIX: Must call renderTreeScaffold after init!
                    console.log('Rendering tree scaffold (first load)...');
                    setTimeout(() => {
                        renderTreeScaffold();
                        console.log('[Relay] âœ… Tree Scaffold rendered after init');
                    }, 100);  // Small delay to ensure scene is ready
                } else {
                    console.log('Rendering tree scaffold...');
                    
                    // ğŸ”’ PHASE 2A: Show navigation HUD in 3D view
                    const navHud = document.getElementById('navHud');
                    if (navHud) navHud.style.display = 'block';
                    
                    // Reset camera to good viewing position for tree
                    if (camera) {
                        camera.position.set(0, 0, 20);  // In front of tree, looking at center
                        camera.lookAt(0, 0, 0);
                        console.log('[Relay] ğŸ“· Camera reset for Tree Scaffold view');
                        console.log('[Relay] ğŸ¥ Camera position:', camera.position);
                        console.log('[Relay] ğŸ¥ Camera looking at: (0, 0, 0)');
                    }
                    
                    if (renderer) {
                        console.log('[Relay] ğŸ–¼ï¸ Renderer size:', renderer.getSize(new THREE.Vector2()));
                        console.log('[Relay] ğŸ–¼ï¸ Canvas dimensions:', renderer.domElement.width, 'x', renderer.domElement.height);
                    }
                    
                    console.log('[Relay] ğŸŒ² Scene has', scene.children.length, 'total objects');
                    
                    // FORCE CANVAS VISIBILITY with bright border
                    if (renderer && renderer.domElement) {
                        renderer.domElement.style.display = 'block';
                        renderer.domElement.style.border = '5px solid #00ff00';  // Bright green border
                        renderer.domElement.style.zIndex = '100';
                        console.log('[Relay] ğŸ¨ Canvas forced visible with green border');
                    }
                    
                    // Add obvious text overlay
                    let debugOverlay = document.getElementById('debugTreeOverlay');
                    if (!debugOverlay) {
                        debugOverlay = document.createElement('div');
                        debugOverlay.id = 'debugTreeOverlay';
                        debugOverlay.style.cssText = `
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            font-size: 48px;
                            color: #00ff00;
                            background: rgba(0,0,0,0.8);
                            padding: 20px;
                            border: 3px solid #00ff00;
                            z-index: 9999;
                            pointer-events: none;
                        `;
                        debugOverlay.textContent = 'TREE SCAFFOLD VIEW ACTIVE';
                        filamentView.appendChild(debugOverlay);
                        console.log('[Relay] ğŸŸ¢ Debug overlay added');
                    }
                    debugOverlay.style.display = 'block';
                    
                    renderTreeScaffold();
                    onWindowResize();
                    
                    // Force a render immediately
                    if (renderer && scene && camera) {
                        renderer.render(scene, camera);
                        console.log('[Relay] ğŸ¬ Manual render triggered');
                    }
                    
                    relayUI.log("Tree Scaffold view ready - click canvas to fly", "ok");
                }
                
            } else if (view === 'graph') {
                // Show Graph Lens (branch trajectories + dependency graph)
                gridView.style.display = 'none';
                filamentView.style.display = 'none';
                graphView.style.display = 'block';
                if (graphBtn) graphBtn.classList.add('active');
                currentViewMode = 'graph';
                
                // Hide FlightHUD in graph view (2D canvas)
                const hud3 = document.getElementById('flightHUD');
                if (hud3) hud3.classList.remove('active');
                
                console.log('Switching to Graph Lens View...');
                renderGraphLens();
            }
            
            // ğŸ”’ PHASE 1 LOCK: Run topology lint after EVERY view switch
            setTimeout(() => {
                const lintResult = relayLintTopology(state);
                if (!lintResult.pass) {
                    console.error('ğŸš¨ TOPOLOGY VIOLATION AFTER VIEW SWITCH');
                }
            }, 100);  // Small delay to allow render to complete
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // 3D INTERACTION: Hover Handler (Timeboxes - Intent Without Authority)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let lastHoveredTimeboxId = null;
        
        window.addEventListener('mousemove', (event) => {
            if (currentViewMode !== 'scaffold' || !camera || !renderer) return;
            
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Check for timebox hover (branch timeboxes + micro-timeboxes)
            const timeboxIntersects = raycaster.intersectObjects(commitNodes.filter(obj => 
                obj.userData && (obj.userData.type === 'timebox' || obj.userData.type === 'microTimebox')
            ));
            
            // Reset all micro-timeboxes to default brightness
            commitNodes.forEach(node => {
                if (node.userData?.type === 'microTimebox' && node.material) {
                    const state = node.userData.state;
                    // Reset to default (dim)
                    if (state === 'VERIFIED') {
                        node.material.emissiveIntensity = 0.15;
                        node.material.opacity = 0.4;
                    } else if (state === 'DEGRADED') {
                        node.material.emissiveIntensity = 0.08;
                        node.material.opacity = 0.25;
                    } else {
                        node.material.emissiveIntensity = 0.05;
                        node.material.opacity = 0.15;
                    }
                }
            });
            
            if (timeboxIntersects.length > 0) {
                const hoveredObj = timeboxIntersects[0].object;
                const hoveredTimebox = hoveredObj.userData;
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // BRIGHTEN MICRO-TIMEBOX ON HOVER (segmentation, not jewelry)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if (hoveredTimebox.type === 'microTimebox' && hoveredObj.material) {
                    const state = hoveredTimebox.state;
                    // Brighten on hover
                    if (state === 'VERIFIED') {
                        hoveredObj.material.emissiveIntensity = 0.6;   // Bright on hover
                        hoveredObj.material.opacity = 0.8;
                    } else if (state === 'DEGRADED') {
                        hoveredObj.material.emissiveIntensity = 0.35;
                        hoveredObj.material.opacity = 0.6;
                    } else {
                        hoveredObj.material.emissiveIntensity = 0.2;
                        hoveredObj.material.opacity = 0.4;
                    }
                }
                
                // Format hover text based on type
                let hoverText;
                if (hoveredTimebox.type === 'microTimebox') {
                    // Micro-timebox hover
                    const commitStart = hoveredTimebox.commitRange[0];
                    const commitEnd = hoveredTimebox.commitRange[1];
                    hoverText = `â° ${hoveredTimebox.timeboxId} | commits ${commitStart}â€“${commitEnd} | ${hoveredTimebox.state} | conf ${hoveredTimebox.confidence.toFixed(2)}`;
                } else {
                    // Branch timebox hover (existing)
                    hoverText = `â° ${hoveredTimebox.timeboxId} | commits ${hoveredTimebox.commitCount} | drifts ${hoveredTimebox.openDrifts} | ERI ${hoveredTimebox.eriAvg}`;
                }
                
                relayUI.setPreview(hoverText);
                
                // Only update preview if hovering a different timebox (debounce)
                if (hoveredTimebox.timeboxId !== lastHoveredTimeboxId) {
                    lastHoveredTimeboxId = hoveredTimebox.timeboxId;
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // TIMEBOX HOVER: Show Commit Range + Causality Preview
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    const [startIdx, endIdx] = hoveredTimebox.commitRange;
                    const stateLabel = hoveredTimebox.confidence >= 80 ? 'VERIFIED' : 
                                      hoveredTimebox.confidence >= 60 ? 'DEGRADED' : 'INDETERMINATE';
                    
                    const stateIcon = hoveredTimebox.confidence >= 80 ? 'âœ“' : 
                                     hoveredTimebox.confidence >= 60 ? 'âš ' : '?';
                    
                    // Build preview text (this is "hover = intent without authority")
                    let previewText = `â° ${hoveredTimebox.timeboxId}`;
                    
                    // Add time range if available
                    if (hoveredTimebox.timebox?.timeRange) {
                        previewText += ` | ${hoveredTimebox.timebox.timeRange}`;
                    }
                    
                    previewText += ` | Commits ${startIdx}â€“${endIdx} (${hoveredTimebox.commitCount}) | ` +
                                  `${stateIcon} ${stateLabel}`;
                    
                    // Add boundary type indicator
                    if (hoveredTimebox.timebox?.boundaryType === 'MATERIAL_BOUNDARY') {
                        previewText += ` | ğŸ”¶ Material boundary`;
                    }
                    
                    // Add warnings for scars and drifts
                    if (hoveredTimebox.scarCount > 0) {
                        previewText += ` | ğŸ”´ ${hoveredTimebox.scarCount} refusal${hoveredTimebox.scarCount > 1 ? 's' : ''}`;
                    }
                    
                    if (hoveredTimebox.driftCount > 0) {
                        previewText += ` | âš¡ ${hoveredTimebox.driftCount} drift${hoveredTimebox.driftCount > 1 ? 's' : ''}`;
                    }
                    
                    // Show in Alive Log preview
                    relayUI.setPreview(previewText);
                }
            } else {
                // Not hovering any timebox - clear preview
                if (lastHoveredTimeboxId !== null) {
                    lastHoveredTimeboxId = null;
                    relayUI.setPreview("â€”");
                }
            }
        });
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // 3D INTERACTION: Click Handler (Timeboxes + Tree Nodes)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        window.addEventListener('click', (event) => {
            if (currentViewMode !== 'scaffold' || !camera || !renderer) return;
            
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            // Calculate mouse position in normalized device coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Check for timebox intersections FIRST (branch timeboxes + micro-timeboxes)
            const timeboxIntersects = raycaster.intersectObjects(commitNodes.filter(obj => 
                obj.userData && (obj.userData.type === 'timebox' || obj.userData.type === 'microTimebox')
            ));
            
            if (timeboxIntersects.length > 0) {
                const clickedTimebox = timeboxIntersects[0].object.userData;
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // TIMEBOX CLICK: Set Active Replay Window
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                console.log(`[Relay] â° Timebox clicked:`, clickedTimebox.timeboxId);
                
                state.activeTimeboxId = clickedTimebox.timeboxId;
                state.activeCommitRange = clickedTimebox.commitRange;
                
                // Filter visible commits to this timebox range
                const [startIdx, endIdx] = clickedTimebox.commitRange;
                const timeboxCommits = state.commits.slice(startIdx, endIdx);
                
                // Update Alive Log with timebox selection
                const stateLabel = clickedTimebox.state || 
                                  (clickedTimebox.confidence >= 80 ? 'VERIFIED' : 
                                   clickedTimebox.confidence >= 60 ? 'DEGRADED' : 'INDETERMINATE');
                
                // Format message based on timebox type
                let logMessage = `â° Timebox ${clickedTimebox.timeboxId} ACTIVE | ` +
                                 `Commits ${startIdx}â€“${endIdx} (${clickedTimebox.commitCount}) | ` +
                                 `${stateLabel}`;
                
                // Add additional metrics if available (branch timeboxes have these)
                if (clickedTimebox.scarCount !== undefined) {
                    logMessage += ` | Scars: ${clickedTimebox.scarCount}`;
                }
                if (clickedTimebox.driftCount !== undefined) {
                    logMessage += ` | Drifts: ${clickedTimebox.driftCount}`;
                }
                if (clickedTimebox.confidence !== undefined) {
                    logMessage += ` | Conf: ${clickedTimebox.confidence.toFixed(2)}`;
                }
                
                relayUI.log(logMessage, 'info');
                
                // TODO: Update inspector panel to show only commits in this timebox
                // TODO: Update HUD to show active timebox metadata
                
                return; // Don't process tree node clicks if timebox was clicked
            }
            
            // Check for intersections with tree nodes (sheets, branches)
            const intersects = raycaster.intersectObjects(commitNodes.filter(obj => 
                obj.userData && obj.userData.type === 'treeNode'
            ));
            
            if (intersects.length > 0) {
                const clickedNode = intersects[0].object.userData.nodeData;
                
                if (clickedNode.type === 'sheet') {
                    // Sheet endpoint clicked - show view options
                    console.log(`Sheet endpoint clicked: ${clickedNode.label}`);
                    state.selectedSheetNode = clickedNode;
                    
                    // Simple prompt for now (can be replaced with UI modal later)
                    const choice = confirm(
                        `${clickedNode.label}\nERI: ${clickedNode.eri}\nDrift: ${clickedNode.drift_count}\n\n` +
                        `Click OK for History Helix view\nClick Cancel for Sheet Volume view`
                    );
                    
                    if (choice) {
                        switchView('filament');
                    } else {
                        switchView('volume');
                    }
                }
            }
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SYSTEM INITIALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        console.log('\n');
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log('ğŸŒ³ RELAY FILAMENT SPREADSHEET - CANONICAL v1');
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log('Status: CANONICAL (cycle-safe, replay-safe, privacy-safe)');
        console.log('Flight Controls: Mode A (world-up, H=HOLD, R=return)');
        console.log('Commit Model: Typed commits + bundle model');
        console.log('Formula Physics: Dependency graph + topological sort');
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log('\n');
        console.log('ğŸ“Š READY: Import CSV or switch to 3D views');
        console.log('ğŸ® 3D Controls: Click canvas â†’ WASD/QE | H: HOLD | R: return | Esc: unlock');
        console.log('\n');
        
        // Initialize
        updateEnforcementStatus();
        
        // Simulate authority expiry
        setInterval(() => {
            updateEnforcementStatus();
            if (!hasAuthority() && state.data.length > 0) {
                renderGrid(); // Re-render to show locked cells
            }
        }, 10000); // Check every 10 seconds
        
        // Startup verification
        setTimeout(() => {
            const checks = {
                'DOM Ready': !!document.body,
                'XLSX Library': typeof XLSX !== 'undefined',
                'THREE.js Loaded': typeof THREE !== 'undefined',
                'State Initialized': !!state,
                'Grid Container': !!document.getElementById('grid'),
                'Flight HUD': !!document.getElementById('flightHUD'),
                'Drop Zone': !!document.getElementById('dropZone'),
                'File Input': !!document.getElementById('fileInput')
            };
            
            console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('ğŸ” RELAY SYSTEM CHECK:');
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            Object.entries(checks).forEach(([name, pass]) => {
                console.log(`  ${pass ? 'âœ…' : 'âŒ'} ${name}`);
                if (!pass) {
                    console.error(`     âš ï¸  ${name} is missing or failed to load!`);
                }
            });
            
            if (typeof XLSX !== 'undefined' && XLSX.version) {
                console.log(`  â„¹ï¸  XLSX version: ${XLSX.version}`);
            }
            
            const allPass = Object.values(checks).every(v => v);
            if (allPass) {
                console.log('\nğŸš€ RELAY SYSTEM ONLINE - Ready for Excel file import');
                console.log('   Drop an .xlsx or .csv file to begin\n');
                relayUI.log("System online - ready for Excel import", "ok");
                relayUI.setPreview("Drop .xlsx to import â†’ build Tree Scaffold");
            } else {
                console.error('\nâš ï¸ SYSTEM CHECK FAILED - Refresh page and check console\n');
                relayUI.log("System check failed - see console", "err");
                relayUI.setPreview("Error - check console (F12)");
            }
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
        }, 500);
    </script>
</body>
</html>
