# üîê Cybersecurity Model ‚Äî Security in a Truth-Preserving Substrate

**Version**: 1.0.0  
**Status**: Canonical Specification  
**Last Updated**: 2026-01-27

---

## üîí Core Principle

> **In traditional systems, security is perimeter defense. In Relay, security is evidence integrity, governance physics, and policy as geometry.**

---

## Table of Contents

1. [The Paradigm Shift](#the-paradigm-shift)
2. [New Threat Model](#new-threat-model)
3. [Relay-Specific Vulnerabilities](#relay-specific-vulnerabilities)
4. [Attack Vectors](#attack-vectors)
5. [Defense Mechanisms](#defense-mechanisms)
6. [Penetration Testing in Relay](#penetration-testing-in-relay)
7. [Discovery & Relationship Attacks](#discovery--relationship-attacks)
8. [Zero Trust in Relay](#zero-trust-in-relay)
9. [Audit & Forensics](#audit--forensics)
10. [Comparison: Traditional vs Relay](#comparison-traditional-vs-relay)
11. [Real-World Attack Scenarios](#real-world-attack-scenarios)
12. [Security Best Practices](#security-best-practices)
13. [FAQ](#faq)

---

## The Paradigm Shift

### Traditional Security Model

**Perimeter defense:**
- Firewalls protect network boundaries
- VPNs encrypt traffic
- ACLs (Access Control Lists) gate resources
- Users authenticate at entry points

**Assumptions:**
- Inside = trusted
- Outside = untrusted
- Authority = who has the keys

**Weaknesses:**
- Single point of breach ‚Üí full compromise
- No history of access (logs are mutable)
- Relationships are implicit (hidden in joins, AD groups)
- Trust is binary (access or no access)

---

### Relay Security Model

**Evidence-based trust:**
- Every action requires cryptographic evidence
- Every commit is immutable and auditable
- Gates are physics (cannot be bypassed without visible trace)
- Trust is graduated (Privacy Ladder: L0-L6)

**Assumptions:**
- Evidence = authority (not keys alone)
- History is immutable (cannot erase traces)
- Relationships are explicit (filament topology)
- Trust is contextual (distance + policy + permission)

**Strengths:**
- Breach is visible (anomalous commits)
- Audit trail is complete (replay reveals everything)
- Relationships are discoverable (topology is rendered)
- Trust is granular (per-locus, per-commit)

---

## New Threat Model

### Traditional Threats (Still Relevant)

1. **Network attacks** (still exist if Relay is networked)
   - DDoS
   - Man-in-the-middle
   - Packet sniffing

2. **Credential theft** (still possible)
   - Phishing
   - Keylogging
   - Social engineering

3. **Malware** (still a threat to client devices)
   - Ransomware
   - Spyware
   - Rootkits

**Relay's advantage:** Even if credentials are stolen, attacker's actions leave **immutable evidence**.

---

### New Threats (Relay-Specific)

1. **Evidence Forgery**
   - Can attacker fake evidence (typecheck/test results, approval signatures)?

2. **Gate Bypass**
   - Can attacker skip governance gates (approvals, reviews) by forking without SCAR?

3. **Presence Spoofing**
   - Can attacker fake presence to impersonate user activity?

4. **Lock Collision**
   - Can two actors simultaneously acquire locks on same locus?

5. **Policy Drift**
   - Can attacker backdate classification filaments to bypass validation?

6. **Replay Attacks**
   - Can attacker re-apply old commits out of order to create false state?

7. **Topology Poisoning**
   - Can attacker make dependency refs point to malicious commits?

8. **Privacy Ladder Bypass**
   - Can attacker see filaments at higher fidelity than policy allows?

9. **Commit Injection**
   - Can attacker inject commits into someone else's filament without detection?

10. **Evidence Tampering**
    - Can attacker modify evidence pointers after commit is created?

---

## Relay-Specific Vulnerabilities

### 1. Evidence Forgery

**Attack:** Attacker creates fake evidence (e.g., "tests passed" when they didn't).

**Example:**
```javascript
// ‚ùå ATTACK: Fake evidence
const commit = {
  op: 'CODE_COMMIT',
  payload: { code: 'malicious code' },
  evidence: {
    typecheck: { status: 'PASS', errors: [] },  // LIE
    tests: { status: 'PASS', passed: 100 }      // LIE
  }
};
```

**Mitigation:**
- **Cryptographic signatures** on evidence
- Evidence must be generated by trusted CI system
- Evidence includes hash of actual CI output (stored externally)
- Evidence is timestamped and signed by CI identity

```javascript
// ‚úÖ DEFENSE: Signed evidence
const commit = {
  op: 'CODE_COMMIT',
  payload: { code: '...' },
  evidence: {
    typecheck: {
      status: 'PASS',
      errors: [],
      signature: '0x1234...abcd',           // Signed by CI system
      ciIdentity: 'ci:github-actions',
      outputHash: 'sha256:9f86d081...',     // Hash of full CI log
      timestamp: 1738001234567
    }
  }
};

// Verification:
function verifyEvidence(evidence) {
  // 1. Check signature matches CI public key
  if (!verifyCryptoSignature(evidence.signature, CI_PUBLIC_KEY)) return false;
  
  // 2. Check outputHash matches actual CI logs
  const actualLogs = fetchCILogs(evidence.ciIdentity, evidence.timestamp);
  if (hash(actualLogs) !== evidence.outputHash) return false;
  
  return true;
}
```

---

### 2. Gate Bypass

**Attack:** Attacker skips required approval gate by forking and merging without SCAR.

**Example:**
```javascript
// ‚ùå ATTACK: Create branch, skip gate, merge
const mainBranch = getFilament('budget-2026');
const attackBranch = fork(mainBranch, commitIndex: 10);

// Add commit without approval gate
appendCommit(attackBranch, {
  op: 'BUDGET_INCREASED',
  payload: { amount: 1000000 },  // No approval!
});

// Attempt to merge back to main
merge(attackBranch, mainBranch);  // Should require GATE
```

**Mitigation:**
- **Gates are enforced at merge** (not just creation)
- Merge requires GATE commit with approval signatures
- Cannot merge without SCAR if branch diverges from policy

```javascript
// ‚úÖ DEFENSE: Gate enforced at merge
function attemptMerge(sourceBranch, targetBranch, actor) {
  // 1. Check if source branch has required gates
  const requiredGates = targetBranch.policy.mergeRequirements;
  
  for (const gate of requiredGates) {
    const gateCommit = findGateCommit(sourceBranch, gate.type);
    
    if (!gateCommit) {
      throw new Error(`Missing required gate: ${gate.type}`);
    }
    
    // Verify gate signatures
    if (!verifyGateSignatures(gateCommit, gate.requiredApprovers)) {
      throw new Error(`Gate ${gate.type} missing valid signatures`);
    }
  }
  
  // 2. If diverged, require SCAR
  if (branchHasDivergence(sourceBranch, targetBranch)) {
    const scarCommit = createSCARCommit(sourceBranch, targetBranch, actor);
    appendCommit(targetBranch, scarCommit);
  }
  
  // 3. Merge
  return merge(sourceBranch, targetBranch);
}
```

---

### 3. Presence Spoofing

**Attack:** Attacker fakes presence to impersonate user activity.

**Example:**
```javascript
// ‚ùå ATTACK: Fake presence
presenceService.heartbeat({
  userId: 'user:alice',  // Attacker claims to be Alice
  locusId: 'budget-2026:commit:42',
  timestamp: Date.now()
});
```

**Mitigation:**
- **Presence requires cryptographic signature**
- Each heartbeat must be signed by user's private key
- Server verifies signature before accepting presence

```javascript
// ‚úÖ DEFENSE: Signed presence
function heartbeat(userId, locusId, signature) {
  // 1. Verify signature
  const message = `${userId}|${locusId}|${Date.now()}`;
  const publicKey = getUserPublicKey(userId);
  
  if (!verifyCryptoSignature(signature, message, publicKey)) {
    throw new Error('Invalid presence signature');
  }
  
  // 2. Accept presence
  presenceService.update({
    userId,
    locusId,
    timestamp: Date.now(),
    verified: true
  });
}
```

---

### 4. Lock Collision

**Attack:** Two actors simultaneously acquire locks on same locus.

**Example:**
```javascript
// ‚ùå ATTACK: Race condition
// Alice and Bob both acquire lock
const aliceLock = acquireLock('budget-2026:cell:A1');  // Succeeds
const bobLock = acquireLock('budget-2026:cell:A1');    // Also succeeds?!
```

**Mitigation:**
- **Atomic lock acquisition** (distributed lock service)
- Lock includes timestamp + cryptographic nonce
- Server rejects duplicate locks

```javascript
// ‚úÖ DEFENSE: Atomic locks
class DistributedLockService {
  constructor() {
    this.locks = new Map();  // In production: Redis, etcd, etc.
  }
  
  acquireLock(locusId, userId, ttl = 30000) {
    // Atomic check-and-set
    const existing = this.locks.get(locusId);
    
    if (existing && existing.expiresAt > Date.now()) {
      // Lock already held
      throw new Error(`Lock held by ${existing.userId}`);
    }
    
    // Acquire lock
    const lock = {
      locusId,
      userId,
      acquiredAt: Date.now(),
      expiresAt: Date.now() + ttl,
      nonce: crypto.randomBytes(32).toString('hex')
    };
    
    this.locks.set(locusId, lock);
    return lock;
  }
  
  releaseLock(locusId, userId, nonce) {
    const lock = this.locks.get(locusId);
    
    // Verify ownership
    if (!lock || lock.userId !== userId || lock.nonce !== nonce) {
      throw new Error('Cannot release lock: not owner');
    }
    
    this.locks.delete(locusId);
  }
}
```

---

### 5. Policy Drift

**Attack:** Attacker backdates classification filaments to bypass policy validation.

**Example:**
```javascript
// ‚ùå ATTACK: Backdate assignment to make posting look valid
const assignment = {
  filamentId: 'assign.costCenterToDept.CC-77',
  commits: [{
    ts: Date.parse('2025-01-01'),  // Backdated!
    op: 'ASSIGNMENT_CREATED',
    payload: { costCenter: 'CC-77', dept: 'Finance', effectiveDate: '2025-01-01' }
  }]
};

// Now posting in 2026 looks valid (references backdated assignment)
```

**Mitigation:**
- **Commits are timestamped and hashed at creation**
- Cannot change timestamp without invalidating hash
- Server validates commit timestamps are monotonic

```javascript
// ‚úÖ DEFENSE: Tamper-evident timestamps
function appendCommit(filament, commit) {
  // 1. Server assigns timestamp (not client)
  commit.ts = Date.now();
  
  // 2. Hash includes timestamp
  commit.hash = hash({
    filamentId: filament.id,
    commitIndex: filament.commits.length,
    ts: commit.ts,
    payload: commit.payload,
    parentHash: getLatestCommit(filament)?.hash || 'genesis'
  });
  
  // 3. Check monotonicity
  const latestCommit = getLatestCommit(filament);
  if (latestCommit && commit.ts < latestCommit.ts) {
    throw new Error('Timestamp must be >= previous commit');
  }
  
  filament.commits.push(commit);
  return commit;
}
```

---

### 6. Replay Attacks

**Attack:** Attacker re-applies old commits to create false state.

**Example:**
```javascript
// ‚ùå ATTACK: Replay old "approve" commit
const oldApproval = filament.commits[5];  // Old approval from 2025
appendCommit(filament, oldApproval);      // Replay in 2026!
```

**Mitigation:**
- **Commits include nonce** (unique, unpredictable value)
- Server rejects duplicate nonces
- Each commit references parent hash (breaks chain if replayed)

```javascript
// ‚úÖ DEFENSE: Nonce + chain integrity
function appendCommit(filament, commit) {
  // 1. Generate nonce
  commit.nonce = crypto.randomBytes(32).toString('hex');
  
  // 2. Reference parent
  const parent = getLatestCommit(filament);
  commit.parentHash = parent?.hash || 'genesis';
  
  // 3. Check for duplicate nonce
  const existingNonces = filament.commits.map(c => c.nonce);
  if (existingNonces.includes(commit.nonce)) {
    throw new Error('Duplicate nonce: commit already exists');
  }
  
  // 4. Verify chain integrity
  if (parent && hash(parent) !== commit.parentHash) {
    throw new Error('Parent hash mismatch: chain broken');
  }
  
  filament.commits.push(commit);
  return commit;
}
```

---

### 7. Topology Poisoning

**Attack:** Attacker makes dependency refs point to malicious commits.

**Example:**
```javascript
// ‚ùå ATTACK: Point to malicious upstream
const commit = {
  op: 'CODE_COMMIT',
  payload: { code: 'safe code' },
  refs: {
    inputs: [{
      filamentId: 'malicious-module',  // Evil module!
      commitIndex: 10
    }]
  }
};
```

**Mitigation:**
- **Dependency refs require evidence** (typecheck/import validation)
- Server validates referenced filaments exist and are accessible
- Downstream consumers verify dependency integrity before use

```javascript
// ‚úÖ DEFENSE: Validated dependencies
function appendCommitWithDeps(filament, commit) {
  // 1. Validate all dependency refs
  if (commit.refs?.inputs) {
    for (const ref of commit.refs.inputs) {
      // Check referenced filament exists
      const depFilament = getFilament(ref.filamentId);
      if (!depFilament) {
        throw new Error(`Dependency not found: ${ref.filamentId}`);
      }
      
      // Check commit index exists
      if (!depFilament.commits[ref.commitIndex]) {
        throw new Error(`Commit ${ref.commitIndex} not found in ${ref.filamentId}`);
      }
      
      // Check permission (can this filament reference that one?)
      if (!canReference(filament, depFilament)) {
        throw new Error(`No permission to reference ${ref.filamentId}`);
      }
    }
  }
  
  // 2. Append commit
  appendCommit(filament, commit);
}

// At consumption time:
function importModule(moduleFilamentId) {
  const module = getFilament(moduleFilamentId);
  const latestCommit = getLatestCommit(module);
  
  // Verify evidence (typecheck passed, no known vulnerabilities)
  if (!verifyEvidence(latestCommit.evidence)) {
    throw new Error(`Module ${moduleFilamentId} has invalid evidence`);
  }
  
  // Import
  return module;
}
```

---

### 8. Privacy Ladder Bypass

**Attack:** Attacker sees filament at higher fidelity than policy allows.

**Example:**
```javascript
// ‚ùå ATTACK: Render at L6 when policy only allows L3
const filament = getFilament('secret-project');
renderFilament(filament, { tier: 'L6' });  // Bypass policy!
```

**Mitigation:**
- **Server enforces tier** (client cannot override)
- Tier is computed server-side based on: policy + distance + permission
- Renderer only receives data allowed at computed tier

```javascript
// ‚úÖ DEFENSE: Server-side tier enforcement
function renderFilament(filamentId, viewerContext) {
  const filament = getFilament(filamentId);
  
  // 1. Compute allowed tier (server-side)
  const tier = resolveTier(
    filament.policy,
    viewerContext.distance,
    viewerContext.permissions
  );
  
  // 2. Filter data based on tier
  const filteredData = filterByTier(filament, tier);
  
  // 3. Send only filtered data to client
  return {
    tier,
    data: filteredData  // L0-L2: no face data, L3: types only, etc.
  };
}

// Client cannot bypass (data simply not sent)
```

---

### 9. Commit Injection

**Attack:** Attacker injects commits into someone else's filament.

**Example:**
```javascript
// ‚ùå ATTACK: Inject commit as Alice
const commit = {
  actor: { kind: 'user', id: 'user:alice' },  // Lie
  op: 'BUDGET_APPROVED',
  payload: { amount: 1000000 }
};

appendCommit(budgetFilament, commit);
```

**Mitigation:**
- **Server verifies actor identity** (not client-provided)
- Actor field is set by server based on authenticated session
- Commits are signed by actor's private key

```javascript
// ‚úÖ DEFENSE: Server-assigned actor
function appendCommitAuthenticated(filament, commitPayload, session) {
  // 1. Server assigns actor (cannot be spoofed)
  const commit = {
    actor: {
      kind: 'user',
      id: session.userId  // From authenticated session
    },
    ts: Date.now(),
    op: commitPayload.op,
    payload: commitPayload.payload,
    signature: null  // Will be signed by user's key
  };
  
  // 2. User signs commit (proves they authorized it)
  const signature = session.signCommit(commit);
  commit.signature = signature;
  
  // 3. Server verifies signature
  if (!verifyCommitSignature(commit, session.userId)) {
    throw new Error('Invalid commit signature');
  }
  
  // 4. Append
  appendCommit(filament, commit);
}
```

---

### 10. Evidence Tampering

**Attack:** Attacker modifies evidence pointers after commit is created.

**Example:**
```javascript
// ‚ùå ATTACK: Change evidence after commit
const commit = filament.commits[10];
commit.evidence.typecheck.status = 'PASS';  // Was 'FAIL'!
```

**Mitigation:**
- **Commits are immutable** (stored as Git blobs or content-addressed)
- Changing evidence breaks commit hash
- Server rejects commits with invalid hashes

```javascript
// ‚úÖ DEFENSE: Content-addressed storage
function storeCommit(filament, commit) {
  // 1. Compute hash of entire commit
  const commitHash = hash({
    filamentId: filament.id,
    commitIndex: commit.commitIndex,
    ts: commit.ts,
    actor: commit.actor,
    op: commit.op,
    payload: commit.payload,
    evidence: commit.evidence,
    parentHash: commit.parentHash
  });
  
  commit.hash = commitHash;
  
  // 2. Store by hash (content-addressed)
  storage.set(commitHash, commit);
  
  // 3. Reference by hash in filament
  filament.commits.push({ ref: commitHash });
  
  return commitHash;
}

// Verification:
function getCommit(commitHash) {
  const commit = storage.get(commitHash);
  
  // Verify hash matches content
  const recomputedHash = hash(commit);
  if (recomputedHash !== commitHash) {
    throw new Error('Commit tampered: hash mismatch');
  }
  
  return commit;
}
```

---

## Attack Vectors

### 1. Malicious Actor (Insider)

**Capabilities:**
- Has valid credentials
- Can create commits
- Can interact with filaments

**Attack strategies:**
- Evidence forgery
- Gate bypass (fork without approval)
- Lock abuse (hold locks indefinitely)
- Policy drift (backdate assignments)

**Defenses:**
- Cryptographic signatures on evidence
- Gates enforced at merge
- Lock TTLs + monitoring
- Timestamp validation

---

### 2. Compromised Credentials

**Capabilities:**
- Attacker has stolen keys/passwords
- Can impersonate user

**Attack strategies:**
- Commit injection (create commits as victim)
- Presence spoofing (fake activity)
- Unauthorized edits

**Defenses:**
- Multi-factor authentication
- Commit signing (separate key from login)
- Presence requires signature
- Activity monitoring (anomaly detection)

---

### 3. System Compromise (Server Breach)

**Capabilities:**
- Attacker has server access
- Can modify database
- Can inject/modify commits

**Attack strategies:**
- Rewrite history (change commits)
- Forge evidence
- Bypass all gates

**Defenses:**
- Immutable storage (Git-backed, content-addressed)
- External audit logs (blockchain, append-only log)
- Hash chain integrity checks
- Regular integrity audits

---

### 4. Supply Chain Attack

**Capabilities:**
- Attacker compromises upstream dependency
- Malicious code in imported filament

**Attack strategies:**
- Topology poisoning (point to evil modules)
- Evidence forgery (fake typecheck results)
- Trojan commits (malicious operations)

**Defenses:**
- Dependency validation (verify evidence)
- Sandboxed imports (isolate until verified)
- Cryptographic proofs (signed releases)
- Community review (governance)

---

## Defense Mechanisms

### 1. Cryptographic Evidence

**All evidence is signed:**
```javascript
evidence: {
  typecheck: { status: 'PASS', ... },
  signature: 'crypto_signature',
  signer: 'ci:github-actions',
  timestamp: 1738001234567
}
```

**Verification:**
- Check signature matches signer's public key
- Validate signer is trusted
- Ensure timestamp is reasonable

---

### 2. Gate Physics

**Gates cannot be bypassed:**
- Merge requires GATE commit
- GATE requires N signatures
- Signatures must be from authorized approvers

**Example:**
```javascript
policy: {
  mergeRequirements: [
    {
      gate: 'APPROVAL',
      requiredSignatures: 2,
      authorizedRoles: ['Manager', 'Director']
    }
  ]
}
```

---

### 3. Immutable History

**Commits are immutable:**
- Stored as content-addressed blobs
- Changing commit breaks hash
- Hash chain links parent commits

**Benefit:** Tampering is detectable.

---

### 4. Presence Verification

**Presence requires proof:**
- Signed heartbeat
- TTL-based expiration
- Anomaly detection (sudden presence spikes)

---

### 5. Lock Atomicity

**Locks are atomic:**
- Distributed lock service
- TTL prevents deadlocks
- Only one actor per locus

---

### 6. Policy as Code

**Policy is auditable:**
- Policy filaments are versioned
- Policy changes are commits
- Policy violations trigger alerts

---

## Penetration Testing in Relay

### Traditional Pen-Testing

**Goal:** Find holes in perimeter defenses.

**Techniques:**
- Port scanning
- Exploit known vulnerabilities
- Brute-force authentication
- SQL injection
- Privilege escalation

---

### Relay Pen-Testing

**Goal:** Test evidence integrity, gate enforcement, policy compliance.

**Techniques:**

#### 1. **Evidence Forgery Test**
Can you create a commit with fake evidence?

**Test:**
```javascript
// Attempt to forge evidence
const commit = {
  op: 'CODE_COMMIT',
  evidence: {
    typecheck: { status: 'PASS' },
    signature: 'fake_signature'
  }
};

// Expected: Server rejects (invalid signature)
```

---

#### 2. **Gate Bypass Test**
Can you merge without required approval?

**Test:**
```javascript
// Create branch, skip gate, attempt merge
const branch = fork(mainFilament, 10);
appendCommit(branch, { op: 'INCREASE_BUDGET' });
merge(branch, mainFilament);  // Should fail
```

---

#### 3. **Presence Spoofing Test**
Can you fake another user's presence?

**Test:**
```javascript
// Attempt to heartbeat as Alice
presenceService.heartbeat({
  userId: 'user:alice',
  locusId: 'budget:commit:42',
  signature: 'fake_signature'
});

// Expected: Server rejects (invalid signature)
```

---

#### 4. **Lock Collision Test**
Can two users lock the same locus?

**Test:**
```javascript
// User A acquires lock
const lockA = acquireLock('cell:A1', 'user:alice');

// User B attempts same lock
const lockB = acquireLock('cell:A1', 'user:bob');

// Expected: lockB throws error (lock already held)
```

---

#### 5. **Policy Drift Test**
Can you backdate commits to bypass policy?

**Test:**
```javascript
// Attempt to append commit with old timestamp
const commit = {
  ts: Date.parse('2020-01-01'),  // Backdate
  op: 'ASSIGNMENT_CREATED'
};

appendCommit(filament, commit);

// Expected: Server rejects (timestamp < latest commit)
```

---

#### 6. **Topology Poison Test**
Can you reference a malicious filament?

**Test:**
```javascript
// Create commit with ref to evil module
const commit = {
  op: 'CODE_COMMIT',
  refs: {
    inputs: [{ filamentId: 'evil-module', commitIndex: 0 }]
  }
};

appendCommit(filament, commit);

// Expected: Server validates dependency or consumer rejects at import
```

---

#### 7. **Privacy Bypass Test**
Can you see data at higher tier than allowed?

**Test:**
```javascript
// Request L6 data when policy only allows L3
const data = fetchFilament('secret-project', { tier: 'L6' });

// Expected: Server returns only L3 data
```

---

## Discovery & Relationship Attacks

### Traditional Discovery Attacks

**Active Directory enumeration:**
- Who is in what group?
- What permissions do they have?
- Hidden admin accounts?

**SQL injection:**
- What tables exist?
- What relationships (foreign keys)?
- Extract all data?

---

### Relay Discovery Model

**Relationships are explicit:**
- Topology is rendered (dependency rays)
- References are in commits (refs.inputs)
- Permissions are in policy filaments

**Discovery is governed by Privacy Ladder:**
- L0: Nothing visible
- L1: Coarse presence only
- L2: Structure (boxes, no content)
- L3: Types (categories, no data)
- L4: Blurred (system visible, data hidden)
- L5: Clear (read-only)
- L6: Engage (editable)

---

### "Pen-Testing" Discovery in Relay

**Test 1: Can you enumerate all filaments?**

**Traditional:** `SELECT * FROM users` (if SQL injection works)

**Relay:**
- Search API respects Privacy Ladder
- L0 filaments: Not in search results
- L1-L3: Limited metadata only
- L5-L6: Full searchability

**Attack:** Query search API, attempt to brute-force IDs

**Defense:** Rate limiting, policy enforcement, no sequential IDs

---

**Test 2: Can you discover hidden relationships?**

**Traditional:** `SELECT * FROM permissions WHERE user_id = 123`

**Relay:**
- Relationships are explicit (topology refs)
- But only visible if policy allows
- Private filaments ‚Üí no topology rays rendered

**Attack:** Inspect commit refs to find hidden dependencies

**Defense:** Refs are filtered by tier (only shown at L4+)

---

**Test 3: Can you infer private activity from presence?**

**Traditional:** Active Directory logs (who logged in when)

**Relay:**
- Presence respects visibility policy
- Private presence ‚Üí not shown
- Group presence ‚Üí only role/team visible

**Attack:** Monitor presence counts to infer activity patterns

**Defense:** Presence Tier 1 is counts only, Tier 2 requires permission

---

## Zero Trust in Relay

### Traditional Zero Trust

**Principles:**
1. Never trust, always verify
2. Assume breach (insider threat)
3. Least privilege access
4. Micro-segmentation

**Implementation:**
- VPN required
- MFA for all access
- Network segmentation
- Continuous monitoring

---

### Relay Zero Trust

**Principles:**
1. **Evidence is authority** (not credentials alone)
2. **Commits are proof** (immutable audit trail)
3. **Gates are physics** (cannot bypass without trace)
4. **Trust is graduated** (Privacy Ladder: L0-L6)

**Implementation:**

#### 1. **Every Action Requires Evidence**
- Commit must be signed by actor
- Evidence must be signed by CI
- Gates must have N signatures

#### 2. **Assume Credentials Compromised**
- Even with stolen keys, attacker leaves evidence
- Anomaly detection (unusual commit patterns)
- Commit signing separate from authentication

#### 3. **Least Privilege (Graduated)**
- Default: L0 (invisible)
- Promote: L1-L3 (discovery)
- Read: L5
- Write: L6 + lock + permission

#### 4. **Continuous Audit**
- Replay commits to verify integrity
- Check hash chain (no broken links)
- Monitor for anomalies (commit rate spikes, etc.)

---

## Audit & Forensics

### Traditional Forensics

**Challenges:**
- Logs can be deleted/modified
- No complete history
- Trust "source of truth" (database)

**Process:**
1. Collect logs (if not deleted)
2. Correlate events
3. Reconstruct timeline
4. Hope nothing was tampered with

---

### Relay Forensics

**Advantages:**
- History is immutable
- Every action is a commit
- Replay reveals exact sequence
- Hash chain proves integrity

**Process:**
1. **Replay commits** from genesis
2. **Verify hash chain** (no breaks)
3. **Check signatures** (evidence, gates, commits)
4. **Visualize in 3D** (see causality)

**Example:**
```javascript
// Forensic replay
function auditFilament(filamentId) {
  const filament = getFilament(filamentId);
  const issues = [];
  
  // 1. Verify hash chain
  let expectedParent = 'genesis';
  for (const commit of filament.commits) {
    if (commit.parentHash !== expectedParent) {
      issues.push({
        type: 'CHAIN_BREAK',
        commitIndex: commit.commitIndex,
        expected: expectedParent,
        actual: commit.parentHash
      });
    }
    expectedParent = commit.hash;
  }
  
  // 2. Verify signatures
  for (const commit of filament.commits) {
    if (!verifyCommitSignature(commit)) {
      issues.push({
        type: 'INVALID_SIGNATURE',
        commitIndex: commit.commitIndex
      });
    }
    
    if (commit.evidence && !verifyEvidenceSignature(commit.evidence)) {
      issues.push({
        type: 'INVALID_EVIDENCE',
        commitIndex: commit.commitIndex
      });
    }
  }
  
  // 3. Verify gates
  const mergeCommits = filament.commits.filter(c => c.op === 'MERGE');
  for (const merge of mergeCommits) {
    const requiredGates = filament.policy.mergeRequirements;
    for (const gate of requiredGates) {
      const gateCommit = findGateBeforeMerge(filament, merge.commitIndex, gate.type);
      if (!gateCommit) {
        issues.push({
          type: 'MISSING_GATE',
          mergeCommit: merge.commitIndex,
          gateType: gate.type
        });
      }
    }
  }
  
  return {
    filamentId,
    totalCommits: filament.commits.length,
    issues
  };
}
```

---

## Comparison: Traditional vs Relay

| Security Aspect | Traditional | Relay |
|----------------|-------------|-------|
| **Authority** | Who has keys | Who has evidence |
| **Trust Model** | Perimeter defense | Evidence-based |
| **Access Control** | ACLs, roles | Privacy Ladder (L0-L6) |
| **Audit Trail** | Mutable logs | Immutable commits |
| **Relationships** | Hidden (implicit) | Explicit (topology) |
| **Breach Detection** | Log analysis | Hash chain + anomaly |
| **Forensics** | Log correlation | Commit replay |
| **Zero Trust** | VPN + MFA | Evidence + graduated trust |
| **Pen-Testing** | Port scan, exploit | Evidence forgery, gate bypass |
| **Defense** | Firewall, IDS | Cryptographic signatures |

---

## Real-World Attack Scenarios

### Scenario 1: Malicious Insider

**Attacker:** Disgruntled employee with valid credentials.

**Goal:** Approve fraudulent budget increase without detection.

**Traditional attack:**
1. Use credentials to access ERP
2. Modify budget in database
3. Delete audit logs
4. Hope not detected

**Relay attack (and why it fails):**
1. ‚ùå Attempt to append commit without approval gate
   - **Fails:** Server requires GATE commit with N signatures
2. ‚ùå Attempt to fork, approve self, merge
   - **Fails:** GATE requires signatures from authorized roles (not self)
3. ‚ùå Attempt to backdate approval commit
   - **Fails:** Timestamp validation, hash chain breaks
4. ‚ùå Attempt to modify existing commit
   - **Fails:** Content-addressed storage, hash mismatch

**Result:** All attacks leave visible evidence. Audit replay reveals attempted gate bypass.

---

### Scenario 2: Compromised CI System

**Attacker:** Compromised GitHub Actions runner.

**Goal:** Inject malicious code with fake "tests passed" evidence.

**Traditional attack:**
1. CI runs malicious code
2. Fake test results in logs
3. Code merged to production

**Relay attack (and why it fails):**
1. ‚ùå Attempt to forge evidence signature
   - **Fails:** Evidence must be signed by trusted CI key (attacker doesn't have it)
2. ‚ùå Attempt to replace CI public key
   - **Fails:** Key registry is governance-controlled, requires GATE to change
3. ‚ùå Attempt to bypass evidence check
   - **Fails:** Downstream consumers verify evidence before import

**Result:** Malicious code rejected at import (invalid evidence).

---

### Scenario 3: Supply Chain Attack

**Attacker:** Compromised upstream dependency.

**Goal:** Get users to import malicious module.

**Traditional attack:**
1. Publish malicious npm package
2. Users install without verification
3. Malicious code runs

**Relay attack (and mitigation):**
1. Attacker publishes malicious module filament
2. ‚úÖ Relay users import: `import('malicious-module')`
3. ‚úÖ Import adapter verifies evidence:
   - Check typecheck evidence (was it signed by trusted CI?)
   - Check community reputation (any flags?)
   - Sandbox and test before use
4. ‚ùå If evidence is forged:
   - **Detected:** Signature mismatch
5. ‚úÖ If evidence is missing:
   - **Blocked:** Policy requires evidence for imports

**Result:** Malicious module detected or sandboxed. Users warned.

---

## Security Best Practices

### For Users

1. **Protect private keys** (commit signing keys)
2. **Verify evidence** before importing dependencies
3. **Review merge requests** visually (inspect geometry)
4. **Monitor presence** (unusual activity patterns)
5. **Set conservative policies** (default: L0, promote as needed)

---

### For Admins

1. **Enforce gate requirements** (N signatures for sensitive filaments)
2. **Rotate CI keys regularly** (evidence signing keys)
3. **Monitor anomalies** (commit rate spikes, unusual patterns)
4. **Run integrity audits** (hash chain verification)
5. **Secure lock service** (distributed, atomic, TTL-enforced)

---

### For Developers

1. **Sign all commits** (cryptographic proof of authorship)
2. **Attach valid evidence** (typecheck, tests, lint)
3. **Verify dependencies** (check evidence before import)
4. **Use least privilege** (don't request L6 unless needed)
5. **Test gate enforcement** (pen-test your policies)

---

## Deletion Is Forbidden ‚Äî Redaction Is Geometry

### Core Principle

> **"Nothing is deleted; visibility collapses. Deletion is a policy attack; redaction is a governed truth operation."**

---

### The Problem with Deletion

**Traditional systems:**
- `DELETE FROM users WHERE id = 123` (data gone forever)
- No audit trail
- No recovery
- Legal/regulatory risk

**Relay:** Deletion is **physically impossible** (commits are immutable, content-addressed).

---

### Redaction as Geometry

**When privacy/legal requires "forgetting":**

#### Option 1: Privacy Ladder Collapse
Change filament visibility policy:
```javascript
// Before: Public (L5)
filament.policy = { discoverability: 'L5' };

// After: Invisible (L0)
filament.policy = { discoverability: 'L0' };
```

**Result:**
- Filament still exists (audit trail preserved)
- No longer visible to public
- Ops/security can still see it (L5+)

---

#### Option 2: Payload Redaction
Create redaction commit:
```javascript
appendCommit(filament, {
  op: 'PAYLOAD_REDACTED',
  payload: {
    redactedFields: ['email', 'ssn', 'ipAddress'],
    redactionReason: 'GDPR Right to be Forgotten',
    redactedBy: 'user:legal-team',
    redactionDate: Date.now()
  },
  evidence: {
    legalBasis: 'GDPR Article 17',
    approvalSignature: '0x1234...'
  }
});
```

**Rendering:**
- Original commit visible (audit trail)
- Redaction commit visible (transparency)
- Redacted fields show `[REDACTED]` instead of value

---

#### Option 3: Cryptographic Erasure
Encrypt payload, destroy key:
```javascript
// Original commit (encrypted)
{
  payload: {
    encrypted: '0xabc123...',
    encryptionKey: 'key-id-567'  // Stored in key vault
  }
}

// Destroy key (makes payload unreadable)
keyVault.destroy('key-id-567');
```

**Result:**
- Commit still exists (audit trail)
- Payload unreadable (privacy preserved)
- Key destruction logged (governance)

---

### Legal Compliance

**GDPR Right to be Forgotten:**
- Use Option 2 (payload redaction)
- Redaction commit is itself evidence (compliance proof)

**HIPAA/PHI:**
- Use Option 3 (cryptographic erasure)
- Key destruction meets "secure deletion" requirement

**NIST 800-88 (Data Sanitization):**
- Use Option 3 (cryptographic erasure)
- Equivalent to "cryptographic erase" standard

---

### Anti-Pattern: Soft Delete

**Bad (traditional soft delete):**
```javascript
// Mark as deleted (but still in database)
UPDATE users SET deleted = true WHERE id = 123;
```

**Problems:**
- Data still readable (not truly deleted)
- No governance (who deleted? why?)
- No audit trail (can be un-deleted silently)

**Relay (proper redaction):**
```javascript
// Create redaction commit (governed, auditable)
appendCommit(userFilament, {
  op: 'USER_DEACTIVATED',
  payload: {
    reason: 'Account closure request',
    requestedBy: 'user:alice',
    approvedBy: 'user:legal-team'
  }
});

// Then redact sensitive fields
appendCommit(userFilament, {
  op: 'PAYLOAD_REDACTED',
  payload: {
    redactedFields: ['email', 'phone', 'address'],
    redactionReason: 'User request'
  }
});
```

---

## Simulation ‚â† Prediction ‚Äî AI Boundary Lock

### Core Principle

> **"AI never predicts truth. It proposes branches. Confidence scores do not replace gates."**

This protects Relay from becoming an **unaccountable oracle**.

---

### The Danger of AI "Prediction"

**Scenario:** AI predicts budget will exceed $1M.

**Traditional approach:**
```javascript
const prediction = aiModel.predict(budgetData);
if (prediction.confidence > 0.9) {
  database.update({ budgetForecast: prediction.value });  // ‚ùå Writes prediction as truth
}
```

**Problems:**
- Prediction treated as truth (no governance)
- No human accountability
- Confidence score bypasses approval

---

### Relay's Approach: AI Proposes, Humans Decide

**AI creates proposal branch:**
```javascript
// AI proposes increase (branch, not truth)
const proposalBranch = fork(budgetFilament, latestCommit);

appendCommit(proposalBranch, {
  op: 'AI_PROPOSED_INCREASE',
  payload: {
    proposedAmount: 1200000,
    currentAmount: 1000000,
    confidence: 0.92,
    reasoning: 'Historical trend + inflation forecast'
  },
  actor: { kind: 'ai', id: 'budget-forecaster-v2' },
  evidence: {
    model: 'gpt-4',
    inputData: '...',
    outputLog: '...'
  }
});

// GATE required to merge (human approval)
// No auto-merge based on confidence score
```

**Result:**
- AI's proposal is visible (transparency)
- AI's reasoning is auditable (evidence)
- Human gate required (accountability)
- Confidence score is context (not authority)

---

### AI Commit Rules

**1. AI cannot create truth directly**
- AI creates proposals (branches)
- Humans approve (gates)
- No "auto-commit" based on confidence

**2. AI actor is explicit**
```javascript
actor: { kind: 'ai', id: 'model-name-version' }
```

**3. AI evidence is mandatory**
```javascript
evidence: {
  model: 'gpt-4',
  inputData: '...',
  outputLog: '...',
  confidence: 0.92,
  temperature: 0.7
}
```

**4. Confidence ‚â† Authority**
- Confidence score is metadata (context)
- Gate signatures are authority (governance)

---

### Use Cases

**Valid: AI-Assisted Data Entry**
```javascript
// AI suggests classification (user reviews)
const suggestion = aiClassify(receipt);

// User reviews, edits, approves
const classification = userReview(suggestion);

// User commits (AI is tool, not actor)
appendCommit(receiptFilament, {
  op: 'CLASSIFIED',
  payload: { classification },
  actor: { kind: 'user', id: 'user:alice' },  // User is actor
  evidence: { aiSuggestion: suggestion }       // AI is evidence
});
```

**Valid: AI Anomaly Detection**
```javascript
// AI detects anomaly (creates failure filament)
const anomaly = aiDetectAnomaly(transactions);

// System creates alert filament
appendCommit(alertFilament, {
  op: 'ANOMALY_DETECTED',
  payload: { anomaly },
  actor: { kind: 'ai', id: 'fraud-detector-v1' },
  evidence: { confidence: 0.95, model: 'isolation-forest' }
});

// Human investigates, decides
// If fraud: create fraud filament + gate to freeze account
// If false positive: append ANOMALY_DISMISSED commit
```

**Invalid: AI Auto-Approval**
```javascript
// ‚ùå WRONG: AI bypasses gate
if (aiModel.confidence > 0.95) {
  appendCommit(budgetFilament, {
    op: 'BUDGET_APPROVED',  // ‚ùå No human gate!
    actor: { kind: 'ai', id: 'auto-approver' }
  });
}
```

---

## Observer Is Also a Filament ‚Äî Observation as Evidence

### Core Principle

> **"Observation itself leaves a trace. Not who observed (privacy-gated), but that something was inspected, that it drew attention, that it mattered."**

This is not surveillance. This is **forensic gravity**.

---

### Why Observation Matters

**Audit heat:**
- Which commits are inspected most? (risk signal)
- Which filaments are ignored? (blind spots)
- Which users are investigating what? (accountability)

**Institutional memory:**
- "This decision was heavily scrutinized"
- "This filament was never reviewed"
- "This commit drew attention after incident X"

---

### Observation Filaments

**When user inspects a commit:**
```javascript
// User hovers over commit 42
presenceService.heartbeat({
  userId: 'user:alice',
  locusId: 'budget-2026:commit:42',
  lensContext: 'audit'
});

// After threshold (e.g., 5s hover), create observation commit
if (inspectionTime > 5000) {
  appendCommit(observationFilament, {
    op: 'COMMIT_INSPECTED',
    payload: {
      targetFilament: 'budget-2026',
      targetCommit: 42,
      lensContext: 'audit',
      duration: 12000  // 12 seconds
    },
    actor: { kind: 'user', id: 'user:alice' },
    refs: {
      inputs: [{ filamentId: 'budget-2026', commitIndex: 42 }]
    }
  });
}
```

---

### Privacy-Governed Observation

**Observation visibility respects Privacy Ladder:**

**L0-L2:** No observation data visible  
**L3:** Aggregate observation counts (no identities)  
**L4:** Role-based observation ("Security team inspected")  
**L5:** Identified observation ("Alice inspected for 12s")  

**Example (L3 view):**
```
Commit 42: 15 observations (last 30 days)
```

**Example (L5 view):**
```
Commit 42 observations:
- Alice (audit, 12s, 2026-01-28)
- Bob (investigation, 45s, 2026-01-27)
- Legal team (compliance, 2m, 2026-01-26)
```

---

### Use Cases

**Audit Heat Map:**
```javascript
// Which commits drew most attention?
const heat = observationFilaments
  .filter(f => f.commits[0].payload.targetFilament === 'budget-2026')
  .reduce((acc, f) => {
    const commitId = f.commits[0].payload.targetCommit;
    acc[commitId] = (acc[commitId] || 0) + 1;
    return acc;
  }, {});

// Render in 3D: "Hot" commits glow brighter
```

**Blind Spot Detection:**
```javascript
// Which commits were never inspected?
const uninspected = budgetFilament.commits.filter(commit => {
  return !observationFilaments.some(obs =>
    obs.commits[0].payload.targetCommit === commit.commitIndex
  );
});

// ‚Üí "Commits 10-20 were never reviewed"
```

**Incident Correlation:**
```javascript
// Did anyone inspect the problematic commit before incident?
const incident = failureFilament.commits[0];
const targetCommit = incident.refs.inputs[0].commitIndex;

const priorObservations = observationFilaments.filter(obs =>
  obs.commits[0].payload.targetCommit === targetCommit &&
  obs.commits[0].ts < incident.ts
);

// ‚Üí "Bob inspected this commit 2 days before the failure"
```

---

### Anti-Pattern: Surveillance

**‚ùå Wrong (surveillance):**
```javascript
// Track everything user does
logUserAction('alice', 'viewed-page', '/budget');
logUserAction('alice', 'clicked-button', 'export');
logUserAction('alice', 'downloaded-file', 'budget.xlsx');
```

**‚úÖ Right (forensic gravity):**
```javascript
// Record significant inspection (thresholded)
if (inspectionDuration > threshold) {
  createObservationCommit({
    targetCommit: commitId,
    duration,
    lensContext: 'audit'  // Why inspecting
  });
}
```

**Key difference:**
- Surveillance tracks all actions (user is suspect)
- Forensic gravity tracks significant attention (commit is interesting)

---

## FAQ

### General

**Q: Is Relay more secure than traditional systems?**  
A: Relay has **different** security properties. It's more auditable (immutable history), but introduces new attack surfaces (evidence forgery, gate bypass). Security depends on correct implementation of cryptographic signatures, gate enforcement, and policy compliance.

**Q: What if the Relay server itself is compromised?**  
A: Relay uses **content-addressed storage** (Git-backed) and **hash chains**. Tampering breaks hashes. External audit logs (blockchain, append-only ledger) provide additional verification. Compromise is detectable.

**Q: Can Relay prevent insider threats?**  
A: No system can fully prevent insiders. Relay makes insider actions **auditable** and **visible**. Anomaly detection can flag unusual commit patterns. Gates prevent unauthorized actions from succeeding without trace.

---

### Cryptography

**Q: What cryptographic primitives does Relay use?**  
A: 
- **Signatures**: Ed25519 (commit signing, evidence signing, presence verification)
- **Hashing**: SHA-256 (content addressing, hash chains)
- **Nonces**: Crypto-secure random (replay prevention)

**Q: Are commits encrypted?**  
A: By default, no (commits are auditable truth). Private filaments can use **encrypted payloads** where payload is encrypted with policy-controlled keys. Evidence and metadata remain unencrypted (for audit).

---

### Policy

**Q: Who sets privacy policies?**  
A: Filament owner (usually creator). For governance filaments, policy is voted on. For personal files, user sets policy.

**Q: Can policy be changed retroactively?**  
A: Policy changes are **commits** (versioned). Changing policy doesn't affect historical commits (immutable). New policy applies to future access only.

---

## Conclusion

Cybersecurity in Relay is fundamentally different:

**Traditional:** Perimeter defense, mutable logs, implicit trust  
**Relay:** Evidence integrity, immutable history, graduated trust

**New vulnerabilities:**
- Evidence forgery
- Gate bypass
- Presence spoofing
- Lock collision
- Policy drift
- Replay attacks
- Topology poisoning

**New defenses:**
- Cryptographic signatures
- Gate physics (cannot bypass)
- Immutable history (hash chains)
- Privacy Ladder (graduated trust)
- Presence verification
- Atomic locks

**Pen-testing shifts from:**
- "Can I break in?" ‚Üí "Can I forge evidence?"
- "Can I escalate privileges?" ‚Üí "Can I bypass gates?"
- "Can I hide my tracks?" ‚Üí "Can I replay commits?"

**The One-Sentence Lock:**

> **In Relay, security is not about walls‚Äîit's about evidence integrity, governance physics, and policy as geometry, where every action leaves an immutable, auditable trace.**

---

**See Also:**
- [Universal Import Spec](UNIVERSAL-IMPORT-SPEC.md)
- [Privacy Ladder Spec](PRIVACY-LADDER-SPEC.md)
- [Filament System Overview](FILAMENT-SYSTEM-OVERVIEW.md)

---

*Last Updated: 2026-01-27*  
*Status: Canonical Specification*  
*Version: 1.0.0*
