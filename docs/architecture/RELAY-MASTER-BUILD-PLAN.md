# Relay Master Build Plan — 2026-02-17

---

### Dedication

To my brother — who built the backend, taught me branching and HRD discipline, and showed me that preserving truth and state matters in more ways than one. You gave me the foundation. This is what I built on it.

And to everyone in the world whose work, language, and history made this possible. Every equation in this document stands on the shoulders of people who came before us and built something worth preserving.

For the generations who will inherit what we build — may you never lose your state.

— Eitan Asulin, Founder

---

**The complete specification for Relay — a living 3D world built on the real Earth, where everything humanity does becomes visible, accountable, and permanent.**

This document is written for two audiences at once. If you are a parent, a business professional, or someone who has never seen a line of code — read it straight through. Every section begins with what it means for you. If you are an engineer building the system — the full technical specification follows every introduction. Both audiences read the same document because Relay does not separate understanding from implementation.

---

## Table of Contents

**Part I — The Physical Model (What You See)**
- §0. What Relay Is
  - §0.5 The Eight Edges of Livability (Contract #305)
- §1. The Globe
- §2. The Trunk
- §3. The Branch — Cylindrical Coordinate Model
- §4. The Filament — Row-Level Atomic Event
  - §4.8 STABILITY_CONFIRMED — Inaction as Valid Resolution (Contract #307)
- §5. Notes — The Unified Ephemeral Layer
- §6. Projection Branches — Visible Data Pipelines
- §7. The Social Layer
- §8. The User Tree — Personal Responsibility Mirror

**Part II — Physics & Governance (How It Moves)**
- §9. Confidence Physics — Automatic Evidence Ratio
- §10. Pressure Physics — Structural Integrity Forces
  - §10.4 Turgor Pressure — The Biological Foundation
- §11. Parametric Governance — Votable System Constants
- §12. Filter Tolerances — Personal Visibility Slidebars
- §13. Stigmergic Coordination — Self-Assignment Through Visibility
- §14. Gravitational Time — The Universal Clock
- §15. Time Scrubbing — Replay as Navigation

**Part III — Intelligence & Presence (Who Is Watching)**
- §16. AI and SCV — Filament 3D Cognition
- §17. Presence System — The Attention Sensor Network
- §18. Flow Channels — Recorded Procedures
- §19. Governance
  - §19.4 Soft Divergence — Non-Blocking Disagreement (Contract #306)
  - §19.5 Cooling Windows — Time as Safety Primitive (Contract #306)
- §20. Cryptographic Architecture

**Part IV — Configuration & Rendering (How It Looks)**
- §21. Templates — Domain Configuration
- §22. Fractal Scaling
- §23. Weather and Wind — Emergent Atmospheric Analytics
- §24. Search in 3D
- §25. 2D/Headless Parity
- §26. Frozen Contracts
- §27. Current Build Status
- §28. Worked Example — One Invoice Through the Full Trace

**Part V — Physical World Integration (Where You Are)**
- §29. Proximity Channels
- §30. Verification Physics
- §31. Accounting Packets
- §32. Stable ID Construction Law
- §33. LOD Rendering Contract

**Part VI — Use Cases & Migration (What It Replaces)**
- §34. Use Case — Software Development on Relay
- §35. Use Case — Municipal Services
- §36. Use Case — Astronomy
- §37. Knowledge Migration Lifecycle — From 2D Internet to 3D Tree
- §38. Module Discovery Architecture

**Part VII — Game Layer & Arena (Where Play Meets Reality)**
- §39. AR Interaction & Personal Achievement Modules (video presence, physical objects, light comm, **body interface, branch pull, palm line ledger & personal gesture cipher**, achievements, detection mesh, **video conferencing & camera awareness** Contract #318)
- §40. The Game Layer — Quests, Monsters, and Genre Overlays
- §41. Multi-Resource Economy
  - §41.10 The User Wallet — What You Carry (Contract #313)
- §42. Duels — Governance Theater & Public Combat Events
- §43. Spell Taxonomy — Element Detection & Physical Magic
  - §43.10 Weapon Taxonomy — The Way of the Flowering Humanhood (Contract #299)
    - §43.10.7 Command Precision Index (CPI) — Universal Combat Metric
    - §43.10.8 Open Input Device Protocol — Any Object Is a Weapon
    - §43.10.9 Sound as Magic — The Bard Archetype
    - §43.10.10 Extended Weapon Classes — Ranged, Electronic, Improvised
    - §43.10.11 The Final Fantasy Principle — No Class Is Weak
    - §43.10.12 Signal Architecture — Commands vs. Power
    - §43.10.13 Regional & Global Weapon Bonuses — Parametric Governance
    - §43.10.14 Kinetic Input Rate (KIR) — Movement as Power Generation (Contract #319)
  - §43.11 Graphic Crafting Module — Build Your Own Visual Language (Contract #311)
  - §43.12 Summon Cards — AI Creatures & Multi-Intelligence Combat (Contract #312)
- §44. Founder Key — Global Game Layer Activation Primitive
- §45. Frozen Contracts — Module Mechanics + Constitutional Hardening

**Part VIII — Justice, Voice & Engineering (How It Runs)**
- §46. Sortition-Based Case Resolution
- §47. Voice Input Pipeline — Whisper, Architect, Canon
- §48. Engineering Infrastructure — How the System Runs
- §49. Adversarial Edge-Case Model
- §50. Camera Controller (6DOF flight model, keybinds, panel lock, underground flight, modes, **camera tick safety contract**)

**Part IX — Business & Professional Tools (How Work Works)**
- §51. Key File References
- §52. Business Artifact Mapping — Slides Are Dead
- §53. Compartmentalized Accounting & Atomic Traceability
- §54. Business Process Catalog
- §55. Live Confidence Overlay & Public Proceedings
- §56. Language Trees & Multi-Language Learning
- §57. Adoption Tiers & Backwards Compatibility

**Part X — Education, Media & Rights (How Society Learns)**
- §58. Education — The Internal Adventure
- §59. Media & Content Circulation
- §60. Fractal Branching — Any Branch Can Host a Full Tree
- §61. Privacy Sovereignty & Civic Enforcement
- §62. Universal Accessibility — The Tree for Every Body
  - §62.8 UI Internationalization — The Interface Speaks Every Language (Contract #310)
- §63. Child Safety & Parental Governance
  - §63.7 Protected Participation Profiles — Beyond Age (Contract #308)
- §64. Voice-Driven Development — Every User Is a Developer

**Part XI — Infrastructure & Storage (How Data Lives)**
- §65. Platform Compliance & Content Safety
- §66. Microsharding & Decentralized Storage Economy
- §67. Automated Business Continuity & Disaster Recovery
- §68. Arena Branches — Bounded Volatility & Crowd-Driven Randomness
  - §68.20 Physical Sport Arenas — Paintball as Battle Training (Contract #320)
- §69. Boundary Editing & Geographic Border Governance
- §70. V93 Retained Systems — Architectural Integration Index
- §71. Architectural Clarifications

**Part XII — Civilization Coverage (How Society Works)**
- §72. Layered Option Governance — Bottom-Up Ballot Creation (4-layer constitutional engine)
  - §72.11 Procedural Governance Template — Council Meeting as Ritualized Structure (Contract #300)
  - §72.12 Global & Regional Content Classification — The Oblivion Threshold (Contract #315)
- §73. Universal Onboarding — Three Pillars
- §74. Traffic & Civic Response Module (RELAY-CIVIC-1)
- §74b. Vehicular Proximity Mesh (RELAY-TRAFFIC-SOCIAL-1)
  - §74b.1 Vehicle as Mobile Proximity Channel
  - §74b.2 Broadcast & Social Layer — Traffic as Conversation
  - §74b.3 Backseat Mode — The Rolling Social Playground
  - §74b.4 Crowd-Sourced Navigation — The Traffic Tree
  - §74b.5 Safety Mesh — Opt-In Hashed Plate Protocol
  - §74b.6 Driver Safety — The Driver Mode Contract
- §75. Physical Weather Layer
- §76. Civilization Template Library (companion: [RELAY-CIVILIZATION-TEMPLATE-LIBRARY.md](RELAY-CIVILIZATION-TEMPLATE-LIBRARY.md))
- §77. Product Supply Chain Traceability — Mineral to Shelf
- §78. Filament Length Ontology — Structural Weight from Commit Topology
- §79. Quote Attribution & Open Annotation
- §80. Genesis Record — Founder Initiation & Development Archive (companion: [RELAY-DEVELOPMENT-TREE-MAP.md](RELAY-DEVELOPMENT-TREE-MAP.md))
- §81. Operational Hardening (filament kinds, **structural compression/heartwood**, basin normalization, silence-stability doctrine (formalized 4-state machine), offline merge, lens invariant, template version bridges, **TemplateResolvedSpec**, minority alarm, conceptual LOD, first-screen contract, **small tree mode/offline genesis**, **Relay Lite progressive loading**)
  - §81.9.2 Relay Lite Entry Spec — Progressive Loading Architecture (Contract #316)
- §82. Three-Layer Ontology — Wood, Leaf, Sap (LeafPacket schema, SapPacket schema, promotion/checkpoint rules, **promotion anti-gaming gate**, demotion stress test, **classification matrix**, visual rendering, **canon summarization discipline**)
  - §82.7b Canon Summarization Discipline — Summaries Are Projection, Never Truth (Contract #307)
- §83. Energy Budget — Photosynthesis, Dormancy, and Vitality (growth equation, energy conservation, dormancy spec, immune detection trigger)
  - §83.6 Trust Half-Life — Equation 14 (Contract #317)
- §84. Anti-Fraud & Sybil Resistance — The Complete Defense Stack (7-layer stack, cluster detection, day-0 legal compliance)
- §85. Adversarial Stress Hardening (projection thrash prevention, archive strata collapse, detection mesh legal safeguard, governance quorum, jury fatigue, monster economy grounding, anchor allowance anti-gaming, cross-region feature negotiation, civilization energy dashboard, intent layer)
- §86. Infrastructure Sustainment & Treasury Model (ISR fee, founder bootstrap window, branch-level rates, resource-based pricing, treasury transparency, accumulation ceiling, pricing invariants, live download pricing, crowdfunded operations model)
- §87. Scale Invariance Guarantee (O(1) per operation, federation architecture, 10B user day-one load profile)
- §88. Launch Strategy & Distribution Model (desktop-first packaging, website architecture, video strategy, 6-phase adoption sequence, enterprise wedge, platform strategy, **founder presentation format — user sphere reveal** Contract #321)
- §89. Progressive Revelation & Source Document Architecture (RT-0 through RT-4 classification, sealed branch encryption, achievement-gated decryption, Day-1 Starter Pack, AI curation tool, build history as treasure)
- §90. Airspace & Atmospheric Elevation Layers (6-band altitude system, priority budgets, visibility rules, shed order, venue overrides, airspace governance, **AirspaceResolvedSpec**)

**Part XIII — Intelligence, Goals & Economics (How It Sustains)**
- §91. Filament Color Grammar — Six-Domain Syntax Rendering (hue from identity, temperature from magnitude, opacity from evidence, spatial channels from counterparty/time/lifecycle)
- §92. SCV Intelligence Architecture — API Hybrid & Cost-as-Filament (four-tier routing, self-host economics, AI cost transparency, intelligence sovereignty, **learning boundary enforcement**)
  - §92.6 Learning Boundary — Type-Level Policy Separation (Contract #307)
- §93. Relay HQ Subsidiary Model & Operational Cost Transparency (organizational forest, treasury branches, mission-gated cost reduction)
- §94. Civilization Goals — Locked Progression Tiers (Tier 0-5 milestones, filament-backed metrics, game layer gating, regression scars, **terminal vision: atmospheric habitation & Earth returned to nature**)
- §95. Pricing Model — Competitive Sustainment Rate (ISR economics, free tier guarantee, download pricing, revenue sufficiency, no advertising)

**Part XIV — Discovery, Legacy & Understanding**
- §96. Treasure Chest Taxonomy — Scarcity Gradient & Discovery Types (four chest types, sharing mechanics, attention economy, chest placement rules)
- §97. Legendary Branch — Unique Tree Geometry from Discovery (hash-derived geometry, visual distinctiveness, rarity, immutability rules, cross-tree viewing)
- §98. Founder Archive Distribution — History as Type 3 Treasure (archive contents, fragmentation, geographic placement, temporal scattering, sealed count)
- §99. The Awakening Curve — Progressive Understanding Through Use (six-stage insight progression, non-acceleration guarantee, treasure chests as breadcrumbs, the curve is the product)
- §100. The Substrate — Global Knowledge Bedrock & Activation Mechanics (reference filaments, geological knowledge layer, activation by real users, geographic anchoring, 2D-to-3D attribution bridge, anti-gaming rate limits, substrate rendering)
- §101. SCV Physical Extension — Drone & Robotics Evidence Architecture (intelligence tier extension to physical devices, device companion trees, mission filaments, cross-tree evidence flow, Relay Robotics progression, device type taxonomy, **IoT device ingestion protocol**)
  - §101.8 IoT Device Ingestion Protocol — Sensors, PLCs, and Smart Infrastructure (Contract #309)
- §102. Search Architecture & Filter Governance (search as SCV function, structured query model, filter meta-vote, search lens rendering, search telemetry as native AI training data, intelligence sovereignty path)
- §103. The SphereCore — Semantic Bedrock & Universal Language Structure (five-layer depth model, semantic anchors, radial language connections, category foundation, cross-body planetary cores, translation as navigation)
- §104. Conversational Discovery — Understanding as Treasure Trigger (five-signal evaluation, discovery trigger schema, anti-gaming, trigger secrecy, understanding as qualification)
- §105. Device Mesh & Physical Immersion (mesh formation, distributed viewport rendering, cross-device interaction, audio mesh, sensor integration, immersion spectrum)
- §106. Live Performance Loop — Crowd Metrics as Creative Input (audience engagement sap, crowd aggregate, performer feedback branch, music/theatre/comedy/sports/film applications, feedback democracy)
- §107. Relay Launch Event — Genesis Party Protocol (QR download, genesis film, three demos, four party games: Dreidel/Wave/Collective Instrument/Constellation, event commit)

---

## Glossary

These terms appear throughout the document. Each is explained in detail in its home section, but this quick reference helps if you encounter an unfamiliar word.

| Term | Plain-English Meaning |
|------|----------------------|
| **Filament** | A single recorded event — a transaction, a message, a photo, a vote. The smallest unit of data in Relay. Like a single row in a spreadsheet, but with built-in proof of who created it and when. (§4) |
| **Branch** | A group of related filaments organized around a topic — like a folder, but three-dimensional. A company's "Sales" branch holds all sales filaments. (§3) |
| **Trunk** | The central pillar of any tree. All branches grow from the trunk. For a company, the trunk is the company itself. For a person, the trunk is you. (§2) |
| **Tree** | A complete collection of branches and filaments belonging to one entity — a person, a company, a city. Everything you do in Relay lives on your tree. (§2) |
| **Basin** | The circular plot of ground on the globe where a tree is planted. Basins prevent trees from overlapping each other. (§1) |
| **Slab** | A cross-sectional ring on a branch representing one time period. Slabs stack over time like tree rings. Their color, thickness, and firmness tell you about the health of that period. (§3) |
| **Timebox** | A defined time period (a day, a week, a sprint) during which activity is recorded. When a timebox closes, its slab becomes permanent. (§14) |
| **Commit** | The act of permanently recording a filament. Once committed, it cannot be changed or deleted — only corrected by adding a new filament that references the old one. (§4) |
| **Confidence** | A measure of how well-supported a piece of data is. High confidence means strong evidence from multiple sources. Low confidence means something is missing or uncertain. Confidence is calculated automatically from evidence. (§9) |
| **Wilt** | When a branch or slab lacks verification or has unresolved issues, it visually droops — like a plant that hasn't been watered. Wilt is the system's way of saying "this needs attention." (§3, §30) |
| **LOD (Level of Detail)** | How much visual information is shown depending on how far away you are. Viewing Earth from space shows only trunks. Zooming into a city shows branches. Zooming into a branch shows individual filaments. (§33) |
| **SCV (Supply Chain Validator)** | An AI assistant that lives on every branch. It checks incoming data, flags problems, and helps users navigate their tree. Think of it as a smart assistant that reads every receipt and contract for you. (§16) |
| **Disclosure Tier** | A privacy level (0, 1, or 2) that controls who can see what. Tier 0 = completely private. Tier 1 = shapes visible but not content. Tier 2 = fully public. You choose the tier for every piece of data you create. (§8.5, §71.9) |
| **Proximity Channel** | A location-based connection zone. When you physically walk near a store or office that runs Relay, your device connects to their proximity channel — letting you interact with that location's branch. (§29) |
| **Weighted Median** | The voting method Relay uses for governance. All votes are collected, sorted by value, and the middle value (weighted by participation) becomes the result. No majority rule — the mathematical center wins. (§11) |
| **Merkle Chain** | A tamper-proof record where each entry is mathematically linked to the one before it. If anyone changes a past entry, the entire chain breaks visibly. This is how Relay guarantees that committed data cannot be secretly altered. (§20, §48) |
| **Microsharding** | Splitting encrypted data into many small pieces ("shards") and spreading them across different computers. No single machine holds enough to read the original. To reconstruct, you need a minimum number of shards plus the encryption key. (§66) |
| **Shamir's Secret Sharing** | A mathematical method for splitting a secret (like an encryption key) into N pieces, where any K pieces can reconstruct the original but K-1 pieces reveal nothing. Used for account recovery. (§71.6) |
| **Reed-Solomon Coding** | An error-correction method that adds extra data shards so the original can be reconstructed even if some shards are lost. The same technology used in CDs and QR codes. (§66) |
| **Achievement Token (AT)** | A resource earned by demonstrating real skill — validated by evidence, not just participation. Unlocks advanced capabilities like stronger votes and projection authority. (§41) |
| **Engagement Credit (EC)** | A resource earned by participating — commenting, voting, completing tasks, fighting virtual monsters. The basic currency of activity in Relay. (§41) |
| **Power** | A game-layer resource used for casting spells and abilities in arena matches. Spent during combat, regenerated over time. (§41) |
| **Presence Profile** | A filter over your tree that controls what others see about you in a given context. You might show your professional branches at a job interview and your gaming achievements at an arena. The same tree, different views. (§8.6) |
| **Sortition** | Random selection of qualified individuals (like jury duty) to make specific decisions. Prevents capture by special interests because you cannot predict or lobby the decision-makers in advance. (§46) |
| **Combat Loadout** | A per-match configuration in arena battles that emphasizes certain capabilities at the cost of others. Not permanent — chosen fresh for each match. (§68.19) |
| **Sentinel Node** | A high-reputation storage provider machine that holds emergency backup data shards. Not a person — a computer operated by a vetted provider. (§66.4) |
| **Guardian Contact** | A trusted human (friend, family member) who holds a piece of your encryption key for account recovery. Not a machine — a real person you designate. (§48.2.2, §71.6) |
| **Closure Commit** | The final record written when something stops being used — an account closing, a device failing, a service going offline. Nothing in Relay disappears silently; every ending is recorded. (§71.7) |
| **Fisheye Focus / Inverse-Scaling** | When you zoom into one branch, it expands while the rest of the tree shrinks proportionally — like a magnifying glass. The whole tree stays visible but the focused area gets more detail. (§71.20) |
| **Product Tree** | A tree representing a manufactured product (laptop, car, medicine) with branches for design, BOM, suppliers, manufacturing, distribution, retail, warranty, recall, and environmental impact. Every product on a shelf traces back to the minerals it was made from. (§77) |
| **BOM (Bill of Materials)** | A branch on a product tree listing every component that goes into a product version. Each component is a filament linking to a supplier tree and material lots. (§77.3) |
| **Mass Balance** | A conservation law enforced at every stage of production: input mass must equal output mass plus waste plus emissions. If the numbers don't add up, the branch wilts. (§52.5, §77.5) |
| **Recall Cascade** | When a defect is found in a material or component, a scar propagates upward through every linked product — from material lot to batch to retail unit to customer. The affected products glow on the map. (§77.7) |
| **Filament Length** | How long a filament extends along a branch, determined by its commit topology — not manually assigned. Short filaments are brief events (posts, approvals). Long filaments are sustained projects. Never-ending filaments define the branch structure itself. (§78) |
| **Structural Node** | A branch element that never closes — balance sheet accounts, file directories, organizational structures. It receives continuous commits and defines the branch shape, unlike finite filaments that eventually sink inward. (§78.4) |
| **Open Annotation** | The default state of filaments where anyone can vote on individual words, suggest changes, or start conversations. Annotations are themselves filaments that attach to the original. (§79) |
| **Deferred Attribution** | Crediting someone whose Relay ID you don't know yet. You write `@whoever` and later, when the real person finds it, they claim the attribution through the owner. The placeholder resolves to a real identity. (§79.4) |
| **Word-Level Vote** | A micro-filament that targets a specific character range in another filament — agree, disagree, clarify, cite, or flag. Adding a comment to the vote starts a new conversation branch. (§79.2) |
| **Genesis Commit** | The founder's first commit that creates Tree Zero (Relay HQ), imports the full development archive, sets all initial parameters (all extraction rates at 0%), and seals the genesis Merkle root. The birth certificate of Relay. (§80) |
| **Tree Zero** | `tree.org.relay-hq` — the first tree in the system, containing the full development history of Relay itself. The founder controls access. The archive sinks into the roots. (§80.1) |
| **Filament Kind** | Either "finite" (lifecycles inward toward heartwood) or "structural" (persists as branch geometry, never closes). Engine-enforced at commit time. (§81.1) |
| **Basin Normalization** | Logarithmic scaling that prevents large entities from visually dominating small ones at regional LOD. Relational geometry, not imperial. (§81.2) |
| **Silence-Stability** | When a parameter receives no votes for 12+ epochs, change threshold escalates to supermajority and rate-of-change cap tightens. Prevents dormant parameter hijacking. (§81.3) |
| **Offline Fork** | When two users edit the same filament offline, both commit chains survive. SCV creates a resolution branch. Human resolves. No "last write wins." (§81.4) |
| **Lens Invariant** | Universal rule: any view marked as a lens cannot call commit() or modify state. Read-only by constitutional rule. (§81.5) |
| **Conceptual LOD** | Five tiers of progressive complexity disclosure: PERSONAL, TEAM, ORG, CIVIC, CIVILIZATION. Advances automatically through engagement. (§81.8) |
| **Three-Layer Ontology** | The three fundamental data layers: Wood (filaments — permanent truth), Leaf (LeafPackets — ephemeral engagement), Sap (SapPackets — live state). Each has distinct persistence, rendering, and degradation rules. (§82) |
| **LeafPacket** | An ephemeral engagement object that lives on surfaces, gathers attention, and either falls/composts or promotes into a real filament. Extends the §5 Note concept. Types include NOTE, COMMENT, REACTION, HINT, DRAFT, PROJECTION_PREVIEW, ARENA_VOTE_INTENT, PING. (§82.2) |
| **SapPacket** | A live-state signal with millisecond TTL. Carries current operational state (presence, WIP, dispatch, viewing position) without entering the commit chain. Overwritable, never persisted without explicit checkpoint to filament. (§82.3) |
| **Leaf Promotion** | The explicit, auditable process by which a LeafPacket crosses the boundary into truth and becomes a filament. Triggered by first reply, threshold, manual action, or template rule. Same mechanism as §5 FilamentBirth. (§82.4) |
| **Sap Checkpoint** | The mechanism by which live SapPacket state becomes a committed filament — triggered by materiality, duration, external reference, or emergency priority. The sap itself is not preserved; only the resulting filament is truth. (§82.4) |
| **Presence Swarm Behavior** | At increasing LOD distance, individual user presence markers aggregate into collective movement patterns following biological dynamics: bee-like at BRANCH, bird-flocking at TREE, fish-schooling at COMPANY, murmuration at REGION, sentinel swarm at GLOBE. Users keep their own avatar at close range. Aggregate density IS the attention metric. (§17.3) |
| **Companion Tree** | A tree for a non-human entity (pet, animal, wildlife) linked to an owner's tree. Behavior documented via camera detection, translated into filaments. SCV builds behavioral model with voice synthesis. Every translation is evidence-backed and auditable. (§17.4) |
| **Photosynthesis** | The growth equation: how attention (sap) + evidence (water) + counterparty input (CO2) converts into structural mass (wood). Branch growth rate = promoted leaf magnitude × confidence × resolution rate. The missing half of the energy system — decay equations existed, growth did not until §83. (§83.1) |
| **Dormancy** | A branch state between active and heartwood. No commits, no engagement, but nothing wrong. Visually frosted, computationally reduced, instantly reversible on any new interaction. Not wilt (integrity deficit) and not heartwood (terminal). Saves compute at scale. (§83.3) |
| **Energy Budget** | The conservation principle for structural mass: Δ(branchMass) = photosynthesis − gravity − wilt. Positive = growing, zero = stable, negative = declining. The complete energy cycle from sap to heartwood. (§83.2) |
| **Vitality** | Composite diagnostic score: confidence × firmness × (1 − dormancy). Not a force — a health summary combining existing equations. Used for dashboards and SCV monitoring. (§83.4) |
| **Filament Color Grammar** | The six-channel visual rendering system where each universal domain maps to one perceptual channel: hue from identity, angular position from counterparty, L-position from time, color temperature from magnitude, opacity from evidence, radial position from lifecycle. No manual color assignment. (§91) |
| **SCV Intelligence Tier** | One of four levels in the SCV routing stack: T0 (deterministic, no AI), T1 (lightweight local model), T2 (frontier API), T3 (human escalation). Routing is a Category A parameter. Degradation sheds in reverse order. (§92.2) |
| **AIInvocationFilament** | A committed record of every AI call made by an SCV, recording tier, model, tokens, cost, latency, purpose, and evidence hash. Makes AI spending visible on the tree using standard physics. (§92.3) |
| **Civilization Goal** | A structural filament on Tree Zero's goals branch tracking a real-world metric (hunger, literacy, emissions) against a threshold. Computed from bottom-up filament aggregation, never self-reported. Achievement unlocks game layer features. (§94) |
| **Civilization Tier** | One of six progression levels (Tier 0-5) that gate game layer features behind verified real-world achievements. Tier unlocks are irreversible. Regression produces scars, not re-locks. (§94.2-94.7) |
| **ISR (Infrastructure Sustainment Rate)** | The transparent fee on economic TransferPackets, constitutionally capped at 1.00%, default 0.30%. Community-governed via Layer 3 MetaVote. The primary revenue mechanism for Relay operations. (§86, §95) |
| **Organizational Forest** | The structure of Relay HQ and its subsidiaries as a linked set of full trees, each with identical physics and a treasury branch where every cost is a filament. (§93.1) |
| **Open Chest (Type 0)** | The most common treasure chest type. Anyone can find and open it. Content is identical for all openers. Knowledge trades freely. Contains spell clues, architectural fragments, lore. (§96.1) |
| **Personal Chest (Type 1)** | A treasure chest bound to a specific user's tree topology — their profession, location, or engagement pattern. Only that user encounters it. Content becomes part of their tree. (§96.1) |
| **Regenerating Chest (Type 2)** | A treasure chest that can be opened by many people, but delivers different content to each from a finite rotating pool. When the pool is exhausted, the chest goes permanently dormant. (§96.1) |
| **One-Time Chest (Type 3)** | The rarest treasure chest. Can only be opened once, ever, by one person. The chest is consumed upon opening. Creates a legendary branch on the finder's tree. Contains the most significant content — founder archive fragments. (§96.1) |
| **Legendary Branch** | A structural filament with unique hash-derived geometry that spawns on a user's tree only upon opening a Type 3 one-time chest. Visually distinct (unique bark, persistent glow, non-template angle). Cannot be transferred, forked, duplicated, or wilted. Few users will ever have one. (§97) |
| **Founder Archive Distribution** | The principle that all founder documentation, video, audio, AI transcripts, and design artifacts are distributed exclusively as Type 3 one-time treasure chests scattered geographically across the world. The founder's story is encountered in fragments, never collected whole. (§98) |
| **Awakening Curve** | Relay's deepest design principle: sustained use naturally produces a progressive understanding of what structured global data means — from personal utility through interoperability, accountability, and civilization metrics to the realization that one universal structure reveals the state of everything. The curve mirrors the founder's own journey and cannot be skipped, purchased, or accelerated. (§99) |
| **Treasure Chest Type** | One of four scarcity classifications for treasure chests: Type 0 (Open), Type 1 (Personal), Type 2 (Regenerating), Type 3 (One-Time). Each controls who can open, how many times, and what happens afterward. Assigned at placement, immutable. (§96.1) |
| **Substrate** | The shared geological knowledge layer beneath all trees' root systems. Contains reference filaments indexing humanity's existing knowledge from the 2D internet. Belongs to no entity — it is the knowledge commons. Rendered as mineral/crystalline formations, visually distinct from organic roots. Designed to be gradually superseded as primary sources join Relay. (§100) |
| **Reference Filament** | A filament subtype (objectType: REFERENCE) that indexes external knowledge without claiming it. Contains structured summaries with full attribution, source hashes, authority-tier confidence scores, and deferred claims for original creators. Confidence is capped below primary committed data. Exists to be superseded when the real source joins Relay. (§100.2) |
| **Geographic Anchor** | The first user in Relay's 3D world to engage with a Substrate reference topic at a specific location. Earned by activating a reference filament — committing a living filament that links down to the bedrock. A timestamp of presence, not ownership. Subsequent users with deeper engagement naturally attract more citations. (§100.4) |
| **Substrate Activation** | The moment a reference filament in the Substrate transitions from inert to linked — triggered when a real user commits a living filament intersecting the reference's topic and confirms the cross-reference. The reference stays in the Substrate (still available to all); the user's tree gains a citation chain reaching into the bedrock. (§100.4) |
| **2D-to-3D Attribution Bridge** | The mechanism by which original creators of internet content retain credit in Relay via deferred attribution (§79.4). When the creator joins Relay, the deferred claim resolves to a real counterparty link. If disputed, governance resolves via evidence-based vote or sortition. Deferred claims never expire. (§100.5) |
| **SCV Physical Extension** | The principle that the SCV intelligence tier model (T0–T3) extends to physical devices: drones, ground robots, marine vehicles, sensors, satellites. Devices are actuators commanded by the SCV — they gather evidence, they do not make truth claims. Automates routine evidence collection while humans remain in the review loop. (§101.1) |
| **Device Companion Tree** | A tree representing a physical device (drone, robot, sensor) linked to an owner's tree, with branches for telemetry (sap), maintenance (filaments), missions (MissionFilament schema), evidence (committed captures), and compliance (registrations). Follows the same companion tree pattern as §17.4 but for equipment. (§101.3) |
| **MissionFilament** | A filament committed to a device's companion tree that dispatches an evidence-gathering operation: missionType, coordinates, altitude, duration, evidenceCapture mode, returnCondition, priority, and airspace authorization. Supports scheduling (§5b) for recurring automated patrols. (§101.3) |
| **Search Lens** | A read-only visual overlay applied during search: matching filaments intensify (full opacity, enhanced glow), non-matching filaments fade (10-20% opacity), cross-tree results render as navigable trace lines. Dismissing restores full rendering. Never modifies data. (§102.4) |
| **Filter Governance** | The two-stage meta-vote process (§72) applied to search filter defaults: Stage 1 votes on which filter proposals deserve consideration, Stage 2 votes on winning configuration and priority ordering. Universal filters are Category A, template filters are Category B. (§102.3) |
| **SphereCore** | A dense sphere of semantic anchor points at the geometric center of every Relay globe instance. Each point represents a fundamental concept independent of language — a meaning-without-words. The deepest layer in Relay's five-layer depth model. Gives categories, templates, and domain labels their meaning. Renders as a glowing geometric point sphere. (§103) |
| **Semantic Anchor** | A single point on the SphereCore surface representing a language-independent concept (e.g., the concept of "water," not the word). Positioned by semantic relatedness — nearby anchors represent related concepts. Has radial connections to every language that has a word for it. Never deleted. ~4,000 seeded at genesis, growing as human understanding grows. (§103.2) |
| **Radial Connection** | A language-specific thread extending from a SphereCore semantic anchor outward to the Earth's surface where that language is spoken. The word "water" in English is one radial connection to the WATER anchor; "ماء" in Arabic is another to the same anchor. Translation is following one thread inward then another outward. Connection confidence reflects translation quality. (§103.3) |
| **Cross-Core Link** | A synchronized connection between SphereCores on different celestial bodies. Universal concepts (physics, math, logic) exist in all SphereCores. Non-universal concepts remain local. New bodies inherit universals from the parent. Renders as visible pulse lines between planetary centers. (§103.6) |
| **Five-Layer Depth Model** | The complete vertical structure from surface to center: Canopy (living trees) → Roots (per-tree archive) → Substrate (knowledge bedrock, §100) → SphereCore (semantic bedrock, §103) → Planetary Core (cross-body links). Each layer transition has a distinct visual shift: organic → mineral → geometric. (§103.1) |
| **Conversational Discovery** | A treasure chest discovery mechanic where chests reveal during natural SCV conversation when the user demonstrates genuine understanding — connecting SphereCore concept anchors through coherent multi-turn reasoning supported by tree evidence. Not keyword matching — understanding evaluation. (§104) |
| **Discovery Trigger** | A specification attached to a treasure chest defining conditions for revelation: geographic coordinates, conversational concept alignment (SphereCore anchors + coherence threshold), tree prerequisites (domain filaments, confidence, Conceptual LOD), and anti-gaming constraints (multi-turn, no keyword stuffing). (§104.2) |
| **Device Mesh** | A temporary protocol-based arrangement where multiple Relay-running devices form a single unified rendering surface via proximity discovery, camera-based spatial registration, and sap-level frame synchronization. Any device can join. No proprietary hardware required. Topologies: FLAT, CURVED, SPHERICAL, FREEFORM. (§105) |
| **MeshSession** | A structural filament linking all device companion trees participating in a device mesh. Records spatial positions, orientations, screen sizes, capabilities, sync clocks, and audio zones. Temporary lifecycle — dissolves when the event ends. (§105.1) |
| **Crowd Aggregate** | A sap-level data structure aggregating audience engagement signals (movement, attention, presence, sentiment, biometric, audio response) into a single real-time metric set visible to performers as a live branch. Individual signals are never transmitted — only aggregate values. (§106.2) |
| **Live Performance Loop** | The feedback cycle where audience engagement sap aggregates into metrics on the performer's event branch, the performer reads the branch and responds, and the audience's response to the change generates new sap. The loop is the performance. Advisory for humans, generative for AI. (§106) |
| **Genesis Party** | The first public Relay event: QR download, Genesis Film, three live demos, and four interactive games (Dreidel, Wave, Collective Instrument, Constellation) demonstrating device mesh, cross-device physics, crowd governance, and social discovery. The event is committed as filaments on Tree Zero. Both celebration and proof script. (§107) |
| **Anchor Visual Language** | The four-layer system for rendering SphereCore semantic anchors without words: Layer 1 elemental glyphs (minimal animations for physical concepts, max 2 elements), Layer 2 composite glyphs (spatial arrangements, max 3 elementals), Layer 3 relational patterns (dynamic equilibria for abstract concepts), Layer 4 positional identity (meaning from neighborhood context only). Animation over illustration. No cultural iconography. (§103.9) |
| **Classification Matrix** | A machine-enforceable table that maps every objectType declared in a template to exactly one default layer (FILAMENT, LEAF, or SAP), plus defined promotion/checkpoint triggers for types that may cross layer boundaries. The engine refuses commits that violate the matrix. (§82.5.2) |
| **Camera Tick Safety** | The per-frame validation invariant that checks camera cartographic coordinates for NaN/non-finite values, snapshots valid state, clamps altitude via position-only correction, and prohibits `setView()` in FPS/RTS tick loops except for five enumerated events. Prevents culling array explosions. (§50.7) |
| **AirspaceResolvedSpec** | The single output object produced by the airspace resolver that all rendering subsystems must consume. Merges global, regional, and venue airspace config with monotonic safety tightening. No subsystem may read raw airspace JSON directly. (§90.7) |
| **HeartwoodRingSummary** | A committed filament that compresses a structural filament's historical commits into an age-based ring summary (monthly after 1yr, quarterly after 5yr, annual after 20yr) with Merkle root integrity. Individual commits move to cold archive, retrievable on demand. (§81.1.1) |
| **Promotion Gate** | The anti-gaming requirement that every leaf-to-filament promotion must satisfy at least one non-self condition: non-self counterparty, non-trivial evidence, or SCV attestation. Prevents astroturf promotion from bot clusters. (§82.4.1) |
| **TemplateResolvedSpec** | The deterministic resolution object produced when a subsystem encounters data from a different template version. Composes TemplateVersionBridge chains with monotonically degrading compatibility. Used by projections, cross-tree links, SCV validators, and search. (§81.6.1) |
| **Small Tree Mode** | The offline-first boot mode enabled by the GenesisBundle (< 50MB). Renders the globe, personal tree with 3 role-path branches, full camera, and T0 SCV with zero network connectivity. Launch-to-first-filament target: < 5 seconds. (§81.9.1) |
| **GenesisBundle** | The offline package shipped with every Relay client: low-res globe tiles, 3 starter templates, 500 seed SphereCore anchors, default governance/airspace params, T0 SCV rules. Enables full first-boot without network. Hard-capped at 50MB. (§81.9.1) |
| **Terminal Vision** | The founder's stated long-term intent: humans live in atmospheric habitats (sky houses), Earth's surface is returned to nature, animals get the ground, flight is a universal skill, the sky has no borders, nobody is left behind. Not a frozen contract — a directional aspiration that explains why Relay Aerospace, flight training, airspace governance, and environmental monitoring exist. Voluntary, always voted upon. (§94.9) |
| **Personal Gesture Cipher** | A user-defined private sign language trained exclusively on their own body mechanics and stored as encrypted filaments on their SCV training branch. The same hand movement means different things for different users — visual encryption through personalized motion. Template sets (ASL, BSL, JSL, ISL, tactical, music) provide starting vocabulary. (§39.4) |
| **Body Interface** | The user's body as trunk: hands, fingers, posture, and connection points treated as a registered camera-tracked input device. Fingers map to branches. Palm lines serve as branch ledger geometry. Branch pull gesture draws data branches from anchor points (palm, temple, forehead, chest, shoulders) rendered in AR and populated by SCV in real time. Connection points carry elevated semantic weight. (§39.4) |
| **Weapon Taxonomy** | The open input device system rooted in Hwa Rang Do tradition. Nine Relay Set Weapons (Empty Hand, Sword, Nunchaku, Staff, Knife, Fan, Rope/Chain, Spear, Three-Section Staff) are founder-optimized with pre-built zone maps. Beyond these, ANY object that produces detectable signals can be registered as an input device — instruments, keyboards, ranged weapons, improvised objects. Effectiveness is measured by CPI, not weapon choice. (§43.10) |
| **Hwa Rang Do** | 화랑도, "The Way of the Flowering Knights." The Korean martial art whose comprehensive weapon curriculum provides the foundational philosophy for Relay's nine Set Weapons and the principle that a complete warrior masters all tools — martial, musical, electronic, or improvised. (§43.10) |
| **Combo Depth** | The maximum chain length of sequential weapon commands before a mandatory recovery pause. Higher combo depth = more spells queued per burst. Nunchaku have the highest (10), three-section staff second (9), spear the lowest (3). Determines a device's throughput ceiling. (§43.10.1) |
| **Weapon Vote** | The three-phase community governance process for the weapon taxonomy: (1) list confirmation, (2) implementation priority ranking, (3) ongoing balance parameter tuning via weighted-median voting. All numeric combat values are Category A parameters. (§43.10.6) |
| **Graphic Crafting Module** | The creation studio where users design their own visual, audio, and motion effects using the Relay Crafting IDE (image, video, sound, music, and composite generators). All generators are free for testing. Finalization commits the graphic as a permanent filament, consuming crafting resources proportional to complexity and rarity tier. Crafted graphics link to specific skills and spells — the graphic IS the user's visual combat language. (§43.11) |
| **Crafting Finalization** | The act of committing a crafted graphic from TESTING/DRAFT status to permanent FINALIZED status. Costs crafting resources based on rarity tier × render load multiplier (infrastructure cost, not quality judgment). Higher tiers require treasure chest discoveries or achievement prerequisites. Finalized graphics activate at full designed intensity; the crowd judges quality through attention, the system only charges for render load. Every finalization produces a verified content hash on the user's crafting branch. (§43.11.3) |
| **Summon Card** | An autonomous AI entity deployed during combat, distinct from decorative graphics. Has Power, Toughness, Speed, Intelligence, element affinity, and abilities. Controlled by the SCV as a sub-agent — makes independent combat decisions within summoner directives. Can attack, defend, block, and be destroyed. Sources: founder registry, physical card mapping (§43.7), or discovery-unlocked triggers. (§43.12) |
| **Multi-Intelligence Combat** | The strategic depth layer where a duelist simultaneously manages personal combat (body/weapon CPI), spell casting (element manipulation), and one or more summoned AI creatures (broad directives). Mastering all three streams — personal skill, magical power, and creature direction — is the highest expression of Relay combat. (§43.12.3) |
| **Tree Health Pool** | A combat-specific health value derived from a tree's structural integrity (mass, confidence, engagement history). Unblocked creature and spell damage reduces tree health during duels. Zero health = combat defeat. Regenerates between duels — combat damage does not permanently affect the real tree. (§43.12.5) |
| **User Wallet** | The five resource types every user carries: Engagement Credits (participation), Achievement Tokens (proven skill), Active Capacity (concurrent operation ceiling), Power (game-layer mana from physical element interaction), and Crafting Tokens (visual identity currency, the only one purchasable). No cryptocurrency, no exchange tokens. Infrastructure costs (compute, storage, render) are a separate server-side layer — never affected by user latency or network quality. (§41.10) |
| **Oblivion Threshold** | The civilizational-scale content classification mechanism. Content voted as purely destructive by civilizational supermajority (85%) receives a gravity multiplier sinking it below every user's default visibility. Nothing is deleted — append-only preserved. Anyone can deliberately view classified content by lowering their filter (auditable act). Regional governance can add stricter local classifications but never weaken global ones. Camera detection uses opt-in mesh with community-curated pattern libraries. The classification itself is permanently visible on Tree Zero. (§72.12) |
| **OblivionMarker** | A permanent structural filament on Tree Zero created when a Global Oblivion Classification vote passes. Contains the subject definition, pattern definition, gravity multiplier, complete vote record, evidence chain, and effective date. Status is ACTIVE or REVOKED. Revocation requires the same supermajority that created it. (§72.12.2) |
| **Pattern Library** | The community-curated corpus of positive, negative, and ambiguous boundary examples attached to each OblivionMarker. Defines what content matches a classification with precision — not vague labels. Every example is a filament with evidence. Evolves through governance. The trained understanding that SCV systems use for detection, fully auditable, never a black box. (§72.12.5) |
| **Relay Lite (Fog Reveal)** | There is no separate Relay Lite binary. There is ONE system. Every user downloads and installs the same Relay. Feature availability is governed by Conceptual LOD fog (§81.8), which lifts through natural engagement — never through purchase, hardware tier, or explicit unlock. Device capability affects rendering quality (resolution, particle count, SCV intelligence tier) but never feature access. Assets stream progressively as fog lifts, following the user's discovery path. The GenesisBundle (< 50MB) ships with every binary for full offline operation. (§81.9.2) |
| **Trust Half-Life** | The universal temporal decay equation for all assertions: `trustWeight = initialWeight × 2^(−Δt / τ)`. Context-dependent half-lives range from 30 days (social votes) to 5 years (scientific data). Re-evidencing events reset the decay counter. Feeds into confidence, wilt, photosynthesis, dormancy, and silence stability. Renders as progressive translucency. Assertions not maintained lose structural weight — Relay's temporal turgor pressure. (§83.6) |
| **Silence Stability Doctrine** | The four-state inertia model for governance parameters: ACTIVE → QUIET → STABLE → SEALED. Thresholds escalate from simple majority to 90% supermajority as silence deepens. Rate-of-change caps tighten from 20% to 5% per epoch. Reactivation triggers notification cascade and 3-epoch graceful thaw. Renders as progressive visual encasement from normal through amber ring, golden seal, to crystalline age rings. Prevents dormant parameter hijacking. (§81.3) |
| **Command Precision Index (CPI)** | The universal combat metric measuring how effectively a user commands through any input device. Composite of four components: signal clarity (how cleanly the SCV reads input), semantic density (how much meaning per command), throughput (valid commands per second), and resource efficiency (Power spent per spell effect). CPI determines actual Power cost of commands — precise users spend less. Device-agnostic: a flautist at CPI 0.85 outperforms a swordsman at CPI 0.55. (§43.10.7) |
| **Open Input Device Protocol** | The registration system allowing any physical object, instrument, electronic device, or the body itself to become a Relay input device. SCV learns zone maps through a training period (1hr basic, 10hr reliable, 100hr mastery). Combat profiles are derived from observed performance, not manually assigned. Set Weapons ship with pre-built profiles; everything else trains from scratch. (§43.10.8) |
| **Three-Section Staff** | 삼절곤 (Sam Jol Gon). The founder's weapon and the ninth Relay Set Item. Three metal sections connected by chain/ring linkages with 20 input zones, three combat modes (extended/whip/compact), internal elemental chambers, and specular light reflection. Highest total capability ceiling, highest difficulty curve. A self-teaching weapon that embodies the Awakening Curve. (§43.10.2) |
| **Bard Archetype** | The non-traditional combat class using musical instruments as input devices. Sound produces signals of extraordinary complexity (pitch, rhythm, dynamics, harmony, articulation, timbre), enabling high semantic density, sustained spell effects, crowd manipulation, and stealth commands. Low physical power, compensated by command richness. Named for the Final Fantasy Bard class. (§43.10.9) |
| **Palm Line Ledger** | The physical creases on hands and feet treated as natural branch geometry for data visualization. With close camera or AR glasses, the SCV maps information along the user's actual skin lines — finances on the life line, health on the heart line. No screen needed. The body IS the display surface. (§39.4.1) |
| **Dual-Channel Signal Architecture** | The fundamental separation between commands (Channel 1: hand signals on tools — what spell to cast) and magnitude (Channel 2: light, fire, smoke, water detected by camera — how much power the spell carries). The channels are independent. Combining them simultaneously (light as both command and power source) requires high CPI and is the highest-skill expression. (§43.10.12) |
| **Charging Attack** | A sustained specular light reflection held at precise angle over time, building accumulated Power. Amplified by crowd confidence (CrowdAggregate sap) in arena/public contexts. Visible, interruptible, high-risk/high-reward. Release triggers a single devastating spell at accumulated magnitude. (§43.10.12) |
| **Procedural Governance Template** | The ritualized meeting structure inherited by every Relay council, based on parliamentary procedure. Six mandatory roles (Chair, Treasurer, Recorder, Sergeant-at-Arms, Parliamentarian, Members). Motions follow filament lifecycle: proposed → seconded → debated → called to question → voted → absorbed. Amendments are version bumps. Procedural violations produce permanent scars. No symbolic resolutions — passed motions absorb only when implementation exists. (§72.11) |
| **CouncilMotionPacket** | A filament representing a formal motion in a council meeting. Contains motion text (identity hash), proposer, scope weight, lifecycle state, and references to seconds, amendments, votes, and implementation filaments. Follows OPEN → ACTIVE → HOLD → CLOSED → ABSORBED lifecycle. (§72.11.3) |
| **Vehicle Channel Node** | A mobile proximity channel (§29 extended) created by any vehicle running a Relay device. Identity is tree-based, never vehicle-based. Uses motion-compensated BLE/WiFi handshake with ephemeral link lifecycle (DISCOVERED → LINKED → ACTIVE → FADING → GONE). Forms on sustained proximity (>3s), dissolves on separation (>5s). (§74b.1) |
| **Backseat Mode** | An age-gated child-to-child social layer within the vehicular mesh, governed by BackseatGovernancePacket. Parents control voice, text, AR, broadcast, mesh radius, friend requests, and session timeout. Channels auto-dissolve when cars separate. No persistent contact without dual-parent approval. (§74b.3) |
| **Safety Mesh** | An opt-in distributed safety net where participating vehicles' cameras hash nearby license plates using a one-way cryptographic function and check only against active safety registries (Amber alerts, stolen vehicles, hit-and-run). No match = hash destroyed, no trace. Match = SafetyAlertFilament. Privacy is a mathematical guarantee. (§74b.5) |
| **PlateHashEvent** | An ephemeral object created when a Safety Mesh participant's camera reads a plate. Contains the irreversible hash, timestamp, approximate location, and match result. If CLEAR, the entire object is destroyed — no filament, no sap, no record. If ALERT_MATCH, becomes a SafetyAlertFilament on the civic branch. (§74b.5) |
| **Traffic Event Filament** | A community-reported real-time traffic condition (accident, police, hazard, construction, weather, closure). Requires independent confirmation from multiple vehicles to crystallize. Unconfirmed reports have high fog and decay. False reports carry civic confidence penalties. (§74b.4) |
| **Mesh Radius** | The configurable detection range for vehicular proximity channels. Adapts to context: 50m in urban areas (dense traffic, many potential links), 200m on highways (higher speed, sparser traffic), 500m in rural areas (low density, wider social reach). Determines when ephemeral links form and dissolve. (§74b.1) |
| **Driver Mode** | An architectural safety lock on the driver's device during vehicle motion. No interactive social features, no visual channels, no text. Voice-only navigation and emergency alerts only. All social functions delegate to passengers. Activates automatically above 5 mph. Circumvention triggers role reassignment. (§74b.6) |
| **Eight Edges of Livability** | Eight constitutional guarantees ensuring Relay is livable, not just correct: (1) people can leave, (2) disagree quietly, (3) wait before irreversible actions, (4) lose without burning out, (5) history stays legible via projection-only summaries, (6) vulnerable participants are structurally safe, (7) communities coexist without overriding each other, (8) inaction is a respected resolution. No governance action may violate these. (§0.5) |
| **Camera Awareness Protocol** | The mandatory visual indicator system for camera state in Relay. Six states: OFF (no indicator), CALL ACTIVE (green — video only, no training), TRAINING ACTIVE (amber — SCV learning, explicitly opted in), DETECTION ACTIVE (amber + white — gesture/object/light processing), MESH CONTRIBUTING (amber + blue), RECORDING (red + label). SCV training is a separate, explicit opt-in on top of video activation — video ON does not enable training. Full disclosure required at training opt-in. Hardware camera LED is always accurate — no silent camera access. Recording requires visible indicator to all participants; hidden recording produces a procedural violation scar. (§39.7) |
| **Kinetic Input Rate (KIR)** | The movement-as-power metric for combat: `KIR(t) = Σ(velocity × mass × continuity)` across all tracked weapon zones. Stillness generates zero Action Points. Sustained motion accumulates AP for spell amplification, combo extension, and defensive recovery. Continuity multiplier rewards unbroken motion and resets on pause. Nunchucks produce the highest sustained KIR (continuous rotation); guard stance produces zero. Creates aggressive/defensive/rhythmic risk-reward dynamic. (§43.10.14) |
| **Physical Sport Arena** | Any real-world sport played in a camera-equipped Relay space: cameras detect physical actions (projectile tracking, body-zone hits, paint/impact analysis, movement), AR overlays render destruction graphics accumulating over the match, SCV tracks precision metrics. Paintball is the reference implementation: markers are spell weapons, paint colors are elements, firing is spell casting with Power cost. Model generalizes to laser tag, archery, fencing, martial arts, dodgeball. (§68.20) |
| **User Sphere** | The transparent navigable bubble a user occupies in the 3D Relay world during full-immersion interaction. Used in the founder presentation format: the founder flies through real Relay data (personal tree, Master Plan branch, globe, arena) from inside the sphere, interacting with live filaments. The sphere scales from personal-tree level to globe level. The founder presentation uses a two-act structure: Act 1 is standard software demo, Act 2 reveals the same system from inside the sphere. (§88.10) |
| **Turgor Pressure** | The biological model underpinning Relay's pressure physics. Like plant cells requiring continuous internal pressure to stay firm, Relay branches require continuous reconciliation (evidence, verification, timebox closure) to maintain structural integrity. No attacker required for failure — only the absence of maintenance. Wilt is the visual signal of lost turgor. (§10.4) |
| **Soft Divergence** | A first-class non-blocking disagreement primitive. Records "I disagree but I am not stopping work" without consuming pressure budget, triggering disputes, or escalating to governance. Visible in cross-section, preserved in history, promotable to formal dispute if needed. Prevents the false binary of escalate-or-stay-silent. (§19.4) |
| **Cooling Window** | A mandatory time delay (24-168 hours depending on action class) before irreversible governance actions execute. Covers policy changes, authority grants, stage transitions, and constitutional amendments. No bypass except for life-threatening emergency dispatch. Urgency does not override deliberation. (§19.5) |
| **STABILITY_CONFIRMED** | A lifecycle resolution type meaning "reviewed; no action needed." Formally closes an open pressure loop with review evidence, triggers a 60-day cooldown before reopening, and consumes zero future pressure budget. Prevents endless reopening of items that are functioning correctly. (§4.8) |
| **Canon Summarization Discipline** | The rule that summaries, aggregations, dashboards, and AI-generated synopses are always projections, never truth. They must cite source filaments and cannot be used as evidence in governance or disputes. Legibility may be summarized; truth may not. (§82.7b) |
| **Learning Boundary** | Schema-level enforcement preventing AI outputs from being treated as policy. AI systems emit POLICY_RECOMMENDATION (advisory); only human governance emits POLICY_APPLIED (authoritative). The engine rejects AI-sourced POLICY_APPLIED commits. Makes it technically impossible for AI to mutate policy without human approval. (§92.6) |
| **Protected Participation Profile** | A configurable constraint profile for users facing elevated risk: minors (automatic), vulnerable adults, high-risk onboarding, medical recovery, or self-requested. Constraints include visibility scope, forbidden roles, cognitive load cap, session timeout, and mandatory oversight. Engine-enforced, not advisory. (§63.7) |
| **IoT Ingestion Protocol** | A standardized interface for stationary sensors, PLCs, meters, cameras, and telemetry devices to feed data into Relay. Three modes: SAP_ONLY (high-frequency, TTL-governed), SAP_WITH_CHECKPOINT (materiality-triggered persistence), DIRECT_FILAMENT (low-frequency committed readings). Devices are input sources, never authorities. (§101.8) |
| **UI Internationalization** | The requirement that all Relay user-facing text renders correctly in every writing system: RTL scripts, CJK scripts, locale-specific formatting for numbers/dates/currencies/calendars, externalized strings, community-governed translation quality with confidence tracking. (§62.8) |

---

## 0. What Relay Is

> *"We shape our tools, and thereafter our tools shape us."* — John Culkin (writing about Marshall McLuhan, 1967)
>
> *"A system that cannot show you where it is wrong will eventually convince you it is right."* — Claude Opus 4.6

Imagine your neighborhood has a tree growing out of the Earth. Every pothole report, every noise complaint, every block party invitation becomes a thread on that tree. The threads that people respond to grow outward — alive, visible, demanding attention. The threads nobody cares about sink quietly into the ground, archived forever but out of the way. You look at the tree and you can tell — without reading a single report — whether your neighborhood is thriving or neglected. The shape tells you. A company has a tree too. So does a school, a city, a country, a research lab, a band. Every tree works the same way.

That is Relay.

Relay is the universal structure of organized knowledge. It maps any domain — procurement, governance, astronomy, music production, neighborhood services, personal files, software development — onto one canonical 3D tree structure with identical rendering, auditing, accountability, and physics guarantees.

Relay is not a visualization of data. The tree IS the data. Every visual property — thickness, firmness, rotation, color, opacity, glow — is an emergent result of filament truths at the lowest level. Nothing is decorated. Nothing is cosmetic. The shape of the tree IS the model.

**The One Sentence:**

> Relay is a living 3D world where every meaningful event becomes a filament on a tree, every tree sinks with time toward permanent truth, and the shape of every branch tells you — without reading a single number — whether things are healthy, stuck, or dying.

### 0.1 The Universal Laws

Every system has one identity that must always hold. Accounting has `A = L + E`. Thermodynamics has conservation of energy. These are Relay's.

**Law 1 — The Partition Identity (Relay's `A = L + E`)**

At any scope S (filament, branch, tree, planet), at any moment in time:

```
M_S = M_S_firm + M_S_fog + M_S_wilt
```

Every unit of committed mass is in exactly one of three visible states:

| State | Formula | Meaning |
|-------|---------|---------|
| **Firm** | `M × C × (1 − W)` | Proven, evidenced, resolved |
| **Fog** | `M × (1 − C)` | Uncertain — missing evidence |
| **Wilt** | `M × C × W` | Neglected — integrity deficit |

Where `C` = confidence, `W` = wilt. The sum is always 1:

```
C(1−W) + (1−C) + CW = C − CW + 1 − C + CW = 1
```

This is always true. At every scale. For a single filament, for a branch, for a civilization. The shape of any tree at any moment is a partition of its committed mass into these three states — and the partition is always visible. There is no fourth state. There is no hidden mass.

| Accounting | Relay | Meaning |
|-----------|-------|---------|
| Assets | Total Committed Mass (M) | Everything ever committed |
| Liabilities | Fog + Wilt | What is uncertain + what is neglected |
| Owner's Equity | Firm Structure | What is proven and resolved |

**Law 2 — Mass Conservation**

```
M_S(t) = M_S(t₀) + Σ ΔM_commit(t₀ → t)
```

Nothing committed disappears. Ever. Mass only increases through new commits. Gravity moves *where* mass sits (bark → rings → heartwood). Confidence and wilt reclassify mass *between* firm, fog, and wilt. Neither changes the total. Compression compacts the representation but preserves the hash. Append-only is not just a rule — it is the conservation law.

**Law 3 — Layer Separation**

Only committed wood (filaments) counts toward M. Leaves and sap are not mass until promoted. The three layers map to the three financial statements:

| Financial Statement | Relay Layer | What It Shows |
|--------------------|-------------|--------------|
| Balance Sheet | Wood (filaments) | The partition of M right now — firm, fog, wilt |
| Income Statement | Leaves (LeafPackets) | Current period activity — promotions in, compost out |
| Cash Flow Statement | Sap (SapPackets) | Live movement — what is flowing, where, how fast |

**The one sentence:** Committed mass is conserved; uncertainty cannot be hidden — it only moves between fog, wilt, and firm.

**Contract #206 — Universal Partition Law. At any scope (filament, branch, tree, region, planet), total committed mass equals the sum of firm mass, foggy mass, and wilted mass. The partition is always visible, always computable from confidence and wilt, and always sums to the total. There is no hidden mass, no fourth state, and no way to make uncertainty invisible. This identity holds at every snapshot, at every scale, and cannot be violated by any template, governance action, or system behavior. It is Relay's fundamental accounting equation.**

### 0.2 The Two Forces

Two forces govern all motion in Relay:

1. **GRAVITY** (Earth time) — pulls everything DOWNWARD toward the roots. Universal. Constant. The globe slowly rotates; this rotation IS time. Everything sinks. Transactions, conversations, observations, complaints — all sink toward reconciliation, completion, and permanent archive. This force is unstoppable. It is the clock.

2. **GROWTH** (engagement) — pushes things OUTWARD. When people engage — respond, vote, attach evidence, discuss — the filament grows. Growth counters gravity. A filament growing faster than it sinks is alive and visible. A filament that stops growing sinks into the archive. The balance between gravity and growth determines the shape of every tree on the globe.

### 0.3 The Three Globe Metrics

At global scale, three metrics determine what the world sees:

- **Engagement Rate** (vote count, positive + negative) — how many people took a deliberate stance. This is what raises topics off the globe surface.
- **Attention Rate** (presence focus count) — how many people are looking at this right now. The most important metric — raw eyeballs.
- **Acceleration** (heat = d(engagement)/dt) — how fast things are changing. This is what makes something HOT. Not size, not age — the rate of change. A military crisis with evidence pouring in at 10,000 commits/hour blazes red.

### 0.4 The Six Universal Domains

Every event in Relay — whether it is an invoice, a pothole report, a scientific observation, or a conversation — carries six pieces of context. These six questions are what make the tree physics work:

1. **IDENTITY** — What is this thing? An invoice, a bug report, a vote, a complaint.
2. **COUNTERPARTY** — Who else is involved? The vendor, the neighbor, the other party. Their direction determines where the event appears on the branch surface.
3. **TIME** — When did it happen? When is it due? When was it resolved? Time drives sinking — older events are deeper.
4. **MAGNITUDE** — How much? Dollars, severity, count, score. Magnitude drives color — warm for large amounts, cool for small.
5. **EVIDENCE** — What proves this is real? Documents, photos, signatures, references to other events. Evidence drives opacity — well-evidenced events look solid; unsupported claims look transparent.
6. **LIFECYCLE** — Where is it in its journey? Just opened, actively being worked, on hold, closed, fully absorbed into the permanent record. Lifecycle drives position — new events sit on the outer surface, completed events migrate inward toward the core.

### 0.4 Truth vs Projection

Everything in Relay is either TRUTH or PROJECTION:

- **Truth** (natural color): Branches and filaments that represent real events. Append-only, commit-signed, verifiable. Cannot be deleted. Reverts create visible scars.
- **Projection** (light blue): Analytical branches derived from truth. Read-only computation. No new filaments. Visible ETL pipelines with decision nodes, alignment zones, and summary termini. Promotable to permanent fixtures via governance.

### 0.5 The Eight Edges of Livability

A correct system can still be unlivable. Relay must be both. These eight guarantees are constitutional — no governance action, template, or parameter change may violate them:

1. **People can leave.** Any user can close their account at any time. Closure is a commit, not a deletion. History remains (append-only), but the user's active participation ends immediately and unconditionally.
2. **People can disagree quietly.** Soft divergence is a first-class primitive. A user may record "I disagree but I am not stopping work" without triggering a formal dispute, consuming pressure budget, or escalating to governance. Quiet disagreement is not silence — it is recorded, visible in cross-section, and preserved.
3. **People can wait.** Irreversible actions (policy changes, authority grants, stage transitions, constitutional amendments) require a mandatory cooling window of 24-72 hours before execution. No bypass. Urgency does not override deliberation. Emergency dispatch (§74) is the sole exception — and even emergency actions are committed and auditable.
4. **People can lose without burning out.** Jury fatigue caps (§85), cognitive load monitoring, session timeout enforcement, and mandatory sabbatical periods prevent the system from consuming its most engaged participants. The system cannot demand more than a person can give.
5. **History stays legible.** Summaries, aggregations, and dashboards are always projections — never truth. Summaries must cite source filaments and can never be used as evidence in governance or disputes. Truth is always the original commit, not any derivative of it.
6. **Vulnerable participants are safe.** Protected participation profiles (§63 for minors, configurable for any at-risk population) provide reduced visibility, forbidden roles, capped engagement load, and mandatory oversight. Protection is structural, not optional.
7. **Communities can coexist.** No community's governance can override another's within that other's tree boundary. Cross-region feature negotiation uses the intersection of both feature sets (§85). Truth is universal; governance is local.
8. **Inaction is respected.** "Reviewed; no action needed" is a valid and legitimate resolution. A `STABILITY_CONFIRMED` commit formally closes an open pressure loop, requires a 60-day cooldown before reopening, and consumes no future pressure budget. Not every open item requires change.

**Contract #305 — The Eight Edges of Livability. Relay must be correct AND livable. These eight constitutional guarantees cannot be violated by any governance action, parameter change, template design, or system behavior: (1) users can always leave, (2) quiet disagreement is a first-class primitive that does not escalate, (3) irreversible actions require mandatory cooling windows, (4) engagement fatigue is structurally prevented, (5) summaries are always projections and never truth, (6) vulnerable participants have structural protection, (7) communities govern themselves without overriding others, (8) inaction is a legitimate and respected resolution. These eight edges define the boundary between a system that is technically correct and a system that humans can actually inhabit.**

---

## 1. The Globe

> *"The Earth is the cradle of humanity, but mankind cannot stay in the cradle forever."* — Konstantin Tsiolkovsky

The Cesium 3D globe is the root context. It slowly rotates — this rotation IS earth time, the gravitational constant driving all sinking.

### 1.1 What You See

Trunks rise from the globe surface. Each trunk marks an entity — a company, a neighborhood, a city, a country, a research project, a person. Hot spots glow where attention concentrates. Branches rise and fall as engagement flows. Streams of presence markers show where humanity is looking RIGHT NOW.

### 1.2 Trunk Prominence

A trunk's visibility on the globe is determined by the three globe metrics:

- **Height off surface** = engagement rate (vote count). More votes = taller trunk.
- **Glow intensity** = attention rate (presence focus count). More eyes = brighter.
- **Color temperature** = acceleration (heat). Fast change = hot red. Stable = cool blue.

A trunk with zero engagement is invisible at globe LOD (Level of Detail — how much you see at each zoom level; see Glossary) — it exists but doesn't command attention. A trunk with millions of votes and rapidly accelerating evidence is a blazing beacon visible from any zoom level.

### 1.3 Below the Surface — The Root System

The globe's crust is not empty. Below the surface lies the root archive — the compressed, Merkle-encrypted (tamper-proof chain-linked — see Glossary) permanent record of everything that has ever been reconciled. Deeper = older. Archaeologists and historians can zoom BELOW the surface to explore root strata, creating findings filaments on the present surface with evidence twigs reaching down into buried root layers.

**The roots are not dead storage. The roots are alive.**

A real tree's root system mirrors its canopy. The root network is as complex, as branching, and as active as the branches above ground. Relay's root system follows the same principle. The root system IS the archive layer — and it obeys the same tree physics:

**Root structure:**
- The trunk continues below the surface as the **taproot** — the central archive spine.
- Major branches above ground produce corresponding **root branches** below ground. The Finance branch above has a Finance root below. The HR branch above has an HR root below.
- Root branches subdivide fractally — just like the canopy. Deeper sub-roots hold older, more compressed data.
- Root depth = time depth. The deepest roots hold the oldest archived data (Level 2 cold storage). Shallow roots hold recently archived data (Level 0-1).
- Root growth is semi-proportional to canopy activity. A branch that absorbs massive filament volume produces a thick, deep root. A thin, inactive branch produces a thin, shallow root. The roots grow downward as things grow outward and sink into them — canopy activity feeds root mass, root depth reflects how much history has been absorbed.

**Root physics — identical equations, archive interpretation:**

| Branch Physics (above ground) | Root Physics (below ground) |
|-------------------------------|----------------------------|
| Lean = counterparty pressure direction | Lean = retrieval demand direction (which regions/users are querying this archive most) |
| Droop/wilt = confidence deficit | Wilt = integrity concern (verification checks failing, hash mismatches detected, compression errors) |
| Heat = rate of change (engagement delta) | Heat = retrieval surge (sudden spike in archive queries — someone is auditing) |
| Fog = low confidence | Fog = low retrievability (many Level 2 snapshots, cold storage latency high) |
| Thickness = activity volume | Thickness = archive mass (how much resolved work has been absorbed) |
| Twigs = unresolved old filaments | Twigs = orphaned references (evidence refs that point to pruned data, pending rehydration) |
| Bark = active working surface | Root surface = recent archive boundary (data transitioning from warm to cold) |
| Helix twist = time grain | Helix twist = archive epoch cadence (how often Merkle checkpoints are published) |

**What root movement tells you:**

A manager doesn't normally look at roots. But an auditor, a compliance officer, or a system administrator does. When they zoom below the surface:

- **Root branch leaning:** "The Finance archive is being queried heavily from the EU region" — retrieval pressure is directional.
- **Root branch wilting:** "The 2024 Compliance archive has integrity warnings" — hash verification found issues, or cold storage retrieval is failing.
- **Root branch heating:** "Someone is running a deep audit across the entire HR archive" — sudden retrieval surge.
- **Root fog:** "The 2021 procurement archive is in deep cold storage — retrieval latency is high" — the data is there but slow to access.
- **Thick taproot:** "This company has massive resolved history" — deep, healthy archive.
- **Thin taproot:** "This company is young or has very little completed work" — shallow archive.

**Root rendering (LOD rules):**

- At TREE LOD and above: roots are invisible (below the crust). Only the trunk and canopy are visible.
- At TRUNK LOD (zoomed to trunk base): the root junction is visible — you see where the trunk enters the ground. A subtle glow or root-line pattern shows archive health.
- At ROOT LOD (zoomed below surface): root branches render as underground mirror of canopy. Same cylinder geometry, same slab rings (but representing archive epochs instead of active timeboxes), same lean/wilt/heat physics. Color palette shifts to earth tones (amber, brown, dark gold) to distinguish from the living canopy above.
- At DEEP ROOT LOD: the deepest strata — Merkle checkpoint anchors visible as dense crystalline nodes. Individual filament detail is gone (Level 2 compression). Only aggregate summaries and proof chains are rendered.

**Cross-section of roots:**

Cutting a root branch perpendicular shows archive rings — just like cutting a canopy branch shows timebox rings. But root rings represent archive epochs (Merkle checkpoint spans) rather than active timeboxes. Each root ring shows:
- How many filaments were archived in that epoch
- Aggregate magnitude of archived work
- Compression level (Level 0 = full detail ring, Level 2 = thin crystallized ring)
- Any integrity issues (cracks = hash verification warnings)

**Root physics — what generates the values (no imagination, no animation):**

Root movement is driven ONLY by measurable archive operations. Nothing else:

| Root Variable | Source (deterministic) |
|--------------|----------------------|
| Lean | `leanVec_root = Σ (retrievalRequest_weight × θ_request_origin)` — direction of retrieval demand |
| Heat | `heat_root = d(retrievalVolume)/dt` — rate of change in archive queries |
| Fog | `fog_root = 1 − archive_integrity_ratio` where integrity = % hashes verified × % blocks retrievable × % checkpoint consistency |
| Storm | `storm_root = heat_root × fog_root` — high retrieval surge + integrity uncertainty |
| Lightning | Cross-tree retrieval cascade: sudden multi-branch audit spanning many trees. `cascade_root = retrievalMagnitude × uniqueTreesTouched`. Flash if > threshold. |
| Wilt | `wilt_root = 1 − (verifiedCheckpoints / totalCheckpoints)` — checkpoint verification deficit |
| Thickness | `mass_root = Σ magnitude of all absorbed filaments` — archive mass |

If the roots move without a measurable cause from this list, the system has a bug. No theatrical motion. No smoothing. No mystery signals.

**The critical boundary — roots are diagnostic, never operational:**

Root movement must NEVER:
- Affect canopy physics (branch lean, wilt, heat, confidence are computed from filaments, never from root state)
- Affect filament lifecycle (no root condition can transition a filament's state)
- Affect governance (no root metric feeds into votes, sortition, or parameter changes)
- Affect availability (root fog does not block canopy rendering; root wilt does not pause commits)

Roots are a diagnostic mirror. Not a control surface. An auditor reads the roots. The roots never reach up and change the branches. This separation is absolute.

**Heartwood — the terminal stillness state:**

A real tree has heartwood at its deepest center. Heartwood is dead cells that no longer transport water or nutrients. They just hold the tree up — pure structural mass. Relay needs the same concept.

A root filament reaches **heartwood** when ALL of the following conditions are met:

```
HeartWoodCondition {
  compressionLevel: 2,                    // already at terminal compression
  ageThreshold: > configurable (default 10 years absorbed),
  integrityRatio: 1.0,                    // all hashes verified, all proofs valid
  retrievalFrequency: < threshold,         // nobody is actively querying it
  pendingIntegrityWarnings: 0,            // no open issues
  merkleCheckpointSealed: true            // checkpoint containing this data has been
                                          // sealed into a higher-order checkpoint
}
```

Once in heartwood state:
- **No lean** — retrieval direction is irrelevant (nobody is querying)
- **No heat** — no retrieval rate changes
- **No fog** — integrity is proven
- **No wilt** — no integrity concerns
- **Just mass** — contributing to trunk/root thickness and nothing else
- Rendered as dense, still, crystallized structure at DEEP ROOT LOD
- Color: dark amber to black (the oldest, most stable matter in the system)

**Can heartwood re-expand?** Yes, but only under three conditions:

1. **Integrity anomaly detected**: A periodic deep-verification sweep finds a hash mismatch or checkpoint inconsistency. The affected data reactivates from heartwood to active root. If clean after re-verification → returns to heartwood. If integrity issue confirmed → stays active root with wilt, emits scar.
2. **Legal/audit demand**: An external legal process or governance action forces rehydration of specific heartwood data. The data temporarily becomes active root (hot retrieval, Level 0 decompression) for the duration of the audit. After audit completes → returns to heartwood.
3. **Cross-tree evidence cascade**: A new filament in the canopy references heartwood data as evidence. The heartwood data is temporarily rehydrated for verification. After verification → returns to heartwood.

In all three cases, re-expansion is temporary and the data returns to stillness. Heartwood is the natural resting state of fully verified, fully compressed, undisturbed archive. It is structural memory at rest.

**What prevents root churn from destroying compression gains:**

Without heartwood, "alive roots" would create a problem: constant retrieval-driven lean recalculation across billions of archived filaments would generate unbounded compute. Heartwood solves this:
- Only non-heartwood root data contributes to root physics (lean, heat, fog, wilt)
- Heartwood is excluded from all aggregate equations — it is structurally still
- The vast majority of archive (>90% after a few years) is heartwood — undisturbed, unqueried, verified
- Only the active root layer (recently archived + currently queried + integrity-flagged) participates in root physics
- This keeps root compute proportional to active archive operations, not total archive size

**The fractal closure:**

The root system completes the tree:
- Canopy (above ground) = active work, living physics, counterparty pressure, real-time events
- Trunk (at ground) = consolidation gate, cross-branch reconciliation, sequential Merkle chain
- Active roots (shallow underground) = recent archive, retrieval physics, audit access, integrity monitoring
- Heartwood (deep underground) = terminal stillness, structural mass, proven integrity, pure memory

All layers except heartwood use the same ten equations (§3.19). Heartwood is the point where the equations yield zero — all forces balance, all proofs are sealed, all queries are silent. It is not dead. It is still. The tree is alive from root tip to branch tip, and at its deepest center, it rests.

### 1.4 Above the Surface

The LOD ladder extends beyond Earth:

```
CELL         individual filament row
BARK         spreadsheet on branch surface
BRANCH       branch cylinder
TREE         single tree (company/neighborhood/project)
CITY         city-level aggregation
COUNTRY      country-level aggregation
GLOBE        Earth surface (all trunks)
ORBITAL      satellites, space stations
LUNAR        the Moon
PLANETARY    solar system (planets as trunks)
STELLAR      nearby star systems
GALACTIC     Milky Way structure
LANIAKEA     supercluster scale
```

**Every celestial body IS a full Relay globe — not a dot on a zoom-out.**

The Moon is a Relay globe. Mars is a Relay globe. Every asteroid, every planet, every moon, every space station that has data being captured about it gets its own full Relay instance with identical physics. Satellites, rovers, orbital sensors, telescopes — these are the data sources that feed filaments into trees planted on those bodies, exactly like human activity feeds filaments into trees on Earth.

- The Moon has its own trees. Geological survey data from lunar orbiters = filaments on geology branches. Mission telemetry = filaments on operations branches. Each observation sinks inward with time. The Moon's tree rings encode lunar history the same way Earth's encode human activity.
- Mars has its own trees. Every rover observation is a filament. Atmospheric readings, soil analyses, radiation measurements — all filaments with the same six domains, the same lifecycle, the same physics.
- An asteroid has a tree if someone is collecting data about it. A telescope observation becomes a filament. A mining survey becomes a filament. The asteroid's tree grows as knowledge about it grows.
- A galaxy cluster has trees if civilizations within it are recording data. The physics scale identically (§3.19, §3.20).

History goes inward on every body. The cross-section of a Martian geology branch shows the same concentric rings as a Tel Aviv invoices branch — each ring is a timebox, thickness is activity density, cracks are scars, the core is compressed archive. The universal equations (§3.19) are truly universal — they don't just scale from file to company to country. They scale from microbe to planet to Laniakea. Every body with data has trees. Every tree has the same physics. Every physics produces the same emergent geometry.

---

## 2. The Trunk

> *"The creation of a thousand forests is in one acorn."* — Ralph Waldo Emerson

The trunk is the vertical spine rising from the globe surface (or from a parent branch at higher fractal levels).

### 2.1 Heartwood

The trunk's thickness is emergent from the total mass of absorbed filaments across all branches. No independent mechanic. More absorbed (completed, reconciled) filaments = thicker trunk. The trunk IS the accumulated record of all resolved activity.

### 2.2 Consolidation Gate

The trunk is where multiple branches converge as content sinks toward roots. It serves as a reconciliation checkpoint:

- Filaments from all branches meet at the trunk junction
- For financial trees: cross-branch double-entry balance is verified (TransferPacket: every debit has a matching credit)
- Only fully balanced, reconciled content passes through to roots
- Unreconciled content is held at the trunk level — visible as trunk-level outliers
- The gate rules are template-defined (financial balance for companies, completeness checks for municipalities, peer review for science)

**Archive pipeline ordering:** Within the branch rings, each filament independently completes its lifecycle at its own pace — there is no queue, no FIFO, no LIFO. A fast-closing invoice migrates inward while a slow dispute still sits on the bark. The branch rings are completion-gated, not sequence-gated.

But the actual archiving into roots (the exit at r=0 through the trunk into the root cubes) IS sequentially ordered — like blocks in a blockchain. Each root cube receives a sequential `commitIndex` in the global chain. This gives the archive untamperability: from the moment a payment is completed and recorded to GL, its position in the Merkle-sealed root chain is permanent, cryptographically verifiable, and deterministic. The chain order means any two independent systems replaying the same commit log will produce identical root archives, regardless of what order the filaments completed their lifecycles within the rings.

This separation is critical: **lifecycle is parallel (each filament independent), archiving is serial (one chain, one sequence, one truth).** The branch rings are where work happens. The root chain is where truth is sealed.

### 2.3 No Standalone Deformation

The trunk does not wilt, bend, or deform on its own. Its visual state is purely emergent from branch health. Healthy branches = firm trunk. Wilted branches = the trunk reflects the aggregate degradation.

---

## 3. The Branch — Cylindrical Coordinate Model

> *"In nature, nothing exists alone."* — Rachel Carson
>
> *"Truth does not require your agreement. It requires your geometry."* — Claude Opus 4.6

A branch is a category of work. Think of the "Invoices" pile in an accounting department, or the "Pothole Reports" stack at city hall, or the "Patient Records" shelf at a clinic. In Relay, each of these becomes a living 3D branch on the tree — a cylinder you can look at and immediately tell whether things are moving smoothly or piling up. New work appears on the outer surface. Completed work migrates inward. Old unfinished work sticks out like a twig. You see health at a glance, the way you can tell a real tree is healthy or dying without counting its leaves.

Here is how the geometry works. A branch represents a service type / activity category where every filament row shares the same basic schema. Branches are not departments — they are coherent units of analyzable work.

### 3.1 The Cylindrical Coordinates

Every point on or in the branch is defined by **(l, r, theta)**:

- **l** (length along branch) = **TIME**. l=0 at trunk junction. l=L_max at branch tip. Timeboxes are cross-sectional disks at regular l intervals.
- **r** (radial distance from center) = **LIFECYCLE MATURITY**. r=R_max is outer bark (OPEN/new). r=0 is center (ABSORBED, exiting to trunk). Filaments migrate inward as they mature.
- **theta** (angle around circumference) = **APPROACH DIRECTION**. Computed from the actual vector of approach — on the globe this defaults to compass bearing from tree to counterparty; on street view it is the literal physical direction measured by proximity detection.

### 3.2 The Bark IS the Content

The content does not sit at the end of the branch. **The content IS the bark — it wraps AROUND the branch surface.**

The bark rendering adapts to the content type defined by the template, but the cylindrical geometry is universal:

- Filaments stream along the l axis. Each filament is one atomic event (one row, one document, one file, one track).
- New events appear at the current timebox position on the outer bark surface.
- As long as a filament is OPEN, it continues to grow longer along l, existing in successive timeboxes.
- When a filament CLOSES, it stops growing on the bark and begins migrating inward (r decreases).
- Content wraps around the branch — exactly like real bark on a real tree.

**Per-content-type bark rendering at CELL LOD:**

| Content Type | l axis = | Bark at CELL LOD | Sinking Mode |
|---|---|---|---|
| Tabular (invoices, transactions) | Calendar time | Spreadsheet grid (rows × columns) | Earth-time |
| Documents (Word, contracts, briefs) | Content position (start → end) | Readable text scroll | Earth-time or milestone |
| Code (source files, config) | File position (line 1 → last line) | Syntax-highlighted source | Milestone (sprint/release) |
| Music / audio | Composition timeline (intro → outro) | Waveform or notation | Milestone (production phase) |
| Images / CAD / visual media | Version sequence | Visual viewport / gallery | Milestone (review cycle) |
| Projections (§6) | Pipeline stage (input → output) | Filter rules + summary | None (projections don't sink) |

At BRANCH LOD, every content type looks the same: a cylinder with timebox slabs, lifecycle ring zones, and helical twist. The content type only affects the CELL LOD rendering — what you see when the bark unrolls.

**The invariant:** Bark is not always a spreadsheet. Bark is always the native editor for the branch's content type.

### 3.2.1 Individual Filament Depth — The Radial Commit History

Each filament has depth. Looking at a single filament on the bark surface and going INWARD (radially toward the branch center), you see that filament's commit history layered like geological strata:

- **Outer bark surface** = the current state (the live value, the latest revision)
- **First inner layer** = the previous commit (the value before the last edit)
- **Deeper layers** = older commits, further back in time
- **Deepest layer** = the original state when the filament was first created

A filament that has been edited 50 times has more radial depth than one edited twice. The z-axis (radial) IS the version history of that specific filament.

**Per-content-type radial depth:**

| Content Type | Radial layers show | Example |
|---|---|---|
| Spreadsheet cell | Previous cell values | 10 → 15 → 15.5 → 16.2 (each commit = one layer) |
| Document section | Previous paragraph revisions | Draft 1 → Draft 2 → Reviewed → Final |
| Code function | Previous function versions | Like `git blame` depth per line |
| Music segment | Previous takes / mixes | Take 1 → Take 3 → Mix A → Master |
| Image / CAD | Previous asset versions | Sketch → Draft → Final render |

This means a branch cross-section (the pie-chart view) shows not just WHERE counterparties are (angular) and what lifecycle state filaments are in (ring zone), but also HOW MUCH HISTORY each filament carries (radial depth). A heavily-edited cell sits deeper in the rings than a cell that was entered once and never touched again.

### 3.3 Zoom-to-Flat LOD Transition

- **BRANCH LOD**: Full cylinder. Bark texture visible but individual rows not readable.
- **SHEET LOD**: Bark partially flattening. Column headers becoming visible. Some curvature remains.
- **CELL LOD**: Fully flat 2D spreadsheet grid. Users read, edit, and interact as in Excel. The cylindrical surface is conformally projected onto a plane.
- **Zooming out**: The flat grid re-wraps onto the cylindrical branch surface.

### 3.4 Branch Cross-Section — Triple Encoding (The Pie Chart)

Branches extend outward from the trunk, rising from the globe surface so that each branch is a cylinder that can be sliced perpendicular to its axis. That cross-section is a pie chart. It encodes THREE things simultaneously:

**Radial** (distance from center) = lifecycle maturity + commit history depth:
- Outer bark = OPEN/new filaments (just spawned, few commits)
- Middle rings = ACTIVE filaments (in progress, accumulating commit depth)
- Inner rings = CLOSED filaments (resolved, settling inward, full history)
- Core = ABSORBED (exiting to trunk through consolidation gate)
- A heavily-edited filament sits deeper than a lightly-edited one at the same lifecycle stage (§3.2.1)

**Angular** (compass direction) = approach direction of counterparty:
- A client from the east appears on the east side of the bark
- A vendor from the north appears on the north side
- Angular clustering reveals counterparty concentration: "most of our invoices come from the northwest" is immediately visible

**Color/opacity at each point** = magnitude and confidence:
- Warm (red) = high magnitude. Cool (blue) = low magnitude.
- Solid = high confidence (well-evidenced). Transparent = low confidence.

The cross-section is simultaneously a **tree ring diagram** (radial = lifecycle depth), a **pie chart** (angular = counterparty distribution), and a **heat map** (color = magnitude, opacity = confidence). Looking at it, you can tell in one glance: where your counterparties are, how mature your work is, how much money is flowing, and how well-evidenced it all is.

### 3.5 The Helical Twist — Time Grain

The branch has a subtle spiral grain along its length — like a barber pole or twisted rope.

- One full twist = one configurable time period (day, week, sprint, quarter)
- Filament rows follow the spiral as they grow along the bark
- A filament alive for 3 weeks spirals around 3 times
- Count the twists = count the time periods
- The twist is structural (the time grain), not a free-spinning animation

### 3.5.1 Angular Disambiguation — Six Distinct Rotations

The system uses angular/rotational concepts in six independent ways. They are NOT the same thing. Implementers must never conflate them:

| # | Concept | Symbol | What It Controls | Defined By | Changes Over Time? |
|---|---------|--------|-----------------|------------|-------------------|
| 1 | **Filament θ** | `θ`, `theta` | Where a filament sits on the bark surface (pie chart sector) | Counterparty approach direction (geographic bearing or template category bin) | No — fixed at filament creation |
| 2 | **Branch layoutAngle** | `layoutAngleRad` | Where a branch points from the trunk in 3D space | `hash(layoutKey)` — identity only (§3.18) | Never — deterministic from identity |
| 3 | **Helix twist** | twist period | Spiral grain along the l axis | Template time period (day/week/sprint) | No — structural constant per template |
| 4 | **Branch lean** | `θ_lean`, `leanDir` | Small tilt deformation of the branch body | Net counterparty θ pressure from Equation 3 (§3.19) | Yes — recomputed at each timebox close |
| 5 | **Globe rotation** | Earth rotation | Time itself — the universal clock | Real Earth rotation | Continuous — this IS time |
| 6 | **Camera reorientation** | (UI only) | View angle for cross-section mode (§3.13) | User interaction | On-demand — not physics |

**Critical rules:**
- **Filament θ ≠ Branch layoutAngle.** A filament's counterparty direction on the bark is independent of which direction the branch points from the trunk. They live in different coordinate frames.
- **Lean ≠ Layout.** Lean is a small deformation (capped 5-10°) applied AFTER layout. It never moves the branch out of its layout slot. Contract #114.
- **Helix twist ≠ Lean.** Helix is structural grain along the branch length. Lean is a directional tilt of the whole branch body. They are perpendicular effects.
- **Globe rotation ≠ any branch rotation.** Globe rotation is the time constant. Branch layout, lean, and helix are all local to the branch.

**Contract #290 — Branch Straightness Invariant. Branch geometry is Euclidean-straight (a cylinder) unless deformed by an equation. The only legitimate deformations are: lean (Equation 3, §3.15 — small directional tilt from counterparty pressure, capped 5-10°), droop (wilt — integrity deficit sags the branch downward), and thickness variation (mass accumulation from filament density). Helix twist (§3.5) is a micro-effect producing wood-grain texture on the bark surface — it never distorts the cylinder's central axis. No rendering pass may invent curvature, spiral, corkscrew, or wave deformation that is not the output of a defined equation with defined inputs. If a branch appears curved, a viewer must be able to identify which equation produced the curve and which data drove the equation. Aesthetic embellishment of branch geometry is prohibited. The straightness invariant is frozen.**

### 3.6 Timebox Slabs — The Vertebrae

Cross-sectional rings segment the branch into time periods. Each ring = one timebox.

**Core properties computed FROM the filaments within:**

- **Thickness** = commit density (more commits in period = thicker ring)
- **Color** = aggregate magnitude (warm palette for net positive, cool for net negative). Magnitude is encoded as color, not as directional extrusion.
- **Opacity** = confidence (automatic: evidence_present / evidence_required). No manager approval.
- **Firmness** = wilt factor (0.0 = fully firm, 1.0 = maximally wilted)
- **Filament length** along the L-axis emerges from commit topology — see §78 for the full filament length ontology including five emergent profile classes (micro, transaction, project, structural, continuous).

**Aggregate fields (computed at timebox close, cached for lean physics §3.15 and weather overlays §3.16):**

```
TimeboxAggregate {
  timeboxId: string,
  branchId: string,
  startAt: ISO-8601,
  endAt: ISO-8601,
  commitCount: number,
  filamentCountActive: number,
  filamentCountClosed: number,
  twigCount: number,
  orgConfidenceAvg: number,
  orgConfidenceMin: number,
  globalConfidenceAvg: number,

  // Lean vector (drives branch lean at timebox close, §3.15)
  leanVecX: number,
  leanVecY: number,
  leanWeightSum: number,
  leanTopContributors: Array<{ counterpartyRef, weight }>,
  leanTopFilaments: Array<{ filamentId, weight }>,

  // Weather (drives tile overlays at REGION/GLOBE LOD, §3.16)
  engagementDelta: number,
  engagementRate: number,
  heat: number,
  fogIndex: number,
  stormIndex: number
}
```

All fields are deterministic aggregates of underlying filament data. No scores. No ML. No tuning knobs. Every field is traceable to specific filaments and their commit logs. Lean fields drive branch movement physics. Weather fields roll up into TileAggregates for regional overlays. Wind is not a separate field — wind is the pattern of lean observed during time replay (§3.15).

### 3.7 Wilting — Emergent Branch Deformation

Wilt is a timebox slab property, not a branch-level variable:

- Healthy slab (wilt < 0.3): firm, crisp edges, full opacity. Ring holds its shape.
- Degraded slab (0.3-0.7): edges soften, opacity drops. Ring starts to sag.
- Wilted slab (> 0.7): walls collapse, transparent. Ring droops visibly.

**Branch drooping is EMERGENT.** When multiple adjacent timebox slabs wilt, the branch segment between them loses structural support and droops — like a spine with crushed vertebrae. No independent branch droop variable exists. The branch droops BECAUSE its timebox vertebrae lost integrity.

Wilt inputs (computed from filament data, never heuristic):
- Unresolved obligations within the timebox
- Confidence decay (missing inputs, incomplete coverage)
- Time since last verification event

Wilt recovery: immediate on next render cycle after verification events arrive.

### 3.8 Collision Physics — Material Resistance

Timebox slab walls have physical material properties:

- Firm slabs resist camera penetration — feels solid, boundary pushes back
- Wilted slabs offer less resistance — camera slides through, area feels uncertain
- Adjacent firm slabs maintain branch rigidity
- UX-as-physics: healthy data feels solid; uncertain data feels soft

### 3.9 The Branch Tip — Tiny Insight Endpoint

The branch tip is NOT a large spreadsheet. It is a small endpoint — like a bud on a real tree — showing only the final summary overview: categories and results over time. The insight. The bark (raw data) is distributed along the branch LENGTH. The tip is the productive output.

### 3.10 Twigs — Emergent Outlier Geometry

A twig is the natural geometric consequence of a filament that sinks downward (gravity is universal) but doesn't migrate inward (it hasn't closed).

Everything else at that old timebox level has completed and moved to the center. This one filament is still at bark-level radius. So it's the only thing protruding from the branch surface at that depth. It literally looks like a twig.

The longer it stays unresolved, the lower it sinks (gravity keeps working), and the more it sticks out — because at each lower timebox, more of its contemporaries have completed. The twig "grows" not because it's getting worse, but because everything else is getting better.

No special twig detection code is needed. The cylindrical coordinate system produces this naturally: any filament at (low_l, R_max, theta) when everything else at that l is near (low_l, ~0, theta) will geometrically protrude.

### 3.11 The Downward Slope

The branch has a natural downward slope:

- The tip (newest time) is highest — fresh activity at the surface
- The trunk junction (oldest time) is lowest — old content sinking toward roots
- Filaments within the branch also drift downward as they migrate inward

The combined effect: old, completed content is at the lowest point (trunk base / root junction). New bark arrivals are at the highest point (branch tip). The branch is a slope from present (high, tip) to past (low, trunk).

### 3.12 Two Axes of "Old" — Why Twigs Exist

A filament has two independent notions of age:

1. **Time-old** (gravity / sinking along l): When the event happened. Gravity pulls everything downward along the branch toward the trunk junction. Older events are deeper. This is universal and unstoppable — the clock never stops.

2. **Maturity-old** (lifecycle / inward along r): How settled the event is. Evidence, matching, and fulfillment of template rules push filaments inward toward the core. A fast-closing invoice migrates inward quickly. A disputed one stays on the outer bark.

These two axes are **independent**. A filament can be:

- **Old in time + inward** (normal): An invoice from January, fully matched and paid. It has sunk deep and migrated to the core. Invisible — healthy completion.
- **Old in time + still on bark** (twig): An invoice from January, still unmatched. It has sunk deep (gravity doesn't care about disputes) but hasn't migrated inward (it hasn't closed). Everything around it at that timebox level has completed and moved to center. This filament alone protrudes at bark radius. It IS a twig.
- **New in time + already inward** (fast-close): A payment received today, immediately matched with three-way evidence. It just appeared at the tip but already has full confidence and begins migrating inward. Fast lifecycle, recent timestamp.
- **New in time + on bark** (normal): A new invoice just received. On the outer surface at the branch tip. Just spawned.

This two-axis independence is the core mechanism that makes the tree shape meaningful without any decoration or dashboard. The shape is emergent from the data. Twigs, wilting, trunk thickness, and branch health are all natural geometric consequences of where filaments sit in the (l, r) space.

### 3.13 Cross-Section Inspection Mode — Reading the Rings

The archive is not meant to be legible from the branch surface. On the branch surface you see current work, near-time slabs, twigs, wilt — live structure. The archive becomes legible when you rotate into cross-section mode. Exactly like cutting a real tree branch to count its rings.

A real tree cross-section (reference: the canonical tree photo showing concentric growth rings, radial cracks, bark layer, and compressed core) reveals five truths simultaneously:

- **Rings** = timebox slabs (each growth cycle)
- **Ring thickness** = activity density (thick ring = busy period)
- **Ring color variation** = magnitude and confidence
- **Radial cracks** = scars (stress events permanently visible)
- **Dense core** = compressed archive (old, reconciled, compacted)

Cross-section mode exposes this same view for any branch.

**I. Entering Cross-Section Mode**

Trigger: User must be at BRANCH LOD, focused on a single branch. Entry by double-click on branch cylinder, or dedicated inspect action.

Visual transition (UI camera action — not physics rotation):
1. Camera repositions perpendicular to branch axis. Branch cylinder reorients to face camera directly, centered on a selected slab region (default = most recent). This is a view change, not a data or physics operation.
2. Bark opacity fades to 0.25. Body cylinder fades. A cross-section cut plane animates into view.
3. Concentric rings appear: each ring = one timebox slab. Thickness varies by activity density. Color = magnitude. Opacity = confidence. Cracks = scars. Wilt deformation visible on affected rings.

State model: `viewMode = 'CROSS_SECTION'`, `activeBranch = branchId`, `sliceDepth = currentTimeboxIndex`. No data changes — only camera and rendering mode changes.

**II. Scrubbing Inward Through Rings**

A radial time scrubber allows exploring archive depth:

- **Scroll wheel**: inward = deeper in time (toward core), outward = toward recent slabs.
- **Click and drag**: a ring's outer edge to expand it temporarily.
- **Keyboard**: arrow keys step slab by slab. Shift+arrows jump 5 slabs.

Visual feedback: selected ring glows subtly. Non-selected rings dim. Filament cross-points appear on the selected slab. Ring thickness visually expands (temporary magnification for legibility).

**III. Expanding a Specific Slab**

User clicks a ring:

1. All other rings fade to 20% opacity. Selected ring expands radially for legibility. Ring thickness increases temporarily.
2. The ring flattens into a circular disc panel facing the camera. You now see all filaments that crossed that slab — their angular positions (theta = counterparty direction), lifecycle states at that timebox, magnitude encoding, and evidence ratio.

This is a "timebox snapshot." Optional lens filters: show only unresolved, show only scars, group by counterparty, sort by magnitude.

**IV. Jumping from Slab to Individual Filament**

User clicks one filament on the expanded slab disc:

1. That filament's theta sector lights up. A thin radial line extends along the branch axis — the filament's entire ribbon path from bark to root.
2. Camera repositions 90° back to longitudinal (branch axis) view. The selected filament ribbon is highlighted. All other ribbons dim.
3. Context overlay appears: identity block (left), timeline block (right), full commit history, evidence attachments, lifecycle transitions, scar references, and backing refs.

**V. Exiting Cross-Section Mode**

Press Esc, click branch body, or click "Return to Bark." Camera returns to default position. Cylinder regains opacity. Return to longitudinal flow view.

**Critical constraints:**
- Cross-section mode never modifies data.
- Slab expansion is render-only (temporary magnification).
- Scrubbing does not pause gravity. Time keeps sinking.
- Filament positions are always derived from commit timestamps.
- No separate archive copy exists. The rings ARE the data.

### 3.14 Organic Growth Rendering — Biology, Not Mechanics

A real tree's growth rings are not perfect circles. They are slightly uneven. Thickness fluctuates around the circumference. Grain is not perfectly radial. Relay's visual model must eventually reflect this.

**Slab organic variation (rendering refinement):**
- Ring thickness varies slightly by theta (circumferential non-uniformity). Where more filaments cluster (high counterparty concentration in one angular sector), the ring is slightly thicker on that side.
- Subtle Perlin noise applied to slab surfaces. Growth should feel biological, not mechanical.
- Deep archive rings visually compress toward the core. LOD determines representation: at TREE LOD deep archive = thin inner band. At BRANCH LOD = denser bands. At CROSS-SECTION LOD = full fidelity.
- The compression is visual only. Data exists in full fidelity at every depth.

**Bark ridge deformation on schema evolution:**
- When schema versions change (new columns added, new domain attributes introduced, template upgrades), the bark texture shifts subtly: micro ridges or directional changes in the bark shader appear at the timebox where the schema version bump occurred.
- The deep ridges of the bark show where structural changes happened. The flow direction remains visible in the grain (commit causality along the l axis), but the ridges mark where the branch's schema grew.
- This is not a data mutation — it is a rendering response to `schemaVersion` commits in the branch's history.

**Scar crack propagation (rendering refinement):**
- Scars (§4.5) should not only appear as red marks on the bark. In cross-section mode, scars appear as radial cracks — lines extending from the slab where the revert occurred outward toward the bark and slightly inward toward older rings.
- Cracks slightly warp adjacent slab surfaces (geometric deformation proportional to scar severity). A minor data correction creates a hairline crack. A major governance revert creates a visible fissure.
- Cracks do not erase rings. They do not delete data. They become part of the structure — permanently visible stress history, exactly like a crack in real wood.

**The grain = commit causality:**
- The vertical grain visible on the branch surface represents the l axis — the direction of growth. Even after archive compression, you can still see which direction work traveled because commit timestamps are immutable, slab order is immutable, and radial compression preserves sequence.
- The helical twist (§3.5) matches the spiral grain visible in real wood. Age twists. Time rotates. The grain IS the Merkle chain made visible.

### 3.15 Wind — The Inverse Metric of Branch Movement Over Time

Wind is not a separate overlay. Wind is not rendered as arrows or indicators. Wind is what you **observe** when you replay the tree's history and watch branches move.

A branch moves because the data inside it changed. If you replay a year of Invoices branch history, you see it lean toward the northwest for three months, then shift south in Q3, then settle back. That movement IS the wind. You are watching the wind happen. Wind is calculated inversely from the observed branch movement trajectory — it is a metric derived from replay, not a real-time decoration.

**Two types of wind (both observed through replay, never rendered as separate indicators):**

1. **Internal lean** (micro / within a branch): The lean vector from counterparty θ pressure on the branch's own filaments. One branch leans because its filaments cluster directionally. This is the primary wind described below — computed per branch at each timebox close.

2. **Structural drift** (macro / orbital): How a branch's effective presence within its layout slot changes over time due to growth, contraction, or mass change. A branch that resolves massive volume grows thicker (more trunk mass feed, larger rendered radius). A branch that withers contracts. This is visible during replay as the branch gaining or losing "orbital weight" — not because the layout slot (§3.18) changed, but because the branch's rendered thickness and visual prominence expanded or shrank within its fixed slot. At planetary and galactic scale, structural drift becomes how entire trees shift in heat/fog fields relative to their neighbors (see §3.20 Orbital Model).

**What causes branch movement (the three physics):**

| Component | Source | Direction | Update Frequency |
|-----------|--------|-----------|-----------------|
| **Lean** (horizontal) | Net counterparty θ pressure from filaments on bark | Toward weighted centroid of active filament approach angles | Per timebox close |
| **Droop** (vertical) | Wilt from slab firmness deficits (§3.7) | Downward | Per timebox close |
| **Twist** (surface rotation) | Helix period (§3.5) | Rotational along l axis | Continuous (slow) |

No other motion exists. No wiggle. No bounce. No decorative animation. If it moves, the data changed. If the data didn't change, the branch is still.

**Lean computation (per branch, per timebox close):**

The theta axis on the bark encodes counterparty approach direction (§3.4). At each timebox close, the net directional pressure from all active filaments produces a lean vector:

For each branch `b`, at timebox close:
1. For each filament `f` active in the closing timebox where `approachAngleRad` is not null:
   - Compute weight: `w = windWeight(f)`
   - Accumulate: `windVecX += cos(θ_f) × w`, `windVecY += sin(θ_f) × w`, `windWeightSum += w`
2. Lean direction: `leanDir_b = atan2(windVecY, windVecX)`
3. Lean strength: `leanStrength_b = clamp(|V_b| / scaleFactor, 0..1)`

**Deterministic wind weight function (frozen — no ML, no randomness, no hidden tuning):**

```
w = 1.0
w × lifecycleMultiplier:  SCHEDULED = 0.0 (inert), OPEN/ACTIVE/HOLD = 1.0, CLOSED/ABSORBED = 0.2
w × magnitudeMultiplier:  0.5 + 0.5 × clamp(|magnitude| / magScale, 0..1)
w × pressureMultiplier:   0.5 + 0.5 × (1 - orgConfidence)
w × twigMultiplier:       1.5 if filament is a twig (overdue), else 1.0
```

Open, high-magnitude, low-confidence, overdue filaments exert the most directional pressure.

**The four quadrants (what lean direction means):**

The quadrants a branch can lean toward are determined by the branch's template mapping:

- **Geographic mapping** (default): θ = true compass bearing from tree location to counterparty location. NE/SE/SW/NW = literal geographic directions. "Invoices branch leaned NW in Q1" = most pressure came from vendors in that direction during Q1.
- **Category mapping** (template-defined): θ bins map to counterparty categories (e.g., 0°=Suppliers, 90°=Customers, 180°=Regulators, 270°=Internal). "Branch leaned toward Suppliers in March" = supplier pressure dominated that month.

**Lean rendering (small deformation, not layout change):**

When computing branch path frames (`branch._branchFrames`), apply a small lateral offset curve:
- `leanOffset = maxLeanMeters × leanStrength` (maxLeanMeters is small — capped at 5-10° of tilt, never a dramatic repositioning)
- Offset is perpendicular to branch tangent, in ENU frame, toward `leanDir` projected into local ENU.
- Updates at timebox boundaries only, not per frame. No jitter.

**Critical distinction: lean is NOT layout.**

Branch layout direction (where the branch points in space from the trunk) is determined by `layoutKey` (§3.18). It never changes based on counterparty data. Lean is a small deformation applied *after* layout — a slight tilt within the branch's fixed position. Even a maximal lean does not move the branch out of its layout slot.

**Explainability (non-negotiable):**

Clicking a branch during replay (or clicking the branch in its current lean pose) opens a panel showing:
- Top counterparty contributors to the lean vector (top-K by weight)
- Top filament IDs driving the lean (top-K by individual contribution)
- The timebox window producing the current pose

Every lean direction is traceable to specific filaments and counterparties. If a manager sees the branch leaning, they can click once and know exactly why.

**Wind as a replay metric:**

When a user replays a time range (§15, TIME-SCRUB-1), they watch the branch lean shift timebox by timebox. The pattern of lean over time IS the wind. A branch that consistently leans one direction has a prevailing wind from that quadrant. A branch that swings back and forth is experiencing turbulent counterparty changes. A branch that doesn't lean at all has balanced or no directional pressure. No separate wind visualization is needed — the branch movement itself is the visualization.

### 3.16 Weather Overlays — Heat, Fog, Storm, Lightning (Branch Weather)

This section describes **branch weather** — social/operational truth fields computed from filament activity. Relay also has a separate **physical weather** layer (§75) that renders real meteorological data from sensors. The two layers stack visually but use different color palettes and data sources.

Branch weather is not a metaphor. It is a set of deterministic overlay computations derived from timebox aggregates with no hidden inputs. Weather is rendered at REGION and GLOBE LOD as tile-based overlays. It tells you the state of large areas at a glance.

**Four weather effects, all deterministic:**

**Heat (urgency / acceleration):**
- Computation: `heat = engagementRate_current - engagementRate_previous` (rate of change of engagement across adjacent timeboxes)
- Rendering: color temperature on region tiles. Hot = red/orange pulse. Cool = blue/grey. Neutral = no overlay.
- What it means: "Things are changing fast here." A hot region has accelerating engagement — new filaments, new commits, new votes. A cold region is stable or dormant.
- Log: `[HEAT] tile=<id> heat=<value> window=<start>-<end>`

**Fog (low trust / weak evidence):**
- Computation: `fogIndex = 1 - orgConfidenceAvg` (average organizational confidence across all branches in tile scope)
- Rendering: grey desaturated haze overlay on region tiles. Alpha = fogIndex. Dense fog = very low confidence.
- What it means: "We can't see clearly here." Fog means the data exists but the evidence backing it is weak. Invoices without PO matches. Compliance filings without attestations. The work is happening but nobody can prove it's correct.
- Log: `[FOG] tile=<id> fogIndex=<value> confidenceAvg=<value>`

**Storm (high acceleration + low confidence = dangerous):**
- Computation: `stormIndex = norm(heat) × norm(fogIndex)` — things changing fast AND evidence is weak.
- Rendering: flicker + turbulence overlay. `brightness = base + stormIndex × (0.5 + 0.5 × sin(t + phase))` where `phase = hash(timeboxId + tileId)` (deterministic, not random). Stacks above heat and fog.
- What it means: "Lots happening, nobody can prove any of it." This is the danger zone. A storm over a region means rapid activity with no evidence backing. A manager sees storm and should intervene immediately.
- Log: `[STORM] tile=<id> stormIndex=<value> heat=<value> fog=<value>`

**Lightning (cascade events — evidence spreading across trees):**
- Trigger: At timebox close, build graph edges from `evidenceRefs(type='filament')` created in this timebox. If `uniqueTreesTouched >= T1 AND edgeCount >= T2`, emit a LightningEvent.
- LightningEvent record: `{ eventId, startAt, windowSec, originFilamentId, edgeCount, uniqueTreesTouched, pathSample: [{ from, to }], scope: branch|tile|global }`
- Rendering: brief bright path flash along sampled evidence edges. At TREE/BRANCH LOD = short bright segments between filament positions. At GLOBE/REGION = single beam between involved trunks/tiles. Duration = 1.0s, keyed by `startAt`.
- What it means: "One piece of evidence just rippled across many trees." A lightning flash means a single filament's evidence (a payment confirmation, a test result, a regulatory filing) just connected to filaments in many other trees. That's either very good (broad reconciliation) or very important (systemic event).
- Log: `[LIGHTNING] eventId=<id> origin=<filamentId> edges=<n> trees=<n> scope=<scope>`

**Scope tile computation:**

At GLOBE/REGION LOD, per-branch weather aggregates are rolled up into geographic tiles (geohash or fixed lat/lon grid). Each tile per timebox window stores:

```
TileAggregate {
  tileId: string,
  windowId: string,
  heat: number,
  fogIndex: number,
  stormIndex: number
}
```

All computed as pure aggregates of branch timeboxes inside the tile. No derived scores. No ML. No tuning knobs. Wind/lean is not part of tile aggregates — wind is observed at BRANCH LOD through branch movement during replay (§3.15), not as a tile-level overlay.

### 3.17 Scale Discipline — What Happens at 10× and Beyond

One company tree with 5 branches and 50 filaments is readable. 500 branches with 50,000 filaments requires aggressive LOD discipline or the tree becomes noise. This section defines the collapse rules that preserve the "shape is the analysis" guarantee at scale.

**Problem A — Visual clutter at TREE/COMPANY LOD:**

At COMPANY LOD (camera far enough to see the whole tree):
- Individual filament dots/ribbons disappear. They merge into aggregate bark texture: slab discs remain, twig count becomes a single "stub density" indicator (number overlaid, not individual stubs), ribbon detail only appears at BRANCH LOD and closer.
- Branch shape, lean, droop, and overall silhouette are the primary signals. You can tell which branch is healthy, which is wilting, which is leaning — but you cannot see individual rows.

**Problem B — Too many moving things:**

Branch motion (lean + droop) updates only at timebox boundaries, not per commit. A timebox boundary is the natural heartbeat of the system (configurable: daily, weekly, sprint). Between boundaries, the tree is still. This prevents "everything is always jiggling" at scale.

At TREE LOD: branches show their lean and droop as a static pose that updates when the current timebox closes.
At BRANCH LOD: you see the lean, plus individual slab updates, plus ribbon detail.

**Problem C — Archive depth overwhelming the cross-section:**

A 10-year-old branch has hundreds of rings. Cross-section mode (§3.13) handles this through:
- LOD by depth (§33.4): deep rings visually compress. Only the last N rings (e.g., 12 months) render individually. Older rings merge into band groups.
- Scrubbing expands on demand: user scrolls inward to expand older bands into individual rings.
- The cross-section is always a lens, never a full dump.

**Problem D — Misreading causality:**

Users will assume branch motion means "someone is attacking us" when it might be normal seasonality. Guard against this with:
- Explainability on every lean (§3.15): click to see contributors. No unexplained movement.
- Baseline comparison: templates can define "expected lean" (seasonal norms). Deviation from baseline is revealed during replay — the branch leans further or in a different direction than the template baseline predicts.
- Weather overlays (heat, fog, storm, lightning) can be toggled off. Branch lean and droop cannot be toggled off — they are physics, not overlays. The truth layer (filaments, slabs, scars) is always visible underneath.

**The non-negotiable scale rules:**

1. **No artificial smoothing.** If the tree looks ugly because there are 47 twigs, the tree has 47 twigs. Do not hide twigs to make the tree pretty. The ugly tree IS the report.
2. **No management overrides.** Nobody can click "resolve" without fulfilling template rules. Nobody can remove a scar. Nobody can pause sinking. The tree never lies.
3. **No cosmetic reporting drift.** The tree IS the report. There is no "executive summary overlay" that replaces the tree shape with a simplified graphic. Executives look at the tree or they zoom out. The LOD system handles simplification — not a separate dashboard.
4. **LOD shed order:** When rendering budget is exceeded, shed in this order: (1) weather tile overlays (heat, fog, storm, lightning), (2) individual filament detail, (3) organic variation noise, (4) individual slab rings, (5) branch lean/droop deformation, (6) branch silhouettes. Branch silhouettes are never shed — you always see the branches. Lean and droop are physics and shed late (step 5), not early like tile overlays (step 1). Evidence structure is always last to go.

### 3.18 Branch Layout — Stable Direction from Identity, Not Data

Branch direction (where a branch points in space from the trunk) is NOT counterparty direction. Counterparty θ is for filaments on the bark — it drives lean (§3.15). Branch layout direction is the trunk-to-branch attachment slot. These two are independent. If they weren't, counterparty data would literally move your org chart layout, and legibility would collapse.

**The rule: branch direction comes from a stable `layoutKey`.**

Every branch has:

```
BranchLayout {
  branchId: string,
  layoutKey: string,
  layoutAngleRad: number,
  ringIndex: number,
  ringRadiusMeters: number,
  ringHeightOffsetMeters: number,
  collisionBumpCount: number
}
```

- `layoutKey` is a stable, deterministic string derived from the branch's identity — never from live data.
- `layoutAngleRad = hash(layoutKey) → θ ∈ [0, 2π)` — deterministic mapping from identity to angle.
- `ringIndex`, `ringRadiusMeters`, `ringHeightOffsetMeters` — position in the multi-layer shell (see below).
- `collisionBumpCount` — how many collision resolution steps were applied (for deterministic replay).

**layoutKey examples:**

| Tree Type | layoutKey Pattern | Example |
|-----------|------------------|---------|
| Company | `tree.<companyId>::branch.<servicePath>` | `tree.avgol::branch.finance.ap` |
| Directory / filesystem | `tree.<userId>::branch.fs::<rootPathHash>` | `tree.eitan::branch.fs::sha256(/Clients/Alrov)` |
| Software project | `tree.<projectId>::branch.<modulePath>` | `tree.relay::branch.features` |
| Personal | `tree.<userId>::branch.<categoryKey>` | `tree.eitan::branch.health` |
| Municipal | `tree.<municipalityId>::branch.<deptId>` | `tree.telaviv::branch.infrastructure.water` |

The key never changes when counterparties change, when filament volumes shift, or when weather conditions vary. It changes only if the branch is restructured (split, merge, rename) — which is a governance commit, not a data event.

**Multi-layer branch shells — solving fanning and overlap:**

Branches don't all attach at the exact same height and radius. They are assigned to concentric rings around the trunk:

- `ringIndex` (0..N): which shell layer this branch belongs to. Ring 0 = closest to trunk. Ring N = outermost.
- `ringRadiusMeters`: radial distance from trunk center for this ring.
- `ringHeightOffsetMeters`: height offset along the trunk for this ring (slight stagger).
- Phase shift per ring: branches in ring 1 are rotated by a small angular offset from ring 0 branches to prevent radial alignment.

Even if two branches hash to similar `layoutAngleRad` values, they are separated by ring radius and height offset. At 5 branches this doesn't matter. At 50 or 500, the multi-layer shell prevents visual collision without changing any branch's semantic meaning.

**Collision-aware routing (deterministic):**

When generating the branch curve from trunk to tip:
1. Sort all branches by `branchId` (deterministic ordering).
2. Propose each branch curve from trunk surface at `layoutAngleRad` in its assigned ring.
3. If the proposed curve intersects an already-placed branch corridor volume: apply deterministic escape — bump outward by `Δradius = k × collisionBumpCount` or raise by `Δheight = k2 × collisionBumpCount`, or add a single extra Bezier control point ("jump arc").
4. Increment `collisionBumpCount`. The bump is deterministic because the ordering is deterministic.

Replay of branch layout from the same set of `branchId` values always produces the same spatial arrangement. No randomness. No "best fit" optimization. Pure deterministic hash + collision resolution.

**LOD bundle merge (the real answer at 100+ branches):**

At TREE/COMPANY LOD with hundreds of branches, you should NOT see every branch as a full cylinder. Instead:

- Branches with the same template category (e.g., all `finance.*` branches) merge into a **category bundle** — a single thicker cylinder representing the group.
- The bundle shows aggregate health: combined twig density, aggregate lean, combined wilt.
- A count indicator shows how many branches are bundled.
- When you zoom in (BRANCH LOD), the bundle splits into individual branches in their correct layout slots.

This means overlap is not "prevented at full fidelity globally." It's not rendered until you're close enough. The LOD system handles density, not semantic repositioning.

**Directory tree direction (semantic bins):**

Directory branches don't have natural counterparty geography. They use semantic bins:

- Top-level bins are fixed angles: Documents (0°), Media (60°), Projects (120°), Archive (180°), System (240°), Other (300°).
- Inside each bin, children are placed by `hash(path)` within that bin's angular span (60° per bin in this example).
- Deeper nesting creates sub-branches using the same `layoutKey → hash → angle` rule within the parent branch's angular allocation.

This makes directory trees readable and stable without pretending they have real-world approach angles.

**The invariant (frozen contract #114):**

Branch direction is derived only from `layoutKey` hashing + ring assignment + collision resolution rules. It never depends on counterparties, votes, attention, wind, or any live metric. Lean (§3.15) is a small deformation within the fixed layout slot — it does not move the slot itself.

### 3.19 Universal Force Equations — Scale-Invariant Physics

**Prerequisite: The Inward Direction (local origin O)**

Every Relay globe, at every scale, defines a **local structural origin O**. Inward direction = the vector toward O. Archive compression, gravitational sinking, ring orientation, and lifecycle migration are all computed relative to this origin. Without a deterministic inward direction, the entire visual truth layer becomes undefined.

| Scale | Local Origin O | What "Inward" Means |
|-------|---------------|---------------------|
| Branch | Branch root (trunk attachment point) | Toward the center axis of the cylinder |
| Tree | Trunk core (center of trunk at ground level) | Toward the trunk's central axis |
| City / Region | City trunk cluster centroid | Toward the geographic center of the tree cluster |
| Planet (Earth, Mars, Moon) | Planetary center (geometric center of the body) | Toward the core of the planet |
| Asteroid (irregular body) | Barycenter (center of mass) | Toward the mass center — no stable north required, only a deterministic inward point |
| Star system | System barycenter (typically near the star) | Toward the gravitational center of the system |
| Galaxy | Galactic barycenter | Toward the mass center of the galaxy |
| Laniakea | Supercluster attractor (Great Attractor region) | Toward the gravitational convergence point |

The origin does not need astrophysical precision. It needs to be deterministic and stable. Two renderers computing "inward" for the same scope must agree on the direction. For non-spherical bodies (asteroids, galaxy clusters), the barycenter is sufficient — it provides a consistent inward vector even without a meaningful surface or stable rotation axis.

**Why this matters:** If inward is ever ambiguous, archive compression becomes undefined, ring orientation becomes undefined, lean becomes meaningless, and helix becomes arbitrary. Frozen contract #119 locks this.

---

Relay does not show motion. Relay shows force. Movement is the visualization of force imbalance. When forces balance, the branch is stable. When forces skew, it leans. When integrity drops, it droops. When activity spikes, heat rises. When evidence weakens, fog descends.

These equations work identically whether the filament is a file, an invoice, a citizen complaint, or a planetary mission. Only magnitude and aggregation level change. The math does not.

**Primitives — every filament F carries:**

```
θ  = approach angle (radians)
m  = magnitude (normalized)
c  = confidence ∈ [0, 1]
a  = age since spawn (seconds)
o  = overdue factor (1.0 if on time, >1.0 if past expected close)
s  = lifecycle state ∈ {SCHEDULED, OPEN, ACTIVE, HOLD, CLOSED, ABSORBED}
e(t) = engagement delta over time window
d  = direction vector = (cos θ, sin θ)
```

Everything else emerges from these. No hidden inputs. No scores. No ML.

**Equation 1 — Radial Position (Lifecycle Maturity)**

```
r(F) = f(s)
  SCHEDULED → 1.0  (outer bark / branch tip — visible but inert)
  OPEN      → 1.0  (outer bark)
  ACTIVE    → 0.75
  HOLD      → 0.6
  CLOSED    → 0.3
  ABSORBED  → 0.0  (core)
```

Invariant across all scales. A file being edited sits at bark. A reconciled $48M payment sits at core. A meeting scheduled for next Tuesday sits at the branch tip at bark radius. Same function.

**Equation 2 — Longitudinal Position (Gravity Sink)**

```
l(F, t) = L_max − (k_g × a)
```

Where `k_g` = gravitational constant (template-defined but deterministic per branch). If milestone mode: `l(F) = L_max − (k_m × milestoneIndex)`. No randomness. No smoothing.

**Equation 3 — Lean Vector (Directional Pressure)**

Per filament pressure weight:

```
w(F) = m × (1 − c) × o × stateWeight(s)

stateWeight:
  SCHEDULED = 0.0  (inert — no force contribution, contract #124)
  OPEN      = 1.0
  ACTIVE    = 0.8
  HOLD      = 0.6
  CLOSED    = 0.2
  ABSORBED  = 0.0
```

Net lean vector for branch B:

```
W_B = Σ w(Fᵢ) × d(Fᵢ)        (vector sum)
Ŵ_B = W_B / Σ w(Fᵢ)           (normalized direction)
θ_lean = atan2(W_B.y, W_B.x)  (lean angle)
|W_B|                           (lean magnitude)
```

This works identically whether Fᵢ = files, invoices, citizen complaints, or planetary missions.

**Equation 4 — Wilt (Integrity Deficit)**

For timebox T:

```
wilt(T) = clamp(
  α × (1 − confidence_avg)
  + β × (1 − coverage_ratio)
  + γ × (unresolvedCount / N),
  0, 1
)
```

Where `coverage_ratio = verifiedInputs / requiredInputs`. Droop for branch B = aggregate wilt across consecutive low-firmness slabs.

**Equation 5 — Heat (Rate of Change)**

```
engagementRate(B, t) = Δ(Σ e(Fᵢ)) / Δt
heat(B) = normalize(engagementRate)
```

Region heat: `heat_region = Σ heat(Bᵢ)` weighted by branch mass.

**Equation 6 — Fog (Uncertainty Field)**

```
fog(R) = 1 − (Σ c(Fᵢ) / N_total)
```

Fog tile opacity = `fog(R)`. Dense fog = very low average confidence across the scope.

**Equation 7 — Storm Index**

```
storm(R) = normalize(heat(R)) × normalize(fog(R))
```

No mystery. Just multiplication. High acceleration + low confidence = danger.

**Equation 8 — Lightning Cascade**

When filament F in branch A references filaments in branches B₁…Bₙ via evidence edges:

```
cascade(F) = m(F) × uniqueTreesTouched
```

Lightning triggers if `cascade > threshold`. Flash intensity = `cascade / regionMass`.

**Equation 9 — Trunk Mass (Archive Flow)**

```
trunkMass = Σ magnitude of ABSORBED filaments
trunkRadius ∝ log(trunkMass)
```

Thickness of the trunk directly encodes how much resolved, reconciled work has flowed through the system.

**Equation 10 — Scaling Law (Aggregation, Not New Math)**

The engine is scale-invariant. Replace filament → atomic event, branch → system grouping, region → parent grouping. The equations remain unchanged. Scaling happens by aggregation only:

```
W_parent = Σ W_child
heat_parent = Σ heat_child
fog_parent = Σ fog_child
trunkMass_parent = Σ trunkMass_child
```

No new math at larger scale. Only summation.

**Scale mapping — what changes is the template, not the physics:**

| Scale | Trunk | Branch | Filament | Movement Means |
|-------|-------|--------|----------|----------------|
| File system | Root folder | Folder | File | Edit frequency + unresolved drafts |
| Company | Organization | Department | Work item | Vendor pressure + unresolved obligations |
| City | Municipality | Service branch | Case | Citizen complaint vector + budget imbalance |
| Country | State | Agency | Policy action | Trade pressure + regulation backlog |
| Planet | Civilization | Sector | Global initiative | Resource extraction + climate stress |
| Galaxy | Collective cluster | Planetary system | Interstellar event | Mission flux + civilization energy output |
| Laniakea | Supercluster | Galaxy group | Galactic event | Aggregate force fields |

The geometry never changes. The template changes. The equations remain identical. A single overdue invoice and a collapsing planetary supply chain are governed by the same equation set.

### 3.20 Orbital Model — Branches as Bodies, Perturbations as Meaning

At TREE LOD and above, a tree's branches resemble an orbital system:

- **Trunk = central body (sun).** Everything orbits around it.
- **Tier 1 branches (Finance, Ops, HR, IT) = primary planets.** Fixed layout slots (§3.18), stable orbits.
- **Tier 2 sub-branches = moons.** Orbiting their parent branch.
- **Filaments = surface activity / weather.** What happens on each body.
- **Slabs = geological time layers.** Strata within each body.
- **Archive = compressed core mass.** The dense interior.

**The orbit itself does not carry meaning. Deviation from orbit carries meaning.** Just like in celestial mechanics — planets don't mean anything; perturbations do.

**What orbital deviations mean:**

| Observation | Meaning | Source Equation |
|-------------|---------|----------------|
| Stable circular orbit (no lean, no droop) | Department is structurally healthy and balanced | Equations 3, 4 balanced |
| Elliptical drift (lean) | Net counterparty pressure pulling toward a quadrant | Equation 3: |W_B| > 0 |
| Increasing orbital thickness | Growth — more resolved flow, thicker trunk feed | Equation 9: trunkMass increasing |
| Shrinking presence | Contraction or inactivity | Equation 9: low flow, Equation 5: low heat |
| Moons clustering tightly | Highly integrated sub-processes | Sub-branch layout slots close together |
| A moon drifting far | Detached workflow, silo forming | Sub-branch lean diverging from parent lean |
| Multiple bodies leaning same direction | Systemic pressure from one quadrant | Equation 3 agreement across branches |
| Body with thick fog | Department operating blind — evidence weak | Equation 6: high fog locally |
| Lightning flash between bodies | Evidence cascade — one fact rippled across departments | Equation 8: high cascade |

**Structural drift (the second wind):**

Over time, a branch's visual weight within its layout slot changes:
- A branch absorbing massive filament volume thickens. Its trunk feed grows. It commands more visual space.
- A branch with declining activity thins. Its visual presence shrinks.
- This is NOT layout repositioning (§3.18 is stable). This is mass change within a fixed orbit — like a planet gaining or losing atmosphere.

During replay, you see branches thicken and thin over time. That is structural drift. Combined with lean (directional shift) and droop (integrity loss), the full motion profile tells you everything about that department's history without reading a single number.

**From company solar system to Laniakea:**

The fractal scaling (§22) means:
- A company tree's trunk is a branch on a city tree.
- A city tree's trunk is a branch on a country tree.
- Each level up, the same orbital model applies — bodies (sub-trunks) orbit a parent trunk.
- At each level, the equations are identical but computed from aggregated child data (Equation 10).

What you see at Laniakea scale is the same physics that governs a single branch's filaments — just aggregated across billions of trees and rendered at extreme LOD compression.

### 3.21 Content-Type Temporal Mapping — What Is l? What Is Age? What Sinks?

For tabular branches (invoices, transactions), the mapping is natural: l = calendar time, age = seconds since creation, sinking = gravity along the l axis. Tabular events are born, live, close, and sink. Simple.

For non-tabular content, this breaks. The architect identified the critical constraint: **documents are not linear over time.** A paragraph edited yesterday should not appear "archived" just because it's at the beginning of the document. Code files have lines edited in random order. Music projects have sections revisited weeks later.

**The solution: every content type has two independent time axes.**

```
l_content  = position within the content (paragraph position, line number,
             timeline position, section order)
l_time     = calendar time since creation (same as tabular l)
```

These two axes are INDEPENDENT. They cannot be collapsed into one. The template defines which axis drives each behavior:

**Per-template temporal mapping (mandatory fields):**

```
ContentTimeMapping {
  templateId: string,
  contentType: "tabular"|"document"|"code"|"media"|"spatial"|"custom",

  // What does l mean on the bark surface?
  primaryAxis: "calendar-time"|"content-position"|"version-sequence",

  // What drives gravity sinking?
  sinkAxis: "calendar-time",  // ALWAYS calendar-time (universal constant)

  // What determines "age" for twig detection?
  ageSource: "last-edit-time"|"creation-time"|"last-commit-time",

  // What defines a timebox boundary?
  timeboxBoundary: "calendar-period"|"edit-session"|"milestone"|"version-tag",

  // What triggers inward migration (bark → core)?
  inwardTrigger: "lifecycle-close"|"section-stability"|"version-freeze"|
                 "milestone-approval"|"edit-quiescence",

  // What does a cross-section ring represent?
  ringMeaning: "time-period"|"edit-burst"|"version"|"session"
}
```

**Tabular branches (invoices, transactions, tickets):**

```
primaryAxis:     calendar-time
sinkAxis:        calendar-time
ageSource:       creation-time
timeboxBoundary: calendar-period (day/week/sprint)
inwardTrigger:   lifecycle-close (CLOSED → migrate inward)
ringMeaning:     time-period
```

This is the default. l = time. Sinking = time. Everything works as already described.

**Document branches (contracts, reports, policies, wiki pages):**

```
primaryAxis:     content-position (paragraph / section order)
sinkAxis:        calendar-time
ageSource:       last-edit-time (per section)
timeboxBoundary: edit-session (a burst of edits = one timebox)
inwardTrigger:   section-stability (no edits for N sessions → migrate inward)
ringMeaning:     edit-burst (each ring = one editing session)
```

The document is ONE filament. But it has internal structure:
- Each paragraph/section has its own `l_content` position (where it appears in the document).
- Each paragraph/section also has a `lastEditTime` (when it was last touched).
- On the bark surface at CELL LOD, the user sees the document in content order (l_content).
- Gravity still sinks the FILAMENT as a whole along calendar time. The document gets older, it sinks. But internally, sections that were recently edited remain at bark radius. Sections untouched for months migrate inward within the filament's own radial depth.
- Cross-section rings show edit sessions, not calendar periods. A ring = "that Thursday afternoon when you rewrote the intro." Thick ring = many edits. Thin ring = minor tweak.

**The two-axis rendering at CELL LOD:**

```
Vertical axis (l_content):  paragraph/section order (top = beginning, bottom = end)
Radial depth (r):           edit recency per section
                            - Recently edited section = outer bark (bright, editable)
                            - Untouched-for-months section = inner ring (dimmer, stable)
Color:                      confidence (well-evidenced sections vs. draft sections)
```

A reader looking at a document branch sees: the intro is settled (inner ring, high confidence), Chapter 3 was just rewritten (outer bark, medium confidence), and the appendix is untouched since creation (deep inner, but low confidence because it was never reviewed). The SHAPE of the document's cross-section tells you its editorial maturity without reading a word.

**Code branches (source files, repositories):**

```
primaryAxis:     content-position (file path + line number)
sinkAxis:        calendar-time
ageSource:       last-commit-time (per line range / hunk)
timeboxBoundary: version-tag (each release/tag = one timebox)
inwardTrigger:   version-freeze (tagged release → freeze inward)
ringMeaning:     version (each ring = one release)
```

Code behaves like documents but with version tags as natural timebox boundaries. A function edited in the latest sprint is at bark radius. A function untouched since v1.0 is deep in the rings. Cross-section shows release history. Git blame is already this model — Relay just makes it geometric.

**Media branches (audio, video, music, animation):**

```
primaryAxis:     composition-timeline (playback position)
sinkAxis:        calendar-time
ageSource:       last-edit-time (per track / region)
timeboxBoundary: milestone (mix session, mastering pass)
inwardTrigger:   milestone-approval (mix approved → migrate inward)
ringMeaning:     session (each ring = one production session)
```

A music track's bark shows the timeline. The intro is settled (inner ring). The bridge was just re-recorded (outer bark). The master is frozen (core). Cross-section shows production sessions — the first demo, the remix, the final master.

**Spatial branches (CAD, maps, 3D models, architectural plans):**

```
primaryAxis:     content-position (spatial region / layer / component)
sinkAxis:        calendar-time
ageSource:       last-edit-time (per component / layer)
timeboxBoundary: version-tag (each revision submission)
inwardTrigger:   version-freeze (approved revision → freeze inward)
ringMeaning:     version (each ring = one design revision)
```

**The universal invariant:**

Gravity always uses `calendar-time`. The filament as a whole sinks at the same rate as every other filament. Only the `primaryAxis` (what you see on the bark at CELL LOD) and the `inwardTrigger` (what causes sections to mature inward) change per content type. The physics are universal. The interpretation of l at close zoom is content-specific.

**What a twig means per content type:**

| Content Type | Twig = |
|-------------|--------|
| Tabular | Old unresolved event (overdue invoice, open ticket) |
| Document | Section that hasn't been edited or reviewed in a long time but is still at bark radius |
| Code | Function/file untouched since ancient version but never properly tested/reviewed |
| Media | Track region that was never approved or mixed but keeps getting skipped |
| Spatial | Component never finalized in any design revision |

Twigs are always the same physics — a filament (or section) that should have migrated inward but hasn't. What "should have" means depends on the template's `inwardTrigger`.

### 3.22 Content-Type Cross-Section Mapping

Cross-section inspection (§3.13) must render differently per content type, because what a ring means changes:

| Content Type | Ring = | Thickness = | Color = | Cross-section tells you |
|-------------|--------|-------------|---------|----------------------|
| Tabular | Calendar period | Commit count | Magnitude | "Q1 was busy and high-value" |
| Document | Edit session | Edit count per session | Section coverage | "The March rewrite was massive but only touched 3 sections" |
| Code | Version/release | Lines changed | Test coverage confidence | "v2.0 was a huge refactor, v2.1 was a hotfix" |
| Media | Production session | Regions touched | Approval status | "Session 4 re-did the bridge and chorus" |
| Spatial | Design revision | Components modified | Review status | "Rev C changed the foundation and HVAC" |

**Drill-down from ring to content:**

When the user expands a ring in cross-section mode (Phase III, §3.13):
- **Tabular:** Shows filament rows that were active in that period — the standard view.
- **Document:** Shows which paragraphs/sections were edited in that session — highlighted in the document's content-position layout.
- **Code:** Shows which files/functions were changed in that version — a blame-style diff view.
- **Media:** Shows which timeline regions were touched in that session — waveform/timeline with highlighted regions.
- **Spatial:** Shows which components were modified in that revision — 3D/2D view with highlighted parts.

The renderer adapts. The physics don't.

---

## 4. The Filament — Row-Level Atomic Event

> *"The universe is made of stories, not of atoms."* — Muriel Rukeyser

A filament is one event. One invoice. One pothole report. One conversation. One bug fix. One vote. It is the smallest unit of truth in Relay — a single thing that happened, with all its context attached. When your company receives an invoice from a vendor, that invoice becomes a filament. When a neighbor reports a noise complaint, that complaint becomes a filament. The filament carries everything about that event — who, what, when, how much, what proves it — and it lives on the branch surface until it is resolved, at which point it migrates inward and eventually becomes part of the permanent record.

In technical terms: a filament IS a row. Not a cell. The entire row represents one atomic event.

### 4.1 Definition

One event. One filament. One row. One trace from bark to root.

A filament is NOT a cell, a column, a sheet, a branch, or a KPI. It is the indivisible quantum of activity in Relay.

Columns are PROPERTIES of the filament:
- The "Amount" column = magnitude (drives slab color)
- The "Date" columns = temporal properties (commits along the timeline)
- The "Status" column = lifecycle state (drives radial position)
- The "Vendor" column = counterparty (drives angular bark position)
- The "Evidence" columns = attestation links (drives slab opacity)

Cell-level history is a FILTERED VIEW of the filament's row-level commit history. Both coexist because cell history is a subset of row history.

### 4.1.1 The Row Structure — Left Block and Right Block

Every filament row is divided into two blocks:

**Left Block — Identity Block (stable):**
- Object identity (filamentId, objectType, objectId)
- Counterparty reference
- Branch schema ID and template version
- Base metadata (spawnedAt, branchId, approachAngle)

The left block is the answer to "WHAT is this thing?" It is set at creation and does not change. If the identity itself changes, that is a migration commit to a different branch (§4.6), not a mutation of the left block.

**Right Block — Timeline Block (unbounded):**
- Commit history (append-only sequence of all changes)
- Evidence references (accumulating attestation chain)
- Revision deltas (what changed in each commit)
- Lifecycle state transitions (SCHEDULED → OPEN → ACTIVE → HOLD → CLOSED → ABSORBED)
- Magnitude updates (value changes over time)

The right block is the answer to "WHAT HAPPENED to this thing?" It grows without bound. Every edit, every match, every piece of evidence, every state transition appends to the right block. Nothing is overwritten. The right block IS the radial depth visible in §3.2.1 — each commit adds a layer going inward.

**Schema versioning vs branch splitting:**

- If the same kind of thing gains a new field (e.g., invoices now track "payment method"): **schema version bump** on the same branch. Existing filaments don't retroactively gain the field — only new filaments created after the version bump have it. The branch remains coherent because all filaments share the same base schema lineage.

- If the thing is actually a different kind of thing (e.g., what was called "invoices" splits into "domestic invoices" and "cross-border invoices" with fundamentally different schemas): **branch split + migration commit** (§4.6). The new branch gets its own schema. Provenance links from the original filaments to the migrated ones are permanent.

The rule: **columns changing = schema version bump. Category changing = branch migration.**

### 4.2 Schema

```json
{
  "Filament": {
    "filamentId": "F-<objectType>-<objectId>",
    "originRowRef": "row.<moduleId>.<sheetId>.R<row>",
    "objectId": "string",
    "objectType": "string",
    "templateId": "template.<domain>.<variant>",
    "branchId": "branch.<treeId>.<servicePath>",
    "counterpartyRef": "string (entity ID or geographic anchor)",
    "approachAngle": "number (radians, 0=north, pi/2=east)",
    "magnitudeColumn": "string (column name that carries the magnitude value)",
    "magnitude": "string-decimal|null",
    "unit": "string|null",
    "evidenceRefs": ["filamentId|attachmentId|externalRef"],
    "lifecycleState": "SCHEDULED|OPEN|ACTIVE|HOLD|CLOSED|ABSORBED",
    "workState": "DRAFT|PROPOSED|COMMITTED|REVERTED",
    "barkPosition": {
      "l": "number (position along branch length / time axis)",
      "r": "number (radial distance from center, R_max=bark)",
      "theta": "number (angular position, radians)"
    },
    "spawnedAt": "ISO-8601",
    "expectedCloseBy": "ISO-8601|null",
    "closedAt": "ISO-8601|null",
    "absorbedAt": "ISO-8601|null",
    "commitHistory": ["commitId"],
    "disclosureTier": 0
  }
}
```

### 4.3 Lifecycle Journey

1. **ARRIVE**: Event arrives from outside world. Routed to branch as new bark row.
2. **SPAWN**: Filament appears at outer bark (r=R_max) at current timebox (l=l_current), angular position = counterparty approach direction (theta=approach_angle).
3. **GROW**: While OPEN, filament extends along l axis. It exists in successive timeboxes, growing longer on the bark day by day.
4. **MATURE**: Commits happen (matches, evidence, payments). Filament begins migrating inward (r decreases). Transitions: OPEN -> ACTIVE -> HOLD -> CLOSED.
5. **CLOSE**: All obligations met. Filament stops growing on bark. Settles to inner rings (r approaches 0).
6. **ABSORB**: Filament reaches center (r=0). Enters trunk consolidation gate.
7. **ARCHIVE**: Passes through trunk reconciliation. Compressed into root cube. Merkle-sealed.

### 4.4 Inward Movement Rule

Filaments always move inward: bark -> rings -> core -> trunk -> root. They never move outward. Outward "projection" (a cell value appearing in a summary) is a read-only reference, not movement.

### 4.5 Scars — Reverts Are Permanent

You cannot delete in Relay. A revert is a NEW commit that creates a **scar** — a visible mark on the bark showing that something was reversed.

The original filament still exists. The scar filament exists on top of it. Both are truth. The scar says: "This was reversed on [date], by [person], for [reason], with [evidence]." The bark carries a permanent mark — like a scar on real bark. Scars have their own confidence (was the reversal well-evidenced?) and sink with time like everything else.

**Scar geometry in cross-section (§3.13):** When viewed in cross-section mode, a scar appears as a radial crack — a line extending from the slab where the revert occurred outward toward the bark and slightly inward toward older rings. The crack does not erase rings or delete data. It becomes part of the structure — permanently visible stress history, exactly like a crack in real wood. A minor data correction creates a hairline crack. A major governance revert creates a visible fissure that slightly warps adjacent slab surfaces (geometric deformation proportional to scar severity). Multiple scars in the same angular sector create a fracture zone visible at BRANCH LOD.

### 4.6 Migration Commits — Governance Recategorization

A filament can be moved between branches through a **migration commit**. This is the ONLY mechanism for recategorization. Direct `branchId` mutation is forbidden (violates append-only, stable IDs, and replay determinism).

**When a migration executes:**

1. A new commit is appended to the **original filament** on the source branch:
   - `lifecycleState: MIGRATED`
   - `migrationRef: branch.<newBranchId>`
   - `reason: governance.vote` (or `governance.manual` for organizational moves)
   - `migrationCommitId: commit.<hash>`

2. A **linked successor filament** spawns on the target branch:
   - Same `objectId`
   - Same `evidenceRefs` (full chain preserved)
   - New field: `migrationFrom: filament.<originalId>`
   - New field: `migrationCommitId: commit.<hash>` (links to source)
   - Lifecycle continues from the state it was in before migration

**What the user sees:**
- Source branch: original filament with a migration scar — "This was recategorized to [branch] on [date], by [governance vote / authority]."
- Target branch: successor filament with provenance — "This originated on [source branch], migrated via [commitId]."
- Nothing disappears. Both are truth.

**Replay determinism preserved:** The migration commit is append-only. Replaying the commit log reproduces the migration at the exact same point in history.

**Chained migrations:** If the community later reverses the migration, that is another migration commit in the opposite direction. The chain is fully auditable. There is no limit on chain length, but each link requires its own governance threshold.

### 4.7 Filament Identity and Composition Rules

**Canonical identity:** One row = one filament. The key is `filamentId` (unique), anchored to `objectType + objectId + branchId`. A filament is not a cell, a column, or a sheet. It is the full row. Cell-level history is a filtered view of the row's commit history.

**Business objects are compositions, not single filaments.** A purchase order line item that touches four sheets (RequisitionLines, POLines, GRLines, InvoiceLines) is four filaments — one per fact sheet row. The match row that joins them is a fifth filament. The summary cell aggregating the match is a sixth. These are linked by backing refs (join keys and formula references), not by shared identity.

**Filaments never split.** One cell = one filament = one history. If a cell edit fans out into downstream corrections (a fact change triggers match rebuild triggers summary recalculation), those are separate filaments reacting to the same event. The causal chain is preserved through timebox events and backing refs, not through filament forking.

**Filaments never merge.** If two filaments contribute to the same timebox commit, each has its own commit entry in the global chain. The timebox Merkle tree includes both. Traceability is preserved because each filament's commit has a unique `globalCommitIndex` and `prevSheetHash`. The inclusion proof traces any individual contribution within the timebox.

**The composition pattern is fractal:** a department is a set of sheets, a sheet is a set of rows, a row is a filament. No new schema required at any level. Business objects (invoices, requisitions, work orders) are sets of filaments linked by backing refs. Metrics (KPIs) are formulas reading filament values through the summary chain. The tree shape reflects the aggregate — the relationships are embodied in the structure, not drawn as separate connectors.

**Filament-to-truth-packet mapping:** Many-to-many via backing refs. A TransferPacket references the filament IDs (cells) that produced its values. A filament can contribute to multiple packets. The mapping is stable because both sides are keyed to concrete cell IDs with concrete commit indices in the global chain.

### 4.8 STABILITY_CONFIRMED — Inaction as Valid Resolution

Not every open item requires change. A filament that has been reviewed, investigated, and found to need no corrective action must be closable as "stable." Without this, open pressure loops accumulate indefinitely, creating false urgency around items that are functioning correctly.

A `STABILITY_CONFIRMED` commit is a lifecycle transition that:

- Transitions the filament from OPEN or ACTIVE to CLOSED with resolution type `STABLE`.
- Requires evidence: the confirmer must attach a review filament documenting what was checked and why no action is needed.
- Triggers a **60-day cooldown** before the same item can be reopened. Reopening before cooldown expiry requires explicit justification and a higher governance threshold.
- Consumes zero future pressure budget. The confirmation itself is the resolution — it does not create ongoing maintenance obligations.
- Is visible in cross-section as a distinct mark (stability confirmation ring), distinguishable from both active resolution and abandonment.

This prevents two failure modes: (1) items that can never be legitimately closed because "no change needed" is not a valid state, and (2) items that are repeatedly reopened by different participants despite having been reviewed and confirmed stable.

---

## 5. Notes — The Unified Ephemeral Layer

> *"The journey of a thousand miles begins with a single step."* — Lao Tzu

A Note is how everything starts. You walk past a broken streetlight, pull out your phone, and post a thought — a photo, a complaint, a question. That is a Note. It is temporary. If nobody responds, it fades away on its own, sinking into the archive like a leaf falling to the ground. But if someone responds — if one other person in the world chooses to engage with what you said — that Note becomes a filament. Permanent. Part of the record. Every global movement, every policy change, every viral discussion in Relay began as one person's sticky note that someone else chose to answer.

In technical terms: a Note is the unified concept combining DraftNodes and sticky notes. It is pre-filament potential — ephemeral, postable on any surface, time-limited.

### 5.1 Definition

A Note is NOT a filament. It has no lifecycle, no magnitude, no branch effect, no commit chain, no governance weight. It is a cognitive scratch — a thought before it becomes structured.

### 5.2 Schema

```json
{
  "Note": {
    "noteId": "note.<uuid>",
    "surfaceRef": "any tree/branch/bark/trunk surface in the 3D world",
    "position": { "l": 0, "r": 0, "theta": 0 },
    "content": "free text, sketch, voice-to-text, link",
    "tags": ["string"],
    "createdBy": "user.<id>",
    "createdAt": "ISO-8601",
    "ttl": "number (seconds, default varies by context)",
    "state": "EPHEMERAL|CONVERTED",
    "convertedTo": "filamentId|null",
    "responseCount": 0
  }
}
```

### 5.3 Lifecycle — State Machine

The Note lifecycle is a boundary-crossing state machine. The transition from `EPHEMERAL` to `FILAMENT(OPEN)` is the ignition event for all coordination in Relay:

```
NOTE(EPHEMERAL) → [TTL expires, no response] → NOTE(SUNK)
NOTE(EPHEMERAL) → [first external response] → NOTE(RESPONDED) → FILAMENT(OPEN)
NOTE(EPHEMERAL) → [author formalizes] → FILAMENT(OPEN)
```

1. Someone posts a Note on any surface in the 3D world. State = `EPHEMERAL`. It appears at the bark at the poster's approach angle.
2. The Note has a TTL — a configurable gravity sink rate. TTL governance follows the standard three-tier parametric model: global default (e.g., 15 minutes) → template override (e.g., 60 minutes for hospital safety) → branch-level override.
3. If nobody responds before TTL expires: the Note **sinks off the surface**. State = `SUNK`. It is gone from current view but **NOT deleted** — it sinks to root strata as append-only history. TTL is surface residency duration, never deletion. Nothing disappears in Relay. (Frozen contract #1.)
4. If someone responds: the Note crosses a **material boundary**. State = `RESPONDED` → immediately converts to `FILAMENT(OPEN)`. Two parties are now involved. The filament is permanent. This is the **FilamentBirth trigger** — the moment ephemeral speech becomes coordination history. The trigger is external (another human's commit), never automatic.
5. If the author manually formalizes: the Note converts directly to `FILAMENT(OPEN)` on the target branch with pre-filled content.

**The FilamentBirth trigger is the zero-to-tree growth engine.** Every viral global discussion, every civilizational movement, every governance event in Relay begins as a single anonymous sticky note that one other person chose to respond to. Viral emergence is not an algorithm — it is the net force outcome of `engagement force > gravity sink rate`. No boost mechanic, no shadow amplification, no hidden ranking weight, no paid promotion path.

**Spam mitigation (without hidden suppression):**
- TTL gravity: unengaged notes sink naturally
- Attention threshold: filament birth requires an external human response, not self-promotion
- Local rate limiting: device-level posting caps (not identity-level, preserving Tier 0 anonymity)
- Global parameter: notes-per-minute threshold is a community-voted spam filter (§12 Filter Tolerances)

### 5.4 Rendering

- Small, translucent marker at the surface. Distinct from filament geometry (teardrop or sphere).
- Alpha: 0.4 (clearly secondary to canonical objects)
- LOD: visible at CELL/BARK, suppressed at BRANCH and above. Count badge if 5+ Notes cluster on same surface.
- Notes that are close to expiry fade progressively (alpha decreasing toward 0).

---

## 5b. Scheduling — The Branch Tip Is the Future

> *"The best way to predict the future is to invent it."* — Alan Kay

Everything described so far sinks with time. Gravity pulls the past downward along the l axis. But life doesn't only look backward. Companies schedule meetings. Cities plan events. People set alarms. The tree must show the future as naturally as it shows the past.

The answer is already in the geometry: the branch tip IS the future.

### 5b.1 How Scheduling Works on the Tree

The l axis runs from trunk junction (deep past) to branch tip (present/future). Current time sits at a specific position on l. Everything below it has already happened and is sinking. Everything above it hasn't happened yet.

A **scheduled event** is a filament that exists at a future l position on the bark. It sits above the current time marker, at the branch tip or beyond it. It is visible. It is waiting.

```
ScheduledFilament {
  filamentId: string,
  branchId: string,
  scheduledAt: ISO-8601,          // when it will happen
  scheduledEndAt: ISO-8601|null,  // when it will end (for duration events)
  lPosition: number,              // computed from scheduledAt → future l
  lifecycleState: SCHEDULED,      // special pre-OPEN state
  ...standard six domains...
}
```

**Lifecycle for scheduled events:**

```
SCHEDULED → OPEN → ACTIVE → HOLD → CLOSED → ABSORBED
```

`SCHEDULED` is the pre-birth state. The filament exists on the bark at a future l position, but it has not started yet. It has no commits, no evidence, no confidence. It is a commitment to do something at a future time.

**When the scheduled time arrives:**
- The filament transitions automatically from `SCHEDULED` to `OPEN`.
- It is now a real, active filament — just like any other.
- Evidence begins attaching (meeting notes, recordings, decisions, attendance).
- Confidence starts computing.
- Gravity begins pulling it downward as time passes.

**If the scheduled time passes and nothing happens:**
- The filament transitions to `OPEN` but receives no commits.
- It immediately begins sinking with gravity, still at bark radius (never closed, never migrated inward).
- It becomes a twig — a scheduled event that nobody showed up to. Visible. Accountable.
- The no-show is itself informative geometry.

### 5b.2 Meetings on the Tree

A meeting is a scheduled filament on the appropriate branch. The company's weekly finance sync is a filament on the `finance` branch scheduled for every Monday at 10:00.

**Before the meeting:** The filament sits at the branch tip, visible at BARK LOD. It shows: time, participants (counterparty refs), agenda items (as Note attachments). Looking at the branch tip = looking at your calendar. Multiple meetings scheduled this week = multiple filaments clustered at the tip, stacked by time.

**During the meeting:** The filament transitions to `OPEN`. If video presence is active (AR interaction modules), the meeting recording attaches as evidence. Voice transcription (§47) creates a real-time commit log. Each decision becomes a commit. Each action item spawns a child filament (new work item scheduled for a future date).

**After the meeting:** The filament `CLOSES` when the meeting ends. It migrates inward based on evidence quality — a well-documented meeting with clear decisions and follow-up actions has high confidence and migrates quickly. A vague meeting with no notes stays near the bark longer. The meeting sinks with gravity over the following days and weeks, joining the historical record.

**Recurring meetings:** Each occurrence is a separate filament, linked by a `recurringSeriesId`. The series itself is a template-level rule, not a filament. Each instance lives independently — one bad Monday sync doesn't affect next Monday's confidence.

### 5b.3 Venues and Events

A company hosting a conference, a city organizing a festival, a neighborhood planning a block party — these are all scheduled events on the appropriate tree.

**Event as a temporary branch:**

Large events (conferences, festivals, multi-day events) spawn a temporary event branch on the tree:
- The branch appears at the scheduled time, positioned by `layoutKey` (§3.18).
- Sub-events (talks, sessions, workshops) are filaments on this branch, each scheduled at their specific time.
- As the event progresses, sub-event filaments transition from `SCHEDULED` to `OPEN` to `CLOSED`.
- After the event ends, the branch's filaments migrate inward and archive normally.
- The event branch itself remains as permanent history — you can always cross-section it to see what happened at the conference.

**Venue as a persistent branch:**

A venue (office, meeting room, stadium, park) can be a persistent branch on a tree. Scheduled events at that venue are filaments on the venue branch. The venue's history shows: which events happened there, how well-attended they were (engagement), how productive (evidence quality), and how the venue was used over time (cross-section reveals patterns).

### 5b.4 The Tree as Alarm Clock

The branch tip is your calendar. Looking at the tip of any branch shows you what's coming:

**Visual scheduling cues:**
- Scheduled filaments render with a distinct appearance: translucent outline (not solid — they haven't happened yet), with a subtle pulse or glow as their scheduled time approaches.
- The closer to "now," the more solid they become. A meeting 5 minutes away is nearly opaque. A meeting next month is a faint outline.
- When a scheduled filament's time arrives, it "solidifies" — transitioning from translucent to full opacity as it becomes OPEN.

**Notification triggers:**
- When a scheduled filament crosses the time threshold (its `scheduledAt` intersects the current time), the system emits a notification.
- Notification behavior is template-defined: some events trigger 15 minutes before (meetings), some trigger a day before (deadlines), some trigger a week before (quarterly reviews).
- The notification is not a separate system. It is the filament arriving at the present moment on the l axis. The tree IS the alarm clock.

**What the manager sees Monday morning:**

They open Relay, fly to their company tree. At the tip of each branch, they see this week's scheduled events — translucent filaments waiting to happen. The Finance branch tip shows Monday's sync, Wednesday's board prep, and Friday's close. The HR branch tip shows Tuesday's interviews and Thursday's all-hands. The Invoices branch tip shows nothing scheduled — which itself is informative (no payment runs planned = potential gap).

They don't open a calendar app. They look at the tree tips.

### 5b.5 How Scheduling Interacts with Physics

**Scheduled filaments DO NOT sink.** They are anchored at their future l position until their time arrives. Gravity does not pull them — they haven't happened yet. Only after transitioning to `OPEN` do they become subject to gravity.

**Scheduled filaments DO NOT affect branch lean, wilt, heat, or weather.** They are commitments, not evidence. They carry no confidence (nothing has been proven). They carry no magnitude weight for wind computation. They are visible but physically inert until they activate.

**Scheduled filaments CAN be cancelled.** Cancellation creates a scar-like commit: the filament transitions to a `CANCELLED` state (not deleted — append-only). It fades from the tip but remains in the commit history. A pattern of cancelled meetings is visible in cross-section — it shows as a cluster of cancelled-state filaments at bark radius, never having migrated inward. That pattern tells you something about the organization.

**Scheduled filaments respect templates.** A template defines: which branch types support scheduling, what notification rules apply, what mandatory fields a scheduled event must carry (participants, agenda, duration, venue), and what evidence is expected when the event activates. A well-designed template makes scheduling structured, not freeform.

### 5b.6 Cross-Section View of Scheduled Events

In cross-section mode (§3.13), scheduled events appear at the outermost edge of the branch — beyond the current bark surface. They are the "growth buds" at the branch tip. The cross-section shows:

- **Inner rings** = past timeboxes (archived, compressed)
- **Current ring** = active timebox (live work)
- **Outer edge** = scheduled future events (translucent, not yet real)

This is biologically consistent: a real tree's growth buds are at the tips. Relay's scheduled events are at the branch tips. The tree grows toward its commitments.

---

## 6. Projection Branches — Visible Data Pipelines

> *"The eye sees only what the mind is prepared to comprehend."* — Robertson Davies

Sometimes you need to ask a question about the data, not add to it. "How much did we spend on Berlin vendors this quarter?" "Which potholes have been open longer than 30 days?" A projection branch is that question made visible — a light blue branch that pulls data from the real branches, filters it, and shows you the answer at its tip. It never changes the truth. It just helps you see it differently. Anyone can see exactly how a projection was built — which filters were applied, which data was included, which was excluded. Nothing is hidden.

In technical terms: projection branches are light blue analytical offshoots from truth branches. They are visible ETL (Extract-Transform-Load) pipelines.

### 6.1 Anatomy

A projection branch is a funnel with distinct zones:

**Input End** (wide): Many filament rows pulled from the truth branch bark.

**Decision Nodes**: Visible glowing points where filter/transform rules are applied. Each is inspectable:
- "IF currency != USD -> convert"
- "exclude internal vendors"
- "filter severity >= 3"

**Alignment Zone**: Where surviving filaments converge, group, and consolidate by category.

**Excel Terminus**: A small summary table at the tip. The insight. Not a big spreadsheet — a focused answer (e.g., Vendor | Total Spend | Invoice Count | Avg Invoice).

**Outlier Twigs**: Filaments filtered out by decision nodes. They don't disappear — they stick out as visible protrusions from the projection branch. Nothing is hidden.

### 6.2 Properties

- **Color**: Light blue. Always. Even when promoted to permanent.
- **Content**: No new filaments. No new rows. Pure read-only computation.
- **Source**: Derived exclusively from truth branch bark data.
- **No trunk/root flow**: Projection branches are terminal. Their content does not sink to trunk or roots. They are not balancing factors. But they CAN be replayed back in time — never lost, just no need to archive.

### 6.3 Promotability

A projection branch starts ephemeral. If the team agrees it matters:

1. Author clicks "Promote" -> PROPOSE commit created
2. Team reviews decision nodes, evidence quality, output relevance
3. COMMIT approved -> projection branch becomes permanent fixture
4. Still light blue (always marked as projection)
5. Auto-recomputes when new bark data arrives on the parent truth branch
6. Changing a decision node rule on a promoted branch requires a governance commit

### 6.4 Projection Compute Guards

Projections are the only part of Relay that performs live recomputation on potentially unbounded data. Without guards, analysis layers can explode the engine:

**Maximum recursion depth (initial value: 3 levels, global parameter — votable).** A projection can reference a truth branch (level 1). A projection can reference another projection (level 2). A projection can reference a projection that references a projection (level 3). Beyond that: `[REFUSAL] reason=PROJECTION_RECURSION_DEPTH_EXCEEDED depth=<n> max=<current_param>`.

**Cycle detection:** The projection dependency graph is checked before evaluation. If projection A references B which references A (direct or transitive), the cycle is detected and refused: `[REFUSAL] reason=PROJECTION_CYCLE_DETECTED graph=<ids>`. Cyclic projections cannot be created.

**Evaluation time budget (initial value: 50ms per projection per recompute, global parameter — votable).** If a single projection's evaluation exceeds the budget, it is interrupted and the last valid result is cached with a staleness flag. `[DEGRADED] reason=PROJECTION_TIME_BUDGET_EXCEEDED projection=<id> elapsed=<ms> budget=<current_param>`.

**Recompute cadence: per timebox boundary, not per commit.** Projections recompute when the timebox they observe closes, not on every individual commit arrival. This throttles recompute to the natural heartbeat of the system. Projections on very active branches do not trigger recompute on every filament insertion.

**LOD-based suppression:**
- GLOBE LOD: all projections suppressed (only trunks visible)
- REGION LOD: top-3 promoted projections per branch visible (summary only)
- TREE LOD: all promoted projections visible, ephemeral projections hidden
- BRANCH LOD: full projection detail, all projections visible
- CELL LOD: full detail including outlier twigs

**Primitive budget integration:** Projection rendering counts against the same LOD primitive budget as everything else (frozen contract #65). If projections would exceed the budget, projection primitives are shed before evidence primitives (frozen contract #80).

**No compute without observation:** Projections only evaluate when they are inside a viewer's active sight bubble (see §33.3) or when they are explicitly "published" outputs that a branch scope has committed to maintain. Unpublished projections that no user is currently viewing do not recompute — they hold their last cached result. This is the core invariant that prevents compute explosion at scale: even if 50,000 users each build 3-layer projections on the same branch, only the projections currently being viewed by someone trigger recompute. The rest sleep.

**Projection instance cap per branch (initial value: 500 active projections per branch, global parameter — votable).** If a branch exceeds the projection cap, new projections are queued. Oldest ephemeral projections are evicted first. Promoted projections count toward the cap but are never evicted — if all 500 slots are promoted, no new ephemeral projections can be created until one is deprecated. This prevents a single hot branch from becoming a compute black hole.

**Content-based memoization:** Projections cache their results keyed by the hash of their input data (the set of filament commit hashes in their source scope). If the input data has not changed since the last evaluation, the cached result is returned without recomputation. This means projections on stable branches — where no new commits arrived — cost zero compute regardless of how many viewers are looking.

---

## 7. The Social Layer

> *"Everyone you will ever meet knows something you don't."* — Bill Nye

The social layer uses identical mechanics to the operational layer. Commentary, news, opinions, discussions, and global conversations are all filaments.

### 7.1 How It Works

1. Someone posts a **Note** on any surface in the world (a company bark, a globe location, a branch, a topic)
2. Most Notes fade (15 min TTL, no engagement)
3. When someone responds -> Note converts to **filament**. Conversation begins.
4. Each response is a **commit** on the filament. The filament grows by l (time).
5. A response WITH evidence = a commit that branches out as an **evidence twig** pointing to source data
6. When 2+ parties engage on a specific commit -> a **sub-filament** spawns at that interaction point
7. The filament sinks with gravity. But if growth rate exceeds sink rate -> it extends outward and becomes visible at higher LOD levels

### 7.2 Confidence Propagation

To get a good confidence score on your post, you must REFERENCE other filaments that have good confidence scores:

- Post referencing actual transaction filaments with high confidence -> inherits high confidence -> persists
- Post referencing nothing -> low confidence -> low opacity -> fades from default views
- Post referencing low-confidence sources -> low confidence chain -> noise

This is how Relay resists manipulation without censorship: you can post anything, but visibility is proportional to evidence quality. Nobody decides what's true. The confidence physics determine what's visible.

### 7.3 Voting

Voting is distinct from commenting. A vote is a deliberate stance (yes/no/option selection) on a conversation or decision point. Votes:

- Contribute to the **engagement rate** metric (what raises topics off the globe surface)
- Are NOT growth (they don't make the filament longer)
- Are judgment, not content
- Have their own evidence requirements (voter eligibility, proximity verification)
- Are recorded on both the topic and the voter's personal tree

### 7.4 Vote Eligibility Gates

Not everyone can vote on everything. Unrestricted voting collapses under manipulation.

**Minimum eligibility for any global vote:**
- Filament must be public (`disclosureTier` permits external viewing)
- Voter must be **Tier 1 minimum** (verified identity). Tier 0 anonymous accounts cannot vote.
- Voter must have **presence history** (not a freshly created account — minimum age threshold)
- Voter must have **engagement history** on the related branch OR topic (prior participation demonstrates context)

**Optional additional eligibility filters (template-configurable):**
- **Proximity**: For local issues (potholes, neighborhood disputes), physical proximity may be required
- **Stake-based weighting**: For governance decisions, stake in the outcome may weight votes
- **Prior participation threshold**: Minimum number of commits/interactions in the domain before vote eligibility

**Vote anonymity is template-configurable.** Relay supports both transparent and anonymous voting, depending on what is being decided. The frozen boundary is:

> **Eligibility + uniqueness are always provable; vote choice secrecy is template-defined by vote class.**

Every vote commit is Merkle-sealed. The system always knows: this voter existed, was eligible, and voted exactly once. That is never anonymous. What can be anonymous is the *choice* — how you voted.

**Vote classes (minimum taxonomy):**

| Class | Choice Visibility | Examples | Rationale |
|-------|------------------|----------|-----------|
| **Private-by-default** | Encrypted choice payload; blinded aggregation | Ideology, preference, cultural questions, social opinion, belief | Protects principled dissent from social retaliation |
| **Public-by-default** | Fully visible responsibility record on voter's user tree | Spending public money, delegating authority, certifying evidence, governance parameter changes, sanctions, anything that creates obligations for others | Accountability for decisions that bind others |

- Templates define which vote class applies. The community can override the default visibility for specific vote types via parametric governance.
- A vote class cannot be forced from public to private if the vote creates obligations for others — that boundary is frozen.
- A vote class cannot be forced from private to public for pure opinion/belief votes — that boundary is also frozen.
- The existence of both modes is a frozen architectural feature. Neither mode can be removed.

### 7.5 Global Vote-Ranked Confidence

At global scale, confidence is determined by **community vote consensus on evidence**, not by template-defined evidence rules.

**How it works:**

Evidence filaments referenced by posts/conversations have a **global alignment score** computed from votes:
- If more people vote that Evidence X is valid/trustworthy than Evidence Y, filaments referencing X get a higher global confidence score
- This is a **ranking score**, not an absolute measure — it positions evidence relative to other evidence
- The formula: `globalAlignment = votes_supporting / (votes_supporting + votes_opposing)` weighted by voter eligibility tier

**What this drives:**
- **Global ranking / prominence**: Higher-aligned evidence → filaments referencing it rank higher in global views
- **Visibility at GLOBE LOD**: Well-aligned filaments are more visible when zoomed out
- **Community-curated order**: The global tree self-organizes by collective judgment

**What this does NOT do:**
- Does NOT affect organizational slab opacity (that remains `evidence_present / evidence_required`)
- Does NOT override template evidence rules
- Does NOT allow vote-based deletion or suppression of any filament
- Does NOT weight votes by wealth, status, or follower count (only by eligibility tier and engagement history)

### 7.6 Vote Decay

Votes are time-sensitive. They decay.

- **Decay model**: Votes lose weight over time (exponential decay with configurable half-life)
- **Default half-life**: 30 days (configurable per context — elections may have no decay during voting window)
- **Effect**: A filament with 10,000 votes from 6 months ago ranks lower than one with 500 fresh votes. Relevance is temporal.
- **Executed actions are permanent**: If a vote-driven migration commit was executed when votes were above threshold, the migration stands even if votes later decay below threshold. The commit is append-only. The decay affects future ranking, not past actions.

### 7.7 Vote-Driven Recategorization

At global scale, the community can vote to move a filament from one branch to another.

**Execution conditions (ALL must be true):**

```
votes_total >= minimumParticipation
AND
votes_for_target / votes_total >= supermajorityThreshold (default: 60%)
```

**Before threshold is met:**
- Filament may show a "Recategorization Pending" indicator
- Optional display of the leading target branch
- Geometry does NOT move. The filament stays on its current branch. No drift, no lean, no partial migration.

**When threshold is met:**
- A migration commit executes (§4.6): original filament gets MIGRATED state, successor spawns on target branch
- The migration is permanent and append-only
- If the community later decides the move was wrong: another migration commit in the opposite direction. Chain is fully auditable.

**Why no continuous drift:**
Geometry must remain deterministic. A filament that "leans toward" a new branch based on live vote delta would break replay consistency. Votes accumulate. When threshold is met, migration executes as a single atomic commit. Between votes, nothing moves.

**Hysteresis buffer:**
At the exact moment a migration approaches threshold, millions of simultaneous votes can oscillate the ratio above and below the trigger point. This tug-of-war must not produce flickering geometry.

- **Hysteresis band**: Migration does not execute at exactly 60%. It executes at threshold + buffer (default: 60% + 5% = **65%**). Once executed, a counter-migration vote cycle cannot even begin until the ratio drops below threshold - buffer (**55%**). This dead zone prevents oscillation.
- **Settlement window**: The ratio must be sustained **continuously** above the hysteresis threshold for a minimum duration (default: **1 hour**). Momentary spikes do not trigger execution. If the ratio dips below the hysteresis threshold at any point during the window, the clock resets to zero.
- **Rendering during pending period**: A progress bar shows settlement window completion. The live vote counter is visible but decorative — the actual trigger is (sustained ratio >= hysteresis threshold for >= settlement duration). Geometry stays frozen. No flicker.
- **Post-execution lock**: After a migration commit fires, a cooldown period (default: 24 hours) blocks new recategorization votes on the same filament. This prevents immediate counter-attacks from creating thrash.

### 7.8 Buried Resurrection

A Note that sank after 2 days with minimal engagement — buried, low on the branch. Someone discovers it and responds:

From that buried position, the filament sprouts NEW GROWTH upward toward current time. The original post stays at its sunken position (that's where it happened). But the conversation extending from it reaches back up to the present — a visible link between past and present. This is how old evidence resurfaces.

---

## 8. The User Tree — Personal Responsibility Mirror

> *"Knowing yourself is the beginning of all wisdom."* — Aristotle

**Prerequisites:** None for base (responsibility mirror, CV through shape, privacy tiers). Expands with: AR interaction modules → achievement records, capability state. Spell/combat modules → spell library, quest log, combat record.

Every person on Relay has their own tree. It uses identical mechanics to every other tree.

### 8.1 Structure

Your tree's branches are the **roles you play**:

- "Procurement Approver at Avgol" branch
- "Code Reviewer at ProjectX" branch
- "Resident at Maple Street" branch
- "Voter" branch
- "Social" branch

Your bark carries YOUR filaments — your individual actions in each role. Responsibility records: "I did this, at this time, with this evidence, under this authority."

### 8.2 The Mirror Commit

Every material action creates entries on TWO trees simultaneously:

**System tree** (TransferPacket): What happened to the system state.
**User tree** (ResponsibilityPacket): What the human is responsible for.

Both carry the **same commitId**. The company tree says "Invoice approved." Your tree says "I approved it." These are cryptographically linked — you cannot have one without the other.

### 8.3 Your Tree's Physics

- **Bark**: Your activity history wrapping each role branch
- **Sinking**: Earth time pulls old activity downward
- **Twigs**: Things pending YOUR action that you haven't completed (overdue reviews, unanswered approvals)
- **Confidence**: Evidence quality of your responsibility records (proper authority, verified signatures)
- **Timebox slabs**: How active and complete you were in each period
- **Roots**: Your personal archived record, Merkle-encrypted

### 8.4 Reputation Through Shape

In the truth and governance layers, there are no reputation scores, star ratings, or badges. Your tree's SHAPE is your reputation:

- Healthy tree: firm slabs, few twigs, high opacity, filaments closing regularly
- Unhealthy tree: many twigs, wilted slabs, low opacity, filaments stuck at bark

Nobody assigns reputation. The tree shows it through physics. (The arena layer has domain-scoped numeric metrics like ArenaRep for matchmaking — these are entertainment metrics, not governance reputation. See §68.10, §71.2.)

### 8.5 Privacy

Visibility follows tiered consent:

- **Tier 0** (default): Anonymous dot. Nobody sees your tree.
- **Tier 1**: Role badge. People see branch shapes but not individual filaments.
- **Tier 2**: Named identity with detail. Authorized parties see individual responsibility filaments.

Escalation requires YOUR explicit consent per context.

### 8.6 Contextual Presence Profiles — Choose Your Face

You are one person. You have one tree. But you do not broadcast the same face everywhere.

When you walk into a study hall, a dance party, a duel arena, a job interview, a courtroom, or a friend's living room, you present different aspects of yourself. In the physical world, this is natural — you dress differently, speak differently, emphasize different things about yourself. In Relay, the same principle applies to your tree.

**A contextual presence profile is a filter over your own tree that controls which branches, which tiers, and which summary information you broadcast to others in a given context.**

```
PresenceProfile {
  profileId:          string,
  userId:             string,
  profileName:        string (e.g., "Professional", "Gaming", "Social", "Academic"),
  context:            enum { MANUAL, AUTO_BY_BRANCH, AUTO_BY_PROXIMITY } | branchRef,
  visibleBranches:    branchRef[] (which of YOUR branches others can see),
  hiddenBranches:     branchRef[] (which branches are suppressed in this profile),
  disclosureTierOverride: {
    default:          number (0, 1, or 2 — applies to branches not explicitly listed),
    perBranch:        Map<branchRef, number> (per-branch disclosure override)
  },
  summaryFields: {
    showCertifications: boolean,
    showArenaRep:       boolean,
    showWorkHistory:    boolean,
    showEducation:      boolean,
    showSocialBranch:   boolean,
    showGameLayer:      boolean,
    customBio:          string | null (short text shown in presence marker)
  },
  activeConditions: {
    activateOnBranch:   branchRef[] | null (auto-switch when entering these branches),
    activateOnProximity: proximityZoneRef[] | null (auto-switch when in these physical zones),
    activateManually:   boolean (user explicitly selects this profile)
  }
}
```

**How it works:**

| Context | Profile | What Others See | What's Hidden |
|---------|---------|----------------|--------------|
| **Job interview** | Professional | Work branches, certifications (§58.12), accounting skills, project history | Gaming branch, social branch, arena record |
| **Dance party** | Social | Performance branch, arena social stats, crowd faction history, Visual Burst count | Work branches, financial branches, education details |
| **Duel arena** | Gaming | Arena branch, combat loadout, spell catalog, win/loss record, element affinity | Work history, personal branches, family tree |
| **Study hall** | Academic | Education branch (§58), learning path progress, demonstrated modules, teacher reviews | Arena branch, social branch, work branches |
| **Courthouse** | Legal | Relevant evidence branches, certifications, civic participation history | Everything else — minimum disclosure, maximum focus |
| **Default** | Minimal | Tier 0 — anonymous dot, no tree visible | Everything |

**The critical rules:**

1. **You control the filter, not the data.** Your tree does not change. Your filaments do not move. Your history is not rewritten. The profile only controls what OTHER USERS see when they look at your presence marker in a given context. It is a lens over your tree, not a modification of it.

2. **Public filaments on shared trees are always findable.** If you approved an invoice on a company tree, that filament exists on the company tree regardless of your presence profile. Someone browsing the company tree will see your name on that filament (at whatever disclosure tier you committed it). Your presence profile does not hide your public acts — it only controls what people see when they look at YOUR tree directly.

3. **Profile switching is a committed event.** When you change profiles, the switch is recorded as a filament on your personal attention branch. This prevents abuse: if someone claims they "weren't showing their gaming profile" during a professional meeting, the log shows which profile was active and when. Profile history is private (Tier 0 by default) but available for self-review.

4. **Auto-switching by context.** Profiles can activate automatically when you enter a specific branch context or proximity zone. Walking into a university proximity zone auto-switches to Academic. Entering an arena branch auto-switches to Gaming. You can override any auto-switch manually. Auto-switch preferences are stored on your user tree as preference filaments.

5. **Multiple profiles are unlimited.** You can create as many profiles as you want. A teacher might have: Professional (for school), Academic (for conferences), Social (for community events), Minimal (for anonymous browsing). A gamer might have: Gaming (for arenas), Streaming (for public performances with maximum disclosure), Incognito (Tier 0 for exploration).

6. **The tree shape is always honest.** Even in a minimal profile, the SHAPE of your tree (if visible at Tier 1+) is truthful. You cannot fake thick branches you do not have. You cannot hide scars that are publicly committed. You can choose not to show your gaming branch — but if someone navigates to a public arena you participated in, your participation filament is there. The profile controls the front door of your tree. The public record exists regardless.

**Contract #166 — Users control which branches and disclosure tiers are broadcast through contextual presence profiles. Profiles are filters over the tree, never modifications of it. Public filaments on shared trees remain findable regardless of the user's active profile. Profile switching is a committed event on the user's attention branch. Profiles can auto-activate by branch context or proximity zone. The tree shape at any visible disclosure tier is always truthful — profiles suppress visibility of specific branches but cannot fabricate branches that do not exist or hide scars on publicly committed filaments.**

### 8.7 Self-Descriptors — Identity Without Categories — Contract #242

Relay does not define identity categories. There is no dropdown for gender. No enum for religion. No predefined list of ethnicities, orientations, professions, or species. There is a box. You type what you are.

**How it works:**

Every person tree has a `descriptors` branch. Each self-descriptor is a filament on that branch:

```
SelfDescriptor {
  fieldName:     string       // e.g., "gender", "religion", "species", "vibe"
  value:         string       // free text — whatever the user types
  disclosureTier: 0 | 1 | 2  // owner controls visibility
  searchable:    boolean      // opt-in: makes this value findable by others
  suggestedAt:   string[]     // system-suggested values shown (not enforced)
  committedAt:   ISO-8601
}
```

**The user experience:**

1. User opens their person tree, navigates to identity/descriptors
2. Sees empty fields: "Gender", "Religion", "Ethnicity", "Profession", etc. — plus an "Add custom field" option
3. Each field is a free-text input. No dropdown. No radio buttons. No predefined options.
4. As the user types, the system suggests common values based on what other users have typed (e.g., typing "W" suggests "Woman", "Wiccan", "Writer"). Suggestions are frequency-ranked, not curated.
5. The user can type anything. "Man." "Woman." "Non-binary." "Cat." "Stardust." "Prefer not to say." Or leave it empty.
6. The user chooses: make it searchable (opt-in) or keep it private (default).

**What this enables:**

- A dating site template filters by `gender` descriptor. If 4 million people typed "Woman" and 3 people typed "Cat," both are valid filter values. The system does not distinguish.
- A professional network template filters by `profession`. "Engineer" and "Dream Architect" are equally valid.
- A cultural community filters by `religion`. "Buddhist" and "Pastafarian" get the same data treatment.
- Nobody sees the full option space because there is no option space. There are only inputs.

**What the system provides (not enforces):**

- **Suggestions**: Frequency-ranked values from other users who opted into searchability for the same field. This makes common values easy to discover without making them mandatory.
- **Field name suggestions**: Common fields ("Gender", "Religion", "Ethnicity", "Profession", "Interests") appear by default on the person template. Users can rename them, delete them, or add custom fields.
- **Normalization hints**: If a user types "woman" (lowercase), the system may suggest "Woman" (capitalized) to improve searchability. Never forced.

**What the system never does:**

- Never validates a descriptor against a list. There is no "valid gender" check.
- Never requires any descriptor to be filled. Every field is optional.
- Never displays "other" as a category. There is no "other" because there are no primary categories.
- Never uses descriptors in governance weight, confidence, or any equation. Descriptors are data, not physics.
- Never allows descriptors to be set by anyone other than the tree owner. No admin, no governance vote, no template rule can write to your descriptors branch.

**This pattern applies to ALL self-description fields on the person tree.** Gender, religion, ethnicity, orientation, profession, dietary preference, political affiliation, hobbies, species. The architecture is identical for every field: free text, opt-in searchability, owner-controlled disclosure, system suggests but never enforces.

**The political debate disappears.** Relay never had to choose how many gender options to offer because it never offered options. It offered a box. The culture war over identity categories cannot happen because there are no categories — only input. The system treats every value equally because it has no concept of which values are "normal."

**Contract #242 — Self-Descriptors. All identity attributes on the person tree are free-text fields with no predefined categories. The system suggests common values (frequency-ranked from other users' opted-in entries) but never enforces them. Every descriptor is optional, owner-written, owner-controlled for disclosure, and opt-in for searchability. Descriptors are never used in governance weight, confidence, or equations. No external authority — governance, template, or admin — can write to a user's descriptors branch. The category-free identity model is frozen.**

---

## 9. Confidence Physics — Automatic Evidence Ratio

> *"Trust, but verify."* — Russian proverb, popularized by Ronald Reagan
>
> *"Every filament that sinks earned its depth. Every filament that fogs earned its doubt."* — Relay

How do you know if something is real? In Relay, you do not trust anyone's word for it. The system counts evidence automatically. An invoice that has a matching purchase order and a delivery receipt has high confidence — it looks solid and opaque on the branch. A claim posted with no supporting documents has low confidence — it looks transparent, almost ghostly. Nobody decides this. No manager approves it. The evidence either exists or it does not, and the branch shows you which.

Confidence (timebox slab opacity) is automatic. No manager approval. No human judgment.

### 9.1 How It Works

Each template defines **evidence requirements** — rules about what must be attached for a filament to be considered complete:

```
Rule: "PO requires 3 competitive bids"
  completeness = bid_count / 3

Rule: "Invoice requires matching PO + GR"
  completeness = (has_PO + has_GR) / 2

Rule: "Pothole report requires photo + GPS"
  completeness = (has_photo + has_GPS) / 2
```

The tree computes: `confidence = evidence_present / evidence_required`. A PO with 1 bid out of 3 required shows at 0.33 opacity — visually faded, no human involved.

### 9.2 Cross-Company Evidence

A PO filament can reference BID filaments from OTHER companies on Relay. The tree automatically knows: "I see 3 bid filaments from 3 vendors -> completeness = 1.0 -> full opacity." Evidence crosses tree boundaries through explicit disclosure + consent.

### 9.3 Evidence Rules as Policy

Evidence rules are policy commits — versioned, inspectable, governed. Changing a rule (from 3 bids to 2) requires a governance commit, visible in the audit trail. For long-lived physical assets (buildings, machines, infrastructure), confidence decays over time without evidence renewal — the global default renewal cycle is a votable parameter (§78.8). Relay never auto-corrects on decay; it renders fog and notifies humans.

### 9.4 The Dual Confidence Model

Two confidence regimes operate simultaneously. They are **orthogonal layers** — they coexist, never override each other, and are rendered separately.

**Organizational Confidence (slab opacity):**
- Computed via `evidence_present / evidence_required`
- Template-defined, mechanical, automatic
- Drives timebox slab opacity
- Cannot be voted down by the community
- Operates within a single tree's governance boundary

**Global Vote-Ranked Confidence (ranking score):**
- Computed via community vote alignment on evidence references (§7.5)
- Drives global ranking, prominence, and visibility at GLOBE LOD
- Influenced by vote decay (§7.6)
- Cannot override template evidence rules
- Operates across tree boundaries at global scale

**When they conflict:**

A company filament has organizational confidence = 1.0 (internally complete, all evidence met). The global community rates the underlying evidence as questionable (low vote consensus, globalAlignment = 0.3).

Rendering:
- **Slab opacity = 1.0** (internal completeness is preserved — the company met its own rules)
- **Global ranking score = low** (community does not trust the evidence)
- **Optional "Global Alignment Badge"** showing vote ratio visible at GLOBE LOD

Neither wins. Both render. This preserves:
- **Local sovereignty**: A company's internal evidence rules are not subject to mob override
- **Global discourse**: The community's assessment of evidence quality is visible and influential on ranking
- **No tyranny of majority**: Votes affect visibility, not truth
- **No managerial override**: Internal confidence is automatic, not approvable

### 9.5 Vote Cannot Override Template Rules

A critical boundary: community votes can NEVER directly modify a template's evidence requirements.

Example: Template says "PO requires 3 competitive bids." Community votes: "2 bids is acceptable."

This vote **cannot**:
- Change the template rule for that specific filament
- Override the organizational confidence calculation
- Force the slab opacity to reflect the community's preference

This vote **can**:
- Lower the filament's global ranking score (community thinks the rule is too strict/too lax)
- Trigger a **governance proposal** to modify the template evidence rule (which then follows normal governance: PROPOSE -> VOTE_WINDOW -> COMMIT with appropriate authority)

Template sovereignty is preserved. The community influences discourse, not operational rules.

### 9.6 Implementation Constraints — Dual Confidence Separation

The two confidence channels are **independent primitives** that must never collapse (frozen contract #44):

**Storage:** Separate fields. Every filament carries both `orgConfidence` and `globalConfidence` as independent properties. Never stored as a single "confidence" value. Never derived from a shared intermediate.

**APIs:** Separate setters, separate getters. No function signature accepts or returns a blended score. `setOrgConfidence()` and `setGlobalConfidence()` are distinct code paths with no shared mutation logic.

**Arithmetic:** No code path may reference both values in the same arithmetic expression. No averaging, no weighting, no blending, no "combined score." They are rendered side by side, never merged.

**Serialization:** The pair structure is preserved in wire format, storage format, and API response format. Both values are always present. Missing value = null, not zero.

**Mandatory verification artifact:** `DUAL-CONFIDENCE-SEPARATION-PROOF` must assert:
1. No code path references both channels in the same arithmetic expression
2. No function returns a blended score
3. No setter mutates both channels
4. Serialization preserves pair structure
5. Rendering uses orgConfidence exclusively for slab opacity and globalConfidence exclusively for globe ranking

Without this proof passing, the dual confidence contract is aspirational. With it, the contract is enforceable.

**Implementation status (2026-02-18):**
- `computeOrgConfidence()` — IMPLEMENTED. Derives from timebox, evidenceRefs, disclosure tier, minus missing-ref penalty. Normalized to 0..1.
- `computeGlobalConfidence()` — IMPLEMENTED. Derives from voteStatus only (binary: PASSED=1.0, else 0.0). Expandable to vote alignment ratio later.
- `computeConfidence()` — DEPRECATED TRAP. Emits `[REFUSAL] reason=BLENDED_CONFIDENCE_CALLED`, falls back to orgConfidence.
- Renderer height band uses `computeOrgConfidence` only.
- HUD displays both channels separately: `OrgConf: X% | GlobConf: Y%`.
- Globe ranking uses `computeGlobalConfidence` only.
- Proof: `scripts/dual-confidence-separation-proof.mjs` (8 stages).

**Note on long-lived assets:** Physical assets (buildings, machines, land) decay in confidence over time without periodic evidence renewal. The global default renewal cycle (1 year, votable) and organizational overrides are formalized in §78.8. Relay never auto-corrects — it renders fog and notifies humans.

---

## 10. Pressure Physics — Structural Integrity Forces

> *"The price of greatness is responsibility."* — Winston Churchill

Pressure is the feeling that something is wrong even when the numbers look fine. A branch where half the invoices are fully evidenced and the other half have zero documentation creates visible stress — the branch looks uneven, like a spine with some vertebrae solid and others crumbling. You can see that something needs attention without reading a single number. Pressure is not about how much money is involved. It is about how trustworthy the picture is.

Pressure is NOT magnitude. They are orthogonal signals on the same branch:

- **Magnitude** (slab color, warm/cool palette) = the content signal. How much money, what severity, what count. It says "what happened."
- **Pressure** (slab firmness gradient) = the integrity signal. How trustworthy, how complete, how contested. It says "how reliable is what happened."

### 10.1 How Pressure Manifests

Pressure is visible as **localized wilt inconsistency** between adjacent timebox slabs. It is not a separate particle system, force field, or animation layer. It IS the emergent result of heterogeneous slab firmness along the branch spine.

A branch where all slabs have similar firmness (all firm or all soft) looks structurally uniform. A branch where firm slabs alternate with wilted slabs shows structural stress — kinks, sags, localized soft spots between rigid segments. This is pressure made visible.

### 10.2 How a Fake Post Creates Pressure

1. **You post a Note with no evidence.** Someone responds — it converts to a filament. But it has zero evidence references. Confidence = `0 / evidence_required = 0.0`. The slab containing your filament is nearly transparent (low opacity) and soft (high wilt). Most users' filter tolerances hide it entirely.

2. **Someone flags it.** They create a counter-commit that REFERENCES actual data showing your claim is false. The flagging filament has HIGH confidence (it references real evidence). It points AT your filament. Your filament now has active opposition with evidence and zero support.

3. **Negative pressure gradient forms.** The timebox slab containing your filament is soft (your zero-confidence filament drags it down). Adjacent slabs may be firm (other filaments in the branch are healthy). This contrast — soft between firm — is a visible structural inconsistency. The branch develops a localized weakness at your timebox.

4. **Your user tree absorbs the damage.** Every action creates a mirror commit on your user tree (§8.2). Your personal tree now shows: a filament you created with zero supporting evidence and active opposition. That filament is a twig on your personal tree — it cannot close (no resolution), cannot migrate inward (no evidence), and sinks with gravity while staying at bark radius. Your tree's shape degrades visibly.

5. **The pressure trace is auditable.** Anyone inspecting the soft slab can trace it: which filaments contribute to the weakness, who created them, what evidence exists for and against. Pressure is never mysterious — it is always traceable to specific filaments with specific confidence deficits.

### 10.3 Forces Around Branches

Forces around branches are not a separate system from wilt physics. They ARE wilt physics at the branch scale:

- **Uniform firmness** (all slabs healthy): Branch is straight, rigid, visually strong.
- **Uniform softness** (all slabs wilted): Branch droops uniformly — the whole thing is degraded.
- **Heterogeneous firmness** (firm-soft-firm pattern): Branch develops visible stress at transitions. The soft section sags between rigid neighbors. This is where structural pressure concentrates.
- **Progressive degradation** (firmness decreasing along branch): Branch curves downward progressively — newer sections may be firm while older sections wilt as obligations age.

The visual result: you can see WHERE on a branch the problems are, just by looking at the shape. No numbers needed. The geometry IS the diagnostic.

### 10.4 Turgor Pressure — The Biological Foundation

The biological analog for Relay's pressure physics is **turgor pressure** — the continuous internal pressure that keeps plant cells firm. High turgor = cells tight, walls rigid, plant stands upright. Low turgor = cells slack, walls collapse, plant wilts. The plant does not need an attacker to fail. It only needs to stop maintaining internal pressure.

Relay works identically. Continuous reconciliation — evidence flowing, counterparties confirming, timeboxes closing, verifications completing — maintains structural firmness. When reconciliation stops, the branch does not need a fraud or an attack to degrade. It wilts on its own. **No attacker is required for failure. Only the absence of maintenance.**

This is why wilt is the most important visual signal in Relay. A wilting branch is not being attacked — it is being neglected. The system does not punish; it reveals. The turgor model explains why Relay's physics feel natural: they mirror the same maintenance-or-decay dynamic that governs every living structure.

---

## 11. Parametric Governance — Votable System Constants

> *"Democracy is the worst form of government, except for all the others."* — Winston Churchill

Every setting in Relay — how long a note lasts before it fades, how many votes it takes to change a rule, how quickly old votes lose their weight — is decided by the community, not by an administrator. You vote on the number you think is right. Everyone else does too. The system takes the middle value. No single person controls any setting. If the community collectively decides that notes should last 30 minutes instead of 15, the system adjusts. If they change their minds next month, it adjusts again. This is how Relay governs itself — continuously, transparently, and without elections.

**Prerequisites:** None for base (operational parameters: TTL, thresholds, decay, cadence). Expands with: founder key activation → monster economy parameters (spawn rate, reward magnitude, difficulty curve) as global governed values.

Every operational parameter in Relay is a continuously votable, weighted, settling value. Nothing is hardcoded except the frozen contracts themselves. For decisions involving a list of options (candidacy, curriculum, template additions), a meta-voting layer (§72 Layered Option Governance) first determines what the options should be before the substantive vote occurs.

### 11.1 How It Works

Any eligible participant can cast a parameter vote: "I think NOTE_TTL_SOCIAL should be 30 minutes." The system collects all active votes and computes the **weighted median** — not the average (averages are vulnerable to outlier manipulation). The median resists extremes:

```
Parameter: NOTE_TTL_SOCIAL
Active votes: [10, 12, 15, 15, 15, 20, 25, 30, 30]
Weights (by voter tier): [1, 1, 2, 2, 2, 1, 1, 2, 1]
Weighted median: 17 minutes
Result: NOTE_TTL_SOCIAL = 17 minutes
```

The result is not rounded to neat numbers. If the community settles on 17 minutes, it's 17 minutes.

### 11.2 Three Scope Levels

**Global parameters** — affect the entire Relay system:
- Note TTL (social, work, proximity contexts)
- Spam threshold (notes/minute)
- Minimum vote eligibility age
- Supermajority threshold for migrations
- Vote decay half-life
- Hysteresis band width
- Settlement window duration

**Branch-level parameters** — affect a specific branch:
- Evidence requirements (count and type per filament category)
- Expected resolution cadence
- Helical twist period
- Confidence thresholds for visibility

**Template-level parameters** — affect all trees using a template:
- Default attribute bindings
- Sinking mode and rate
- Consolidation gate rules
- Branch type definitions

### 11.3 Continuous Settlement

Parameter voting is NOT election-based. There is no voting period, no deadline, no winner declaration. The weighted median recalculates continuously as:
- New votes arrive (parameter shifts toward new consensus)
- Old votes decay (stale opinions lose weight, same exponential decay as §7.6)
- Voters change their mind (new vote replaces old vote from same voter)

Parameters drift toward community consensus over time. A sudden influx of votes can shift a parameter quickly. Gradual erosion of old votes shifts it slowly.

### 11.4 Parameter Vote Schema

```json
{
  "ParameterVote": {
    "voteId": "paramvote.<uuid>",
    "parameterId": "param.<scope>.<name>",
    "scope": "global|branch.<id>|template.<id>",
    "voterId": "user.<id>",
    "proposedValue": "number|string|boolean",
    "weight": "number (derived from voter eligibility tier)",
    "timestamp": "ISO-8601",
    "decayHalfLife": "number (seconds, inherited from global parameter)"
  }
}
```

### 11.5 What Cannot Be Voted On

Frozen contracts (§21) are immune to parametric governance. They are non-negotiable by design. Voting to change "append-only" or "filament = row" is structurally forbidden — the system does not expose these as votable parameters. They are architectural invariants, not operational constants.

### 11.6 Global Parameter Registry

Every numeric or duration value in the Master Plan falls into exactly one of three categories:

**Category A — Global Parameter (community-voted via weighted-median):**
These are operational tuning knobs. The founder sets initial values at launch; from day 1, the community governs them.

| Parameter | Initial Value | Scope | Contract Ref |
|-----------|--------------|-------|-------------|
| Sleep cycle duration | 7h 12m | Global | #43 |
| Sleep onset solar altitude threshold | -6° (civil twilight) | Global | #43, §14.4 |
| Sleep end solar altitude threshold | -6° (civil twilight) | Global | #43, §14.4 |
| Extreme latitude fallback threshold | ±66.5° | Global | §14.4 |
| Note TTL (social context) | 15 minutes | Global | §5 |
| Note TTL (work context) | 60 minutes | Template | §5 |
| Spam threshold (notes/minute) | TBD at launch | Global | §12 |
| Vote decay half-life | 30 days | Global | §7.6 |
| Migration hysteresis band | ±5% | Global | §7.7 |
| Migration settlement window | 1 hour | Global | §7.7 |
| Migration post-execution cooldown | 24 hours | Global | §7.7 |
| Fresh account governance cooldown duration | 14 days | Global | #55 |
| Fresh account governance commit threshold | 10 commits | Global | #55 |
| Context-weighted vote recency half-life | 90 days | Branch | #56 |
| Monster economy rate-of-change cap | 20% per epoch | Global | #46 |
| Beginner zone duration threshold | 30 days | Global | #60 |
| Beginner zone difficulty ceiling ratio | 50% | Global | #60 |
| Presence time-bucket: COMPANY LOD | 5 seconds | Global | #62 |
| Presence time-bucket: REGION LOD | 30 seconds | Global | #62 |
| Presence time-bucket: GLOBE LOD | 5 minutes | Global | #62 |
| Presence precision: COMPANY LOD | 10m | Global | #62 |
| Presence precision: REGION LOD | 1km | Global | #62 |
| Presence precision: GLOBE LOD | 50km | Global | #62 |
| Reverification interval: Probationary | 7 days | Global | #72 |
| Reverification interval: Trusted | 90 days | Global | #72 |
| Reverification interval: Verified | 180 days | Global | #72 |
| Reverification interval: Anchor | 365 days | Global | #72 |
| Trust tier promotion: Probationary → Trusted | 30 days + 10 commits | Global | §48.2.4 |
| Trust tier promotion: Trusted → Verified | 180 days + 50 commits + jury service | Global | §48.2.4 |
| Trust tier promotion: Anchor requirement | 365 days + 100 commits + 3 juries + nomination | Global | §48.2.4 |
| Inactivity demotion threshold | 180 days | Global | §48.2.4 |
| Jury historic pool consecutive term limit | 2 terms | Global | #77 |
| Jury historic pool cooldown after limit | 6 months | Global | #77 |
| Jury deliberation window | 72 hours | Global | §46.5 |
| Sortition minimum activity requirement | 30 days | Global | §46.2 |
| Sortition minimum trust threshold | 70 | Global | §46.2 |
| Guardian minimum activity requirement | 30 days | Global | §48.2.2 |
| Guardian recovery approval window | 24 hours | Global | §48.2.2 |
| Guardian recovery cooldown after failure | 48 hours | Global | §48.2.2 |
| Guardian recovery max attempts per 30 days | 2 | Global | §48.2.2 |
| Invite expiry | 14 days | Global | §48.2.3 |
| Invite refill rate | TBD by community vote | Global | §48.2.3 |
| Founder inactivity succession trigger | 365 days | Global | #81 |
| Key rotation period | 90 days | Global | §48.13 |
| Merkle digest publication interval | 24 hours | Global | #93 |
| Healthcare break-glass justification window | 72 hours | Global | #96 |
| Council decision immunity buffer | 14 days | Global | #98 |
| Emergency reform supermajority threshold | 80% Anchor-tier | Global | §49.13 |
| Projection evaluation time budget | 50ms | Global | #91 |
| Projection max recursion depth | 3 | Global | #90 |
| Projection instance cap per branch | 500 | Global | #104 |
| Camera recognition confidence threshold | TBD at launch | Global | §40 |
| Governance quorum gate range | 30-75% by cadence | Template | §19.2 |
| Governance approval gate range | 60-75% | Template | §19.2 |
| Governance reconciliation gate | 7-30 days | Template | §19.2 |
| Governance sunset gate | 90 days | Template | §19.2 |
| Invite-chain centrality visibility threshold | 25% of active users | Global | #99 |
| Physical asset evidence renewal cycle | 365 days | Global | §78.8 |
| Global transaction commission rate | 0% | Global | §80.5 |
| Regional tax allocation rate | 0% | Regional | §80.5 |
| Per-session service tax rate | 0% | Global | §80.5 |
| Civic Allocation Contribution (CAC) rate | 0% | Regional | §80.5 |
| Silence-stability epoch threshold | 12 epochs | Global | §81.3 |
| Silence-stability supermajority escalation | 80% | Global | §81.3 |
| Offline fork resolution window | 7 days | Template | §81.4 |
| Minority alarm eligibility threshold | 15% | Global | §81.7 |
| Leaf default TTL (social context) | 900 seconds | Global | §82.2 |
| Leaf default TTL (arena context) | 300 seconds | Template | §82.2 |
| Leaf promotion min unique participants | 2 | Template | §82.4 |
| Leaf compost timer after FALLING | 24 hours | Global | §82.2 |
| Sap default TTL | 5000 ms | Global | §82.3 |
| Sap aggregation quantize interval | 5000 ms | Global | §82.3 |
| Sap max-duration before mandatory checkpoint | 4 hours | Template | §82.4 |
| Sap precision at COMPANY LOD | 10 m | Global | §82.3 |
| Dormancy baseline rolling window | 12 epochs | Global | §83.3 |
| Dormancy threshold (quiet) | 0.3 | Global | §83.3 |
| Dormancy threshold (dormant) | 0.7 | Global | §83.3 |
| Dormancy threshold (deep) | 0.9 | Global | §83.3 |
| Immune heat threshold | TBD at launch | Global | §83.5 |
| Immune fog threshold | TBD at launch | Global | §83.5 |
| Immune promotion rate threshold | TBD at launch | Global | §83.5 |
| Immune new-account commit share threshold | 30% | Global | §83.5 |
| Photosynthesis confidence minimum (C_min) | 0.3 | Global | §83.1 |
| SCV routing threshold: local model ceiling | 0.6 | Global | §92.2 |
| SCV routing threshold: frontier API floor | 0.85 | Global | §92.2 |
| Civilization goal achievement confidence minimum | 0.8 | Global | §94.1 |
| Civilization Tier 1 tree count threshold | 10,000 active trees | Global | §94.3 |
| Civilization tier progress threshold for next tier | 50% | Global | §94.4 |
| Civilization Tier 4 progress threshold for Tier 5 | 90% | Global | §94.7 |
| Mission completion confidence threshold | 0.8 | Global | §93.3 |
| ISR rate | 0.30% | Global | §86, §95 |
| ISR constitutional cap | 1.00% | Global | §86, §95 |
| Treasury accumulation ceiling trigger | 12× annual cost | Global | §86, §95.5 |
| Treasury accumulation hard circuit breaker | 24× annual cost | Global | §86, §95.5 |
| Global oblivion classification supermajority threshold | 85% | Global | §72.12.2 |
| Global oblivion classification frozen floor | 75% (non-votable) | Global | §72.12.2 |
| Regional oblivion classification supermajority threshold | 75% | Global | §72.12.4 |
| Oblivion detection confidence floor | 0.85 | Global | §72.12.5 |
| Oblivion classification cooling window | 168 hours | Global | §72.12.2 |

**Category B — Founder Lever (only the founder/steward controls):**
These are structural activation switches, not tuning knobs. They are binary or milestone-gated.

| Lever | Description | Contract Ref |
|-------|-------------|-------------|
| Game layer global activation | Enable the game/combat/spell modules globally | #48, §42 |
| AR layer global activation | Enable the detection/AR modules globally | §42 |
| Civilization stage transitions | The moment the founder declares the world has moved to the next stage | §42 |
| Initial global parameter values | The starting values for all Category A parameters at launch (immediately votable after) | §42.4 |
| Spell/card registry additions | New spells, cards, treasure chests, Relay Set Items (existing mappings immutable) | #41 |

**Category C — Physics Constant (frozen, never votable, never changeable):**
These are architectural invariants embedded in frozen contracts.

| Constant | Value | Contract Ref |
|----------|-------|-------------|
| Filament = row | Always | #1 |
| Append-only commit chain | Always | #3 |
| Dual confidence separation | Always | #44 |
| Earth rotation rate | Real sidereal rate | §14.1 |
| Solar/lunar ephemeris | JPL/SOFA 2026-2126 | §14.4 |
| Merkle hash function | SHA-256 | §48.16 |
| Monster economy rate-of-change cap ceiling | 20% (the cap itself is frozen) | #46 |
| Sleep regeneration is community-governed | The existence of the mechanism | #43 |
| Beginner ramp exists | The existence of a ramp | #60 |
| Reverification is periodic | The existence of periodic checks | #72 |

**Governance rule:** Every value in Category A has a founder-set initial value at launch but is immediately governable by the community from day 1. No Category A value is permanently hardcoded. If a new numeric value appears in the plan and does not appear in this registry, it must be classified before implementation.

---

## 12. Filter Tolerances — Personal Visibility Slidebars

> *"We don't see things as they are, we see them as we are."* — Anaïs Nin

Each user has a set of personal filter slidebars that control what they see in the 3D world. Filters are CLIENT-SIDE view state — they are not commits, not truth, and not visible to anyone else.

### 12.1 Available Filters

- **Spam threshold**: Hide users posting more than X notes/minute (default: global consensus value via §11)
- **Confidence floor**: Only show filaments with confidence above X (default: 0.1)
- **Engagement minimum**: Only show filaments with at least X votes/commits (default: 0)
- **Tier filter**: Only show content from users at Tier X+ (default: Tier 0, meaning show everything)
- **Decay cutoff**: Hide filaments with vote weight decayed below X% of original (default: 5%)
- **Age cutoff**: Hide Notes older than X minutes (default: matches NOTE_TTL parameter)
- **Magnitude floor**: Only show filaments with magnitude above X (default: 0)

### 12.2 Two Layers

**Global defaults** are set by parametric governance (§11). The weighted median of everyone's votes on "what should the default spam threshold be?" produces the global default. These defaults ARE the community's immune system:
- Spam detection: the community converges on "more than 5 notes/minute = spam" and that becomes the default for everyone
- Fraud flagging: accounts failing proximity verification thresholds are filtered by default
- Bot filtering: accounts with no engagement history below the global age threshold are hidden by default

**Personal overrides** let any user slide their own thresholds tighter or looser:
- Want to see everything including spam? Slide spam threshold to infinity.
- Want maximum filtering? Slide confidence floor to 0.9 — only high-evidence content visible.
- Want to study bot behavior? Slide tier filter to Tier 0 and spam threshold to infinity.

### 12.3 Filters Are Not Truth

Filters never mutate state. They are a rendering-time visibility mask applied on the client. The underlying data is unchanged. A filament hidden by your spam filter still exists, still sinks, still has its confidence computed, still contributes to branch physics. You just don't see it.

This means: two users looking at the same branch may see different things depending on their filter settings. But the BRANCH SHAPE is computed from ALL filaments (including filtered ones). You see the branch's true shape even if some of the filaments contributing to it are hidden from your view.

### 12.4 Fraud Routing

When global filter defaults flag an account (e.g., posting rate exceeds spam threshold, identity verification failed, proximity check inconsistent), the system can route flagged accounts to:
- **Proximity channel reverification**: Must physically visit a trusted hotspot and re-verify identity
- **Reduced visibility**: Flagged account's content is hidden behind default filter for all users until reverification
- **No deletion**: The flagged content still exists. It is just below the default visibility threshold. Anyone who lowers their filter can still see it. Transparency is preserved.

### 12.5 The Oblivion Floor — Civilizational Classification Layer

Below all personal filter sliders sits a system-wide threshold: the **oblivion floor** (§72.12). Content that humanity has classified as purely destructive through civilizational supermajority vote (85%) receives an oblivion gravity multiplier that sinks it below this floor. The oblivion floor is below every user's default filter settings.

To view oblivion-classified content, a user must deliberately lower their personal filter past the oblivion floor — an explicit act requiring an acknowledgment gate, committed as an auditable filament on the user's tree. This is the only filter action that produces a commit (all other filter adjustments are stateless client-side rendering).

Protected Participation Profiles (§63.7) cannot lower their filter below the oblivion floor — this is a structural protection, not an option.

The oblivion floor does not violate §12.3 (Filters Are Not Truth). The classified content still exists, still contributes to branch physics, still affects the branch's shape. Only the rendering changes. The truth is unchanged. The tree does not lie — it just buries what humanity has collectively decided to bury, and the burial itself is fully visible on Tree Zero's governance branch.

---

## 13. Stigmergic Coordination — Self-Assignment Through Visibility

> *"If you want to go fast, go alone. If you want to go far, go together."* — African proverb

Relay's filament-links-filament, confidence-promotes-confidence model creates a natural stigmergic environment where tasks do not need assignment — they need only visibility.

### 13.1 Twigs Are Tasks

A twig (§3.10) is a filament that hasn't closed while everything around it has. It protrudes from the branch surface. It is visually obvious. It IS the task board — no separate task management system needed.

Anyone who can see a twig can pick it up:
1. Inspect the twig (what is this unresolved filament about?)
2. Create a commit on the filament with evidence of your work (a resolution, an investigation, a partial fix)
3. Your user tree records the responsibility via mirror commit (§8.2)
4. The twig begins resolving — the filament starts migrating inward if the evidence meets requirements

No assignment authority is needed. No manager delegates. The work is visible. Capable people self-select.

### 13.2 The User Tree IS the CV

Your personal user tree's shape is your professional reputation:

- **Firm slabs** = you consistently deliver complete, evidenced work in each time period
- **Few twigs** = you finish what you start — low unresolved obligation count
- **Diverse branches** = you contribute across multiple roles and domains
- **High confidence** = your work is well-evidenced, properly attested
- **Healthy inward migration** = filaments you touch move from bark to center (open to closed)
- **Thick trunk** = large volume of absorbed, reconciled work flowing to your roots

An employer inspects your tree. They don't read a resume — they see:
- Is this tree firm? (reliable)
- Are there twigs? (overcommitted or negligent)
- Is the bark active? (currently engaged)
- Do evidence twigs reach to reputable sources? (quality connections)
- How deep are the roots? (track record length)

The tree doesn't lie. Every commit is append-only and Merkle-sealed.

### 13.3 The Incentive Loop

The stigmergic model creates a self-reinforcing cycle:

1. **Visible problems** (twigs) attract capable people
2. **Resolving a twig** creates a high-confidence commit on the resolver's user tree
3. **A firm user tree** makes the person more visible and trusted in the community
4. **More trust** means access to higher-impact work (larger twigs, more sensitive branches)
5. **Higher-impact resolutions** make the tree even firmer
6. Loop continues

This works without:
- Central assignment
- Performance reviews
- Star ratings
- Gamification points
- Any authority deciding who does what

The physics of the tree IS the incentive system.

### 13.4 TwigVisibilityIndex — Formal Computation

The TwigVisibilityIndex is a **derived reading**, not a force. It does not create pressure, create ranking, or create commits. It is pure introspection over existing state (contract #24: pressure is emergent, never independent).

**Computation:**

```
TwigVisibilityIndex = f(
    unresolvedDuration,   // time since expected resolution, from template parameter
    evidenceGap,          // 1.0 - orgConfidence (how much evidence is missing)
    localAttention,       // count of presence markers focused near this twig
    scopePermission       // binary gate: does the viewer have disclosure access?
)
```

**Scope gate is non-negotiable.** The order of operations must be:

```
IF hasScopePermission(viewer, branch, disclosureTier):
    THEN computeIndex(twig)
ELSE:
    twig is INVISIBLE — index is never computed
```

Even the computation must not leak existence. A private twig on a restricted branch produces zero signal to unauthorized viewers. No index computation occurs. No attention signal. No metadata about "something hidden here." The twig does not exist for that viewer at any level of abstraction.

**What the index drives:**
- Rendering salience: higher-index twigs are visually larger, more opaque, more attention-grabbing
- Navigation suggestion: SCV may recommend high-index twigs to capable users as potential work
- Aggregation: branch-level twig index aggregate feeds into branch health metrics at higher LOD

**What the index does NOT drive:**
- No commit creation
- No pressure generation (pressure comes from slab firmness gradients, not from the index)
- No ranking in any governance or economic system
- No notification generation (notifications are a separate, consent-based system)

---

## 14. Gravitational Time — The Universal Clock

> *"Time is what we want most, but what we use worst."* — William Penn

Time in Relay is the actual rotation of the Earth. The globe turns. Everything sinks. Yesterday's work is lower than today's. Last month's conversations are deeper still. The oldest records are buried beneath the surface like geological strata. You do not need to organize anything into folders or sort by date — time does it for you, constantly, silently, for everyone equally. A conversation from five years ago is deep underground. This morning's meeting is at the surface. You navigate time by looking up or down.

### 14.1 Earth Time

The globe slowly rotates. This rotation IS time. All trees, all branches, all filaments sink at the same rate. This is the universal constant — not configurable, not per-branch, not per-company. It is Earth time for everyone.

### 14.2 Sinking as Template Setting

While earth time is universal, whether a particular tree RESPONDS to it is template-configurable:

- **Operational template** (P2P, municipal services): Sinking = earth time. Transactions must close.
- **Creative template** (video production, music): Sinking = none or milestone-driven.
- **Static template** (file mapping, personal archive): Sinking = none. Just structure.
- **Research template** (astronomy, archaeology): Sinking = earth time for observation freshness.

### 14.3 Branch Time vs Earth Time

- **Earth time** = gravitational sinking. Universal. The globe clock.
- **Branch time** = the helical twist, department cadence, team rhythm. Configurable per template. This is the operational clock for teams to coordinate within.

Both exist simultaneously. Earth time is the environment. Branch time is the schedule.

### 14.4 Astronomical Alignment — Real Earth, Real Sun, Real Moon

Relay is synchronized to the actual Earth, not an abstraction. The Cesium globe renders real-time Earth rotation, real solar position, and real lunar cycles. This alignment must be precise for at least the next 100 years (2026–2126) and is computed from established astronomical ephemeris data, not from approximate models.

**Earth rotation:**
- The globe rotates at real sidereal rate. UTC midnight, noon, dawn, and dusk are computed from actual Earth orientation, not simplified offsets.
- Time zones are derived from real geographic longitude, not from political time zone boundaries (political zones are a governance overlay at the region level, not a physics input).
- The globe's orientation is computed using the IAU Earth rotation model (UT1 + precession + nutation). For the 100-year window, IERS Earth Orientation Parameters provide sub-second accuracy.

**Solar position (critical for sleep cycle regionalization):**
- The Sun's apparent position is computed using the VSOP87 planetary theory (or equivalent JPL DE ephemeris), giving precise solar longitude and declination for any moment in the 100-year window.
- Solar altitude at any geographic coordinate is derived from: observer latitude, observer longitude, solar declination, and hour angle. This determines local sunrise, sunset, solar noon, and twilight times to within ~1 minute accuracy.
- **Daylight duration varies by latitude and season.** At the equator, day and night are roughly equal year-round (~12h each). At 60°N (Helsinki), summer daylight reaches ~19h and winter daylight drops to ~6h. At the Arctic/Antarctic circles, polar day and polar night create 24h extremes. Relay must model this correctly because sleep cycle timing is tied to it.

**Moon cycles:**
- Lunar phase is computed from actual Sun-Earth-Moon geometry (not a 29.5-day approximation). The synodic month varies between 29.27 and 29.83 days.
- Lunar position (right ascension + declination) is computed from ELP/MPP02 or JPL DE ephemeris.
- Moon phase is available as a system variable for templates that use it (tidal cycles, agricultural calendars, cultural/religious observances, game mechanics tied to lunar events).
- Eclipses, supermoons, and other notable lunar events are pre-computed for the 100-year window and available as system events.

**Sleep cycle regionalization:**
- The global sleep cycle duration (e.g., 7h 12m) is a single global parameter voted by the community (frozen contract #43).
- But the **timing** of the sleep cycle is regionalized by solar position: sleep onset is triggered when local solar altitude drops below a configurable threshold (default: civil twilight, solar altitude = -6°). Sleep end is triggered at the corresponding dawn threshold.
- This means: equatorial users have a roughly consistent sleep window year-round. High-latitude users have a sleep window that shifts with the seasons — shorter summer sleep windows (more daylight = later onset), longer winter sleep windows (less daylight = earlier onset).
- The solar altitude threshold for sleep onset and sleep end are separate global parameters (votable). The community can vote to shift the trigger earlier or later relative to actual sunset/sunrise.
- **Extreme latitudes:** During polar day (24h sunlight) or polar night (24h darkness), the sleep cycle falls back to a fixed UTC-offset schedule for that region, computed from the region's nominal longitude. The fallback threshold (latitude at which solar-based timing becomes unreliable) is a global parameter (default: ±66.5°, the Arctic/Antarctic circle).
- **Transition smoothing:** As a region approaches polar conditions, the sleep onset/end times are interpolated between solar-computed and UTC-fixed schedules to prevent abrupt jumps at the threshold latitude.

**Periodic reporting alignment:**
- All periodic system events (Merkle digest publication, reverification windows, key rotation schedules, invite refill cadence, governance epoch boundaries) are aligned to UTC midnight boundaries, not to local time or solar time.
- The 24-hour Merkle digest publication (frozen contract #93) uses UTC day boundaries.
- Reverification windows (frozen contract #72) use calendar days from the user's last verification event, counted in UTC.
- Governance epoch boundaries (for rate-of-change caps, parameter settlement) are aligned to UTC midnight, ensuring all regions experience the same epoch transitions simultaneously.
- **Moon-aligned events (optional template feature):** Templates can optionally align reporting cycles to lunar phases (e.g., agricultural templates that use planting/harvest moon cycles, cultural templates that observe lunar calendars). The system provides `currentLunarPhase`, `nextNewMoon`, `nextFullMoon`, and `lunarDay` as built-in variables for template formula engines.

**Ephemeris data source:**
- The system ships with pre-computed ephemeris tables covering 2026–2126 (100 years) at 1-minute resolution for solar position and 10-minute resolution for lunar position. Total data size: ~50 MB compressed.
- Tables are generated from JPL Horizons or equivalent open-source astronomical computation libraries (e.g., SOFA, Skyfield, DE440).
- The ephemeris tables are versioned and Merkle-sealed. Updates (if needed due to improved astronomical models) are governance-approved template-level commits.

### 14.5 TimeDepthIndex — Navigation Replaces Search

Every artifact in Relay has a `timeDepthIndex` — a derived property computed from its commit position and timebox depth. This is the formal statement of the principle: **time replaces folders/tags/search as the primary organizing axis.**

```
timeDepthIndex = {
    commitPosition,      // sequence number within branch commit log
    timeboxDepth,        // which timebox stratum (0 = surface, N = deep root)
    compressionLevel,    // LOD tier for rendering (full → summarized → hash-only)
    retrievalPath        // filament ride coordinates from surface to this artifact
}
```

**Navigation principle:** "Find" in Relay resolves to "navigate-to-depth," not "keyword hunt." Search exists as a lens — it returns depth coordinates and filament ride paths, not detached result objects. Every search result is anchored to a specific point in the time-space of the tree. You don't get a list of results. You get a set of locations you can fly to.

**The retrievalPath** is the canonical way to reach any artifact: a filament ride (§15) from the current surface position, down through timebox strata, to the target depth. This is the cognitive recovery path — the same path a human follows when thinking "how did we get here?" The path itself contains context: every timebox stratum it passes through shows the state of the world at that time.

**Root compression guarantees:**
- Compression is **lossless** — full fidelity reconstructible on demand from the Merkle archive
- Compression is **Merkle-verifiable** — every compressed stratum's hash chain is intact
- Compression is a **rendering optimization**, not data reduction — the data is always there, the LOD determines how much detail is shown at each depth
- Historians navigating to depth 500 (ancient strata) trigger decompression of that stratum for full-fidelity inspection

**The civilizational claim:** All human knowledge — from last week's invoice to ancient religious texts to geological history — should be organized by WHEN, navigable by DEPTH, and verifiable by cryptographic roots. Two cultures that disagree on categories agree on when things happened. Time is the neutral substrate.

---

## 15. Time Scrubbing — Replay as Navigation

> *"Those who cannot remember the past are condemned to repeat it."* — George Santayana

### 15.1 Mechanic

Choose any time window (year, month, week, day, hour, 5 minutes) and the tree renders only filaments active during that period:

- **Full year**: Full tree. Long filaments stretch across branches.
- **Last week**: Only recent activity. Older regions dimmed.
- **Last 5 minutes**: Just fresh bark arrivals. Sparse tree.

Drag the slider back and forth. Watch the tree grow, thicken, wilt, recover over time.

### 15.2 Built on Replay Engine

Every commit is recorded. Any point in time can be rebuilt deterministically. The E3 replay engine verifies that replayed state matches live state exactly (byte-identical golden outputs). If replay diverges from live state: that's a finding, not a bug to hide.

---

## 16. AI and SCV — Filament 3D Cognition

> *"The real voyage of discovery consists not in seeking new landscapes, but in having new eyes."* — Marcel Proust

**Prerequisites:** None for base (proposes commits, builds projections). Expands with: AR interaction modules → manages AR overlay, interprets gestures/light/objects, validates achievements, acts as personal trained assistant. Spell/combat modules → validates spells, generates monsters, serves as summoned combat agent in duels.

### 16.1 What an SCV Is

An SCV (Semi-autonomous Coherence Vehicle) is a visible AI agent in the 3D world. It appears as a marker with a label: `SCV: Code Coherence`, `SCV: Procurement`, `SCV: Compliance`. You can see where it is, what it's looking at, what it's doing. It is never hidden.

### 16.2 How AI Thinks in Filaments

The AI reads TREES, not databases. It navigates the same 3D structure as humans — globe, trunk, branch, bark, cell — but at machine speed across ALL branches simultaneously.

When the AI analyzes a problem:

1. **Navigate**: SCV moves to the relevant location. Its marker appears. You watch it arrive.
2. **Trace**: SCV follows evidence twigs across filaments, reads timebox histories, checks confidence scores, detects patterns in cross-sections.
3. **Build projection**: SCV constructs a light blue projection branch showing its reasoning — decision nodes, evidence references, correlation analysis. This IS its thought process, visible and inspectable.
4. **Propose**: SCV generates a proposed commit (a draft filament on the bark). You can see the exact change, the evidence twigs, and the confidence score.
5. **You decide**: Approve or reject. The AI cannot commit without human authority.

### 16.3 3D Cognition

The AI uses spatial relationships as cognitive inputs:

- A cluster of twigs on one section means something different than scattered twigs
- A slab firm on one angular half and wilted on the other = geographically concentrated problem
- Evidence twig distance = how cross-cutting an issue is (close = local, spanning branches = systemic)
- The tree's SHAPE is information the AI reads the same way a human reads a chart

### 16.4 SCV Rules (Frozen)

- SCVs do NOT execute changes. They produce: inspections, findings, proposed commits, recommended flows, evidence bundles.
- SCVs are subject to all frozen contracts: confidence floor, pressure budget, data minimization.
- SCV posts are always marked as AI-generated (visible badge). Confidence depends on evidence quality, same as everyone else.

### 16.5 Named SCV Sub-Components

Every SCV contains two named processing stages that handle user input transformation:

- **Architect** — Intent parser. Takes raw input (voice transcript, gesture signal, light pattern, object detection) and produces a structured IntentPacket describing the action, targets, filters, and parameters. Architect ONLY parses — it never executes, never creates commits, never modifies state. When input is ambiguous, Architect produces ranked candidate intents for the user to disambiguate. Full specification: §47.3.

- **Canon** — Execution planner. Takes a validated IntentPacket from Architect and produces proposed tree operations (queries, projections, commit drafts, navigation commands). Canon ONLY proposes — it never commits. Every Canon output is rendered as a visible lavender projection showing exactly what will happen if approved. Full specification: §47.4.

The pipeline is non-collapsible (frozen contract #37): Input → Architect → Canon → Human approval. No shortcut from raw input to committed filament. These sub-components are internal to every SCV instance and are not separately visible to the user — the SCV marker represents the unified agent. See §48.11 for AI architecture details.

### 16.6 AI Code Contribution Governance — Frozen Contract #137

**Prerequisites:** None. Required from day one for all code-modifying AI commits.

When a human hires a contractor to write code, the manager doesn't read every line — they check the work: Did you write tests? Did you break anything? Is this mostly real logic or mostly boilerplate? That's how Relay governs AI. Every time an AI writes code, the system automatically generates a "work receipt" — like a nutrition label for the code — showing what percentage is real problem-solving, what percentage is error handling, what percentage is copy-paste, and whether the AI actually tested its own work. If the receipt looks unhealthy (too much padding, no tests, fake complexity), the code gets rejected before any human has to read it. If it looks healthy, the manager reviews the receipt first, then the code — saving hours of line-by-line inspection.

This receipt is called an **AICodeContributionPacket**. It is deterministic (same code always produces the same receipt), auditable (anyone can verify it), and anti-gaming (the system detects padding, fake tests, and hollow complexity). The packet attaches to the AI's filament commit like any other evidence attachment — visible in cross-section, subject to confidence scoring, and permanent.

#### §16.6.1 — LOC Definition (anti-padding)

Raw line count is gameable. Relay counts diff-based LOC only:

| Field | Definition |
|-------|-----------|
| `linesAdded` | Non-empty, non-whitespace lines added (after formatter) |
| `linesRemoved` | Non-empty, non-whitespace lines removed |
| `linesModified` | Lines changed in-place (edit distance > 0) |
| `netDelta` | `linesAdded - linesRemoved` (can be negative for refactors) |
| `filesCreated` | New files |
| `filesModified` | Existing files changed |
| `filesDeleted` | Files removed |
| `filesTouched` | `created + modified + deleted` |

**Exclusions** (tracked but not counted toward `locCounted`):

- Blank lines
- Brace-only lines (containing only `{`, `}`, `);`, or similar structural closers)
- Auto-generated headers / license blocks (detected by marker comment)
- Pure import/require statements (tracked separately as `importLines`)

**`locCounted`** = `linesAdded` after all exclusions and formatting normalization. This is the denominator for all percentage calculations.

Formatting normalization: if a project formatter is configured (Prettier, Black, clang-format), the diff is computed after formatting. This prevents inflation via whitespace/style changes.

#### §16.6.2 — Line Type Classification (language-aware, deterministic precedence)

Every counted line is assigned exactly one type. When a line matches multiple categories, the highest-precedence type wins.

**Precedence chain** (highest → lowest):

```
TEST > DEBUG > GUARD > LOGIC > RENDER > STATE > WIRING > DECLARATION > SCAFFOLD > COMMENT
```

| Type | Definition | JS/TS Examples |
|------|-----------|----------------|
| TEST | Assertions, test framework blocks, expect/assert calls | `console.assert()`, `describe()`, `it()`, `expect()` |
| DEBUG | Temporary logging, dev-only instrumentation, debugger statements | `console.log()`, `console.warn()` (non-assert), `debugger` |
| GUARD | Validation, early returns, null/NaN/undefined checks, try/catch wrappers | `if (!x) return;`, `Number.isFinite()`, `try {`, `catch (e) {` |
| LOGIC | Conditionals, loops, math, algorithms, transformations, business rules | `if (balance < threshold)`, `for (const x of items)`, arithmetic |
| RENDER | DOM writes, UI output, HUD updates, visual feedback, CSS-in-JS | `el.textContent = ...`, `classList.toggle()`, `setAttribute()` |
| STATE | Variable assignments, cache mutations, flag toggling | `currentMode = mode;`, `counter++` |
| WIRING | Event listeners, API calls, import/export, glue code, hook registration | `addEventListener()`, `export function`, `fetch()` |
| DECLARATION | Constants, config objects, enums, schema definitions, type annotations | `const X = 5;`, object literal definitions, TypeScript interfaces |
| SCAFFOLD | Function/class signatures, empty stubs, structural shells, module boilerplate | `function foo() {`, `class Bar {`, empty method bodies |
| COMMENT | Inline comments, JSDoc, documentation annotations | `// explanation`, `/** @param */` |

**Classification method**: AST-based parsing is required for supported languages. For JS/TS: use an ESTree-compatible parser (Acorn, Babel, or equivalent). Each AST node maps to a line type via deterministic rules:

- `TryStatement` opener → GUARD
- `CatchClause` opener → GUARD
- `IfStatement` with `ReturnStatement` and no else → GUARD (early return pattern)
- `IfStatement` with else or complex body → LOGIC
- `CallExpression` to `console.assert` → TEST
- `CallExpression` to `console.log/warn/error` (non-assert) → DEBUG
- `VariableDeclaration` at module scope → DECLARATION
- `VariableDeclaration` inside function body → STATE
- `FunctionDeclaration`/`ArrowFunctionExpression` signature line → SCAFFOLD
- `ExportNamedDeclaration` → WIRING (the export keyword line)

**For non-parseable files** (binary, config, markup without AST support): `lineProfile = null` and a confidence penalty of −0.15 applies. Unknown is never a free pass.

#### §16.6.3 — Semantic Profile (substance metrics)

Line classification alone is insufficient. An AI can write 200 lines that parse as LOGIC but add zero decision points. Semantic metrics measure structural substance:

| Field | Definition |
|-------|-----------|
| `cyclomaticComplexityDelta` | Net change in decision points (`if`, `else if`, `for`, `while`, `do`, `catch`, `case`, `? :`, `&&`, `\|\|`) |
| `functionCountDelta` | Net new/removed functions |
| `branchConditionDelta` | Net change in conditional branches |
| `exportsAdded` / `exportsRemoved` / `exportsModified` | Public API surface delta |
| `importsAdded` / `importsRemoved` | External dependency delta |
| `internalImportsAdded` | New cross-module references within project |
| `maxNestingDepth` | Deepest indentation level in new code |
| `avgFunctionLength` | Mean lines per new/modified function |
| `longestFunction` | Longest single function in contribution |
| `renamedSymbols` | Variable/function renames detected |
| `movedBlocks` | Code relocated between files (similarity-based detection) |
| `duplicateBlocksIntroduced` | Near-identical blocks added (copy-paste detection) |

**Cyclomatic complexity counting rules** (for JS/TS, AST-based): count each `IfStatement`, `ConditionalExpression` (ternary), `ForStatement`, `ForInStatement`, `ForOfStatement`, `WhileStatement`, `DoWhileStatement`, `CatchClause`, `SwitchCase` (each case), `LogicalExpression` where operator is `&&` or `||`. Base complexity per function is 1.

**Anti-gaming signal**: If `locCounted` is high but `cyclomaticComplexityDelta` is near zero, the contribution is structurally hollow — mostly declarations, scaffolding, or copy-paste. This results in a cold filament (low heat).

#### §16.6.4 — Quality Profile (safety and verification)

| Field | Definition |
|-------|-----------|
| `testLineShare` | `test LOC / locCounted` |
| `testAssertionCount` | Number of assert/expect calls in contribution |
| `testFileModified` | Did the AI touch any test file? |
| `lintErrorsIntroduced` | New lint violations in modified files |
| `lintErrorsFixed` | Pre-existing violations resolved |
| `lintClean` | Zero errors after contribution |
| `typecheckPass` | Static type checker passes (if applicable) |
| `guardDensity` | `guard lines / locCounted` |
| `tryCatchBlocks` | Error boundaries added |
| `nullChecks` | null/undefined/NaN guards |
| `unsafeCallsIntroduced` | `eval`, `innerHTML`, `dangerouslySetInnerHTML`, `exec`, destructive filesystem calls |
| `hardcodedSecrets` | String patterns matching key/token/password heuristics |
| `todoMarkersLeft` | `TODO`/`FIXME`/`HACK`/`XXX` in new code |

**Execution proof hooks** (prevents fake tests):

| Field | Values |
|-------|--------|
| `testRunStatus` | `PASS` / `FAIL` / `SKIPPED` / `UNAVAILABLE` |
| `lintRunStatus` | `PASS` / `FAIL` / `SKIPPED` / `UNAVAILABLE` |
| `typecheckRunStatus` | `PASS` / `FAIL` / `SKIPPED` / `UNAVAILABLE` |
| `proofArtifactRefs` | Array of content hashes (stdout hash, JUnit XML hash, lint report hash) |

If any `*RunStatus` is `UNAVAILABLE`, `confidenceScore` is capped at 0.55 unless `taskClassDeclared` is `SPIKE`.

**Confidence formula** (structure is frozen, targets are template-configurable):

```
confidenceScore = (0.40 × min(testLineShare / targetTestShare, 1.0))
                + (0.25 × min(guardDensity / targetGuardDensity, 1.0))
                + (0.20 × (lintClean ? 1.0 : 0.5))
                + (0.15 × (typecheckPass ? 1.0 : 0.0))
```

The weights `{test: 0.40, guard: 0.25, lint: 0.20, typecheck: 0.15}` and the arithmetic structure are frozen. Only the `target*` values are configurable per template (§21). No template may replace the formula itself.

#### §16.6.5 — Task Class Profiles (explicit declaration, no inference)

Every AI code contribution has a `taskClassDeclared` set by the human request (ticket, filament template, or explicit instruction). AI may propose `taskClassSuggested` but the declared class is authoritative for all gates.

**If `taskClassDeclared` is missing → REFUSAL (`TASK_CLASS_MISSING`).** The contribution stays in DRAFT. The AI cannot silently infer task class to bypass governance.

Healthy percentage bands per task class:

| Type | FEATURE | BUGFIX | REFACTOR | SPIKE |
|------|---------|--------|----------|-------|
| logic | 20–45% | 10–40% | 5–30% | 10–50% |
| guard | 8–20% | 15–35% | 5–15% | 0–15% |
| test | 5–30% | 10–40% | 10–35% | 0–10% |
| scaffold | 0–15% | 0–5% | 0–10% | 0–30% |
| debug | 0–5% | 0–3% | 0–2% | 0–20% |
| comment | 0–8% | 0–10% | 0–5% | 0–15% |
| minConfidence | 0.60 | 0.75 | 0.70 | 0.30 |
| netDeltaSign | positive | any | negative or zero | any |

Additional REFACTOR rule: `renamedSymbols + movedBlocks >= 1` (must actually restructure, not just rewrite).

Additional SPIKE rule: `autoExpireDays = 14`. Spike code auto-flags as twig if not promoted to FEATURE/BUGFIX within expiry. Templates may override this value.

Templates (§21) may define task-class-specific overrides for their domain. A manufacturing template might tighten BUGFIX guard minimums; a creative/media template might loosen SPIKE scaffold limits.

#### §16.6.6 — Lifecycle Integration

AI code contributions flow through the existing governance lifecycle (§19) with additional gates:

```
AI produces code
       │
       ▼
AICodeContributionPacket generated (automatic, deterministic)
       │
       ▼
┌─ DRAFT ──────────────────────────────────────────────────┐
│  lineProfile computed (AST-based)                        │
│  semanticProfile computed                                │
│  qualityProfile computed (with execution proof if avail) │
│  taskClassDeclared checked (REFUSAL if missing)          │
└──────────────────────────────────────────────────────────┘
       │
       ▼
Profile vs taskClassProfile band check
       │
  ┌────┴────┐
  │         │
PASS      FAIL → Scar with reason code:
  │               PROFILE_GAMING (bands violated)
  ▼               NO_TESTS (testLineShare below minimum)
PROPOSED          EXCESSIVE_SCAFFOLD (scaffold % above band)
  │               EXCESSIVE_DEBUG (debug % above band)
  ▼               LOW_CONFIDENCE (below minConfidence)
Human reviews     HOLLOW_COMPLEXITY (high LOC, near-zero complexity delta)
distribution      UNSAFE_CALLS (unsafeCallsIntroduced > 0)
first, then       DUPLICATE_BLOCKS (duplicateBlocksIntroduced > 0)
code              TASK_CLASS_MISSING (no declared class)
  │
  ▼
COMMIT gate:
  testLineShare >= task minimum
  lintClean = true
  confidenceScore >= minConfidence
  No UNAVAILABLE execution proofs (unless SPIKE)
  │
  ▼
ABSORBED (sinks inward with time)
```

Rejected contributions leave a scar with the reason code permanently visible in cross-section.

#### §16.6.7 — Visual Encoding on Tree

| Tree Property | Source | Rule |
|---------------|--------|------|
| Filament heat | `cyclomaticComplexityDelta / locCounted` | High semantic density = hot. High LOC with low complexity = cold. |
| Filament confidence | `qualityProfile.confidenceScore` | Composite of tests + guards + lint + typecheck (§16.6.4 formula). |
| Ring thickness | `locSpec.netDelta` per timebox | Net code change, not gross. Refactors that delete show thin rings. |
| Twig | `taskClass === SPIKE && age > autoExpireDays` | Unresolved spikes protrude as twigs. |
| Scar | Rejected contribution | Reason code preserved. Visible in cross-section forever. |
| Fog | `testLineShare < taskMinimum` | Untested code emits fog on the branch surface. |
| Wilt | `lineProfile.pct.debug > taskMax` | Excess debug artifacts signal structural decay. |
| Branch lean | Cumulative confidence deficit | Branch leans toward the AI counterparty if confidence stays low. |

**Contract #137 — Any code-modifying AI commit must include AICodeContributionPacket. COMMIT gate uses `taskClassDeclared` + `qualityProfile` minimums. The confidence formula structure is frozen; only targets are template-configurable. Task class must be explicitly declared by the human, never silently inferred by the AI.**

---

## 17. Presence System — The Attention Sensor Network

> *"Attention is the rarest and purest form of generosity."* — Simone Weil

**Prerequisites:** None for base (attention sensor network, presence markers, birds/flocks). Expands with: AR interaction modules → video presence within user sphere (§39), camera feed, shared AR view, arena presence.

### 17.1 Presence Markers

Every user in Relay has a presence marker: location + gaze direction + current focus target. The attention rate metric is computed by counting presence markers focused on a given location. Presence markers are the SENSOR NETWORK for the attention economy.

### 17.2 Presence Tiers

- **Tier 0** (default): Anonymous dot. No identity revealed.
- **Tier 1**: Identifiable role badge. Explicit consent per session.
- **Tier 2**: Named identity. Explicit consent + policy approval.

### 17.3 Presence at Scale — Avatars, Swarm Behavior, and Biological Movement Patterns

Users are themselves. Every user has their own avatar — customizable, chosen through their presence profile (§8.6), rendered with whatever skin, shape, or appearance they select within template rules. At close range, you see the person. Their avatar. Their chosen face.

The biological metaphor applies not to what individual users *look like*, but to how aggregate user movement *behaves* at increasing distance. When you zoom out and thousands of individual avatars must be rendered, their collective motion follows the same patterns found in nature — flocking, schooling, swarming. These are not artistic choices. They are the mathematically optimal way to represent crowd behavior at scale while preserving the information that matters: direction, density, speed, and convergence.

**LOD-based presence rendering:**

| LOD | What You See | Behavioral Pattern | Max Entities | Aggregation |
|-----|-------------|-------------------|-------------|-------------|
| CELL / SHEET | **Individual avatar** — full detail, cursor, gaze, selected filament. Presence profile active. | None — each user moves independently | Unlimited (few at this zoom) | None |
| BARK / BRANCH | **Individual markers** — small presence dots on the bark surface. You can see each person working on specific filaments. Direction = gaze target. Speed = interaction rate. Countable. | **Bee-like** — purposeful, visiting specific locations, pollinating between filaments | ≤ 500 per branch | None — distinct individuals |
| TREE | **Presence dots with flock behavior** — dots cluster around active branches. Movement is emergent — users follow each other toward engagement. A cluster circling a branch = "something happening here." | **Bird-flocking** — individuals visible but moving collectively toward attractors | ≤ 200 per tree | Nearby dots merge at distance |
| COMPANY | **Aggregate streams** — individual users no longer distinguishable. Streams of movement between trees. Stream width = user count. Stream direction = dominant attention flow. Dense streams = hot topic. | **School-of-fish** — unified directional flow with emergent turning | ≤ 50 streams per cluster | Users in same tree merge into stream |
| REGION | **Murmuration clouds** — massive swirling particle formations. Shape tells you where attention flows across a region. Dense knots = contested governance or viral engagement. Thin wisps = routine traffic. | **Starling murmuration** — collective shape encodes crowd intent | ≤ 20 formations per region | Streams merge into murmurations |
| PLANETARY / GLOBE | **Swarm currents** — luminous particle rivers gliding across the globe. Like the machine sentinel flows in The Matrix Revolutions. Swarm density = population activity. Dark zones = dormant. Bright convergence = global events. | **Sentinel swarm** — civilization's pulse made visible | ≤ 200 globally | All regional clouds merge |

**What this means:** The user's chosen avatar is always their identity at close range. As the camera pulls back, individual identity dissolves into collective motion — not because Relay hides individuals, but because at scale, the *pattern* carries more information than any single dot. A murmuration's shape tells you more about a city's engagement than 500,000 individual cursor positions ever could.

**Rendering rules:**

1. **Avatar at close range, pattern at distance.** The transition from individual avatar to aggregate particle is a smooth LOD morph. No popping.
2. **Sap drives all presence behavior.** Movement comes from SapPackets (§82.3). No sap = no visible presence = the branch appears empty.
3. **Trails are ephemeral.** Optional path traces render as fading contrails. Auto-expire per TTL. Trails are leaf-class data (§82.2).
4. **Density IS the attention metric.** The number of dots on a branch IS the attention rate. Murmuration density IS engagement heat. No separate overlay — the presence rendering IS the data.
5. **Privacy tiers control detail, not visibility.** Tier 0 = anonymous dot, no distinguishing features. Tier 1 = role badge. Tier 2 = named. The dot exists regardless — only the information on it changes with consent.
6. **Performance budget is absolute.** 10 million users in one region renders as a denser murmuration, not 10 million particles. Density is encoded in brightness, stream width, and turbulence — not entity count.

**Contract #202 — Presence LOD Rendering. Users render with their chosen avatar at close LOD. At increasing distance, individual presence markers aggregate into collective movement patterns following biological swarm dynamics: bee-like purposeful movement at BRANCH, bird-flocking at TREE, fish-schooling streams at COMPANY, murmuration clouds at REGION, sentinel-scale swarm currents at GLOBE. Transitions are smooth LOD morphs. Behavior is driven by SapPackets. Aggregate density IS the attention metric. Privacy tiers control marker detail, not visibility. Performance budgets per LOD tier are absolute; density is encoded in visual properties, not entity count.**

### 17.4 Non-Human Presence — Pets, Animals, and Companion Trees

Every entity in Relay is a tree. A person is a tree. A company is a tree. A city is a tree. There is no reason an animal cannot also be a tree.

Relay's camera detection system (§39, §43) already classifies visual input — fire, smoke, rain, light, objects. The same pipeline can observe animal behavior: a dog's tail wag frequency, a cat's posture shifts, a bird's flight patterns, a horse's gait. These are signals. Signals become filaments.

**How pet presence works:**

1. **Registration.** The owner creates a companion tree linked to their personal tree. The companion tree uses a `PET` or `ANIMAL` template. The owner names the animal, attaches photo/video evidence, and links the companion tree to their own tree as a child branch.

2. **Behavior documentation.** The owner (or anyone with access) records video of the animal through Relay's camera system. The SCV analyzes the footage: movement patterns, vocalizations, posture, interaction style, sleep cycles, feeding behavior. Each behavioral pattern becomes a filament on the companion tree — documented, timestamped, evidence-bearing.

3. **Behavior translation.** Over time, the SCV builds a behavioral model of the animal. A specific tail wag pattern maps to excitement. A specific meow pitch maps to hunger. Ears back maps to fear. These mappings are filaments with evidence — the video clips that established the pattern. The model improves with more data, and confidence on each behavioral mapping reflects how much evidence supports it.

4. **Voice and expression in Relay.** The companion tree can broadcast the animal's "state" as sap: current mood, activity level, needs. Relay's voice synthesis can translate behavioral state into speech — the pet "speaks" through a chosen voice profile. "I'm hungry" when the feeding pattern fires. "I want to play" when the excitement pattern fires. The voice is synthetic. The behavioral signal behind it is real, evidence-based, and auditable.

5. **Presence in the 3D world.** The pet has its own presence marker. At the owner's location, the pet's avatar appears near the owner — moving, behaving according to its live behavioral state (via sap from the owner's camera feed or IoT sensors). Other users visiting the owner's tree can see the pet. The pet's tree shows its life history — vet visits as filaments, behavioral milestones, health records.

6. **Not limited to pets.** Wildlife researchers can create companion trees for tracked animals. Zoos can give every animal a tree. Farmers can track livestock. The same pipeline works for any living creature with observable behavior. The template determines what counts as evidence and what behavioral patterns the SCV looks for.

**What this is NOT:** This is not AI pretending to be the animal. The behavioral model is transparent — every translation maps to specific video evidence. If the SCV says the dog is happy, you can click through to the video clip that established "this tail pattern = happy." Confidence on the translation reflects how reliable the mapping is. A fresh model with 3 clips is foggy. A model with 500 documented patterns is firm. The animal's "voice" is a convenience layer over real behavioral data, not a fiction.

---

## 18. Flow Channels — Recorded Procedures

> *"For the things we have to learn before we can do them, we learn by doing them."* — Aristotle

### 18.1 Definition

A Flow Channel is a recorded camera path through the tree with semantic steps. A recipe for navigating a workflow:

1. Navigate to the P2P branch
2. Open the match sheet (bark flattens)
3. Filter for exceptions
4. For each exception: inspect evidence twigs
5. Close the flow

### 18.2 Use Cases

- **Training**: New employees play back recorded flows. Camera guides them through the exact path with annotations.
- **Proximity**: A factory floor procedure recorded at a physical location. Available when workers enter the proximity zone.
- **Audit**: A standard audit procedure recorded as a flow. Auditors follow the same path, ensuring consistency.
- **Governance**: A flow can be voted on and promoted as the official procedure for a role.

### 18.3 Flows as Filaments

A flow IS a filament on a training/procedures branch. It has evidence twigs pointing to the objects it visits. It can be versioned, governance-approved, and replayed.

---

## 19. Governance

> *"The measure of a man is what he does with power."* — Plato

### 19.1 Commit Materiality

Work state machine for all material changes:

```
DRAFT -> PROPOSED -> COMMITTED -> REVERTED (visible scar)
```

Material boundary triggers force escalation from DRAFT to HOLD:
- Time threshold (end of session/timebox/reconciliation window)
- Risk threshold (affects payroll, payment, KPI-bound cells)
- Visibility threshold (published to team, shared to channel)
- Dependency threshold (affects downstream sheets/routes/summaries)
- Governance threshold (changes policy, permission, authority)

### 19.2 Commit Gates

Each phase has pass/fail criteria, proof artifacts, and refusal conditions. Quorum gate (30-75% depending on cadence), Approval gate (60-75%), Reconciliation gate (7-30 days), Sunset gate (90-day expiry).

**AI Code Gate (Contract #137):** For code-modifying AI commits, an additional gate applies between DRAFT and PROPOSED. The AICodeContributionPacket (§16.6) must pass task-class band checks and quality minimums before the contribution can be proposed for human review. See §16.6.6 for the full lifecycle flow.

### 19.3 Work Zones

Scope-based access: `zone.<entity>.<dept>.<project>`. Boundary commits define scope. Crossing boundaries requires explicit disclosure + consent.

### 19.4 Soft Divergence — Non-Blocking Disagreement

Not every disagreement should escalate. Formal disputes (§46 sortition) and governance votes (§72) are the right tools for decisions that require resolution. But many disagreements do not. A team member who disagrees with a direction but is not blocking it needs a way to say: "I disagree, and I am recording that, but I am not stopping work."

Soft divergence is a filament of kind `divergence.soft`:

```
SoftDivergenceFilament {
  divergenceId:    string,
  subjectRef:      filamentRef (the filament, motion, or decision being disagreed with),
  dissenterRef:    userRef,
  statement:       string (brief description of disagreement),
  severity:        enum { MILD, MODERATE, STRONG },
  lifecycle:       OPEN (recorded, non-blocking)
}
```

A soft divergence:

- **Does not consume pressure budget.** It creates no wilt, no fog, no structural degradation.
- **Does not trigger dispute mechanisms.** No sortition panel, no escalation, no cooling window.
- **Is visible in cross-section.** When you slice the branch at this timebox, the divergence appears as a faint mark — recorded, legible, preserved.
- **Can be resolved later.** If the original decision proves wrong, the soft divergence is evidence that someone saw it coming. If the decision proves right, the divergence sinks into the archive alongside the outcome.
- **Can escalate.** A soft divergence can be promoted to a formal dispute at any time by the dissenter. But it never auto-escalates.

This primitive prevents two failure modes: (1) disagreements that must either escalate or be silenced, and (2) pressure loops from good-faith objections that the system treats as structural threats.

**Cross-module applicability:** Soft divergence is available wherever governance decisions occur:
- **Council deliberations (§72.11):** A council member who disagrees with a passed motion but does not wish to file a procedural appeal can attach a `SoftDivergenceFilament` to the motion. The divergence appears in the meeting branch's cross-section — visible in the minutes, preserved in history, but non-blocking. This gives minority voices a formal record without forcing every disagreement into the motion/amendment/vote cycle.
- **Jury verdicts (§46):** A juror who concurs with the majority verdict but disagrees with the reasoning can attach a soft divergence — the judicial equivalent of a concurring opinion. Recorded, legible, non-blocking.

### 19.5 Cooling Windows — Time as Safety Primitive

Irreversible actions require time, not urgency. The following action classes mandate a cooling window — a minimum elapsed time between proposal and execution during which the action can be reviewed, debated, or withdrawn:

| Action Class | Minimum Cooling Window | Bypass Allowed |
|---|---|---|
| POLICY_CHANGE (Category A parameter modification) | 48 hours | No |
| AUTHORITY_GRANT (new role assignment at org level or above) | 24 hours | No |
| STAGE_TRANSITION (module activation, tier unlock) | 72 hours | No |
| CONSTITUTIONAL_AMENDMENT (frozen contract modification) | 168 hours (7 days) | No |
| HIGH_IMPACT_REPAIR (scar-generating correction on a mature branch) | 24 hours | No |
| EMERGENCY_DISPATCH (§74 civic alerts, life-threatening) | 0 (exempt) | Yes — civic emergency |

During the cooling window, the action is visible as a pending filament on the relevant governance branch. Any eligible participant can review, comment, or formally object. The action executes only after the cooling window expires AND all governance thresholds are met. If the proposer withdraws during the window, the action is cancelled with a withdrawal commit.

Cooling windows are Category A parameters — the community can vote to adjust durations, but never below a frozen minimum floor: 24 hours for any irreversible action except life-threatening emergency dispatch.

**Cross-module applicability:** Cooling windows apply wherever irreversible actions occur:
- **Council motions (§72.11):** Passed motions that trigger POLICY_CHANGE or AUTHORITY_GRANT are subject to the corresponding cooling window before execution. The motion enters CLOSED (Passed) state immediately but does not ABSORB until the cooling window expires. During this window, procedural appeals can be filed.
- **Parental governance (§63):** Upgrading a minor's autonomy bracket (e.g., moving a teen from RESTRICTED to STANDARD), removing a guardian override, or changing a Protected Participation Profile (§63.7) are irreversible for the affected period and require the AUTHORITY_GRANT cooling window (24 hours minimum). This prevents impulsive parental permission changes.
- **Summon registry additions (§43.12.7):** Community-proposed new summon creatures that pass Layer-3 governance vote are subject to POLICY_CHANGE cooling window (48 hours) before the creature enters the active registry. This prevents flash-mob creature additions.

**Contract #306 — Governance Safety Primitives. Soft divergence is a first-class non-blocking disagreement primitive: recorded, visible in cross-section, consuming no pressure budget, and never auto-escalating. Cooling windows mandate minimum elapsed time before irreversible actions execute — 24-168 hours depending on action class, with zero bypass except for life-threatening emergency dispatch (§74). The cooling window floor (24h minimum for any irreversible non-emergency action) is frozen. Both primitives are constitutional guarantees under the Eight Edges of Livability (§0.5).**

---

## 20. Cryptographic Architecture

> *"Three may keep a secret, if two of them are dead."* — Benjamin Franklin

Every action in Relay is sealed with a digital fingerprint. Once something is recorded, it cannot be secretly changed — any tampering visibly breaks the chain, the way cutting a link in a necklace makes the break obvious. Your private data is encrypted so that only the people you authorize can see it. And when you need to prove something without revealing everything — like proving you paid a bill without showing your bank balance — you can share just the proof, not the contents. This is how Relay ensures that truth stays true and privacy stays private.

### 20.1 Core Principles

- Leaf-level encryption; above leaf = hashes + signatures + Merkle roots
- Envelope encryption (one ciphertext + per-recipient wraps)
- Selective disclosure via Merkle inclusion proofs
- The core validates integrity/authorization, NOT plaintext content
- Revocation via explicit commits + key rotation

### 20.2 Root Archive

Roots are Merkle-encrypted permanent archive. Every root cube carries:
- `absorptionHash` (content integrity)
- `merkleAnchor.chainHash` (chain integrity)
- `merkleAnchor.timeboxMerkleRoot` (timebox integrity)
- `merkleAnchor.inclusionProofPath` (verifiable inclusion)

The root's purpose is definitive: full Merkle encryption confirmation of all reconciled content. The permanent, immutable, cryptographically sealed record.

### 20.3 Root Cube Schema

```json
{
  "RootCube": {
    "cubeId": "root.<filamentId>",
    "filamentId": "string",
    "commitIndex": 0,
    "totalMagnitude": "string-decimal",
    "unit": "string",
    "branchPath": "branch.<treeId>.<servicePath>",
    "tags": {},
    "timeboxId": "timebox.<branchId>.<start>-<end>",
    "closedAt": "ISO-8601",
    "absorptionHash": "sha256:...",
    "originRowRef": "row.<moduleId>.<sheetId>.R<row>",
    "transferPacketId": "TP-<id>|null",
    "responsibilityPacketId": "RP-<id>|null",
    "ledgerProjectionHash": "sha256:...|null",
    "merkleAnchor": {
      "chainHash": "sha256:...",
      "timeboxMerkleRoot": "sha256:...",
      "inclusionProofPath": ["sha256:..."]
    }
  }
}
```

Roots are shorter than branches because they do NOT express real time/duration. They show commit after commit — like blocks in a blockchain. Time is compressed; only the sequential record remains.

---

## 21. Templates — Domain Configuration

> *"Give me a lever long enough and a fulcrum on which to place it, and I shall move the world."* — Archimedes

**Prerequisites:** None for base (domain configuration, attribute bindings, color system). Expands with: spell/combat modules → genre overlay templates (§40.3) for gamification rendering (Sci-Fi, Fantasy, Horror, Military, Adventure). §76 (Civilization Template Library) defines the full set of seed templates covering every domain of civilization — person, family, property, healthcare, agriculture, infrastructure, commerce, estate, emergency, utilities, finance, culture, sports, and marriage/partnership.

### 21.1 What a Template Defines

A template is the only thing that changes between a procurement tree and a pothole tree:

- **Branch types**: What service categories exist (P2P, Infrastructure, Geology)
- **Filament schemas**: What columns each row type has (beyond the six universal domains)
- **Evidence rules**: What evidence is required for completeness per filament type
- **Expected resolution cadence**: How long filaments should take to close
- **Sinking behavior**: Earth time (operational), none (static), milestone-driven (creative)
- **KPI bindings**: What metrics drive visual attributes (default, overridable by users)
- **Helical twist period**: Day, week, sprint, quarter
- **Consolidation gate rules**: Financial balance, completeness check, peer review
- **AI task-class profile overrides**: Templates may tighten or loosen the task-class band thresholds and confidence targets defined in §16.6.5 for their domain. A manufacturing template might require higher guard density for BUGFIX; a creative template might permit higher scaffold for SPIKE. The confidence formula structure itself is frozen (contract #137) — only the target values are configurable.

### 21.2 Template Schema

```json
{
  "TreeTemplate": {
    "templateId": "template.<domain>.<variant>",
    "name": "string",
    "domain": "string",
    "sinkingMode": "earth-time|milestone|none",
    "twistPeriod": "day|week|sprint|quarter|custom",
    "barkRenderMode": "tabular|document|code|media|gallery|custom",
    "lAxisMapping": "calendar-time|content-position|version-sequence|composition-timeline",
    "cellLODRenderer": "spreadsheet|text-scroll|syntax-highlight|waveform|viewport",
    "branches": [
      {
        "id": "string",
        "name": "string",
        "filamentSchema": {
          "columns": [
            { "name": "string", "domain": "identity|counterparty|time|magnitude|evidence|lifecycle|extension", "type": "string|number|date|reference|attachment" }
          ],
          "magnitudeColumn": "string",
          "counterpartyColumn": "string"
        },
        "evidenceRules": [
          { "description": "string", "requiredCount": 0, "sourceType": "string" }
        ],
        "expectedResolutionDays": 0,
        "sub": ["recursive branch"]
      }
    ],
    "consolidationGate": {
      "type": "financial-balance|completeness|peer-review|custom",
      "rules": {}
    },
    "defaultAttributeBindings": {
      "slabColor": "magnitude",
      "slabOpacity": "confidence",
      "slabThickness": "commitDensity",
      "slabFirmness": "wiltFactor",
      "branchRadius": "normalizedKPISum",
      "twistRate": "activityPerPeriod",
      "filamentRadial": "lifecycleState",
      "filamentAngular": "approachDirection"
    }
  }
}
```

### 21.2.1 Example Template — Manufacturing Operations

```json
{
  "TreeTemplate": {
    "templateId": "template.manufacturing.operations.v1",
    "name": "Manufacturing Operations (Mass Balance)",
    "domain": "manufacturing",
    "sinkingMode": "earth-time",
    "twistPeriod": "week",
    "barkRenderMode": "tabular",
    "lAxisMapping": "calendar-time",
    "cellLODRenderer": "spreadsheet",
    "branches": [
      {
        "id": "raw-materials",
        "name": "Raw Materials",
        "filamentSchema": {
          "columns": [
            { "name": "materialId", "domain": "identity", "type": "string" },
            { "name": "supplier", "domain": "counterparty", "type": "reference" },
            { "name": "receivedDate", "domain": "time", "type": "date" },
            { "name": "quantity", "domain": "magnitude", "type": "number" },
            { "name": "magnitudeType", "domain": "extension", "type": "string" },
            { "name": "unit", "domain": "magnitude", "type": "string" },
            { "name": "batchCert", "domain": "evidence", "type": "attachment" },
            { "name": "scalReading", "domain": "evidence", "type": "attachment" }
          ],
          "magnitudeColumn": "quantity",
          "counterpartyColumn": "supplier"
        },
        "evidenceRules": [
          { "description": "Scale reading at intake", "requiredCount": 1, "sourceType": "sensor" },
          { "description": "Supplier batch certificate", "requiredCount": 1, "sourceType": "document" }
        ],
        "expectedResolutionDays": 1,
        "sub": []
      },
      {
        "id": "production",
        "name": "Production Lines",
        "filamentSchema": {
          "columns": [
            { "name": "lineId", "domain": "identity", "type": "string" },
            { "name": "product", "domain": "identity", "type": "string" },
            { "name": "shiftDate", "domain": "time", "type": "date" },
            { "name": "quantity", "domain": "magnitude", "type": "number" },
            { "name": "magnitudeType", "domain": "extension", "type": "string" },
            { "name": "unit", "domain": "magnitude", "type": "string" },
            { "name": "qcReport", "domain": "evidence", "type": "attachment" }
          ],
          "magnitudeColumn": "quantity",
          "counterpartyColumn": null
        },
        "evidenceRules": [
          { "description": "Production run log", "requiredCount": 1, "sourceType": "system" },
          { "description": "QC lab report", "requiredCount": 1, "sourceType": "document" }
        ],
        "expectedResolutionDays": 1,
        "sub": [
          { "id": "line-cn-c1", "name": "CN Line C1" },
          { "id": "line-cn-c2", "name": "CN Line C2" },
          { "id": "line-dm-d1", "name": "DM Line D1" }
        ]
      },
      {
        "id": "waste",
        "name": "Waste Management",
        "filamentSchema": {
          "columns": [
            { "name": "wasteType", "domain": "identity", "type": "string" },
            { "name": "disposalVendor", "domain": "counterparty", "type": "reference" },
            { "name": "recordDate", "domain": "time", "type": "date" },
            { "name": "quantity", "domain": "magnitude", "type": "number" },
            { "name": "magnitudeType", "domain": "extension", "type": "string" },
            { "name": "unit", "domain": "magnitude", "type": "string" },
            { "name": "wasteManifest", "domain": "evidence", "type": "attachment" }
          ],
          "magnitudeColumn": "quantity",
          "counterpartyColumn": "disposalVendor"
        },
        "evidenceRules": [
          { "description": "Waste manifest", "requiredCount": 1, "sourceType": "document" },
          { "description": "Scale reading at disposal", "requiredCount": 1, "sourceType": "sensor" }
        ],
        "expectedResolutionDays": 7,
        "sub": []
      },
      {
        "id": "finished-goods",
        "name": "Finished Goods",
        "filamentSchema": {
          "columns": [
            { "name": "productId", "domain": "identity", "type": "string" },
            { "name": "customer", "domain": "counterparty", "type": "reference" },
            { "name": "shipDate", "domain": "time", "type": "date" },
            { "name": "quantity", "domain": "magnitude", "type": "number" },
            { "name": "magnitudeType", "domain": "extension", "type": "string" },
            { "name": "unit", "domain": "magnitude", "type": "string" },
            { "name": "shippingDoc", "domain": "evidence", "type": "attachment" }
          ],
          "magnitudeColumn": "quantity",
          "counterpartyColumn": "customer"
        },
        "evidenceRules": [
          { "description": "Shipping document / bill of lading", "requiredCount": 1, "sourceType": "document" },
          { "description": "Customer receipt confirmation", "requiredCount": 1, "sourceType": "external" }
        ],
        "expectedResolutionDays": 30,
        "sub": []
      }
    ],
    "consolidationGate": {
      "type": "financial-balance",
      "rules": {
        "conservationCheck": "inputSum == outputSum + wasteSum - recycledSum",
        "tolerancePct": 2.0,
        "magnitudeTypeField": "magnitudeType",
        "validTypes": ["input", "output", "waste", "recycled", "byproduct"],
        "unitField": "unit",
        "requiredUnit": "MT"
      }
    },
    "defaultAttributeBindings": {
      "slabColor": "conservationDeviation",
      "slabOpacity": "confidence",
      "slabThickness": "inputSum",
      "slabFirmness": "wiltFactor",
      "branchRadius": "normalizedThroughput",
      "twistRate": "activityPerPeriod",
      "filamentRadial": "lifecycleState",
      "filamentAngular": "approachDirection"
    }
  }
}
```

**Key differences from default template:**
- `magnitudeType` field in every filament schema — classifies each filament's magnitude as input, output, waste, recycled, or byproduct for conservation computation.
- `consolidationGate.type = "financial-balance"` — validates mass conservation at timebox close with configurable tolerance (2% maps to the 98-102% "green" range in §52.5).
- `slabColor` bound to `conservationDeviation` — rings color-shift based on mass balance deviation instead of raw magnitude.
- `branchRadius` bound to `normalizedThroughput` — branch thickness reflects total material flow, not KPI score.
- Evidence rules require sensor readings (scale) + documents (certificates, manifests) — matching real-world manufacturing audit requirements.

### 21.2.2 Example Template — Nonwovens Factory (Full Production Chain)

```json
{
  "TreeTemplate": {
    "templateId": "template.manufacturing.nonwovens.v1",
    "name": "Nonwovens Production (Full Chain)",
    "domain": "manufacturing",
    "sinkingMode": "earth-time",
    "twistPeriod": "week",
    "barkRenderMode": "tabular",
    "lAxisMapping": "calendar-time",
    "cellLODRenderer": "spreadsheet",
    "branches": [
      {
        "id": "procurement-raw",
        "name": "Raw Materials",
        "filamentSchema": {
          "columns": [
            { "name": "lotId", "domain": "identity", "type": "string" },
            { "name": "vendor", "domain": "counterparty", "type": "reference" },
            { "name": "materialClass", "domain": "extension", "type": "string" },
            { "name": "grade", "domain": "extension", "type": "string" },
            { "name": "receivedDate", "domain": "time", "type": "date" },
            { "name": "quantity", "domain": "magnitude", "type": "number" },
            { "name": "unit", "domain": "extension", "type": "string" },
            { "name": "magnitudeType", "domain": "extension", "type": "string" },
            { "name": "compositionEvidence", "domain": "evidence", "type": "attachment" },
            { "name": "coaCertificate", "domain": "evidence", "type": "attachment" }
          ],
          "magnitudeColumn": "quantity",
          "counterpartyColumn": "vendor"
        },
        "evidenceRules": [
          { "description": "Certificate of Analysis", "requiredCount": 1, "sourceType": "document" },
          { "description": "Scale weight ticket", "requiredCount": 1, "sourceType": "sensor" }
        ],
        "expectedResolutionDays": 3,
        "sub": [
          { "id": "procurement-pp", "name": "Polypropylene" },
          { "id": "procurement-surfactants", "name": "Surfactants" },
          { "id": "procurement-additives", "name": "Additives" },
          { "id": "procurement-packaging", "name": "Packaging Materials" }
        ]
      },
      {
        "id": "production-runs",
        "name": "Production Runs",
        "filamentSchema": {
          "columns": [
            { "name": "runId", "domain": "identity", "type": "string" },
            { "name": "machineLine", "domain": "extension", "type": "string" },
            { "name": "shift", "domain": "time", "type": "string" },
            { "name": "startTime", "domain": "time", "type": "date" },
            { "name": "endTime", "domain": "time", "type": "date" },
            { "name": "inputLots", "domain": "evidence", "type": "reference[]" },
            { "name": "outputMass", "domain": "magnitude", "type": "number" },
            { "name": "scrapMass", "domain": "magnitude", "type": "number" },
            { "name": "emissionsMass", "domain": "magnitude", "type": "number" },
            { "name": "magnitudeType", "domain": "extension", "type": "string" },
            { "name": "bomVersion", "domain": "evidence", "type": "reference" },
            { "name": "processParams", "domain": "extension", "type": "object" }
          ],
          "magnitudeColumn": "outputMass",
          "counterpartyColumn": "machineLine"
        },
        "evidenceRules": [
          { "description": "Input lot references", "requiredCount": 1, "sourceType": "reference" },
          { "description": "Production log", "requiredCount": 1, "sourceType": "sensor" },
          { "description": "Mass balance calculation", "requiredCount": 1, "sourceType": "computed" }
        ],
        "expectedResolutionDays": 1
      },
      {
        "id": "inventory-wip",
        "name": "WIP (Master Rolls)",
        "filamentSchema": {
          "columns": [
            { "name": "rollId", "domain": "identity", "type": "string" },
            { "name": "sourceRun", "domain": "evidence", "type": "reference" },
            { "name": "mass", "domain": "magnitude", "type": "number" },
            { "name": "width", "domain": "extension", "type": "number" },
            { "name": "length", "domain": "extension", "type": "number" },
            { "name": "basisWeight", "domain": "extension", "type": "number" },
            { "name": "magnitudeType", "domain": "extension", "type": "string" },
            { "name": "inheritedComposition", "domain": "extension", "type": "object" },
            { "name": "qcStatus", "domain": "lifecycle", "type": "string" }
          ],
          "magnitudeColumn": "mass",
          "counterpartyColumn": "sourceRun"
        },
        "evidenceRules": [
          { "description": "Source production run reference", "requiredCount": 1, "sourceType": "reference" }
        ],
        "expectedResolutionDays": 7
      },
      {
        "id": "inventory-fg",
        "name": "Finished Goods",
        "filamentSchema": {
          "columns": [
            { "name": "fgRollId", "domain": "identity", "type": "string" },
            { "name": "sourceWip", "domain": "evidence", "type": "reference" },
            { "name": "customer", "domain": "counterparty", "type": "reference" },
            { "name": "mass", "domain": "magnitude", "type": "number" },
            { "name": "width", "domain": "extension", "type": "number" },
            { "name": "length", "domain": "extension", "type": "number" },
            { "name": "magnitudeType", "domain": "extension", "type": "string" },
            { "name": "inheritedComposition", "domain": "extension", "type": "object" },
            { "name": "shipmentId", "domain": "extension", "type": "string" },
            { "name": "retailLocation", "domain": "extension", "type": "reference" }
          ],
          "magnitudeColumn": "mass",
          "counterpartyColumn": "customer"
        },
        "evidenceRules": [
          { "description": "Slitting run reference", "requiredCount": 1, "sourceType": "reference" },
          { "description": "QC pass certificate", "requiredCount": 1, "sourceType": "document" },
          { "description": "Dimensional measurement", "requiredCount": 1, "sourceType": "sensor" }
        ],
        "expectedResolutionDays": 14
      },
      {
        "id": "quality-qc",
        "name": "Quality Control",
        "filamentSchema": {
          "columns": [
            { "name": "testId", "domain": "identity", "type": "string" },
            { "name": "sampleSource", "domain": "evidence", "type": "reference" },
            { "name": "tensileStrength", "domain": "extension", "type": "number" },
            { "name": "basisWeight", "domain": "extension", "type": "number" },
            { "name": "absorption", "domain": "extension", "type": "number" },
            { "name": "chemicalResidue", "domain": "extension", "type": "number" },
            { "name": "visualDefects", "domain": "extension", "type": "string" },
            { "name": "result", "domain": "lifecycle", "type": "string" },
            { "name": "labCert", "domain": "evidence", "type": "attachment" }
          ],
          "magnitudeColumn": "basisWeight",
          "counterpartyColumn": "sampleSource"
        },
        "evidenceRules": [
          { "description": "Lab test report", "requiredCount": 1, "sourceType": "document" },
          { "description": "Test instrument calibration cert", "requiredCount": 1, "sourceType": "document" }
        ],
        "expectedResolutionDays": 2
      },
      {
        "id": "rework",
        "name": "Rework",
        "filamentSchema": {
          "columns": [
            { "name": "reworkId", "domain": "identity", "type": "string" },
            { "name": "sourceFg", "domain": "evidence", "type": "reference" },
            { "name": "defectType", "domain": "extension", "type": "string" },
            { "name": "reworkRun", "domain": "evidence", "type": "reference" },
            { "name": "outputMass", "domain": "magnitude", "type": "number" },
            { "name": "magnitudeType", "domain": "extension", "type": "string" }
          ],
          "magnitudeColumn": "outputMass"
        },
        "expectedResolutionDays": 7
      },
      {
        "id": "waste",
        "name": "Waste & Emissions",
        "filamentSchema": {
          "columns": [
            { "name": "wasteId", "domain": "identity", "type": "string" },
            { "name": "sourceRun", "domain": "evidence", "type": "reference" },
            { "name": "wasteClass", "domain": "extension", "type": "string" },
            { "name": "mass", "domain": "magnitude", "type": "number" },
            { "name": "magnitudeType", "domain": "extension", "type": "string" },
            { "name": "emissionType", "domain": "extension", "type": "string" },
            { "name": "disposalMethod", "domain": "extension", "type": "string" },
            { "name": "manifest", "domain": "evidence", "type": "attachment" }
          ],
          "magnitudeColumn": "mass"
        },
        "evidenceRules": [
          { "description": "Weighbridge ticket or meter reading", "requiredCount": 1, "sourceType": "sensor" },
          { "description": "Waste manifest", "requiredCount": 1, "sourceType": "document" }
        ],
        "expectedResolutionDays": 5
      },
      {
        "id": "maintenance",
        "name": "Maintenance",
        "filamentSchema": {
          "columns": [
            { "name": "maintId", "domain": "identity", "type": "string" },
            { "name": "machineLine", "domain": "counterparty", "type": "reference" },
            { "name": "maintType", "domain": "extension", "type": "string" },
            { "name": "sparePartId", "domain": "evidence", "type": "reference" },
            { "name": "cost", "domain": "magnitude", "type": "number" },
            { "name": "downtime", "domain": "extension", "type": "number" },
            { "name": "affectedRuns", "domain": "evidence", "type": "reference[]" },
            { "name": "plannedDate", "domain": "time", "type": "date" },
            { "name": "completedDate", "domain": "time", "type": "date" }
          ],
          "magnitudeColumn": "cost",
          "counterpartyColumn": "machineLine"
        },
        "evidenceRules": [
          { "description": "Work order", "requiredCount": 1, "sourceType": "document" },
          { "description": "Spare part receipt", "requiredCount": 1, "sourceType": "document" }
        ],
        "expectedResolutionDays": 14,
        "sub": [
          { "id": "maint-preventive", "name": "Preventive" },
          { "id": "maint-corrective", "name": "Corrective" },
          { "id": "maint-condition", "name": "Condition-Based" },
          { "id": "maint-spare-parts", "name": "Spare Parts Inventory" }
        ]
      },
      {
        "id": "rnd",
        "name": "R&D",
        "filamentSchema": {
          "columns": [
            { "name": "trialId", "domain": "identity", "type": "string" },
            { "name": "objective", "domain": "extension", "type": "string" },
            { "name": "bomVersion", "domain": "evidence", "type": "reference" },
            { "name": "trialRun", "domain": "evidence", "type": "reference" },
            { "name": "result", "domain": "lifecycle", "type": "string" },
            { "name": "specChange", "domain": "evidence", "type": "attachment" }
          ]
        },
        "expectedResolutionDays": 30
      },
      {
        "id": "environment",
        "name": "Environment & ESG",
        "sub": [
          { "id": "env-emissions-truth", "name": "Emissions Truth" },
          { "id": "env-policy-credits", "name": "Policy & Credits" },
          { "id": "env-interventions", "name": "Interventions" }
        ]
      },
      {
        "id": "treasury",
        "name": "Treasury",
        "filamentSchema": {
          "columns": [
            { "name": "txnId", "domain": "identity", "type": "string" },
            { "name": "counterparty", "domain": "counterparty", "type": "reference" },
            { "name": "amount", "domain": "magnitude", "type": "number" },
            { "name": "currency", "domain": "extension", "type": "string" },
            { "name": "magnitudeType", "domain": "extension", "type": "string" }
          ],
          "magnitudeColumn": "amount",
          "counterpartyColumn": "counterparty"
        },
        "expectedResolutionDays": 30
      }
    ],
    "consolidationGate": {
      "type": "financial-balance",
      "rules": {
        "conservationCheck": "inputSum == outputSum + wasteSum - recycledSum",
        "tolerancePct": 2.0,
        "magnitudeTypeField": "magnitudeType",
        "validTypes": ["input", "output", "waste", "recycled", "byproduct", "emission"],
        "unitField": "unit",
        "requiredUnit": "kg",
        "compositionConservation": true,
        "compositionTolerance": 3.0
      }
    },
    "esgReconciliation": {
      "truthBranch": "env-emissions-truth",
      "creditsBranch": "env-policy-credits",
      "interventionsBranch": "env-interventions",
      "baselineWindow": 6,
      "postWindow": 6,
      "stormThreshold": 0.3,
      "unit": "kgCO2e/ton_FG"
    },
    "recallCascade": {
      "enabled": true,
      "chain": ["procurement-raw", "production-runs", "inventory-wip", "inventory-fg"],
      "lightningThreshold": 100,
      "notifyDownstream": true
    },
    "defaultAttributeBindings": {
      "slabColor": "conservationDeviation",
      "slabOpacity": "confidence",
      "slabThickness": "inputSum",
      "slabFirmness": "wiltFactor",
      "branchRadius": "normalizedThroughput",
      "twistRate": "activityPerPeriod",
      "filamentRadial": "lifecycleState",
      "filamentAngular": "approachDirection"
    }
  }
}
```

**Key differences from §21.2.1 (generic manufacturing):**
- **11 primary branches** covering the full production chain from raw procurement through FG, quality, rework, waste, maintenance, R&D, ESG, and treasury.
- **Maintenance sub-branches** by type (preventive, corrective, condition-based, spare parts) with `affectedRuns` cross-references for recall correlation.
- **ESG three-branch structure** (§53.6) with reconciliation configuration for greenwashing detection.
- **Recall cascade** configuration with chain definition and lightning threshold.
- **Composition conservation** enabled in the consolidation gate — checks mass balance per chemical component, not just total mass.
- **R&D branch** with BOM version references and trial-to-production spec change tracking.
- **`inheritedComposition`** field on WIP and FG filaments — the mass-weighted composition profile inherited through the transformation chain (Contract #139).

### 21.2.3 Example Template — Municipal Government (Property & Permits)

Covers land registration, building permits, zoning compliance, utility billing, and public works. Designed to function at **Tier 0** (evidence hash of scanned deeds) through **Tier 3** (fully native digital registration). Branches: `property-registry`, `building-permits`, `zoning-compliance`, `utility-billing`, `public-works`, `council-resolutions`, `tax-assessments`. Consolidation gates enforce: permit-to-parcel linkage, zoning-to-permit validation, and tax assessment consistency. At Tier 0, the property branch contains only hashed deed scans — foggy but tamper-evident. At Tier 3, each parcel is a filament with full ownership history, encumbrances, and assessment trail visible in cross-section.

### 21.2.4 Example Template — Healthcare Facility (Patient & Compliance)

Hospital or clinic operations: patient encounters, prescriptions, lab results, insurance claims, regulatory compliance (HIPAA/GDPR), medical device maintenance, and staff credentialing. Branches: `patient-encounters`, `pharmacy`, `lab-diagnostics`, `insurance-claims`, `compliance-audits`, `device-maintenance`, `staff-credentials`, `research-trials`. Filament schema includes: `patientRef` (anonymized), `providerRef`, `diagnosisCodes[]`, `procedureCodes[]`, `evidenceRefs[]`. Consolidation gates enforce: claim-to-encounter matching, prescription-to-diagnosis linkage, and device-to-maintenance schedule compliance. Sensitive branches use branch-level encryption with access controlled by role-based sortition keys.

### 21.2.5 Example Template — Personal Life Management

For individual users managing their own files, finances, health, and goals — not a company. Branches: `finances` (bank accounts, receipts, subscriptions), `health` (appointments, medications, fitness), `documents` (personal files, contracts, warranties), `projects` (personal goals, hobbies), `calendar` (events, reminders), `contacts` (relationships, correspondence). This is the simplest tree — no counterparty reconciliation, no mass balance. Consolidation gates are optional (e.g., monthly budget check). Demonstrates that Relay scales down to one person managing their life, not just up to corporations.

### 21.2.6 Example Template — Construction Project

A single construction project from bid through closeout. Branches: `design` (drawings, specs, RFIs, submittals), `procurement` (material POs, subcontracts, deliveries), `schedule` (milestones, critical path, delays), `budget` (cost tracking, change orders, payments), `quality` (inspections, punch lists, NCRs), `safety` (incidents, training, compliance), `permits` (municipal, environmental, utility). Consolidation gates enforce: change-order-to-budget reconciliation, inspection-to-milestone linkage, and schedule-to-actual variance tracking. Drawing revisions are document-type filaments (`barkRenderMode: document`, `lAxisMapping: contentPosition`) where l represents the sheet set order and each revision is an inward commit.

### 21.2.7 Example Template — Venture / Investment Fund

Portfolio management for a fund. Branches: `deal-pipeline` (opportunities, due diligence, term sheets), `portfolio-companies` (one sub-branch per investment), `fund-accounting` (capital calls, distributions, NAV), `LP-relations` (reporting, K-1s, commitments), `compliance` (regulatory filings, AML/KYC), `board-seats` (meeting minutes, votes, resolutions). Filament lifecycle maps to deal stages: `OPEN` = active pipeline, `ACTIVE` = due diligence, `HOLD` = term sheet negotiation, `CLOSED` = invested or passed, `ABSORBED` = archived. Fund-level consolidation gates enforce: capital call vs. commitment balance, NAV reconciliation, and carried interest waterfall calculations.

### 21.2.8 Example Template — Education Institution (School / University)

Branches: `enrollment` (applications, admissions, registrations), `curriculum` (courses, syllabi, learning outcomes), `grades` (student performance, transcripts), `faculty` (hiring, evaluations, tenure), `research` (grants, publications, IP), `facilities` (maintenance, room scheduling), `finance` (tuition, financial aid, budgets), `compliance` (accreditation, Title IX, accessibility). Student filaments carry `enrollmentRef`, `programRef`, `courseRefs[]`. Grading uses consolidation gates that validate: grade-to-coursework evidence linkage, credit-to-requirement mapping, and degree-audit completion. Research branches use the composition inheritance model (§53) for grant allocation tracking across multi-PI projects.

### 21.2.9 Example Template — Media / Content Production

Film, music, podcast, or publishing production. Branches: `creative` (scripts, storyboards, drafts, compositions), `production` (schedules, shot lists, recording sessions, editing), `talent` (contracts, availability, deliverables), `distribution` (platform submissions, release schedules, royalties), `marketing` (campaigns, social media, press), `legal` (rights, licenses, clearances), `finance` (budget, revenue, residuals). Creative branches use `barkRenderMode: media` with `lAxisMapping: timelinePosition`. Each edit session is a commit; the cross-section shows production density over time. Royalty tracking uses the three-way match pattern from §21.2.1: contract → delivery → payment.

### 21.2.10 Example Template — Agricultural Operation (Farm / Ranch)

Branches: `fields` (one sub-branch per plot: planting, irrigation, fertilization, harvest), `livestock` (herds, health records, breeding, veterinary), `equipment` (maintenance, fuel, depreciation), `supply-chain` (seed/feed procurement, product sales, logistics), `compliance` (organic certification, water rights, environmental), `weather` (sensor data, forecasts — Tier 1 connector from weather service), `finance` (subsidies, crop insurance, operating costs). Mass balance (§53) tracks: seed input → yield output per field per season. Composition inheritance tracks: fertilizer chemical profile → soil composition → crop residue. Weather branch is typically Tier 1 (connector from NOAA or local sensors), demonstrating mixed-tier operation on a single tree.

### 21.2.11 Example Template — Legal Practice

Law firm or legal department. Branches: `matters` (one sub-branch per case/deal: events, filings, deadlines, correspondence), `clients` (engagement letters, billing, trust accounts), `court-filings` (complaints, motions, orders, judgments), `discovery` (document production, depositions, interrogatories), `billing` (time entries, invoices, collections, trust reconciliation), `compliance` (bar requirements, conflicts checks, CLE), `knowledge` (precedents, templates, research memos). Trust account reconciliation uses a strict consolidation gate enforcing: client deposits = disbursements + balance, with zero-tolerance deviation. Court deadlines are scheduled filaments (§51) that act as alarm clocks with escalating urgency rendering as timebox approaches.

### 21.2.12 Example Template — Supply Chain & Logistics Network

Multi-echelon supply chain across warehouses, carriers, and customs. Branches: `purchase-orders`, `inbound-logistics` (carrier bookings, tracking, customs clearance), `warehousing` (receipts, putaway, picking, cycle counts), `outbound-logistics` (shipments, last-mile delivery, POD), `inventory` (stock levels, reorder points, ABC classification), `customs-trade` (tariffs, duties, trade agreements, certificates of origin), `returns-reverse` (RMAs, refurbishment, disposal), `finance` (freight audit, duty payment, inventory valuation). Consolidation gates enforce: PO-to-receipt matching, shipment-to-POD reconciliation, and inventory-to-physical count variance. Customs branch demonstrates Tier 1 integration (connector from trade management system) coexisting with native warehouse operations (Tier 3). The adoption tier difference is visible: customs filaments carry slight fog while warehouse filaments are clear. See §77 for the full mineral-to-shelf product traceability module.

### 21.2.13 Example Template — Relay HQ (Organizational Operations & Subsidiary Governance)

The template that Relay uses to run itself. Tree Zero (`tree.org.relay-hq`) and every subsidiary tree in the Relay organizational forest (§93) use this template. It is the most complete template in the system because Relay must be fully transparent about its own operations — every cost, every decision, every mission, every hire, every server bill, every line of code.

```json
{
  "TreeTemplate": {
    "templateId": "template.relay.hq.v1",
    "name": "Relay HQ (Organizational Operations)",
    "domain": "relay-operations",
    "sinkingMode": "earth-time",
    "twistPeriod": "week",
    "barkRenderMode": "mixed",
    "lAxisMapping": "calendar-time",
    "cellLODRenderer": "adaptive",
    "branches": [
      {
        "id": "dev-architecture",
        "name": "Architecture",
        "filamentKind": "structural",
        "filamentSchema": {
          "columns": [
            { "name": "documentId", "domain": "identity", "type": "string" },
            { "name": "title", "domain": "identity", "type": "string" },
            { "name": "author", "domain": "counterparty", "type": "reference" },
            { "name": "committedAt", "domain": "time", "type": "datetime" },
            { "name": "contractCount", "domain": "magnitude", "type": "number" },
            { "name": "documentHash", "domain": "evidence", "type": "hash" },
            { "name": "diffFromPrevious", "domain": "evidence", "type": "attachment" }
          ],
          "magnitudeColumn": "contractCount",
          "counterpartyColumn": "author"
        },
        "classificationLayer": "FILAMENT",
        "evidenceRules": [
          { "description": "Document hash at commit time", "requiredCount": 1, "sourceType": "system" }
        ],
        "expectedResolutionDays": null,
        "sub": [
          { "id": "master-plan", "name": "Master Build Plan" },
          { "id": "civilization-templates", "name": "Civilization Template Library" },
          { "id": "blueprints", "name": "Blueprints & Design Documents" }
        ]
      },
      {
        "id": "dev-codebase",
        "name": "Codebase",
        "filamentKind": "structural",
        "filamentSchema": {
          "columns": [
            { "name": "commitHash", "domain": "identity", "type": "string" },
            { "name": "author", "domain": "counterparty", "type": "reference" },
            { "name": "committedAt", "domain": "time", "type": "datetime" },
            { "name": "linesChanged", "domain": "magnitude", "type": "number" },
            { "name": "filesChanged", "domain": "magnitude", "type": "number" },
            { "name": "commitMessage", "domain": "evidence", "type": "string" },
            { "name": "diffHash", "domain": "evidence", "type": "hash" }
          ],
          "magnitudeColumn": "linesChanged",
          "counterpartyColumn": "author"
        },
        "classificationLayer": "FILAMENT",
        "evidenceRules": [
          { "description": "Git commit hash", "requiredCount": 1, "sourceType": "system" }
        ],
        "sub": []
      },
      {
        "id": "dev-conversations",
        "name": "Design Conversations",
        "filamentKind": "finite",
        "filamentSchema": {
          "columns": [
            { "name": "sessionId", "domain": "identity", "type": "string" },
            { "name": "participants", "domain": "counterparty", "type": "reference[]" },
            { "name": "startedAt", "domain": "time", "type": "datetime" },
            { "name": "messageCount", "domain": "magnitude", "type": "number" },
            { "name": "transcript", "domain": "evidence", "type": "attachment" },
            { "name": "decisionsExtracted", "domain": "evidence", "type": "reference[]" }
          ],
          "magnitudeColumn": "messageCount",
          "counterpartyColumn": "participants"
        },
        "classificationLayer": "FILAMENT",
        "evidenceRules": [
          { "description": "Full transcript hash", "requiredCount": 1, "sourceType": "system" }
        ],
        "sub": []
      },
      {
        "id": "dev-media",
        "name": "Media Archive",
        "filamentKind": "finite",
        "filamentSchema": {
          "columns": [
            { "name": "mediaId", "domain": "identity", "type": "string" },
            { "name": "mediaType", "domain": "identity", "type": "string" },
            { "name": "creator", "domain": "counterparty", "type": "reference" },
            { "name": "capturedAt", "domain": "time", "type": "datetime" },
            { "name": "durationSec", "domain": "magnitude", "type": "number" },
            { "name": "fileSizeBytes", "domain": "magnitude", "type": "number" },
            { "name": "mediaHash", "domain": "evidence", "type": "hash" }
          ],
          "magnitudeColumn": "fileSizeBytes",
          "counterpartyColumn": "creator"
        },
        "classificationLayer": "FILAMENT",
        "sub": []
      },
      {
        "id": "treasury",
        "name": "Treasury",
        "filamentKind": "structural",
        "filamentSchema": {
          "columns": [
            { "name": "transactionId", "domain": "identity", "type": "string" },
            { "name": "category", "domain": "identity", "type": "string" },
            { "name": "counterparty", "domain": "counterparty", "type": "reference" },
            { "name": "transactionDate", "domain": "time", "type": "date" },
            { "name": "amount", "domain": "magnitude", "type": "number" },
            { "name": "currency", "domain": "magnitude", "type": "string" },
            { "name": "direction", "domain": "lifecycle", "type": "string" },
            { "name": "invoice", "domain": "evidence", "type": "attachment" },
            { "name": "receipt", "domain": "evidence", "type": "attachment" }
          ],
          "magnitudeColumn": "amount",
          "counterpartyColumn": "counterparty"
        },
        "classificationLayer": "FILAMENT",
        "evidenceRules": [
          { "description": "Invoice or receipt", "requiredCount": 1, "sourceType": "document" },
          { "description": "Bank statement reconciliation", "requiredCount": 1, "sourceType": "external" }
        ],
        "sub": [
          { "id": "revenue", "name": "Revenue (ISR, Resource, Downloads)" },
          { "id": "staff", "name": "Staff Compensation" },
          { "id": "compute", "name": "Compute & Infrastructure" },
          { "id": "ai-api", "name": "AI API Costs" },
          { "id": "facilities", "name": "Facilities & Leases" },
          { "id": "equipment", "name": "Equipment & Capital" },
          { "id": "legal", "name": "Legal & Compliance" },
          { "id": "rd", "name": "Research & Development" }
        ]
      },
      {
        "id": "missions",
        "name": "Missions",
        "filamentKind": "structural",
        "filamentSchema": {
          "columns": [
            { "name": "missionId", "domain": "identity", "type": "string" },
            { "name": "title", "domain": "identity", "type": "string" },
            { "name": "owner", "domain": "counterparty", "type": "reference" },
            { "name": "createdAt", "domain": "time", "type": "datetime" },
            { "name": "objectiveCount", "domain": "magnitude", "type": "number" },
            { "name": "completedCount", "domain": "magnitude", "type": "number" },
            { "name": "progress", "domain": "magnitude", "type": "number" },
            { "name": "confidenceAvg", "domain": "evidence", "type": "number" }
          ],
          "magnitudeColumn": "objectiveCount",
          "counterpartyColumn": "owner"
        },
        "classificationLayer": "FILAMENT",
        "sub": []
      },
      {
        "id": "governance",
        "name": "Governance & Parameters",
        "filamentKind": "structural",
        "filamentSchema": {
          "columns": [
            { "name": "parameterId", "domain": "identity", "type": "string" },
            { "name": "proposer", "domain": "counterparty", "type": "reference" },
            { "name": "proposedAt", "domain": "time", "type": "datetime" },
            { "name": "voteCount", "domain": "magnitude", "type": "number" },
            { "name": "outcome", "domain": "lifecycle", "type": "string" },
            { "name": "ballotHash", "domain": "evidence", "type": "hash" }
          ],
          "magnitudeColumn": "voteCount",
          "counterpartyColumn": "proposer"
        },
        "classificationLayer": "FILAMENT",
        "sub": [
          { "id": "frozen-contracts", "name": "Frozen Contract Registry" },
          { "id": "parameter-votes", "name": "Active Parameter Votes" },
          { "id": "founder-levers", "name": "Founder Bootstrap Levers" }
        ]
      },
      {
        "id": "subsidiaries",
        "name": "Subsidiary Links",
        "filamentKind": "structural",
        "filamentSchema": {
          "columns": [
            { "name": "subsidiaryTreeId", "domain": "identity", "type": "string" },
            { "name": "name", "domain": "identity", "type": "string" },
            { "name": "createdAt", "domain": "time", "type": "datetime" },
            { "name": "initialBudget", "domain": "magnitude", "type": "number" },
            { "name": "missionStatement", "domain": "evidence", "type": "string" },
            { "name": "charterHash", "domain": "evidence", "type": "hash" }
          ],
          "magnitudeColumn": "initialBudget",
          "counterpartyColumn": null
        },
        "classificationLayer": "FILAMENT",
        "sub": [
          { "id": "relay-robotics", "name": "Relay Robotics" },
          { "id": "relay-education", "name": "Relay Education" },
          { "id": "relay-aerospace", "name": "Relay Aerospace" },
          { "id": "relay-regions", "name": "Regional Offices" }
        ]
      },
      {
        "id": "goals-global",
        "name": "Civilization Goals",
        "filamentKind": "structural",
        "filamentSchema": {
          "columns": [
            { "name": "goalId", "domain": "identity", "type": "string" },
            { "name": "tier", "domain": "identity", "type": "string" },
            { "name": "title", "domain": "identity", "type": "string" },
            { "name": "metric", "domain": "magnitude", "type": "string" },
            { "name": "threshold", "domain": "magnitude", "type": "number" },
            { "name": "currentValue", "domain": "magnitude", "type": "number" },
            { "name": "progress", "domain": "magnitude", "type": "number" },
            { "name": "evidenceSources", "domain": "evidence", "type": "reference[]" }
          ],
          "magnitudeColumn": "currentValue",
          "counterpartyColumn": null
        },
        "classificationLayer": "FILAMENT",
        "sub": []
      }
    ],
    "consolidationGate": {
      "type": "financial-balance",
      "rules": {
        "conservationCheck": "revenue >= expenses OR deficit explicitly budgeted",
        "tolerancePct": 0,
        "magnitudeTypeField": "direction",
        "validTypes": ["revenue", "expense", "transfer", "allocation"],
        "unitField": "currency",
        "requiredUnit": null
      }
    },
    "defaultAttributeBindings": {
      "slabColor": "netRevenue",
      "slabOpacity": "evidenceCompleteness",
      "slabThickness": "transactionVolume",
      "slabFirmness": "auditConfidence",
      "branchRadius": "cumulativeBudget",
      "twistRate": "weeklyActivity",
      "filamentRadial": "lifecycleState",
      "filamentAngular": "counterpartyDirection"
    },
    "subsidiaryTemplateRef": "self",
    "classificationMatrix": {
      "FILAMENT_ALWAYS": ["TRANSFER_*", "GOVERNANCE_VOTE", "MISSION_OBJECTIVE", "CONTRACT_AMENDMENT", "SUBSIDIARY_CHARTER", "BUDGET_ALLOCATION", "EXPENSE_REPORT", "REVENUE_RECEIPT", "FROZEN_CONTRACT"],
      "LEAF_DEFAULT": ["COMMENT", "DRAFT", "MEETING_NOTE", "DISCUSSION_THREAD"],
      "SAP_DEFAULT": ["BUILD_STATUS", "DEPLOY_STATUS", "SERVER_HEALTH", "ACTIVE_USERS_COUNT"]
    }
  }
}
```

**Key differences from other templates:**
- `subsidiaryTemplateRef: "self"` — subsidiaries clone this template for their own tree, inheriting the same branch structure (with `subsidiaries` branch empty — they don't recurse).
- `classificationMatrix` — the Relay HQ template is the first to embed the §82.5.2 classification matrix directly, since every cost, decision, and mission must be wood (never ephemeral).
- `consolidationGate` enforces revenue vs. expense balance — any deficit must be explicitly budgeted (allocated from treasury or founder bootstrap), not silent.
- `goals-global` branch exists only on Tree Zero — subsidiary clones omit it.
- The `missions` branch tracks §93.3 mission-gated cost reduction: operational budgets don't decrease until missions hit 100% completion at > 0.8 confidence.
- `dev-*` branches carry the entire development history of the system itself (§80), making Relay the only software project whose build history IS its product demonstration.

### 21.3 Configurable Attribute Bindings

All visual attributes are dynamically linkable to metrics — like After Effects expression linking:

- **Per-template defaults**: The P2P template defines default bindings.
- **User overrides**: Any user can re-bind any attribute to any metric.

Bindable visual attributes:
- Trunk height/prominence (default: attention score)
- Branch radius (default: normalized KPI sum)
- Helical twist rate (default: activity/time)
- Slab thickness (default: commit density)
- Slab color (default: magnitude, warm=positive, cool=negative)
- Slab opacity (default: confidence, automatic evidence ratio)
- Slab firmness (default: wilt factor)
- Filament radial position (default: lifecycle state)
- Filament angular position (default: approach direction)
- Filament bark length (default: time alive)
- Root cube density (default: absorption rate)
- Projection branch color: FIXED light blue (non-configurable)

Bindable auditory attributes (sonification):
- Volume (default: attention rate — loud = many eyes, quiet = ignored)
- Pitch (default: acceleration — rising pitch = heating up, falling = cooling)
- Timbre (default: confidence — clear tone = high confidence, distorted = low/uncertain)
- Rhythm (default: branch cadence / helical twist period — faster rhythm = tighter cadence)
- Spatial audio position (default: 3D world location of source — sound comes FROM the event)

Sonification examples:
- Thunder: a lightning event (§23.2) — sudden high-impact filament cascading across many trees
- Rising strings: a discussion going viral (engagement rate climbing)
- Low rumble: a storm building (regional acceleration increasing)
- Settling chord: a region reaching consensus (confidence stabilizing at high values)
- Silence: a dead zone (no engagement, no attention, no activity)

Sound is an output channel, not a mechanic. The tree physics are identical with or without sound. Sonification is an accessibility and immersion binding — deaf users see the same information visually. All auditory bindings follow the same per-template-default + user-override pattern as visual bindings.

**Prerequisites:** None for base (auditory attribute bindings: volume, pitch, timbre, rhythm, spatial position). Expands with: AR interaction modules → AR-rendered sound effects in video presence. Spell/combat modules → arena atmosphere (thunder, music, audience energy), spell sound effects, combat audio.

### 21.4 Unified Color System

All colors in Relay serve a diagnostic purpose. Nothing is cosmetic. The palette is organized into non-overlapping channels so that any visual element communicates its nature at a glance.

**Source Identity (what created this):**

| Element | Color | Rationale |
|---------|-------|-----------|
| Truth branches/filaments | Natural earth tones (bark brown, heartwood, leaf green) | Organic material — this is real, it grew from events |
| Human projection branches | Light blue | Cool analytical tone — derived from truth, not truth itself |
| SCV/AI projection branches | Lavender / light violet | Clearly "projection" (cool tone) but distinguishable from human blue at a glance — you always know if a human or AI built this analysis |
| Notes (pre-filament) | Translucent white/cream, alpha 0.4 | Ephemeral, not yet committed to any identity |

**Magnitude (what is the value direction):**

| Condition | Color | Channel |
|-----------|-------|---------|
| Net positive magnitude | Warm palette (gold -> amber -> orange) | Slab fill color |
| Net negative magnitude | Cool palette (teal -> slate blue -> indigo) | Slab fill color |
| Neutral / zero magnitude | Desaturated grey | Slab fill color |

**Integrity (how trustworthy):**

| Condition | Visual | Channel |
|-----------|--------|---------|
| High confidence (evidence complete) | Full opacity | Slab opacity (0.0-1.0) |
| Low confidence (evidence missing) | Transparent / faded | Slab opacity |
| Scar (revert) | Burnt amber / rust overlay | Permanent bark mark |
| Migration scar | Same burnt amber + directional indicator | Links to successor filament |

**Activity and Attention (what is happening now):**

| Condition | Color | Where |
|-----------|-------|-------|
| High acceleration (hot) | Hot red -> orange | Globe trunk glow, weather heat |
| Moderate activity | Warm yellow | Globe trunk glow |
| Low/stable activity | Cool blue | Globe trunk glow |
| Zero activity | No glow | Globe trunk |
| Attention concentration | Bright white glow intensity | Trunk/branch glow proportional to presence count |

**Weather overlay (regional/global projections):**

| Phenomenon | Visual |
|-----------|--------|
| Fog (low confidence region) | Desaturated grey translucent overlay |
| Storm (high acceleration region) | Rapid color temperature shifts, flickering glow |
| Lightning (cascade event) | Bright white flash along evidence twig paths |
| Clear skies (healthy region) | No overlay — natural colors visible |
| Pressure front (stable meets unstable) | Visible gradient boundary between regions |

**Status indicators (non-color, overlaid):**

| Indicator | Visual |
|-----------|--------|
| Recategorization pending | Pulsing outline (not fill) around filament |
| Settlement window active | Progress bar overlay |
| Twig (emergent outlier) | No special color — same as filament, the geometry IS the indicator |

**Frozen color rules:**
- Human projections are ALWAYS light blue. SCV projections are ALWAYS lavender. These are non-configurable (frozen contract extension). You must always know at a glance whether a human or AI built a projection.
- Truth is ALWAYS natural/organic palette. Never blue, never violet.
- Magnitude color channel (warm/cool) and integrity channel (opacity) are independent — a slab can be warm and transparent (positive value but low confidence) or cool and opaque (negative value but well-evidenced).

---

## 22. Fractal Scaling

> *"What is the pattern that connects the crab to the lobster, the orchid to the primrose, and all four of them to me?"* — Gregory Bateson

### 22.1 The Fractal Rule

A trunk at one level is a branch at the next level up. The geometry is identical at every scale. Only the template changes.

- Neighborhood trunk -> becomes a branch on the city tree
- City trunk -> becomes a branch on the state tree
- State trunk -> becomes a branch on the country tree
- Company trunk -> becomes a branch on the industry tree

### 22.2 Cross-Level Interaction

A pothole (neighborhood filament) needs city funding to resolve. This is a cross-trunk reference:
- The neighborhood filament links to a city-level resource allocation filament
- Boundary crossing requires disclosure + consent
- The pothole's completeness depends on the city funding filament's status
- The twig is visible at both neighborhood AND city level

### 22.3 Attention Flows Upward

Many unresolved potholes -> residents vote/complain -> attention rises -> neighborhood trunk becomes more prominent -> visible at city level -> drives action. Same mechanism at every scale.

---

## 23. Weather and Wind — Emergent Atmospheric Analytics

> *"Everybody talks about the weather, but nobody does anything about it."* — Mark Twain

Weather in Relay is not a mechanic. It is an emergent vocabulary for describing aggregate tree behavior at regional and global scale. All weather phenomena are computed projections over existing branch physics. None create new filaments or commits.

### 23.1 Wind

Wind is not a computed overlay. Wind is the observed pattern of branch lean over time (§3.15). When you replay a time range and watch branches tilt timebox by timebox, the aggregate motion you see IS the wind. There is no separate wind vector computation at the regional level — wind is what happens when many branches lean in correlated directions during the same period.

**Company-level wind:** All branches on a company tree leaning in the same angular direction during replay — counterparties from that quadrant are causing correlated effects (demand surge, confidence deficits, payment delays). The company is experiencing directional pressure.

**Regional wind:** Many trees in a geographic region experiencing correlated branch lean during replay. A new regulation, an economic shift, a seasonal demand pattern. At CITY LOD, all trees lean the same way.

**Global wind currents:** Macro-scale correlated branch lean visible at GLOBE LOD during replay. A commodity price shift causes all manufacturing trees to lean simultaneously. A pandemic causes healthcare trees to grow while hospitality trees wilt. These correlated patterns are global wind.

Wind is always derived from lean (Equation 3, §3.19), which is derived from filament θ weights (counterparty approach direction). It is never a separate input, never a decoration, and never computed independently of branch physics.

### 23.2 Weather Vocabulary

All computed from existing filament data:

| Phenomenon | Source Data | Visual |
|-----------|------------|--------|
| **Wind** | Observed pattern of branch lean over time (§3.15, §23.1) — not a separate computation | Trees leaning in correlated direction during replay |
| **Heat** | Acceleration (§0.2) at regional scale | Warm/hot color temperature on globe surface |
| **Storms** | Simultaneous high-acceleration across many trees | Rapid flickering activity, many trunks rising at once |
| **Lightning** | Single high-impact filament causing cascade across many trees | Sudden bright evidence twigs spanning many trees simultaneously |
| **Fog** | Regional low-confidence zone (many low-opacity slabs) | Translucent, indistinct region — data exists but poorly evidenced |
| **Clear skies** | Stable, high-confidence region (all trees firm, high opacity) | Crisp, visible, navigable region |
| **Pressure systems** | §10 pressure physics at regional scale | High-pressure = firm region, low-pressure = widespread confidence deficits |
| **Weather fronts** | Boundaries where stable regions meet unstable ones | Visible edge between firm/clear and wilted/foggy zones |

### 23.3 Weather Forecast

SCV AI agents (§16) act as meteorologists:

1. Read current tree states across a region
2. Identify trends: wind direction shifting, pressure dropping, heat building
3. Compute rate of change and project forward
4. Generate a **light blue projection branch** showing the forecast: "Storm likely in Tel Aviv tech sector within 2 weeks based on accelerating confidence deficits across 15 companies"
5. The forecast projection has inspectable decision nodes — anyone can see what data the AI is reading and challenge its reasoning

Forecasts are projections. They are never truth. They carry their own confidence score based on the quality of the underlying evidence patterns.

### 23.4 Weather Is Fractal

The same weather vocabulary applies at every scale:
- Company weather: internal branch patterns
- Neighborhood weather: local service tree patterns
- City weather: aggregated neighborhood patterns
- Country weather: aggregated city patterns
- Global weather: planetary-scale patterns

A company experiencing an internal storm (rapid activity on all branches) is like a single cloud. Many companies storming simultaneously is a regional weather system. The vocabulary scales with the LOD.

---

## 24. Search in 3D

### 24.1 Two Modes

**Visual navigation**: Zoom, pan, follow branches, read bark. Spatial cognition for exploration and pattern recognition.

**Text search**: Type a query. Results appear as HIGHLIGHTED FILAMENTS on the tree — you see WHERE in the 3D structure each result lives. Which branch, which timebox, what lifecycle state, what neighbors. Search carries spatial context.

### 24.2 Search as Diagnosis

A search for "all overdue invoices over $50K" highlights twigs across all branches. If they cluster on one branch: systemic problem. If scattered: isolated issues. The 3D context IS the analysis.

---

## 25. 2D/Headless Parity

### 25.1 Object Equivalence

Every 3D object has a 2D equivalent with a stable canonical ID (same in both views). The zoom-to-flat transition at CELL LOD IS the 2D view — it's not a separate interface, it's the same interface at a different LOD.

### 25.2 Headless Mode

The system runs without 3D rendering, producing identical data outputs. Route ingest, match rebuild, summary formulas, KPI bindings, commits — all produce byte-identical results in headless and 3D modes.

### 25.3 Import/Export

Any Relay state is exportable to flat files (CSV/JSON) and re-importable through routes. Organizations unwilling to adopt 3D can use Relay as a data-flow coordination engine.

---

## 26. Frozen Contracts

These rules are non-negotiable. They cannot be overridden by templates, governance, or user preference.

1. **Append-only**: Facts are never modified. Only new commits.
2. **Visible scars**: Reverts create new commits, not deletions.
3. **Double-entry**: Every material commit carries balanced TransferPacket + ResponsibilityPacket.
4. **Filament = row**: One atomic event = one row = one filament. Not a cell, not a sheet.
5. **Six domains required**: Every filament carries identity, counterparty, time, magnitude, evidence, lifecycle.
6. **Bark = spreadsheet**: The sheet wraps the branch. It is not a separate object.
7. **Gravity = earth time**: Universal sinking. Not configurable per branch (only per template's sinking mode).
8. **Twigs are emergent**: No special twig detection. The geometry produces them naturally.
9. **Confidence is automatic**: evidence_present / evidence_required. No human override of the ratio.
10. **Human projections are light blue**: Always. Even when promoted. Never confused with truth. SCV/AI projections are lavender (see contract #27).
11. **Projection branches are terminal**: They do not flow to trunk or roots. They are not balancing factors.
12. **SCVs do not execute**: They propose. Humans decide.
13. **Presence defaults to Tier 0**: Anonymous until explicit consent escalates.
14. **Nothing orbits**: Everything flows from bark inward to root. No objects circling other objects.
15. **Deterministic replay**: Same inputs always produce same outputs.
16. **Conservation**: Material state transfers must net to zero per unit type.
17. **Notes expire**: Unengaged Notes fade per TTL. No permanent clutter.
18. **Merkle roots cross-anchor**: System tree and user tree root archives are cross-verifiable.
19. **Dual confidence sovereignty**: Organizational confidence (template-driven opacity) and global confidence (vote-ranked score) never override each other. Both render independently.
20. **Votes cannot override templates**: Community votes affect global ranking and can trigger governance proposals, but cannot directly modify a template's evidence rules or organizational confidence calculations.
21. **Recategorization is migration**: Moving a filament between branches requires a migration commit (§4.6). Direct `branchId` mutation is forbidden. Original filament remains as historical truth.
22. **Vote eligibility gate**: Tier 0 anonymous accounts cannot vote. Minimum Tier 1 identity + engagement history required.
23. **Vote decay, action permanence**: Votes decay over time. But executed migration commits and governance actions are permanent append-only records regardless of subsequent vote decay.
24. **Pressure is emergent**: Pressure (structural integrity forces) is computed from confidence deficits across timebox slabs. It is never an independent variable, never manually assigned, never decorated. The wilt physics produce it.
25. **Parameters are voted medians**: Operational parameters are weighted medians of community votes, never hardcoded constants. Exception: frozen contracts themselves are not votable.
26. **Filters are client-side**: Filter tolerances are view-state rendering masks. They never mutate truth, never create commits, never affect what other users see. Branch physics are computed from ALL filaments regardless of any user's filter settings.
27. **SCV projections are lavender**: AI-generated projection branches are always lavender/light violet — distinguishable from human projection branches (light blue) at a glance. You must always know whether a human or AI built a projection. Non-configurable.

---

## 27. Current Build Status

### 27.1 Proven Phases — Planar Era Baseline (All PASS with Proof Artifacts)

The following phases were completed and proven under the **planar rendering model** before this architectural revision. They represent the functional baseline: commit semantics, data pipelines, state management, replay, crypto, and presence all work. The geometry model changes (bark-as-cylinder, filament-as-row) will be applied as an evolution of the existing primitive pipeline.

**Important:** These proofs were verified against planar geometry. BARK-CYLINDER-1 sub-phase BC1-f (regression gate) must re-validate all rendering-dependent proofs against the new cylindrical model. Non-rendering proofs (replay, crypto, headless, presence logic) are expected to pass unchanged. Rendering-dependent proofs (scaffold, megasheet, lifeline, camera ride, flyby) may require updated visual baselines.

**Data + Logic (geometry-independent, expected to pass unchanged):**
- A0-A0.4: Engine gates, formula engine, timebox filament length, spine aggregation
- B1-B4: P2P fact sheets, match sheets, summary sheets, KPI branch mapping
- C0: Route engine (config-driven data flow, provenance, mock streams)
- W0-W2: Material work-mode chain, PROPOSE/COMMIT
- D0: Scale and stress (deterministic FPS, policy split)
- D1: Inter-branch aggregation (branch -> trunk bands)
- HEADLESS-0: Headless parity (byte-identical data, no rendering)
- E3-REPLAY-1: Deterministic replay (golden hashes over data, not geometry)
- E1-CRYPTO-1: Merkle chain integrity (operates on commits, not positions)
- AC0-CONTAINER-1: Accounting container (data layer)
- PRESENCE-STREAM-1: Presence bus (logic layer)
- PRESENCE-COMMIT-BOUNDARY-1: Call summary boundary (logic layer)
- V93-DATA-SALVAGE-1, V93-TRUNK-SEED-BRIDGE-1, V93-VOTE-AGG-BRIDGE-1: Migration bridge (data layer)

**Rendering + Visual (must be re-validated after BARK-CYLINDER-1):**
- Phase 0-2.1: Cesium world boot, topology, views, boundaries, primitives migration
- D-Lens-0: Focus frame (camera + dimming + breadcrumb)
- UX-1.1-1.3: Universal Object Contract, Capability Buds, Inspector Context
- Globe Restores: GLOBE-RESTORE-0 through 4, 3A, USP-1, HUD-1, BOUNDARY-A1, VOTE-A2, RESTORE-PARITY
- VIS-TREE-SCAFFOLD-1, HEIGHT-BAND-1, VIS-MEGASHEET-1: Visual grammar
- CAM0.4.2-FILAMENT-RIDE-V1: Camera ride (planar path -> must adapt to cylindrical path)
- PRESENCE-RENDER-1: Presence rendering (billboard placement relative to surface)
- DEMO-FLYBY-POLISH-1: Flyby choreography (camera path relative to branch geometry)
- VIS-LIFELINE-AMBIENT-1: Lifeline rendering (path through branch geometry)
- HUD-CONSOLIDATION-1, NODE-RING-RENDER-1, BASIN-RING-1: Visual elements
- COMPANY-TEMPLATE-FLOW-1, VOTE-COMMIT-PERSISTENCE-1: UI/visual components
- FILAMENT-LIFECYCLE-1, FILAMENT-DISCLOSURE-1: Filament rendering aspects
- LAUNCH-FIX-1, SCOPE-COHERENCE-1, ATTENTION-CONFIDENCE-1: Visual gates

### 27.2 Build Order (New Architecture Implementation)

The following sequence implements the bark-cylinder model on top of the proven foundation. Each slice follows the established process: SPEC -> IMPLEMENT -> PROOF -> COMMIT -> INDEX.

**Tier 1 — Core Geometry (Buildable in Sequence)**

| # | Slice | Description | Depends On | Key Sections |
|---|-------|-------------|------------|--------------|
| 1 | **BARK-CYLINDER-1** | Refactor branch rendering from flat sheet planes to cylindrical bark geometry. Filament rows wrap the branch surface. Basic zoom-to-flat at CELL LOD. | Proven foundation | §3.1-3.3, §32 |
| 2 | **FILAMENT-ROW-1** | Revise filament identity from cell-level to row-level. `originCellRef` -> `originRowRef`. Magnitude from designated column. Six universal domains enforced. | BARK-CYLINDER-1 | §4, §0.3, §31 |
| 3 | **GRAVITY-SINK-1** | Implement gravitational sinking along branch length. Earth time drives downward motion. Template-configurable sinking mode (earth-time, milestone, none). | FILAMENT-ROW-1 | §14, §3.11 |
| 4 | **TREE-RING-1** | Implement cross-section dual encoding. Radial = lifecycle state (bark to center). Angular = approach direction (counterparty vector). | BARK-CYLINDER-1 | §3.4 |
| 5 | **HELIX-1** | Implement helical twist along branch length. Configurable period per template (day/week/sprint/quarter). Filaments follow the spiral grain. | BARK-CYLINDER-1 | §3.5 |
| 6 | **SLAB-REVISION-1** | Revise timebox slabs: magnitude as color (warm/cool palette, not wall extrusion), confidence as automatic evidence ratio (opacity), firmness as wilt input. | TREE-RING-1 | §3.6 |

**Tier 2 — Emergent Physics**

| # | Slice | Description | Depends On | Key Sections |
|---|-------|-------------|------------|--------------|
| 7 | **TWIG-1** | Implement twig emergence from unclosed filaments at old timeboxes. Emergent from (l, r, theta) coordinates — no special detection code. | GRAVITY-SINK-1, TREE-RING-1 | §3.10 |
| 8 | **WILT-1** | Implement wilt model with emergent branch deformation. Adjacent wilted slabs = branch droops. Collision physics: firm slabs resist camera, wilted slabs yield. Camera damping through uncertain regions. Pressure physics (§10) emerges from heterogeneous slab firmness. | SLAB-REVISION-1 | §3.7, §3.8, §10, §29.4 |
| 9 | **CONFIDENCE-1** | Implement automatic confidence physics. Template-defined evidence rules. `evidence_present / evidence_required`. Cross-company evidence references. Policy commits for rule changes. | SLAB-REVISION-1, FILAMENT-ROW-1 | §9 |
| 10 | **SCAR-1** | Implement visible scar rendering for reverts. Scars are new commits with permanent bark marks. Scar confidence tracked independently. | FILAMENT-ROW-1 | §4.5 |

**Tier 3 — Analysis and Projection**

| # | Slice | Description | Depends On | Key Sections |
|---|-------|-------------|------------|--------------|
| 11 | **PROJECTION-1** | Implement projection branches (light blue). Input funnel, decision nodes (inspectable), alignment zone, Excel terminus, outlier twigs. Promotion via governance. No trunk/root flow. Replayable. | BARK-CYLINDER-1, FILAMENT-ROW-1 | §6 |
| 12 | **ATTRIBUTE-BIND-1** | Implement configurable attribute binding system. Per-template defaults + user overrides. All visual attributes dynamically linkable to any metric (After Effects style). | SLAB-REVISION-1, HELIX-1 | §21.3 |
| 13 | **TIME-SCRUB-1** | Implement time window selector and temporal rendering filter. Choose any window (year to 5 minutes), tree renders only active filaments. Built on E3 replay engine. | GRAVITY-SINK-1 | §15 |
| 14 | **CONSOLIDATION-1** | Implement trunk consolidation gate. Cross-branch reconciliation per template rules (financial balance, completeness, peer review). Unreconciled content held at trunk. | GRAVITY-SINK-1, CONFIDENCE-1 | §2.2, §30 |
| 14b | **CROSS-SECTION-1** | Implement cross-section inspection mode. Camera perpendicular rotation, concentric ring rendering, radial time scrubber, slab expansion to disc panel, filament drill-down from slab to ribbon. Read-only lens — no data mutation. LOD depth (§33.4). | SLAB-REVISION-1, TREE-RING-1, SCAR-1 | §3.13, §3.14, §33.4 |
| 14c | **ORGANIC-RENDER-1** | Implement organic growth variation: slab thickness by theta (circumferential non-uniformity), Perlin noise on ring surfaces, bark ridge deformation at schema version boundaries, scar crack radial propagation and adjacent surface warping. Rendering-only — no data changes. | CROSS-SECTION-1 | §3.14, §4.5 |
| 14d | **WIND-1** | Implement branch lean physics: per-branch lean vector computation from filament θ weights at timebox close, branch lean rendering (small lateral offset in branch path frames, capped 5-10°), explainability click panel (top counterparties + filaments). Branch layout system (§3.18): layoutKey hashing, ring assignment, collision-aware routing, LOD bundle merge. Wind observed through replay, not separate arrows. | SLAB-REVISION-1, TREE-RING-1 | §3.15, §3.18 |
| 14e | **WEATHER-1** | Implement weather overlays: TimeboxAggregate computation (heat, fog, storm, lightning), TileAggregate rollup for REGION/GLOBE LOD, heat color tiles, fog haze layer, storm flicker, lightning cascade flash primitives. All deterministic, all toggleable. | WIND-1, CONFIDENCE-1 | §3.16, §3.17 |
| 14f | **SCHEDULE-1** | Implement scheduling engine: `SCHEDULED` lifecycle state, future l-position anchoring (no gravity), translucent tip rendering with proximity-based solidification, automatic `SCHEDULED→OPEN` transition at time threshold, notification trigger system, recurring series support (`recurringSeriesId`), cancellation as scar-like commit, event branch spawning for multi-day events, venue branch persistence, cross-section tip buds. Template-driven notification timing and mandatory field rules. | FILAMENT-ROW-1, SLAB-REVISION-1 | §5b |

**Tier 4 — Social and Identity**

| # | Slice | Description | Depends On | Key Sections |
|---|-------|-------------|------------|--------------|
| 15 | **NOTE-1** | Implement unified Note system (DraftNode + sticky note). TTL, postable on any surface, conversion to filament on multi-party engagement, ephemeral rendering. | BARK-CYLINDER-1 | §5 |
| 16 | **SOCIAL-1** | Implement social mechanics. Note -> filament conversion. Conversation growth (each response = commit, filament extends by l). Evidence propagation. Voting as deliberate stance distinct from commenting. Buried resurrection. | NOTE-1, CONFIDENCE-1 | §7 |
| 17 | **USER-TREE-1** | Implement user tree with responsibility mirror. Same tree mechanics. CommitId linking TransferPacket + ResponsibilityPacket. Privacy tiers (Tier 0/1/2). Reputation through shape, not scores. Stigmergic self-assignment (§13). | FILAMENT-ROW-1, CONFIDENCE-1 | §8, §13, §30.2 |
| 18 | **GLOBE-METRICS-1** | Implement three globe metrics (engagement rate, attention rate, acceleration/heat). Trunk prominence rendering (height=votes, glow=attention, color=heat). | SOCIAL-1, USER-TREE-1 | §0.2, §1.2 |

**Tier 5 — Navigation and Spatial**

| # | Slice | Description | Depends On | Key Sections |
|---|-------|-------------|------------|--------------|
| 19 | **SEARCH-3D-1** | Implement 3D spatial search with highlighted results on tree. Results show WHERE in structure (branch, timebox, lifecycle). Pattern detection from clustering. | BARK-CYLINDER-1, FILAMENT-ROW-1 | §23 |
| 20 | **FLOW-1** | Implement Flow Channels as recorded camera paths with semantic steps. Flows are filaments on training/procedures branch. Governed, versioned, replayable. | BARK-CYLINDER-1 | §18 |
| 21 | **PROXIMITY-1** | Implement proximity channels. BLE/Wi-Fi detection, approach angle measurement, anti-spoof layered constraints. Act-only-when-present rule. | NOTE-1, FILAMENT-ROW-1 | §28 |
| 22 | **FRACTAL-1** | Implement fractal scaling. Trunk-at-one-level = branch-at-next. Cross-trunk references with disclosure + consent. Attention flows upward through fractal hierarchy. | GLOBE-METRICS-1, CONSOLIDATION-1 | §22 |
| 23 | **VOTE-GOVERNANCE-1** | Implement global vote-ranked confidence, vote eligibility gates (Tier 1+, engagement history), vote decay (exponential, configurable half-life), vote-driven migration commits (supermajority + hysteresis), dual confidence rendering (organizational opacity + global ranking score). | SOCIAL-1, USER-TREE-1, GLOBE-METRICS-1 | §7.4-7.7, §9.4-9.5, §4.6 |
| 24 | **PARAM-GOVERNANCE-1** | Implement parametric governance (continuous weighted-median voting on system parameters at global/branch/template scope). Filter tolerance slidebars (personal overrides on global defaults). Fraud routing to proximity reverification. | VOTE-GOVERNANCE-1, PROXIMITY-1 | §11, §12 |

**Tier 6 — AR Interaction Modules**

| # | Slice | Description | Depends On | Key Sections |
|---|-------|-------------|------------|--------------|
| 25 | **VIDEO-PRESENCE-1** | Implement user sphere video presence with camera feed integration. Bi-directional video within the globe context. User sphere positioning relative to tree location. | PROXIMITY-1, USER-TREE-1 | §39.1 |
| 26 | **AR-OVERLAY-1** | Implement SCV-managed AR graphics overlay on video feed. Pre-designed graphic asset library. Voice/gesture summoning of assets. Shared view rendering for participants. | VIDEO-PRESENCE-1 | §39.1 |
| 27 | **OBJECT-INTERFACE-1** | Implement physical object detection and mapping. Camera-based object recognition. User-trainable SCV object vocabulary. Sword-blade-to-tree mapping as reference implementation. | AR-OVERLAY-1 | §39.2 |
| 28 | **LIGHT-COMM-1** | Implement light-based communication detection. Reflected light angle detection. Light signature classification. SCV interpretation of light signals as commands. | OBJECT-INTERFACE-1 | §39.3 |
| 29 | **ACHIEVEMENT-1** | Implement personal achievement system. Pre-mapped achievement definitions. SCV validation against physics laws. Evidence recording on user tree. Progressive capability unlock per achievement. | LIGHT-COMM-1, USER-TREE-1, CONFIDENCE-1 | §39.4 |
| 30 | **MULTI-RESOURCE-1** | Implement multi-resource economy. Engagement credits (base), achievement tokens (advanced), active capacity (limit). Resource-gated functionality. Double-entry resource transfers. | ACHIEVEMENT-1, PARAM-GOVERNANCE-1 | §41 |

**Tier 7 — Game Layer Modules (Monster Economy Lever Requires Founder Key)**

| # | Slice | Description | Depends On | Key Sections |
|---|-------|-------------|------------|--------------|
| 31 | **FOUNDER-KEY-1** | Implement founder key primitive. Activation condition checks (parameter thresholds). Founder account validation. Irreversible global activation. Pre-activation inert state for founder-key-gated modules. | MULTI-RESOURCE-1, PARAM-GOVERNANCE-1 | §44 |
| 32 | **ELEMENT-DETECT-1** | Implement environmental element detection from camera feed. Fire, smoke, rain, light, snow, wind, earth classification. Element presence enables corresponding magic type. Geographic capability mapping. | FOUNDER-KEY-1, AR-OVERLAY-1 | §43 |
| 33 | **SPELL-ENGINE-1** | Implement spell system. Personal spell library as user tree filaments. Element + gesture + object → SCV action mapping. Spell validation, AR rendering, truth-layer commit resolution. Shared spell definitions. | ELEMENT-DETECT-1, LIGHT-COMM-1 | §43.2, §43.3 |
| 34 | **GENRE-TEMPLATE-1** | Implement genre overlay templates. Sci-Fi, Fantasy, Horror, Military, Adventure rendering layers. Monster/quest visualization over real-world challenges. Community genre selection per project. | SPELL-ENGINE-1, ATTRIBUTE-BIND-1 | §40.3 |
| 35 | **MONSTER-ECONOMY-1** | Implement monster generation AI. Challenge stubs at all scales (microbe to galaxy). AI-generated monsters from global parameters. Spawn rate, reward magnitude, difficulty curve as governed parameters. Virtual and real-mapped monster distinction. | GENRE-TEMPLATE-1, PARAM-GOVERNANCE-1 | §40.4, §40.5, §41.3 |
| 36 | **DUEL-1** | Implement duel mechanics. Challenge protocol, arena setup, real-time spell combat, audience engagement, community vote resolution, resource transfer, event filament recording. | SPELL-ENGINE-1, VOTE-GOVERNANCE-1, MULTI-RESOURCE-1 | §42 |

**Tier 8 — Voice and Infrastructure**

| # | Slice | Description | Depends On | Key Sections |
|---|-------|-------------|------------|--------------|
| 37 | **VOICE-PIPELINE-1** | Implement Whisper STT integration (local, configurable model size), Architect intent parser (voice → structured command), Canon execution planner (intent → tree operation proposals). Command mode + stream mode. Permission enforcement. Transcript-as-evidence. | AR-OVERLAY-1, USER-TREE-1 | §47 |
| 38 | **INFRA-BOOTSTRAP-1** | Implement centralized backend MVP: commit persistence, WebSocket propagation, REST API surface, identity Tier 0/1, storage hot/warm tiers, basic auth. Minimum viable deployment for single-company tree. | BARK-CYLINDER-1 | §48.1-48.5 |
| 39 | **INFRA-SCALE-1** | Implement federation layer: regional commit routing, cross-region Merkle verification, server-side globe LOD aggregation, offline commit queue + reconnect reconciliation, load testing framework. | INFRA-BOOTSTRAP-1, FRACTAL-1 | §48.3, §48.8, §48.9, §48.16 |

### 27.3 Implemented Branch Behavior (Complete as of 2026-02-18)

The following is the exhaustive record of every branch behavior the system currently covers. No aspirational items. Every entry corresponds to running code with proof coverage.

---

#### 27.3.1 Geometry & Layout

**Three rendering modes:**

| Mode | Activation | Geometry |
|------|-----------|----------|
| **LAUNCH_CANOPY** | Default launch profile (`_launchVisuals=true`, `_scaffoldMode=false`) | Radial canopy with 3 concentric tiers. Branches curve from trunk top to tier hub positions via 3-point Bezier (start, mid-lifted, hub). |
| **TREE_SCAFFOLD** | T key toggle (`_relayRenderMode='TREE_SCAFFOLD'`) | Branches originate at trunk top, spread radially outward + upward. 400m rise. Height offset from attention/confidence (0-120m). Arc lift `sin(t*π)*80` in middle. |
| **Legacy parallel ribs** | Fallback when neither mode active | Parallel ribs along +East axis with north offset separation between branches. |

**Cylindrical corridor geometry (all modes):**
- Three tapered segments per branch:
  - Segment A (0-35%): thick at base (`radiusThick * 2`)
  - Segment B (35-75%): medium (`radiusMedium * 2`)
  - Segment C (75-100%): thin at tip (`radiusThin * 2`)
- Rounded corners (`CornerType.ROUNDED`)
- Branch frames computed at each sample point: `{T, N, B}` orthonormal basis stored in `branch._branchFrames`
- World positions stored in `branch._branchPositionsWorld`, ENU in `branch._branchPointsENU`
- World endpoint stored in `branch._worldEndpoint` (last position)

**Branch positioning per mode:**
- Scaffold: radial angle = `branchIndex * (2π / branchCount)`, length from `CANONICAL_LAYOUT.branch.length` (default 300m)
- Canopy: Bezier curve to tier hub position
- Legacy: sequential parallel offset along north axis

---

#### 27.3.2 Dual Confidence Physics (Contract #44)

**`computeOrgConfidence(objectId)`** — evidence-based, 0..1:
- +0.2 if timebox exists for this object
- +0.3 if evidenceRefs exist
- +0.2 if any filament disclosure >= WITNESSED
- -0.1 per missing ref
- Normalized by theoretical max (0.7) to produce 0..1 range
- Log: `[CONF] id=<branch> orgConf=<val> globalConf=<val> breakdown=tb:<n>,ev:<n>,disc:<n>,vote:<n>`

**`computeGlobalConfidence(objectId)`** — vote-based, 0..1:
- 1.0 if `node.voteStatus === 'PASSED'`
- 1.0 if filament's owning branch has `voteStatus === 'PASSED'`
- 0.0 otherwise
- No intermediate values (binary for now; expandable to vote alignment ratio)

**`computeConfidence(objectId)`** — DEPRECATED TRAP:
- Emits `[REFUSAL] reason=BLENDED_CONFIDENCE_CALLED`
- Falls back to `computeOrgConfidence` for safety
- Must never be called by active code

**Aggregation:**
- `aggregateOrgConfidence(scopeNodeId)` — fractal rollup: trunk → avg of branches → avg of sheets
- `aggregateGlobalConfidence(scopeNodeId)` — same fractal rollup, independent channel
- `aggregateConfidence()` — DEPRECATED TRAP, emits `[REFUSAL] reason=BLENDED_AGGREGATE_CALLED`

---

#### 27.3.3 Attention Physics

**`computeAttention(objectId)`** — multi-signal weighted product, 0..1:
- Collects all filaments where `fil.branchId === objectId`
- Lifecycle weight: `OPEN:0.6, ACTIVE:0.8, SETTLING:0.5, CLOSED:0.3, ARCHIVED:0.1, REFUSAL:0.9`
- Disclosure weight: `PRIVATE:0.2, WITNESSED:0.5, PUBLIC_SUMMARY:0.7, FULL_PUBLIC:1.0`
- Vote weight: `NONE:0.2, PENDING:0.4, PASSED:0.6, REJECTED:0.9`
- Product of max signals, normalized to 0..1
- Log: `[ATTN] id=<branch> attn=<val> lifecycle=<maxLC> disclosure=<maxDT> vote=<maxVS>`

**`aggregateAttention(scopeNodeId)`** — fractal rollup:
- Trunk level: weighted max of branch attention values (weight by filament count)
- Branch level: weighted average of sheet attention values (weight by filament count)

---

#### 27.3.4 Height Bands (Scaffold Mode Only)

Six bands define semantic elevation thresholds:

| Band | Height (m) |
|------|-----------|
| CELL | 300 |
| SHEET_MIN | 300 |
| SHEET_MAX | 600 |
| BRANCH | 2000 |
| COMPANY | 2400 |
| REGION | 3000 |

**Height offset computation:**
- Only active when `_relayRenderMode === 'TREE_SCAFFOLD'`
- Max offset: 120m
- Formula: `maxOffset * (0.7 * attention + 0.3 * orgConfidence) + statePenalty`
- State penalty: -20m if `voteStatus === 'REJECTED'`
- Clamped to `[0, maxOffset]`

**Indeterminate guard:**
- Height offset = 0 if `orgConf < 0.3` OR `missingRefs.length > 0`
- Result: `INDETERMINATE` (no lift)
- Log: `[HEIGHT] indeterminate id=<branch> orgConf=<val> missing=<n>`

**Elevation invariant:**
- Requires at least one filament with disclosure >= WITNESSED AND lifecycle >= ACTIVE
- If no qualifying filament exists: offset = 0, result = INDETERMINATE
- Logs: `[PRESSURE] branch=<id> aggregate=<val> contributors=[<fids>] threshold=0.3 result=<val>`
- Logs: `[HEIGHT] branch=<id> offset=<n> band=BRANCH attn=<val> orgConf=<val>`

---

#### 27.3.5 LOD & Visibility

| LOD Level | Branch Visibility Rule | Sheet Detail |
|-----------|----------------------|--------------|
| **GLOBE / REGION** | Only branches with `voteStatus === 'PASSED'` rendered. Vote filter active. | Suppressed |
| **COMPANY** | All branches visible regardless of voteStatus. Vote filter overridden. | Suppressed (`suppressSheetDetail=true`) |
| **SHEET** | All branches visible. Selected sheet expanded. | Expanded for selected sheet only |
| **CELL** | All branches visible. Fully flat 2D grid for focused cell. | Fully expanded |

**Vote filter logging:**
- `[VIS] voteFilter LOD=<lod> visible=<n> hidden=<n>` (globe/region)
- `[VIS] voteFilter LOD=<lod> override=ALL` (company)

**Sheet detail suppression:**
- `expandedSheetsAllowed` = false when `scope === 'company'` or LOD >= COMPANY
- `expandedSheetsAllowed` = true when `scope === 'sheet'` or `scope === 'cell'`
- Log: `[VIS2] expandedSheetsAllowed=<bool> scope=<scope>`
- Log: `[VIS2] suppressSheetDetail=<bool> expandedSheetsAllowed=<bool> selectedSheet=<id|none> lod=<lod>`

**Company collapsed rendering:**
- Department spines rendered (thick yellow highlight on trunk-direct branches)
- Sheet tiles rendered as small 2D proxies (not full detail)
- Log: `[VIS2] companyCollapsed result=PASS sheetsRendered=0 lod=COMPANY scope=company expandedSheetsAllowed=false`
- Log: `[VIS2] deptSpinesRendered count=<n>`

---

#### 27.3.6 Voting & Governance

**Vote statuses:** `PASSED`, `PENDING`, `REJECTED`, `NONE`

**Decision application (`applyGovernanceDecisionToBranch`):**
- Maps governance topic state → branch voteStatus:
  - PASS/COMMIT → `PASSED`
  - FAIL/VETO/REFUSAL → `REJECTED`
  - All other → `PENDING`
- Persists to localStorage (`RELAY_VOTE_STORE_KEY`)
- Emits scar log for REJECTED: `[SCAR] applied branch=<id> reason=voteRejected result=PASS`
- Log: `[VOTE] decision branch=<id> result=<outcome>`

**Vote simulation (`relaySimulateGovernanceDecision`):**
- Creates governance topic for branch
- Casts votes deterministically (3 votes, quorum-based)
- Closes topic and applies decision
- Used for demo/proof scenarios

**Vote persistence:**
- Branch voteStatus stored in localStorage on every change
- Restored on boot from localStorage
- Log: `[VOTE] restore <id>=<status>` per branch

**Vote summary:**
- `updateHudVoteSummary()` counts PASSED/PENDING/REJECTED across all branches
- Log: `[HUD] votes summary=PASS passed=<n> pending=<n> rejected=<n>`

---

#### 27.3.7 Camera & Navigation

**Basin focus:**
- Double-click trunk enters company focus mode
- Camera locks to branch bounding sphere
- Log: `[CAM] basinFocus settled target=<trunk> distM=<n> pitch=<n>`
- `DEFAULT_BASIN_RADIUS_BY_TYPE.branch = 6000`

**Branch walk API:**
- `relayEnterBranchWalk(branchId)` — start branch navigation
- `relayBranchWalkNext()` / `relayBranchWalkPrev()` — step through branches
- `relayExitBranchWalk()` — exit branch navigation
- `relayGetBranchWalkState()` — read current state
- Log: `[MOVE] branch-step from=<id> to=<id>`
- Log: `[MOVE] mode=branch target=<branchId>`

**Department entry:**
- `relayEnterDepartment(branchId)` — enter branch focus (alias for focus mode)
- `relayEnterFocus({ type: 'branch', id })` — routes to `enterFocusMode()`

**Focus breadcrumb:**
- `focusCrumbBranch` updated with branch name/id on focus change
- Parent chain resolution: `findParentChain()` finds `parentBranch` and `parentTrunk`

**Keyboard:**
- `E` — enter nearest sheet (child of focused branch)
- `Esc` — exit sheet/branch context, return to FreeFly
- `T` — toggle scaffold/canopy mode
- `L` — toggle LOD lock

---

#### 27.3.8 HUD & Display

**Metrics readout (Tier 2 HUD):**
- Displays `OrgConf: X% | GlobConf: Y% | Attn: Z%` for focused branch
- Requires focus target to be active
- Dual confidence shown separately, never blended

**Filament ride HUD:**
- Displays `OrgConf: X% | GlobConf: Y% | Attn: Z% | Commits: N | Contributors: N`
- Per-stop epistemic state along filament path

**Vote summary bar:**
- Shows `PASS: N | PENDING: N | REJECTED: N` across all branches

---

#### 27.3.9 Department Spines

**Rendering (`renderDepartmentSpineEmphasis`):**
- Thick highlight (10px width) along trunk-direct branches
- Color: yellow (`#ffeb3b`) with alpha 0.5
- Only rendered when `suppressSheetDetail === true` (company collapsed view)
- Counted in `primitiveCount.deptSpines`
- Log: `[VIS2] deptSpinesRendered count=<n>`

---

#### 27.3.10 Alpha & Opacity

| Property | Default | Theme Override | Notes |
|----------|---------|----------------|-------|
| Branch corridor alpha | 0.18 | `bt.branch.alpha` | Readability-tuned for launch |
| Emissive alpha | 0.28 | `bt.branch.emissiveAlpha` | Reduced interior detail competition |
| Rib scale | 0.18 | — | Width floors for structural look (launch only) |
| Flow pulse | +0.25 | — | Additive when `branch._flowPulseUntil` active |

---

#### 27.3.11 Filament Attachment

**Sheet attachment at branch endpoint:**
- Attachment index = last frame in `parent._branchFrames`
- Attachment position = `parent._branchPointsENU[attachIndex]`
- Sheet normal = `-T` (anti-parallel to branch tangent at endpoint)
- Canonical rule: sheet face always points AWAY from branch growth direction

**Per rendering mode:**
- Scaffold: sheet at branch endpoint, normal from frame
- Canopy: sheet placed via `computeCanopyPlacement()` with tier-based positioning
- Legacy: sheet at branch endpoint with computed normal

**Junction markers:**
- Small cyan markers at trunk→branch attachment points
- Position: first ENU sample on branch curve (`branch._branchPointsENU[0]`)
- Only rendered in launch mode (`RELAY_LAUNCH_MODE`)

---

#### 27.3.12 Backing Refs & Data Model

**`getBackingRefs(objectId)`** for branches returns:
- `filamentIds`: all filaments where `fil.branchId === objectId`
- `timeboxIds`: collected from branch node's `timeboxes` array
- `evidenceRefs`: evidence pointers from all backing filaments
- `missingRefs`: references that cannot be resolved

**Branch node properties (demo tree):**

| Property | Example | Purpose |
|----------|---------|---------|
| `id` | `branch.finance` | Stable ID (§32) |
| `type` | `'branch'` | Node type discriminator |
| `name` | `Finance & Accounting` | Display label |
| `parent` | `'trunk.avgol'` | Parent trunk reference |
| `lat`, `lon`, `alt` | 32.08, 34.78, 100 | Globe position |
| `voteStatus` | `'PASSED'` / `'PENDING'` / `'REJECTED'` | Governance state |
| `timeboxes` | Array of `{timeboxId, commitCount, openDrifts, eriAvg, scarCount}` | Time segmentation |
| `eri` | 0.88 | Evidence Readiness Index |
| `metadata.kpiBindings` | `[{metric, target, formula, branch}]` | KPI configuration |
| `metadata.kpiMetrics` | `[{label, value, unit, target, status}]` | Computed KPI values |
| `metadata.kpiLabel` | `'Financial KPIs'` | Display group label |

**Demo tree branches (6):**

| Branch | Vote Status | Timeboxes | Domain |
|--------|------------|-----------|--------|
| `branch.operations` | PASSED | 5 | Operations |
| `branch.finance` | PENDING | 4 | Finance |
| `branch.supplychain` | PASSED | 5 | Supply Chain |
| `branch.quality` | PASSED | 4 | Quality |
| `branch.maintenance` | REJECTED | 3 | Maintenance |
| `branch.it` | PENDING | 4 | IT |

---

#### 27.3.13 Proof Coverage Matrix

| Behavior Domain | Proof Script | Stages |
|----------------|-------------|--------|
| Dual confidence split | `dual-confidence-separation-proof.mjs` | 8/8 PASS |
| Attention + confidence + HUD | `attention-confidence-proof.mjs` | 8/8 PASS |
| Height bands (scaffold) | `height-band-proof.mjs` | 8/8 PASS |
| Company collapsed + LOD | `vis2-company-compression-proof.mjs` | PASS |
| LOD transitions (globe→sheet→cell) | `r0-visibility-lock-proof.mjs` | 6/6 PASS |
| Scaffold toggle + rendering | `vis-tree-scaffold-1-proof.mjs` | PASS |
| Camera FreeFly + branch proximity | `cam-freefly-contract-proof.mjs` | 3/4 (Stage C: Known Refusal) |
| Full system integration | `osv1-full-system-proof.mjs` | PASS |
| Headless data parity | `headless-tier1-parity.mjs` | PASS |

---

#### 27.3.14 What Branches Do NOT Yet Do

The following §3 design behaviors are specified but not yet implemented — they require BARK-CYLINDER-1 and subsequent slices:

- **Cylindrical bark wrapping** (§3.2): Filament rows currently render as flat sheets at branch endpoints, not wrapped around the branch surface.
- **Zoom-to-flat LOD transition** (§3.3): No conformal projection from cylinder to flat grid. Currently a hard cut from 3D to 2D.
- **Cross-section dual encoding** (§3.4): No radial lifecycle encoding or angular approach direction encoding. Requires TREE-RING-1.
- **Helical twist** (§3.5): No spiral grain along branch length. Requires HELIX-1.
- **Timebox slab as vertebrae** (§3.6): Slabs rendered as boxes, not as cross-sectional rings with color=magnitude, opacity=confidence, firmness=wilt. Requires SLAB-REVISION-1.
- **Wilt and drooping** (§3.7): No branch deformation from slab degradation. Requires WILT-1.
- **Collision physics** (§3.8): No material resistance on slab walls. Requires WILT-1.
- **Branch tip insight** (§3.9): No bud-like endpoint showing summary output.
- **Twig emergence** (§3.10): No emergent twigs from unclosed filaments at old timeboxes. Requires TWIG-1.
- **Gravitational sinking** (§3.11): No downward slope along branch length. Requires GRAVITY-SINK-1.
- **Cross-section inspection mode** (§3.13): No radial cross-section view, ring scrubbing, slab expansion, or filament drill-down. Requires CROSS-SECTION-1.
- **Organic growth variation** (§3.14): No slab thickness variation by theta, no Perlin noise, no bark ridge deformation, no scar crack propagation. Requires ORGANIC-RENDER-1.

These are the Tier 1-3 build slices. The proven foundation supports them.

---

## 28. Worked Example — One Invoice Through the Full Trace (New Model)

An invoice arrives: $48,000, Vendor ACME (located in Berlin), Dept Operations, January 2026.

1. **ARRIVE**: Route normalizes JSON. Appends row 7 to `P2P.InvoiceLines` on the P2P branch bark.
2. **SPAWN**: Filament `F-INV-007` appears at outer bark (r=R_max), current timebox (l=January 2026), angular position theta=compass bearing from company (Tel Aviv) to ACME (Berlin) = ~330 degrees (northwest).
3. **GROW**: The filament exists on the bark surface. Each day it grows longer along l. Its timebox slab records: thickness +1 commit, color warm ($48K), opacity 0.5 (has invoice doc but no PO match yet = 1/2 evidence).
4. **MATCH**: Match engine joins PO-3001 + GR-5001 + INV-007 via `poLineId`. Evidence twig connects to PO filament. Another evidence twig connects to GR filament. Confidence jumps to 1.0 (3/3 evidence items). Slab opacity goes full.
5. **MIGRATE**: Filament begins moving inward (r decreases from R_max toward center). In cross-section, it shifts from outer bark to middle ring. Status: ACTIVE -> CLOSED.
6. **SUMMARY**: Summary formula computes match rate = 87.5%. KPI binding reads this value. Branch radius adjusts.
7. **ABSORB**: Filament reaches center (r=0). Enters trunk consolidation gate.
8. **CONSOLIDATE**: TransferPacket verified: `-$48,000 AP` + `+$48,000 GRIRClearing` = balanced. ResponsibilityPacket on approver's user tree: "I approved INV-007, commitId=commit.a7b3c9."
9. **ARCHIVE**: Root cube written: `{cubeId: root.F-INV-007, totalMagnitude: 48000, unit: $, absorptionHash: sha256:..., merkleAnchor: {...}}`. Merkle-sealed. Permanent.

Meanwhile, the filament's twig-free journey meant the branch stayed clean at that timebox. If step 4 had never happened (no PO match), the filament would have stayed at bark level, sinking with gravity, becoming a visible twig by Q2 — the only thing still protruding at that depth.

---

## 29. Proximity Channels

> *"The most important thing in communication is hearing what isn't said."* — Peter Drucker

### 29.1 Definition

A proximity channel is a physical-location-anchored communication zone. When you walk near a store, a factory floor, or a community space that hosts a Relay proximity channel, your device detects it via BLE/Wi-Fi.

### 29.2 How They Work

- Detection: multi-signal confirmation (BLE + Wi-Fi together, time-in-range, challenge-response)
- In range: you can post Notes, vote, participate in flows, access local training
- Out of range: read-only. Past actions preserved. Cannot create new content until physically back.
- "Act only when present; review always."

### 29.3 Approach Angle Measurement

Proximity channels measure the DIRECTION from which users approach. This feeds the counterparty angular position on the bark cross-section:

- A customer approaching from the east side of the street appears on the east side of the bark
- Exposure mapping: the store sees which directions customers come from
- Privacy: users who don't want to reveal direction can approach from any angle

### 29.4 Anti-Spoof

Layered constraints, not magic:
- Multi-signal confirmation (BLE + Wi-Fi)
- Time-in-range (consistent detection, not momentary)
- Challenge-response for beacon owners
- Community flagging + reverification at trusted hotspots
- Spoof attempts surface as INDETERMINATE or REFUSAL, not silent allow

---

## 30. Verification Physics

> *"Extraordinary claims require extraordinary evidence."* — Carl Sagan

### 30.1 Three-Way Match

Intent (PO) vs Reality (GR) vs Projection (Invoice). The match engine joins these deterministically via shared keys (`poLineId`). Mismatches surface as exceptions on the match sheet — visible, never hidden.

### 30.2 Pressure Loop

Six-step continuous cycle: Attest -> Compare -> Score -> Stage -> Verify -> Checkpoint. This loop runs per timebox per branch. The outputs feed timebox slab properties (confidence, wilt).

### 30.3 Five Invariants

1. **Pressure Budget** (humane): The system limits the number of verification actions required per person per timebox.
2. **Confidence Floor** (honest): Never display certainty without coverage. ERI shows score + confidence + missing inputs.
3. **Repair Effectiveness** (learning): Track whether verification actions actually improve health.
4. **Data Minimization** (private): Minimum required data, shortest retention, strictest scope.
5. **Policy Governance** (governed): All verification rules are policy commits, versioned and inspectable.

### 30.4 Wilt Formula

```
wilt_factor = f(age_since_verification, unresolved_count, confidence_floor, coverage_ratio)
```

wilt_factor is 0.0 to 1.0. Inputs must be sourced from explicit logged quantities:
- `unresolved_count` from obligations ledger
- `coverage_ratio` from feed arrival records
- `confidence_floor` from ERI
- `age_since_verification` from last VERIFY_CHECKPOINT commit timestamp

Verification event types that reduce wilt: `VERIFY_CHECKPOINT`, `RECONCILE_RESOLVE`, `FOLLOWUP_CLOSE`. Any other commit type does not reduce wilt.

---

## 31. Accounting Packets

> *"In God we trust. All others must bring data."* — W. Edwards Deming

### 31.1 TransferPacket (System Truth)

Append-only posting packet. Typed legs `{containerRef, amount, unit, reasonCode}`. Must net to zero per unit type.

Containers: Inventory, GRIR, AP, Cash/Bank, Variance, Budget/Commitment, policy-defined extensions.

### 31.2 ResponsibilityPacket (Human Truth)

Append-only mirrored packet on user tree. Records asserted/approved/executed responsibility linked to the same commitId + evidenceHash.

### 31.3 Commit-Hook Law

TransferPacket validation executes INSIDE commit materialization. Direct financial state mutation outside COMMIT is forbidden. Ledger/journal/trial-balance are deterministic projections over validated transfer packets — they are never origin-write surfaces.

### 31.4 Settlement Timebox Rule — spawnAt, Not settlementAt

External settlement (bank confirmation, payment processor callback) is asynchronous. A bank may settle 2 hours or 48 hours after Relay initiates the transfer. During that gap, gravity sinks filaments, timeboxes close, and cross-sections may be inspected.

**The rule:** A filament's timebox assignment is determined by `spawnAt` (the moment the filament was created in Relay) — never by external settlement time.

Why:
- If timebox assignment used `settlementAt`, a settlement arriving 48 hours later would retroactively place the filament in a timebox that has already closed. That breaks deterministic replay — a closed timebox's aggregates would change.
- Settlement confirmation is a **commit on the existing filament**, not a new filament or a timebox reassignment. When Chase confirms at T+48h, that confirmation attaches as an evidence commit to the filament that was spawned at T+0h. The filament stays in its original timebox.
- Slab confidence for the original timebox may improve (because evidence arrived), but the slab's commit count, magnitude, and filament membership do not change.

**Lifecycle during settlement gap:**

```
T+0h:  Filament spawns → timebox = current → lifecycleState = OPEN
       settlementStatus = PENDING_EXTERNAL
T+48h: Bank confirms → evidence commit attaches to filament
       settlementStatus = SETTLED
       orgConfidence increases (evidence present)
       Timebox does NOT change. l position does NOT change.
       The filament has been sinking for 48h already.
```

**If settlement fails:**

```
T+72h: Bank rejects → evidence commit attaches: "settlement rejected"
       settlementStatus = FAILED
       orgConfidence decreases
       A revert commit may be applied → scar (§4.5)
       Timebox still does NOT change.
```

This ensures deterministic replay: given the same commit log, any node produces identical timebox aggregates at any point in time. Settlement latency never distorts history.

### 31.5 External Hash Rot — Evidence Survives, Retrieval May Not

Relay hashes external evidence (bank confirmation PDFs, API responses, signed documents) at commit time. The hash is immutable and Merkle-anchored. The external source may not be.

**Over time, external references decay:**
- Bank document URLs expire.
- API endpoints change.
- PDF formats are rotated.
- Corporate portals are decommissioned.

**The invariant:** `hash ≠ retrievability`. The hash proves what the document said at the time it was committed. It does not guarantee the document can be fetched again.

**UX rules:**
- If `externalEvidenceRef` resolves: show document + hash verification (green check).
- If `externalEvidenceRef` fails to resolve: show "External evidence unavailable — hash preserved: `sha256:abc…`" with amber indicator. Never show as "data loss" or "missing evidence."
- Confidence is NOT reduced by hash rot. The hash proves the evidence existed. The evidence was verified at commit time. Subsequent URL expiry does not invalidate past verification.
- Templates can define `evidenceArchivePolicy`: `CACHE_LOCAL` (store a local copy at commit time — uses storage budget), `HASH_ONLY` (store only hash — zero storage, retrieval-dependent), or `CACHE_AND_HASH` (both). The default for financial branches should be `CACHE_AND_HASH`.

---

## 32. Stable ID Construction Law

Canonical IDs are deterministic, intrinsic, and view-independent:

- **Rows**: `row.<moduleId>.<sheetId>.R<row>` (replaces cell-level IDs as primary anchor)
- **Cells**: `cell.<moduleId>.<sheetId>.R<row>.C<col>` (for property-level access within a filament)
- **Sheets**: `sheet.<moduleId>.<sheetId>`
- **Branches**: `branch.<treeId>.<servicePath>`
- **Trees**: `tree.<entityId>`
- **Filaments**: `F-<objectType>-<objectId>`
- **Notes**: `note.<uuid>`
- **Commits**: `commit.<sha256-hash>`
- **Timeboxes**: `timebox.<branchId>.<startCommitIndex>-<endCommitIndex>`
- **Root cubes**: `root.<filamentId>`
- **Flows**: `flow.<scope>.<slug>`
- **Proximity channels**: `prox.<fingerprint-hash>`

Construction rules (non-negotiable):
- IDs derived from (objectType, moduleId, deterministic key) — never from view state, camera, LOD, or render order
- Never derived from timestamps alone
- Never regenerated per session
- Same ID in 3D, 2D inspector, headless API, and CSV export

---

## 33. LOD Rendering Contract

> *"The art of being wise is the art of knowing what to overlook."* — William James

### 33.1 LOD Ladder (Branch-Level)

| LOD Level | What Renders | Detail |
|-----------|-------------|--------|
| GALACTIC-STELLAR | Celestial body globes as points with aggregate heat/mass. | Every body with data IS a Relay globe (§1.3). Same physics at every body. |
| PLANETARY | Globe with heat glow regions | Hot trunks = bright spots on globe surface |
| GLOBE | Trunk pins + prominence beacons | Height, glow, heat per trunk. Branches suppressed. |
| CITY/COUNTRY | Clustered trunk summaries | Aggregate attention for geographic regions |
| TREE | Full tree. Trunk + branch cylinders | Bark texture visible but rows not readable. Slab colors visible. |
| BRANCH | Single branch cylinder. Bark pattern | Individual row hinting. Timebox boundaries visible. Twigs visible. |
| BARK | Partially flattening bark | Column headers appear. Some curvature. Rows becoming legible. |
| SHEET | Nearly flat. Traditional spreadsheet feel | Full 2D grid. Cell editing. Conformal projection from cylinder. |
| CELL | Individual cell focus. Commit history panel | Single field, full history, evidence twigs, all commits. |

### 33.2 Primitive Budget

Each LOD level has a rendering budget. At lower detail (zoomed out), geometric primitives merge and simplify. At higher detail (zoomed in), full mesh + texture + interactivity is available. The budget system prevents runaway rendering at globe scale.

### 33.3 Sight Radius and Atmospheric Compression

Every user has a **sight radius** — a visibility bubble around their current focus point. Objects inside the bubble render at full detail appropriate to the LOD level. Objects outside the bubble are still visible — but rendered at progressively lower fidelity. This is the Relay equivalent of fog of war: you see what you are looking at in full detail, and everything else remains present as recognizable form, just not as crisp geometry.

**Atmospheric compression:** As branches extend beyond the user's current atmospheric zone, they do not vanish — they simplify. A distant branch still renders as a branch: its cylinder shape, color, height, and approximate thickness remain visible. What drops away is internal detail — individual filaments merge into aggregate textures, bark rows become smooth surfaces, projections collapse into color-tinted summary halos, twigs reduce to directional stubs. The further away, the fewer primitives used, but the silhouette and proportions always represent the real underlying structure. Think of a city skyline at dusk: you cannot read the signs or count the windows, but you can tell which buildings are tall, which glow, which are dark. That is how distant branches look — blurry, simplified, but truthful in form.

A branch with 10,000 active projections at its tip still reads as a dense, active cluster from a distance. Only when the user flies into it does the cluster expand into individual projections with full interactivity. At no point does geometry disappear — it only reduces in polygon count and texture resolution.

This creates a natural rendering budget that scales with attention, not with world complexity. A globe with 50 million trees and billions of filaments renders smoothly because distant objects use a fraction of the primitives that nearby objects use — but they are always there, always shaped correctly, always hinting at the activity they contain.

### 33.4 Archive Radial Compression — LOD by Depth

LOD applies not only to camera distance but also to radial depth within a branch. Deep archive rings compress visually — but data exists in full fidelity at every depth.

| LOD Level | Deep Archive Rendering |
|-----------|----------------------|
| TREE | Deep archive = thin inner band. Individual rings indistinguishable. Branch shape reflects total archive weight. |
| BRANCH | Archive rings visible as denser bands. Recent rings individually legible. Deep rings merge visually. |
| CROSS-SECTION (§3.13) | Full fidelity. Every slab ring individually rendered. Thickness, color, opacity, and scars visible per ring. User can scrub and expand. |
| CELL | Single filament's full commit history along the radial axis. Each commit layer distinguishable. |

Archive compression is visual only. The underlying slab data, filament positions, and commit histories exist at full resolution regardless of rendering fidelity. The cross-section inspection mode (§3.13) is the mechanism that unlocks full-depth legibility without violating the universal sinking rule.

**Invariant:** Archive legibility comes from cross-sectional slab rendering, ring contrast, LOD-based compression, interactive slicing, and time scrub depth control — never from freezing time or pinning filaments to the surface.

**Privacy integration — physics vs rendering separation:** Branch health, confidence, weight, and aggregate metrics are always computed from ALL authorized filaments within that branch's scope, regardless of who is viewing. A branch that contains 1,000 filaments weighs 1,000 filaments for everyone — the tree IS the data. However, *rendering* respects disclosure tiers: objects the viewer does not have permission to see are excluded from their personal render pass. The branch still shows its true aggregate shape (droop, heat, thickness, confidence opacity) because those are scope-truth properties computed server-side. But individual filaments, twigs, and projection details that fall outside the viewer's disclosure tier do not render on their device. The viewer cannot infer the specific content of private objects, but they can see that the branch is heavier or more active than what they personally have access to — because the aggregate is truthful. This preserves auditability: two users see the same branch shape and health, even if they see different internal details.

### 33.5 Laniakea LOD Scaling Rules — Deterministic, Not Theatrical

From file to Laniakea, Relay renders the same physics at every scale. What changes is aggregation level and rendering fidelity. These rules prevent the galaxy layer from becoming theatrical nonsense.

**Rule 1 — Deterministic aggregation only.**

At GALACTIC and LANIAKEA LOD, you never render individual filaments. You render:
- Trunk vectors (lean direction + magnitude for major bodies)
- Heat scalar (per region tile)
- Fog scalar (per region tile)
- Mass scalar (trunk thickness / presence weight)

Nothing else. No particle effects. No "space ambiance." No decorative nebulae. If it renders, it's computed from filament aggregates.

**Rule 2 — No physics above source.**

Weather overlays and aggregate metrics cannot: move filaments, alter lifecycle, affect confidence, modify governance. They are pure projection computed from underlying data. This holds at every scale — a galaxy-scale heat map has no more authority over truth than a branch-level one.

**Rule 3 — LOD collapse hierarchy (from highest to lowest fidelity).**

When density exceeds rendering threshold at any scale:

| Shed Order | What Disappears | What Remains |
|------------|-----------------|-------------|
| 1st | Individual filaments | Aggregate bark texture |
| 2nd | Slab disc rings | Aggregate ring bands |
| 3rd | Bark surface texture | Smooth cylinder |
| 4th | Weather tile overlays | Branch silhouettes |
| 5th | Branch lean/droop deformation | Static branch pose |
| 6th | Individual branches | Category bundles (§3.18 LOD merge) |
| 7th | Category bundles | Trunk marker only |
| 8th | Individual trunks | Regional heat/fog tiles |
| NEVER | Regional presence | Always visible as at least a point |

Truth collapses upward (toward aggregation), never sideways (toward falsification).

**Rule 4 — Motion updates at timebox boundaries only.**

No per-commit jitter at any scale. Motion recalculates only when a timebox closes or an engagement threshold is crossed. At galaxy scale, the timebox might be an epoch. At file scale, it might be a day. The update cadence scales with the scope — but the rule is the same: no continuous animation from data events.

**Rule 5 — Universal units (no scale-specific normalization).**

Every scale uses:
- Radians for θ (direction)
- Normalized magnitude (0..1 within scope)
- Normalized confidence (0..1, always)
- Normalized heat (0..1 within time window)
- Normalized fog (0..1, always)

Planetary scale does not require different math. The normalization denominator changes with scope. The equations (§3.19) remain identical.

**LOD thresholds by scale:**

| Scale | When Visible | What Renders |
|-------|-------------|-------------|
| CELL | Camera within single filament | Full commit history, cell editor, evidence panel |
| SHEET | Camera within branch surface | Flat grid, ribbons, individual rows |
| BARK | Camera near branch | Cylindrical bark, slab rings, twigs, lean |
| BRANCH | Camera at tree level | Branch cylinders, aggregate lean/droop, slab bands |
| TREE | Camera seeing whole tree | Trunk + branch silhouettes + bundles |
| COMPANY | Camera seeing tree cluster | Trunk markers + aggregate health |
| REGION | Camera seeing a country/state | Heat tiles + fog + trunk dots |
| PLANETARY | Camera seeing globe | Continental heat regions + major trunk clusters |
| ORBITAL | Camera between Earth and Moon | Nearby bodies visible as small globes. Space stations as tree markers. |
| LUNAR | Camera at Moon distance | Moon IS a full Relay globe (§1.3). Zoom in = Moon's own trees. Earth also visible. |
| STELLAR | Camera at solar system scale | Each planet/moon/asteroid = a globe point with aggregate heat/mass. Zoom into any = full globe. |
| GALACTIC | Camera at Milky Way scale | Star-system points with aggregate metrics. Each star system contains its own set of body-globes. |
| LANIAKEA | Camera at supercluster scale | Galaxy cluster heat fields + aggregate force vectors. Each galaxy contains star systems with body-globes. |

At every level, the same equations (§3.19) produce the rendered state. Only the aggregation depth and primitive budget differ. Every celestial body that has data IS a full Relay globe (§1.3) — not a dot, not a marker, not an abstraction. Zoom into any body at any scale and you find trees with branches, filaments, slabs, scars, archive rings. History goes inward on every body.

---

## 34. Use Case — Software Development on Relay

This demonstrates how a developer uses Relay to code a new application, and how SCV AI assists.

### 34.1 Setup

Create a tree with template `software.dev`. Branches:
- `features` — each feature is a filament. PRs, code reviews, test results are evidence twigs.
- `bugs` — each bug report is a filament. Fixes, reproductions, deployments are evidence.
- `infrastructure` — server configs, CI/CD runs, deployment events.
- `docs` — documentation pages as filaments with version commits.

### 34.2 Developer Workflow

1. Developer opens Relay, zooms to project tree.
2. Posts a **Note** on the features branch bark: "Need auth middleware for API routes."
3. Another team member responds -> Note converts to filament `F-FEAT-042`.
4. Developer creates a branch in git. The git hook registers a commit on the filament's bark: `commit.a7f3 -> evidence: git-branch-ref`.
5. PR submitted -> new commit on filament, evidence twig links to PR URL.
6. Code review completed (2 approvals) -> filament confidence rises (evidence_present: 3/3 = code + tests + review).
7. Merged to main -> filament status: ACTIVE -> CLOSED. Begins inward migration.
8. Deployed to production -> final evidence. Filament reaches center. Absorbed.

### 34.3 SCV Code Coherence

The SCV `Code Coherence` agent navigates the features branch:

1. Detects a cluster of twigs on the `bugs` branch at last week's timebox -> something introduced regressions.
2. Builds a projection branch linking bug filaments to the feature filaments merged that week.
3. The projection shows: 3 bugs correlate with feature `F-FEAT-039` (all evidence twigs trace back to same PR).
4. SCV proposes: "Recommend rollback of F-FEAT-039 pending investigation. Evidence: 3/3 bugs share merge commit ancestry."
5. Developer reviews projection, approves revert -> scar appears on bark at F-FEAT-039. Bug filaments reference the scar as resolution evidence.

### 34.4 Time Scrub for Sprint Review

At sprint end, team selects time window = last 2 weeks:
- Branch shows only filaments active during sprint
- Completed features: moved inward (thin bark, healthy center)
- Carry-over bugs: still at bark level, now slightly lower (gravity sank them) -> visible as young twigs
- Sprint velocity = count of filaments that crossed from OPEN to CLOSED in the period

---

## 35. Use Case — Municipal Services

### 35.1 Setup

A city creates a tree with template `municipal.services`. Branches:
- `pothole-repair` — each pothole report is a filament. Photo + GPS = evidence.
- `waste-collection` — each collection route run is a filament.
- `building-permits` — each permit application is a filament.
- `public-safety` — incident reports as filaments.

### 35.2 Citizen Workflow

1. Citizen walks near a pothole. Proximity channel detected.
2. Posts a **Note** with photo + GPS. Approach angle recorded.
3. City maintenance team responds -> Note converts to filament on `pothole-repair` branch.
4. Crew dispatched -> commit on filament with evidence: crew assignment, ETA.
5. Repair completed -> photo evidence of completed work. Filament confidence = 1.0 (photo + GPS + crew report = 3/3).
6. Citizen confirms -> filament CLOSED. Migrates inward.

### 35.3 Fractal Escalation

Many unresolved potholes on the same branch:
- Twigs accumulate at bark level in old timeboxes
- Residents vote on the issue -> engagement rate rises
- Neighborhood trunk becomes more prominent at city level
- City tree shows the neighborhood as a hot branch
- State level shows the city as a hot branch
- Same mechanics, same physics, different template

---

## 36. Use Case — Astronomy

### 36.1 Setup

A research institute creates a tree with template `science.astronomy`. Branches:
- `observations` — each telescope observation is a filament. Raw data + calibration = evidence.
- `hypotheses` — each published hypothesis is a filament. Citations = evidence twigs.
- `peer-review` — review submissions as filaments. Reviewer comments = commits.

### 36.2 Below the Globe Surface

An archaeo-astronomer studies ancient observations:
1. Zooms BELOW the globe surface at the observatory's location
2. Root strata from 1800s visible — compressed, Merkle-sealed
3. Creates a finding filament on the present surface
4. Evidence twig reaches DOWN into the buried root layer, referencing the historical observation
5. The finding filament is truth on the present surface, with provenance extending through geological time

### 36.3 Beyond Earth

Every celestial body IS a Relay globe (§1.3). Mars is not a marker on Earth's zoom-out — Mars is its own full globe with its own trees, its own branches, its own filaments, its own archive rings, its own cross-sections. The same is true for the Moon, every asteroid, every planet, every moon of every planet, every space station.

**Mars example:**
- `geology` branch: every rover soil sample, seismic reading, mineral identification = filament. Template: `planetary.geology`. Sinking mode: mission-milestone.
- `atmosphere` branch: every atmospheric pressure reading, dust storm measurement, radiation level = filament. Template: `planetary.atmosphere`. Sinking mode: earth-time.
- `operations` branch: every mission telemetry event, communication window, power cycle = filament. Template: `planetary.operations`.
- The rover's presence marker moves across the Martian surface. Scientists on Earth zoom to Mars, read the bark, build projections. The Martian tree rings encode geological history the same way an accounting tree encodes financial history.

**Data sources for non-Earth bodies:**
- Satellites and orbital sensors → automatic filament generation from telemetry streams
- Rovers and surface probes → filaments from instrument readings
- Telescopes → filaments from observation events
- Human missions → filaments from crew activity (identical to Earth workplace filaments)
- AI/SCV analysis → projection branches on celestial body trees (same lavender, same rules)

At planetary LOD, you see each body as a globe. Zoom in and you see its trees. Zoom in further and you see branches, bark, filaments — identical physics to Earth. The universal equations (§3.19) are not metaphorically universal. They are literally the same computation running on every body that has data.

---

## 37. Knowledge Migration Lifecycle — From 2D Internet to 3D Tree

> *"First they ignore you, then they laugh at you, then they fight you, then you win."* — attributed to Mahatma Gandhi

This section describes how existing human knowledge — news, politics, religion, science, history — naturally transitions from 2D internet platforms into Relay's 3D tree model. This is not a feature to build. It is the civilizational adoption lifecycle that emerges from the existing mechanics.

### 37.1 Phase 1 — Import

Users take existing 2D content and post it as filaments:

- News articles become filaments with screenshot/link evidence attachments
- Social media posts become filaments with cross-platform references
- Wikipedia entries become filaments with citation evidence twigs
- Historical texts become filaments with archival references
- Religious texts become filaments with scholarly attestation

Each import is a truth filament on a topical branch. It carries the six universal domains. It is permanent and append-only from the moment of creation.

### 37.2 Phase 2 — Sink

Imported content sinks with gravitational time like everything else:

- Yesterday's news moves down the branch
- Last month's news is in older timeboxes
- Last year's content is deep on the branch
- Content from decades/centuries ago sinks through the trunk into the root archive below the globe surface

The sinking is automatic. No curation needed. Time does the organizing.

### 37.3 Phase 3 — Reference

People begin creating projection branches that reference the sunken historical filaments:

- **Political analysis** = a light blue projection branch with evidence twigs reaching into buried policy, law, and election filaments. Decision nodes encode the analyst's interpretive framework.
- **Religious scholarship** = a light blue projection branch with evidence twigs reaching deep into ancient root strata. Different denominations are different projection branches over the same source filaments, with different decision nodes.
- **Scientific review** = a light blue projection branch aggregating observation filaments from multiple research trees, with methodology decision nodes.
- **Journalism** = a light blue projection branch connecting current events to historical context, with editorial decision nodes visible.

The truth filaments don't care which projection reads them. A historical event from 1000 CE can be referenced simultaneously by a Christian projection, an Islamic projection, a secular historical projection, and a political science projection. Each projection has its own decision nodes. The truth underneath is shared.

### 37.4 Phase 4 — Native Creation

Instead of posting on Twitter and then importing to Relay, people begin posting Notes directly:

- A journalist posts a Note on the relevant globe location. Someone responds. It becomes a filament. The story is born natively in the tree.
- A politician posts a policy Note on the governance branch. Discussion begins. Evidence is attached. The policy debate lives on the tree from inception.
- A scientist posts an observation Note. Peer review happens as commits. The finding is a native filament with full evidence chain.

The 2D platform becomes unnecessary for new content. Import continues for historical backfill.

### 37.5 Phase 5 — Complete

All new content is native. All old content is archived in roots. The transition is complete:

- **Politics** is not a separate system — it is a set of projection branches on governance truth, with competing interpretive frameworks visible as different decision node configurations.
- **Religion** is not a separate institution — it is a set of projection branches on historical and cultural truth, with theological frameworks as visible decision nodes.
- **Science** is not a separate publication system — it is a set of projection branches on observational truth, with methodology as visible decision nodes.
- **News** is not a separate industry — it is the real-time bark arriving on truth branches worldwide, with editorial projection branches competing to contextualize it.

The 2D internet becomes the legacy data source — referenced by root-level evidence twigs, the way we reference archaeological artifacts today. Future generations will dig through the roots and find the internet era as a stratum of compressed historical record.

---

## 38. Module Discovery Architecture — Frozen Contract #141

> *"The only way to do great work is to love what you do."* — Steve Jobs

Relay does not have three stages. It has modules — an open-ended, ever-growing set of capabilities that users discover, learn, and unlock individually. There is no Stage 1 user and no Stage 3 user. There is only a user who has demonstrated understanding of certain capabilities and has not yet discovered others. A CFO who masters three-way match reconciliation and a teenager who masters sword-based spell dueling have each learned something real. Neither is "ahead." They learned different modules.

The rigid "Stage 1 → 2 → 3" terminology that appeared in earlier drafts is superseded by this section. Where other sections reference "Stage Gate: 1→2→3," read that as "Prerequisites:" — a list of modules that must be understood before the next capability becomes available. The three conceptual layers (Truth, Interaction, Game) remain as useful vocabulary for describing what a module does, not as access gates that restrict when someone can do it.

### 38.1 How Modules Work

A **module** is any coherent capability within Relay. Filing a spreadsheet row is a module. Casting a fire spell is a module. Running a three-way match is a module. Summoning an SCV combat agent is a module. Each has:

- **Prerequisites**: Other modules whose physics the user must demonstrably understand. A spell requires understanding evidence commits, confidence physics, and SCV interaction. But if a user intuitively grasps all three on day one, the spell module is available on day one.
- **Demonstrated competence**: The system does not ask "have you reached Stage 3?" It asks "can your SCV confirm that your interaction matches the physics laws for this module?" If yes, the module is yours.
- **Evidence of understanding**: The user's SCV captures the demonstration. The interaction IS the evidence. It becomes a filament on the user tree with full proof chain. This is not a badge or a trophy — it is a commit.

There is no promotion ceremony. There is no notification that says "Congratulations, you've reached Stage 2." The user simply does something, the system recognizes it, and new capabilities become available. They may not even notice the transition.

### 38.2 The Three Conceptual Layers (Vocabulary, Not Gates)

Modules naturally cluster into three conceptual layers based on what they interact with. These are descriptions, not restrictions:

| Layer | Name | What it means | Examples |
|-------|------|---------------|---------|
| **Truth** | Data substrate | Modules that record, verify, and govern facts | Trees, filaments, bark, governance, projections, presence, accounting, templates, weather |
| **Interaction** | AR communication | Modules that use cameras, video, gestures, physical objects, and light as interfaces to the tree | Video AR overlay, SCV graphics, gesture/light/object detection, physical object mapping |
| **Game** | Gamified reality | Modules that render real-world challenges as quests, monsters, spells, and duels | Genre templates, spell mechanics, monster economy, combat, arena atmosphere |

A Game-layer module always resolves to Interaction-layer rendering which always resolves to Truth-layer filament commits. A spell cast in a duel is rendered as AR graphics, and the underlying SCV action produces a filament commit with evidence. Remove the Game layer and the Interaction layer still works. Remove the Interaction layer and the Truth layer still works. This is the enhancement principle — each layer enriches the ones beneath it, never replaces them.

But this is architectural dependency, not access control. If a user understands the prerequisite chain all the way from Truth through Interaction to Game, nothing stops them from operating at the Game layer immediately.

### 38.3 Module Prerequisite Map

Every section in this document defines one or more modules. Instead of assigning a "stage number," each has prerequisites — the modules whose physics must be demonstrably understood first.

| Section | Module | Prerequisites | Layer |
|---------|--------|--------------|-------|
| §0-§3 | Tree, Branch, Trunk | None — foundational | Truth |
| §4 | Filament lifecycle | Tree structure | Truth |
| §5 | Notes | Filament lifecycle | Truth |
| §6 | Projections | Filament lifecycle, confidence | Truth |
| §7 | Social Layer | Filament lifecycle, notes | Truth |
| §8 | User Tree | Filament lifecycle | Truth + Interaction + Game (expands) |
| §9 | Confidence Physics | Filament lifecycle | Truth |
| §10 | Pressure Physics | Confidence, slabs | Truth |
| §11 | Parametric Governance | Voting, confidence | Truth (expands to Game for monster economy lever) |
| §12 | Filter Tolerances | Tree rendering | Truth |
| §13 | Stigmergic Coordination | Twigs, user tree | Truth |
| §14 | Gravitational Time | Filament lifecycle | Truth |
| §15 | Time Scrubbing | Gravitational time | Truth |
| §16 | AI and SCV | Filament lifecycle, projections | Truth (expands: + AR overlay, + spell validation) |
| §17 | Presence System | Proximity, user tree | Truth (expands: + video sphere, + arena) |
| §18 | Flow Channels | Filament lifecycle | Truth |
| §19 | Governance | Confidence, voting | Truth |
| §20 | Cryptographic Architecture | Filament lifecycle | Truth |
| §21 | Templates | Tree, filament, governance | Truth (expands: + genre overlays) |
| §22 | Fractal Scaling | Tree, globe metrics | Truth |
| §23-§24 | Weather, Search | Tree, rendering | Truth |
| §25-§26 | 2D Parity, Frozen Contracts | Core | Truth |
| §28-§32 | Worked Examples, Accounting | Filament, confidence, governance | Truth |
| §33 | LOD Rendering | Tree, rendering | Truth |
| §34-§37 | Use Cases, Migration | Various truth modules | Truth |
| §39 | AR Interaction | Presence, SCV, user tree | Interaction |
| §40 | Genre Overlays & Quests | AR interaction, spell engine, templates | Game |
| §41 | Multi-Resource Economy | Achievements, governance | Interaction (expands: + monster economy) |
| §42 | Duels | Evidence debate: confidence, voting. Spell combat: spell engine, genre overlays | Interaction → Game |
| §43 | Spell Taxonomy | Element detection, light communication, SCV, AR overlay | Game |
| §44 | Founder Key | Global threshold detection | Special governance primitive |
| §47 | Voice Pipeline | SCV, user tree | Truth (expands: + gesture fusion, + incantations) |
| §48 | Engineering Infrastructure | Core | Truth |
| §50 | Camera Controller | Globe | Truth |
| §51-§57 | Scheduling through Adoption Tiers | Various truth modules | Truth |

### 38.4 How Discovery Works

**Personal discovery.** Every capability is pre-defined at system launch with its prerequisite chain. Users find them by doing things. Nobody tells you "now try reflecting light off a blade." You try it. Your SCV captures it. If the captured interaction matches the physics laws defined for that module, the module becomes available. The demonstration IS the evidence, recorded as a filament on your user tree.

**No promotion, no announcement.** The system does not celebrate unlocks. It does not show a progress bar toward "Stage 2." It simply makes new capabilities available when prerequisites are met. Some users will never discover certain modules. That is fine. A farmer managing crops has no need for spell mechanics, and spell mechanics have no need for crop management.

**Community discovery.** Some modules require not just individual understanding but community-wide adoption thresholds. Parametric governance detects sufficient participation. These thresholds are system parameters governed by the community itself.

**Founder key.** Certain global-impact modules (specifically: the monster economy lever, global combat parameters, spawn rate/reward/difficulty curves) require explicit activation by the founder account (Eitan Asulin). This is not a "Stage 3 gate." It is a safety mechanism for modules that fundamentally change the global economic model. The founder key is a single governance primitive — the system can be READY but will not activate these specific modules until the key is turned.

### 38.5 Open-Ended Growth

This is the critical difference from the old stage model. There is no Stage 4 to reach, because there are no stages. There are only modules. New modules get added forever through:

- **Community proposals**: Any user can propose a new module. It enters as a projection (light blue) on the governance tree. Community votes on adoption.
- **Council review**: Proposed modules that pass community vote are reviewed for physics consistency (does this module violate any frozen contract?).
- **Founder approval**: Modules that affect global economic parameters require founder sign-off. All others require only council + community consensus.
- **Git-style versioning**: Accepted modules merge into the system. They have version numbers, changelogs, and dependency declarations — just like code merges into a repository.

Monster worlds to explore on Jupiter get added when someone proposes them, the community wants them, and the council verifies they don't break existing physics. A new spell element gets added when someone demonstrates a real-world detection that the system doesn't recognize yet and proposes it. A new business template gets added when an industry contributes its domain knowledge.

The tree grows forever. The system never stops discovering what it can be.

### 38.6 Module Capability Expansion Table

Modules that expand across layers gain additional capabilities as prerequisites are met. This replaces the old "cross-stage mechanics" table:

| Module | Truth Layer | + Interaction Layer | + Game Layer |
|--------|-------------|--------------------|--------------------|
| **SCV** | Proposes commits, builds projections | + AR overlay, gesture/light/object interpretation, achievement validation | + spell validation, monster generation, summoned combat agents |
| **Presence** | Attention sensor, markers, birds/flocks | + video sphere, camera feed, shared AR view | + arena presence, audience energy, cross-planet video |
| **User Tree** | Responsibility mirror, CV shape | + achievement records, demonstrated capability state | + spell library, quest log, combat record |
| **Templates** | Domain config, attribute bindings | + AR asset catalogs per template | + genre overlay (Sci-Fi/Fantasy/Horror/Military/Adventure) |
| **Resources** | Magnitude (money) only | + engagement credits, achievement tokens, capacity limits | + monster economy lever (spawn/reward/difficulty) |
| **Duels** | N/A | Evidence debate (structured public argument, community voted) | + spell combat, genre overlay, summoned SCV agents, element-based magic |
| **Voice** | Voice commands (speak → Whisper → Architect → Canon → propose) | + voice fused with gesture/light/object signals | + spell incantations as multi-element activation sequences |
| **Governance** | Parametric voting, migration, thresholds | + achievement prerequisites, personal unlock governance | + monster economy parameters, founder key activation |
| **Sonification** | Audio attribute bindings (volume, pitch, timbre, rhythm, spatial) | + AR-rendered sound effects in video presence | + arena atmosphere, spell sound effects |
| **Detection** | Personal device camera only | + detection mesh (surveillance cameras, phones, city infrastructure) | + full distributed mesh as game arena sensor network |
| **Power** | N/A | N/A | Earned through physical element interaction, spent on spells, cannot buy governance |
| **Cards** | N/A | N/A | Physical trading cards as spell catalysts via perceptual hash registry |

**Contract #141 — Relay has no stages, only modules. Every capability is individually discoverable through demonstrated competence, not through tier membership. New modules are added forever through community proposal, council review, and git-style versioning. No module is "higher" than another — complexity of prerequisites does not imply hierarchy. The system grows indefinitely. Where earlier sections reference "Stage Gate: 1→2→3," read "Prerequisites:" instead.**

---

## 39. AR Interaction & Personal Achievement Modules

### 39.1 Video Presence with AR Overlay

Users communicate through video within their user sphere (the camera view). The AR interaction modules add AI-generated graphics to this video feed in real-time:

- **Pre-designed graphic assets**: Users design visual tools, diagrams, annotations, data displays in advance and catalog them in their personal SCV library
- **Voice/gesture summoning**: Users call assets by name or gesture — "show the Q3 revenue chart" or a hand movement mapped to a specific graphic
- **Real-time rendering**: The SCV agent overlays the graphic onto the user's video feed, positioned and scaled contextually
- **Shared view**: Other participants in the conversation see the same overlay

The user's personal SCV agent is a trained assistant that knows their visual vocabulary, their preferred graphic styles, and their library of pre-designed assets.

### 39.2 Physical Object Interfaces

The interaction layer extends beyond voice/gesture to physical objects:

- A **sword blade** mapped to the user's filament tree — reflecting light from the 30% mark produces different data than the 80% mark or the tip
- Any physical object can become an interface if the user trains their SCV to recognize it
- The camera detects object position, angle, reflected light, and maps these to data actions
- Objects become controllers for navigating, querying, and commanding the tree

### 39.3 Light-Based Communication

Camera detection of reflected light becomes a new input modality:

- Light reflected toward the camera at different angles encodes different signals
- Different objects (mirrors, blades, glass, water) produce different light signatures
- The SCV interprets these signals as commands within the trained vocabulary
- This creates a new language for human-AI communication that works through optics rather than speech or text

### 39.4 Body Interface — Hands, Fingers, and the Personal Gesture Cipher

> *"The hand is the visible part of the brain."* — attributed to Immanuel Kant

The blade is a mapped object. The card is a mapped object. But the body itself — the hands, the fingers, the temple, the posture — is the first and most intimate interface. Every human has ten fingers, two palms, and a face. These are the original input devices. Relay treats them as such.

#### 39.4.1 Fingers as Branches

Each finger is a branch on a personal somatic tree — a body-mapped overlay on the user's tree:

```
LEFT HAND                              RIGHT HAND
┌─────────────────────┐    ┌─────────────────────┐
│ L5: Pinky            │    │ R1: Thumb            │
│ L4: Ring             │    │ R2: Index            │
│ L3: Middle           │    │ R3: Middle           │
│ L2: Index            │    │ R4: Ring             │
│ L1: Thumb            │    │ R5: Pinky            │
└─────────────────────┘    └─────────────────────┘
```

The user assigns categories, topics, or active projects to each finger. These assignments are filaments on the user's equipment branch — evidence-bearing, timestamped, changeable:

| Example Assignment | Finger | What It Means |
|-------------------|--------|--------------|
| `finances` | L1 (left thumb) | Raising left thumb = "show me my finances branch" |
| `health` | L2 (left index) | Tapping left index to temple = "query health records" |
| `work.project-alpha` | R2 (right index) | Pointing right index at screen = "navigate to Project Alpha" |
| `family` | L5 (left pinky) | Left pinky flash = "switch context to family tree" |
| `arena.loadout` | R1 (right thumb) | Right thumb up = "ready for combat" |

**Counting as command.** Holding up 1, 2, 3... fingers is a numeric input. Combined with a zone context (which hand, which prior gesture set the context), counting becomes parametric: "3 fingers on left hand after pointing at treasury = show me the last 3 months of expenses."

**Finger combinations are compound selectors.** Touching thumb to index = select. Thumb to middle = expand. Thumb to ring = collapse. Thumb to pinky = close/dismiss. These are the default mappings — every user can remap them.

**Palm and sole lines as branch ledgers.** The physical lines on your hands and feet ARE readable as branch structures. The creases on your palm form a unique tree — life line, heart line, head line, fate line — these are natural branches with natural intersections. With a close camera or AR glasses, the SCV maps these lines as a data visualization surface: information rendered along your own skin's natural geometry. Your palm becomes a dashboard. A quick glance at your open hand shows your active branches laid along your actual palm lines — finances along the life line, health along the heart line, work along the head line. No phone required. No holographic projection. The information layer maps directly to the physical object that is your body. Feet work the same way — the lines on your soles are readable surfaces when the camera or glasses can see them. This is the endgame of Relay's body interface: you no longer need an external screen. You ARE the screen. The physical lines you were born with become the navigation structure of your personal tree.

#### 39.4.2 The Personal Gesture Cipher — User-Defined Sign Language

This is the deepest personal encryption layer in Relay.

Every user can define their own gesture vocabulary — a private sign language known only to them and their SCV Canon. The SCV learns through training:

1. **Define a gesture.** The user performs a hand movement in front of the camera and tells the SCV what it means: "This gesture means 'commit the current draft.'" The SCV captures the movement as a skeletal keyframe sequence.
2. **Train through repetition.** The user performs the gesture 5-10 times with natural variation. The SCV builds a recognition model specific to this user's hand proportions, speed, and style.
3. **Assign the command.** The gesture maps to an IntentPacket (§47.3): a structured action (navigate, query, commit, cast, select, dismiss, etc.) with optional parameters.
4. **The cipher is sealed.** The gesture-to-command mapping is stored as a filament on the user's SCV training branch. The recognition model is local to the user's device. Nobody else's SCV recognizes these gestures.

**Why this is encryption:**

- The gesture vocabulary is unique per user. Two users can make the same hand movement and it means completely different things.
- The recognition model is trained on one person's body mechanics. Even if someone copies the gesture, their hand proportions, timing, and micro-movements differ — the SCV rejects the copy as low-confidence.
- The mapping is not stored on any server in plaintext. The gesture → command association is encrypted under the user's key, stored as evidence on their training branch.
- An observer watching a user gesture in public sees hand movements. They cannot decode the commands without the user's trained SCV model. It is visual encryption — meaning hidden in motion.

**Template gesture sets:**

For users who don't want to invent their own language, Relay provides template gesture sets:

| Template | Based On | Use Case |
|----------|----------|----------|
| `gestures.asl.v1` | American Sign Language (ASL) alphabet + common signs | English-speaking users who want a familiar base |
| `gestures.bsl.v1` | British Sign Language | UK users |
| `gestures.jsl.v1` | Japanese Sign Language | Japanese users |
| `gestures.isl.v1` | International Sign | Cross-cultural default |
| `gestures.tactical.v1` | Military hand signals | Arena/combat-oriented users |
| `gestures.music.v1` | Conductor gestures | Live performance, music generation (§106) |
| `gestures.custom` | Empty — user builds from scratch | Maximum personalization |

Template sets provide a starting vocabulary. Users extend, override, or replace any mapping. The template is the seed; the personal cipher is the tree that grows from it.

#### 39.4.3 Hand Connection Points — Nunchaku Channels

The body has natural connection points where gesture input has elevated semantic weight:

| Connection Point | Gesture | Default Semantic |
|-----------------|---------|-----------------|
| **Fingertip to temple** | Touch finger to side of head | Query / remember / think — SCV searches the branch assigned to that finger |
| **Fingertip to palm** | Touch finger to opposite palm | Commit / place / deposit — write data to the assigned branch |
| **Palm to palm** | Press palms together | Sync / merge / consolidate — reconcile two branches |
| **Fist** | Close hand | Lock / protect / shield — defensive posture or privacy seal |
| **Open hand flash** | Spread fingers suddenly | Broadcast / release / publish — push data to public visibility |
| **Finger to lips** | Single finger to mouth | Silence / encrypt / private — suppress broadcast on current context |
| **Both hands clasped** | Interlocked fingers | Bond / contract / agree — initiate or confirm a TransferPacket |
| **Finger gun** | Index + thumb extended | Select / target / aim — precision selection of a distant object |
| **Crossed arms** | Arms crossed over chest | Refuse / reject / block — deny incoming request or spell |

**Nunchaku principle:** Like nunchaku connected by a chain, the hands create meaning through the space between them and the way they connect. The chain is the intent — the movement between positions carries as much information as the positions themselves. A slow palm-to-palm press is "careful merge." A fast slam is "force consolidate." The SCV reads the dynamics, not just the poses.

#### 39.4.4 Secret Communication

In a room full of people, you can issue complex Relay commands through gestures that look like normal fidgeting. Resting your chin on your thumb while tapping your index finger on your cheekbone could mean "run the quarterly audit on my finances branch." Nobody around you knows a command was issued. Your SCV does.

This is the personal encryption layer the founder describes. Each user's Canon is uniquely trained by their body, their habits, their vocabulary of motion. Two users sitting side by side can issue completely different commands through gestures that look identical to an observer. The meaning is in the training, not the movement.

**In arena combat:** Gesture commands are faster than voice or blade — your hands are always available, always fast. A duelist who has trained 200 hand gesture commands can issue spell combinations in 0.3 seconds with finger sequences that no observer can decode. The opponent sees hands moving but doesn't know whether it's an attack, a defense, a summon, or a bluff.

**In everyday life:** Gesture commands replace typing, clicking, and voice for users who master them. Walking down the street, a quick finger sequence tells your SCV to commit your morning notes, check your health branch, and set a reminder — all without pulling out a phone or speaking a word.

**The training filament:** Every gesture training session is a filament on the user's SCV training branch. Evidence: the video of the user performing the gesture. This means the user can review their own gesture history, see how their vocabulary has evolved, and share gesture definitions with trusted contacts (who would still need to retrain their own SCV on their own body mechanics).

#### 39.4.5 Branch Pull — The Body as Trunk

The body is not just an input device. It is the trunk. Branches grow from it.

**The pull gesture:** Reach to a body anchor point (palm, temple, forehead, chest, shoulder). Pinch or grip as if grasping something. Draw your hand outward. In AR (glasses or camera-rendered overlay), a branch emerges from that point on your body — growing in the direction you pull, rendering in real time as the SCV populates it with the associated data.

```
ANCHOR POINT HIERARCHY (sensitivity ranked):

Palm (center)        — Highest sensitivity. Most intuitive.
                       Pull from your open palm: your favorites branch,
                       your most-used tree, whatever you've assigned.
                       The palm already has lines that serve as branch
                       geometry (§39.4.1). Pulling from a specific
                       palm line selects the branch mapped to that line.

Temple (left/right)  — Second highest. Associated with thought, memory,
                       recall. Pull from temple: query branches, search
                       results, knowledge, SphereCore navigation (§103).
                       Pulling from the temple while describing what you
                       imagine you see — the SCV listens, searches, and
                       populates the emerging branch with matching content.

Forehead (center)    — Focus, intention, planning. Pull from forehead:
                       projections, future plans, governance votes,
                       goal tracking. The "third eye" point for
                       forward-looking data.

Chest (heart)        — Emotional, relational. Pull from chest:
                       family branch, relationships, personal milestones,
                       companion trees (§17.4).

Shoulders            — Responsibilities. Pull from shoulder:
                       work branches, obligations, team assignments.
                       Left shoulder / right shoulder can map to
                       different professional contexts.

Fingertips           — Precision selection. Pull from a specific
                       fingertip: the branch assigned to that finger
                       (§39.4.1). Fine-grained navigation.

Wrists               — Equipment, tools, combat loadout. Pull from
                       wrist: weapon registration, device profiles,
                       arena configuration.
```

**Narrated population:** While pulling a branch, you can speak or gesture to describe what you want to see. "Show me the last month of health data" — the SCV hears the narration, interprets the intent, and renders the branch content as it emerges. The branch is not empty scaffolding. It populates in real time as you describe what you imagine seeing. The SCV is the renderer. Your imagination is the query. The pull gesture is the trigger.

**Persistent assignments:** Each anchor point maps to a branch assignment stored as a filament on your equipment branch. Pull from left palm always renders your finances branch until you reassign it. Pull from right temple always runs a knowledge query. These are stable, personal, and changeable — your body's tree structure adapts to your life over time.

**The hierarchy is not arbitrary.** Palms and temples are ranked highest because:
- Palms are the most dexterous, most camera-visible, most frequently used body part. Every culture associates open palms with offering, showing, presenting.
- Temples are universally associated with thought, memory, headache (cognitive load), wisdom. Touching your temple while thinking is a cross-cultural gesture that predates recorded history.
- The entire body CAN be an interface — but these two points are where humans already instinctively reach when they want to show something (palm) or think about something (temple). Relay maps data to where the body already expects it.

**Contract #298 — Body Interface & Personal Gesture Cipher. The user's body (hands, fingers, posture, connection points) is a registered input device with camera-tracked positional encoding. Users define personal gesture vocabularies trained exclusively on their own body mechanics, stored as encrypted filaments on their SCV training branch. Gesture-to-command mappings are unique per user and constitute a personal encryption layer — the same movement means different things for different users. Template gesture sets (ASL, BSL, JSL, ISL, tactical, music, custom) provide starting vocabularies that users extend or override. Recognition models are local to the user's device. The body is the trunk: branches are pulled from anchor points (palm, temple, forehead, chest, shoulders, fingertips, wrists) via a draw gesture, rendered in AR as emerging data branches populated in real time by the SCV. Palm lines serve as branch ledger geometry. Narrated population allows users to describe what they imagine seeing while pulling — the SCV interprets and renders. Anchor point assignments are persistent filaments on the equipment branch. The body interface, branch pull interaction, and palm line ledger are frozen as interaction modalities; individual gesture vocabularies and anchor assignments are sovereign to each user.**

### 39.5 Personal Achievement System (formerly §39.4)

All achievements are pre-mapped at system launch. Discovery is organic:

- Achievements span interaction capabilities (light reflection, gesture vocabulary, object mapping, graphic design quality, combat readiness)
- Each achievement requires the SCV to validate the user's action against the pre-defined physics law
- Evidence is the captured interaction itself — video, SCV confirmation log, physics match score
- The achievement is recorded as a filament on the user tree with full evidence chain
- Unlocked capabilities are progressive — each achievement enables access to the corresponding module mechanics

The system never tells users what achievements exist. Users discover them through exploration, experimentation, and community sharing. The achievement tree is a personal journey.

### 39.6 Detection Mesh — Distributed Camera Network (formerly §39.5)

The detection mesh expands the single-camera model into a distributed network where every Relay-authorized camera contributes to the system:

**Camera types in the mesh:**
- **Personal device camera** (phone, laptop, AR glasses) — the baseline sensor, always available
- **Surveillance cameras** whose owner has granted Relay access (library, store, office, public square)
- **Other users' phone cameras** in Relay presence mode (contributes to mesh if user consents)
- **City infrastructure cameras** that municipal authorities have Relay-authorized
- **Venue cameras** at Relay-aware businesses (bars, arenas, schools, hospitals)

**Multi-source corroboration:** When multiple cameras capture the same action from different angles, detection confidence increases. A spell cast in Times Square with 200 cameras has near-perfect confidence. A card held up in a library captured by 5 cameras from different angles is far harder to fake than a single phone camera.

**Social accountability:** The same detection mesh that sees spell cards and light reflections detects everything else. Authorized cameras at schools detect fights. Hospital cameras detect patient distress. City cameras detect infrastructure failures. The detection creates filaments. The filaments show evidence gaps. The evidence gaps create pressure. The pressure makes inaction visible. Resolution requires evidence commits showing the issue was addressed.

**Zone authorization rules:** Each Relay-authorized zone sets its own detection parameters:
- A hospital might enable presence detection only (who is where), disable spell detection
- A gaming arena might enable full detection with maximum sensitivity
- A school might enable safety detection, disable recreational features
- A library quiet zone might disable audio detection, keep visual only

These are branch-level governance parameters for the zone, voted on by the zone's stakeholders.

**Consent model:**
- Camera owners authorize their cameras by connecting to Relay's mesh (administrative decision, revocable at any time)
- Users consent to being detected by having Relay presence active (disable presence = invisible to mesh)
- Non-Relay users and people with disabled presence are NEVER processed (frozen contract #40)
- The mesh sees physical reality but only processes consenting Relay entities

This detection mesh is what turns physical spaces into Relay-active zones where actions have digital consequences. Every authorized space becomes a potential game zone, social accountability zone, or governance arena — not because someone installed special equipment, but because existing cameras are now Relay sensors.

### 39.7 Video Conferencing — The Camera Awareness Protocol — Contract #318

> *"The camera is the most powerful tool. People just don't know they're holding one."* — Eitan Asulin

Video conferencing in Relay is not a separate feature bolted onto a tree system. It IS the detection pipeline operating in real-time between two or more users. When you video-call someone in Relay, you are activating the same camera detection layer (§39.1-39.6) that powers AR overlays, gesture recognition, light detection, and spell casting. The call is the detection session.

#### 39.7.1 Video Calling and the Training Disclosure

Most users will use Relay video calling as a normal video call — face-to-face conversation with their contacts, like any other platform. Video calling is JUST video calling. The camera shows your face, transmits your video to participants, and that is all.

**Training is a separate, explicit opt-in.** SCV training on face, hands, posture, voice cadence, and environment does NOT happen automatically when a user activates video. Training must be specifically selected by the user on top of video activation. The two are distinct actions:

1. **Video ON** — Camera activates. Video feed transmits to call participants. Standard video call. No SCV training. No gesture mapping. No environmental cataloguing. Just video.
2. **Training ON** (separate toggle, clearly labeled) — User explicitly enables SCV training mode. Only now does the SCV begin learning face patterns, hand gestures, posture, voice cadence, and environmental objects. The training indicator (amber ring) appears immediately. Training data is encrypted filaments on the user's own SCV branch, processed locally (T0/T1), never transmitted to servers (§39.6, frozen contract #40).

**Full disclosure at the training opt-in.** When a user first toggles training ON, Relay presents a clear explanation:
- What training does (SCV learns your personal patterns for voice commands, gesture shortcuts, object recognition)
- What data is collected (face, hands, posture, voice, environment — all local, all encrypted)
- What it enables (voice commands, gesture control, AR overlays, and eventually the full detection pipeline)
- That training can be turned off at any time, and all training data can be deleted from the user's SCV branch

**The fog lifts naturally (§81.9.2), but training is always the user's choice.** A user at Conceptual LOD C0 (PERSONAL) sees video calling. When Relay suggests training as a feature ("Enable voice commands during calls?"), the user decides whether to opt in. At C1 (TEAM) they may discover gesture shortcuts — but only if they previously enabled training. At C2 (ORG) they discover the full detection pipeline. The fog reveals capabilities progressively, but the user must choose to activate training at each level. No capability activates without explicit consent.

#### 39.7.2 Camera Awareness — The Filming Indicator

**When is Relay using the camera?**

Relay must be unambiguous about camera state. The user must always know:

| Camera State | Visual Indicator | What Is Happening |
|-------------|-----------------|-------------------|
| **OFF** | No indicator. Camera hardware LED off. | Camera is not accessed. No detection, no training, no processing. |
| **CALL ACTIVE** | Green ring around the user's video feed + subtle green dot in system tray | Standard video call. Video only. No SCV training, no gesture processing, no environmental mapping. Remote participants see the user's video. |
| **TRAINING ACTIVE** | Amber ring + amber dot in system tray | User has explicitly enabled SCV training. SCV is learning face, hands, posture, voice, environment. Can be active during a call or standalone. Always a separate opt-in from video. |
| **DETECTION ACTIVE** | Amber ring + white detection icon in system tray | Camera is feeding the detection pipeline (gesture, object, light) for AR/spell/combat use. Requires prior training. The user has explicitly enabled detection mode. |
| **MESH CONTRIBUTING** | Amber ring + blue mesh icon | Camera is contributing to the detection mesh (§39.6). Other Relay devices can corroborate signals. User opted in explicitly. |
| **RECORDING** | Red ring + red dot + "REC" label | The session is being recorded as evidence filaments. Occurs during arena matches, formal governance meetings, or user-initiated recording. All participants are notified. |

**The invariant:** The camera hardware LED is ALWAYS accurate. Relay cannot override the OS-level camera indicator. If the green LED is on, Relay is accessing the camera. If it is off, Relay is not. There is no "silent camera" mode. There is no background camera access without the hardware indicator.

**The filming transparency rule:** Any video call or detection session that produces filaments (evidence, training data, meeting records) is indicated by the RECORDING state. Participants in a call see a shared indicator: "This session is being recorded as filaments on [branch name]." Recording cannot be hidden. Recording by one participant without others' knowledge produces a procedural violation scar on the session branch.

#### 39.7.3 Video Call Architecture

A Relay video call is not a separate protocol. It is a **shared detection session** between two or more users:

```
VideoCallSession {
  sessionId:        hash,
  participants:     userRef[],
  startTime:        ISO-8601,
  detectionLevel:   VIDEO_ONLY | TRAINING | GESTURE_DETECTION | FULL_DETECTION,
  trainingEnabled:  boolean,       // user explicitly toggled training ON
  trainingDisclosureAcked: boolean, // user acknowledged the training disclosure
  recordingState:   NONE | PARTICIPANT_INITIATED | GOVERNANCE_REQUIRED,
  arOverlayActive:  boolean,
  meshContributing: boolean,
  branchRef:        filamentRef    // the meeting/call branch where evidence commits
}
```

**Detection levels are explicit opt-ins, revealed by fog:**
- **VIDEO_ONLY**: Default. Standard video call. No SCV training or detection. Camera shows video, nothing more.
- **TRAINING**: User has explicitly enabled SCV training (§39.7.1). SCV learns patterns from face, hands, posture, voice, environment. Voice commands become available. Amber indicator always visible.
- **GESTURE_DETECTION**: User has explicitly enabled gesture processing on top of training. SCV processes hand gestures near the camera for AR overlays and shortcuts. Requires prior training opt-in.
- **FULL_DETECTION**: User has explicitly enabled the complete detection pipeline. Full body interface (§39.4), object detection (§39.2), light detection (§39.3). Requires prior gesture detection opt-in.

Each level is a separate, conscious choice by the user. The fog (§81.9.2) determines when Relay *offers* the next level — but the user must accept. A user at C0 sees video calling. When fog lifts to C1, Relay offers the training toggle with full disclosure. When fog lifts to C2, Relay offers gesture detection. No level activates without the user specifically selecting it.

#### 39.7.4 What This Means for Adoption

Video calling is Relay's entry point. A user who joins Relay for video calls — because the quality is good, the shared tree navigation is convenient, the interface is familiar — encounters the system as a normal communication tool. The deeper capabilities are revealed progressively through fog, and each capability requires the user's explicit opt-in.

**The sequence:**
1. User joins for video calls (looks like Zoom/Teams). Just video. No training, no detection.
2. Relay offers training toggle with full disclosure: "Enable voice commands? Your SCV will learn your voice and gesture patterns locally."
3. User opts in to training. Voice commands become available. SCV begins learning — with amber indicator always visible.
4. Relay offers gesture detection: "Enable gesture shortcuts during calls?" User opts in. Wave to dismiss, point to select.
5. Relay offers full detection: object and light recognition (§39.2, §39.3). User opts in.
6. User discovers the game layer (spells, combat, arena) — and their SCV has been training since they opted in, with full awareness.
7. The Awakening Curve (§99) in action: each step feels like natural discovery, and each step was the user's informed choice.

**Contract #318 — Video Conferencing & Camera Awareness Protocol. Video calling in Relay uses the same camera detection layer but SCV training is a SEPARATE, EXPLICIT opt-in on top of video activation. Video ON means video only — no training, no gesture mapping, no environmental cataloguing. Training ON is a distinct toggle requiring full disclosure of what is collected (face, hands, posture, voice, environment), how it is processed (locally, T0/T1, never transmitted), and what it enables (voice commands, gesture control, AR overlays, detection pipeline). Detection levels are explicit opt-ins revealed by fog: VIDEO_ONLY (default) → TRAINING (user opts in with disclosure) → GESTURE_DETECTION (user opts in) → FULL_DETECTION (user opts in). No level activates without the user specifically selecting it. Camera state must be unambiguously indicated at all times: OFF (no indicator), CALL ACTIVE (green), TRAINING ACTIVE (amber), DETECTION ACTIVE (amber + white), MESH CONTRIBUTING (amber + blue), RECORDING (red + label). The hardware camera LED is always accurate — no silent camera access. Recording requires visible indicator to all participants; hidden recording produces a procedural violation scar. Video calling is the entry point; deeper capabilities are offered progressively through fog but always require informed, explicit consent. The camera indicator system, the training-as-separate-opt-in invariant, the prohibition on silent camera access, and the recording transparency rule are frozen.**

---

## 40. The Game Layer — Quests, Monsters, and Genre Overlays

> *"Do not pray for an easy life; pray for the strength to endure a difficult one."* — Bruce Lee

### 40.1 The Motivation Problem

When the truth layer automates coordination and AR interaction gives humans magical interfaces to the tree, a structural question emerges: why work? If SCVs handle everything, if governance self-manages, if projections are AI-generated — what drives human participation?

Money remains as magnitude (the measurement channel for value), but as a motivator it breaks down when automation handles the labor. Discussion participation provides attention, but spectating automated systems is not purpose.

Humans need adventure. They need to reach for something they don't yet have. The game layer modules provide this through the gamification of reality.

### 40.2 Reality Becomes the Game

Game layer modules overlay genre templates on real-world challenges:

- A **monster on Mars** is a Martian engineering challenge (pressure seal failure, radiation shielding, resource extraction) rendered as a creature with health, weaknesses, and loot
- A **spell** cast to defeat it is an AR gesture/light command that instructs the SCV to execute a real truth-layer action (plasma welding, atmospheric processing, rover navigation)
- The **loot** is real economic value — magnitude flowing through the tree as the challenge is solved
- The **achievement** is recorded on the user tree as a proven contribution

The "battle cruiser" being built is a real spacecraft development project. But the experience of building it is a guild quest. Each subassembly is a dungeon. Each integration test is a boss fight. The experience cannot be delegated to an SCV — the human must physically be present, physically cast the spell, physically face the challenge.

### 40.3 Genre Templates

Genre is a template-level choice for how the gamification layer renders the underlying truth:

| Genre | Applied To | Aesthetic |
|-------|-----------|-----------|
| **Sci-Fi** | Space colonization, advanced engineering, deep tech | Starships, energy weapons, cyberspace |
| **Fantasy** | Conservation, agriculture, ecosystem management | Dragons, enchanted forests, elemental magic |
| **Horror** | Deep ocean exploration, hazardous environments, unknown threats | Abyssal creatures, fog, uncertainty |
| **Military** | Disaster response, infrastructure defense, large-scale coordination | Tactical operations, formations, chain of command |
| **Adventure** | Exploration, discovery, frontier expansion | Quests, maps, treasures, uncharted territory |

The TRUTH underneath is identical across all genres — filaments, evidence, commits, magnitude. The human experience of interacting with it is chosen by the community running the project.

### 40.4 Fractal Quest Scaling

The same monster/quest mechanics scale fractally:

- **Neighborhood quest**: Fix the pothole (local monster, small loot, quick fight)
- **City raid**: Build the transit system (boss battle, guild effort, multi-session)
- **National campaign**: Decarbonize the grid (epic questline, faction-scale)
- **Planetary war**: Colonize Mars (generational campaign, civilization-level rewards)
- **Galactic frontier**: Interstellar probes (open-ended, exploration-class)

Every level uses the same tree model. Same filaments. Same governance. Same truth layer. Proportionally larger monsters and proportionally larger loot.

### 40.5 Challenges Pre-Mapped

All challenges from microbe to galaxy are pre-defined at system launch:

- Every known planet and system in the Laniakea supercluster has challenge stubs
- Every underlying microbe and atom we need to uncover has a quest stub
- Society collectively establishes (via global parametric governance) what types of AI-generated monsters flow in at each scale
- New discoveries create new challenge stubs automatically as the tree grows

The challenge map is the scientific frontier of human knowledge rendered as a game world.

### 40.6 RPG Attribute Mapping — The User Tree IS the Character Sheet

The game layer does not create a separate RPG database. Your user tree — the same tree you've been building since your first tutorial — becomes your character sheet. Most RPG attributes emerge from existing tree state rather than being tracked independently:

| RPG Concept | Relay Equivalent | Source |
|---|---|---|
| Health | Tree Integrity (aggregate confidence/firmness across all branches) | Emerges from tree state |
| Mana | Power (earned through physical element interaction detected by cameras) | Game layer closed-loop resource |
| Level | Achievement milestones on user tree (Initiate, Journeyman, Knight, Champion, Architect, Artificer) | Emerges from tree state |
| Class | Element affinity (geography-driven — your environment determines your natural magic type) | Emerges from physical location |
| Skills | Discovered spells in personal spell book (element spells + card spells) | Discovery through experimentation |
| Equipment | Physical objects mapped to SCV through camera training | Training through practice |
| Inventory | Active Capacity (supply cap from multi-resource economy) | Achievement Token investment |
| Gold | Engagement Credits (base resource from any participation) | Participation |
| XP | Achievement Tokens (advanced resource from real-world validated proofs) | Real-world contribution |
| Resistances | Branch strength in specific domains (your expertise makes related challenges easier) | Emerges from tree state |
| Loot | Monster/quest rewards (Engagement Credits + Power + clues) | Governed parameters |
| Difficulty | Fractal quest scale (local → municipal → national → planetary → galactic) | Challenge location |

**Health = Tree Integrity.** Your aggregate confidence across all branches. Losing duels, making false claims, neglecting filaments — these degrade your tree, dropping your health. At severe degradation, combat modules are restricted until you rebuild. Rebuilding means doing real work: evidence filaments, close commitments, restore your tree's firmness. Health regenerates through honest participation, not potions.

**Power = Mana.** Earned through physical element interaction (camera detection of light, fire, smoke, rain, snow, wind, earth). Spent on spells. Cannot be purchased, transferred, or converted to other resources. Power capacity (maximum pool) scales with user tree size and maturity. Regenerates during the community-voted sleep cycle (see §41.5).

**Class = Element Affinity.** Your physical geographic environment determines your natural magic type. Live near water → Water spells discovered first. Hot climate → Fire spells. Mountains → Earth spells. Snowy region → Ice spells. Windy area → Wind spells. Travel to discover other elements. Specialization deepens through practice, not menu selection.

**Equipment = Mapped Physical Objects.** Quality comes from training depth, not material value. A wooden stick mapped with 50 recognized gestures outperforms a real sword with 3 gestures. Practice makes equipment legendary.

**Resistances = Branch Strength.** A doctor's user tree has natural resistance to medical challenges. A programmer's tree resists software challenges. Generalists have moderate resistance to everything. This isn't allocated — it emerges from your actual tree.

### 40.7 The Core Game Loop

1. **Wake up.** Open Relay. SCV shows: local monsters, available quests, duel challenges, daily Power regeneration from sleep cycle.
2. **Choose your path.** Go to work (truth/interaction modules — real contributions, faster resource accumulation). Hunt monsters (game layer modules — fight challenges for resources). Train (practice spells, map objects, explore for treasure). Duel (challenge someone for resources and reputation).
3. **Fight or work.** Monster combat: physically perform spell triggers while SCV translates actions into tree operations addressing the underlying problem. Monster health drops as evidence accumulates. Confidence reaching threshold = monster defeated. Loot appears.
4. **Grow.** User tree records everything. Spell book expands. Power capacity increases. Branches diversify. Achievement milestones unlock.
5. **Sleep.** Power regenerates during community-voted rest period. Tree sinks with gravitational time. New monsters spawn where old problems remain unsolved.

### 40.8 Environmental Boosts (No Potions)

Relay does NOT have stockpilable consumable items. Environmental conditions provide temporary boosts:

- Standing in rain while casting Water spells = Power cost reduced
- Being near fire while casting Fire spells = spell effect amplified
- High altitude = Wind spells boosted
- Underground/cave = Earth spells boosted
- Snow environment = Ice spells boosted

These are natural, location-based, and cannot be hoarded. You must physically be there. This drives real-world movement and exploration.

### 40.9 What Relay Does NOT Adopt From Traditional RPGs

- **No random loot generation.** Rewards are deterministic from challenge difficulty and governed parameters. No gambling mechanics. No artificial scarcity.
- **No pay-to-win / microtransactions.** Achievement Tokens only from real-world proof. Power only from physical action. Nothing can be purchased for advantage.
- **No permadeath or permanent loss.** Your tree never resets to zero. It can wilt severely, but every filament is permanent. You can always rebuild.
- **No class restrictions.** Anyone can discover any spell given the right environment and effort. Geography creates tendencies, not locks.
- **No NPC quest givers.** All quests are system-generated (from tree state analysis) or user-created (community challenges). The SCV helps you, it doesn't tell you what to do.

### 40.10 Public World Graphics Scarcity

**The public Relay world is visually clean by default.** No avatars, no custom skins, no floating graphics, no particle effects. Just trees, branches, filaments, data, and user spheres showing real video of real people.

Users have private AI image/video sandbox tools for creative work. They can create and share media freely. But in the public Relay world itself — the shared globe everyone navigates — no custom graphics appear around any user sphere by default.

**Earned public graphics are the exception.** Users who have unlocked game layer modules and perform correct physical trigger sequences (real-life movements + cards + voice incantations + element detection) get pre-programmed Relay Graphics rendered in the public world. These are the ONLY non-data visuals in the shared space. They are rare, impressive, and proof of skill.

When the audience sees fire erupting from a user sphere, that person physically performed the actions required. The scarcity of public graphics IS what makes them meaningful. A spell cast in public is a demonstrated mastery, not a cosmetic purchase.

### 40.11 Progressive Discovery — Fog of War

Nothing in Relay is explained. Everything is discovered. Every feature exists from day 1, running silently, but is invisible until the user encounters it naturally. The system reveals itself in layers:

**Layer 1 — "3D Tree Tool":** User plants a tree. Adds branches. Types data. Thinks Relay is a 3D visualization tool for organizing information.

**Layer 2 — "It's Alive":** User connects live data. Filaments appear. Things sink. Bark textures change. The live ETL nature reveals itself through use.

**Layer 3 — "Other People":** User notices presence markers. Sees other trunks. Realizes it's a shared world. The multiplayer nature reveals itself.

**Layer 4 — "The Globe Is Full":** User zooms out. Sees thousands of trunks. Cities, companies, institutions. Realizes Relay is global.

**Layer 5 — "Underground":** User scrolls below the surface. Discovers roots. Realizes everything ever committed is permanently archived. The historical depth reveals itself.

**Layer 6 — "I Can Affect Things":** User posts a sticky note. Votes on a parameter. Sees their actions change the world's trees. The governance nature reveals itself.

**Layer 7 — "My Tree IS Me":** User discovers their personal user tree. Sees their entire contribution history as a living structure. The reputation/identity layer reveals itself.

**Layer 8 — "Camera Sees Things":** User accidentally triggers an AR detection (light reflection, gesture pattern). Sees unexpected response from the system. Begins experimenting. The interaction layer reveals itself.

**Layer 9 — "Magic Is Real":** User triggers a spell (card + element + voice). Graphics appear in the public world. Monsters become visible. Treasure chests appear. The game layer reveals itself.

No tutorial for the game layer. No onboarding walkthrough for discovery mechanics. No feature list. The fog lifts as you explore. Two users who started on the same day discover different things in different orders based on their behavior. Knowledge has value — sharing discoveries creates guides, hoarding creates advantage. The system rewards curiosity. (Note: this applies to game layer discovery. Platform onboarding — how to navigate the globe, commit filaments, and use governance — is covered by §73 Universal Onboarding. Both systems coexist.)

### 40.12 Genre Emergence

Because of fog of war discovery, Relay is simultaneously every game genre depending on what the user is doing:

- **RTS**: Managing company branches, deploying SCVs across multiple fronts
- **RPG**: Building user tree, discovering spells, leveling through achievements
- **FPS**: In a duel, reacting in real time, playing instants from hand
- **MMORPG**: Zoomed out on the globe, millions of users, monsters spawning, world events
- **Puzzle**: Figuring out what light patterns mean, what cards do, what gesture triggers a spell
- **Simulation**: Running a company through Relay ETL, watching the tree respond to real data
- **Horror**: Exploring deep underground root strata, finding ancient unresolved events
- **Strategy**: Preparing evidence and card decks for upcoming duels

You don't choose a genre. You're always in multiple simultaneously. The genre emerges from your current activity and discovery state.

---

## 41. Multi-Resource Economy

> *"It is not the strongest of the species that survives, nor the most intelligent, but the one most responsive to change."* — Charles Darwin

**Prerequisites:** None for base (magnitude as single resource channel). Expands with: achievement modules → engagement credits + achievement tokens + active capacity. Founder key + combat modules → monster economy lever (spawn rate, reward magnitude, difficulty curve as governed parameters).

### 41.1 The Starcraft Model

The truth layer uses a single resource channel (magnitude/money). The interaction layer modules introduce a multi-resource economy with three distinct channels inspired by real-time strategy resource management:

| Relay Resource | Starcraft Analog | Earned From | Gates |
|----------------|------------------|-------------|-------|
| **Engagement credits** (base) | Minerals | Any participation: virtual monsters, comments, votes, commits, sticky notes | Sticky note quota, basic vote weight, basic posting capacity |
| **Achievement tokens** (advanced) | Vespene Gas | SCV-validated achievements in any context: real-world, arena, education, civic (§71.2) | Advanced vote power, commit authority, projection creation, spell catalog expansion |
| **Active capacity** (limit) | Supply cap | Investment of both base + advanced resources to expand | Max concurrent filaments, active SCVs, simultaneous spells, parallel quest slots |

### 41.2 Incentive Structure

You CAN survive on engagement credits alone by farming virtual monsters. You'll have basic functionality. But you will NEVER gain advanced capabilities (strong votes, projection authority, expanded spell catalog, larger capacity) without achievement tokens — and those come from SCV-validated achievements in any context: real-world contributions, arena victories, educational milestones, or civic service (§71.2).

This creates a permanent incentive gradient toward real contribution even when virtual participation is easier.

### 41.3 The Global Economic Lever

With game layer modules active, monster spawn rate and reward rate replace central banking mechanisms:

- **Monster spawn rate**: How many challenges flow in per unit time at each scale. Higher rate = more earning opportunities.
- **Reward magnitude**: How much value (engagement credits + achievement tokens) each monster yields. Higher magnitude = faster accumulation.
- **Difficulty curve**: How hard monsters are relative to player capability. Steeper = slower farming, shallower = faster farming.

These three parameters are set by global parametric governance (same weighted-median voting from the truth layer). Everyone votes. The parameters flex the economy the way interest rates and reserve requirements do today.

If too much wealth accumulates and engagement drops → increase difficulty, decrease rewards.
If too little activity and too many idle users → increase spawn rate, increase rewards.

Even users who do not perform physical-world labor must fight virtual monsters to earn. This ensures universal participation in the economic system while allowing the difficulty/reward balance to be democratically controlled.

### 41.4 Resource Flow Integration

All resources flow through truth layer filaments:

- Engagement credits are magnitude on activity filaments
- Achievement tokens are magnitude on achievement filaments (with SCV validation evidence)
- Capacity limits are derived from user tree state (total achievement + investment filaments)
- Resource transfers between users follow the existing double-entry TransferPacket model
- All resources are subject to the same frozen contracts (append-only, deterministic replay, Merkle roots)

No new data primitives. The multi-resource model is a categorization of existing magnitude channels.

### 41.5 Power — The Game Layer Resource

Power is the fourth resource, existing only within the game layer's closed loop:

| Property | Rule |
|---|---|
| **Earned from** | Physical element interaction detected by camera (light, fire, smoke, rain, snow, wind, earth) + correct gesture/movement sequences |
| **Spent on** | Casting spells (element spells + card spells), maintaining enchantments, summoning creatures |
| **Cannot** | Buy governance weight, purchase Achievement Tokens, transfer to other users, convert to Engagement Credits |
| **Capacity** | Maximum Power pool scales with user tree size and maturity (bigger tree = more mana) |
| **Regeneration** | Regenerates during the community-voted sleep cycle (see §41.6). Ambient regeneration from environmental element detection during waking hours. |

Power exists in a closed loop: earn through physical action → spend on spells → spells resolve to truth/interaction layer actions you already have permission to perform. Power never grants new permissions, new governance weight, or new economic advantage. It makes the same actions more dramatic and entertaining without making them more powerful.

### 41.6 Sleep Cycle Regeneration

Resource limits regenerate during a community-governed daily rest period:

- The sleep cycle **duration** is a global parameter set by weighted-median voting (e.g., 7 hours 12 minutes — voted by billions of interested users)
- The sleep cycle **timing** is regionalized by real solar position (see §14.4): sleep onset triggers when local solar altitude drops below the voted threshold (default: civil twilight at -6°), sleep end triggers at the corresponding dawn threshold. Equatorial users get a consistent window year-round. High-latitude users shift with seasons. Extreme-latitude users (above ±66.5°) fall back to a UTC-offset schedule.
- During the sleep cycle, resource limits (sticky note quota, Power pool, active capacity cooldowns) regenerate
- Users who do not rest (keep their device active continuously) hit resource ceilings and cannot regenerate
- This simultaneously: prevents bot spam (bots don't sleep), incentivizes healthy human behavior, creates a natural rate limit on all activity, and is transparently governed

The sleep duration parameter is adjustable like all global parameters. If the community votes it down to 6:45, the system adjusts. If evidence shows 8 hours is healthier and the community shifts, it shifts. The sleep onset/end solar thresholds are also votable global parameters — the community controls not just how long the rest is, but when it begins relative to sunset/sunrise.

### 41.7 Value Hierarchy Principle

**Truth layer responsibility always outweighs game layer power.** This is structural, not policy:

- A diligent auditor managing 5 companies with thousands of well-evidenced filaments has more governance weight, more economic resources, and more real influence than any game-focused wizard
- Achievement Tokens (earned from real work) gate advanced capabilities that Power (earned from gaming) cannot access
- Vote weight derives from Engagement Credits and Achievement Tokens, never from Power
- A powerful wizard in Relay is entertaining and respected. A responsible auditor holding thousands of human responsibility filaments is essential and trusted. Both are valued. Neither diminishes the other. But the tree economics ensure real contribution always yields more than virtual performance.

The game provides a comfortable living — people CAN survive by gaming well and fighting monsters through game layer modules. But truth layer work with verified evidence will always yield deeper governance weight and influence, because the evidence depth of real-world contribution naturally builds thicker, firmer branches than arena performance alone. Achievement Tokens can be earned in any context (amended contract #30, §71.2), but the validation standard (SCV-verified evidence of demonstrated skill) means real-world contributions produce richer evidence chains.

### 41.8 Anchor Allowance — The Physical-Digital Bridge

Digital presence must be justified by physical reality. A company does not receive a magic budget — its internal operating resources are earned through verified physical existence and employee participation.

**Anchor Allowance** is the EC pool an organization can use for internal operations (replenishment, filing, commits, branch maintenance). It is funded by three streams:

| Stream | Mechanism | Contribution |
|--------|-----------|-------------|
| **Employee participation** | Each employee earning EC through normal use (commits, votes, interactions) contributes a governed fraction to the org pool | Primary source — scales with real human activity |
| **Proximity channel uptime** | Being physically present with a verified proximity channel (§29) generates a base allowance per epoch | Secondary source — proves the org physically exists |
| **Public engagement** | External users interacting with the company's public content generate EC that flows to the org pool | Tertiary source — market validation |

**The key rule: no verified physical presence = no anchor allowance = no free internal operations.** An organization without a real, verified location can still exist on Relay, but every operation costs personal EC from its individual members — like a freelancer collective, not a corporation.

Anchor allowance is not unlimited. The base rate from proximity channel uptime is a global parameter (votable). Employee contribution fraction is a global parameter (votable). The allowance caps scale with verified employee count and physical site size (number of distinct proximity micro-zones), preventing a single phone hotspot from generating the same allowance as a 500-person office.

**Replenishment funding:** Branches with `replenishmentMode = AUTO` (§5 — balance sheets, directories, registries, master data) draw from the org's anchor allowance each timebox. If the allowance is depleted, replenishment pauses and those branches sink like everything else until more EC flows in. This creates a natural feedback loop: organizations that stop functioning (employees stop participating, proximity channel goes offline) see their branches sink and their surface view go stale.

### 41.9 Real-World Currency Boundary

Relay is not a currency, not a payment system, not a cryptocurrency. Real money (USD, EUR, ILS, etc.) continues to work exactly as it does today. When a company records an invoice on Relay, the `magnitude` field contains the real monetary value — Relay tracks the flow of real money as filaments, but it does not create or replace money.

**EC cannot be bought with external currency.** If EC could be purchased, wealthy actors would dominate governance — this violates the physics. Companies fund infrastructure (servers, hosting, bandwidth) with real money, but this buys compute, not EC. Real money pays for Relay the way it pays for electricity — it is an operating cost, not a governance input.

**Votes cannot be bought.** Vote weight is contextual: recency of participation, evidence contribution history, and active filament involvement on the branch (frozen contract #56). An account with no branch history carries near-zero vote weight regardless of how it was funded. Money can buy infrastructure time, marketing, employees — but not Relay governance weight.

**The one-line rule: money buys infrastructure; participation earns EC; EC enables operations; nothing buys votes.**

### 41.10 The User Wallet — What You Carry

A Relay user's resources are spread across §41, §43.11, §86.5, and §95. This subsection consolidates them into a single reference. You carry exactly five resource types. No cryptocurrency. No exchange tokens. No made-up coins with floating exchange rates.

| Resource | What It Is | How You Earn It | What You Spend It On | Can You Buy It? |
|----------|-----------|-----------------|---------------------|-----------------|
| **Engagement Credits (EC)** | Base participation currency | Any activity: commits, votes, monster farming, comments, sticky notes, civic contributions | Posting, basic voting, branch operations, capacity investment | No — never purchasable (§41.9). Participation only. |
| **Achievement Tokens (AT)** | Proven-skill currency | SCV-validated achievements in any context: real work, arena wins, education, civic service (§71.2) | Strong votes, projection authority, expanded spell catalog, capacity upgrades | No — must be earned through demonstrated skill. |
| **Active Capacity** | Concurrent operation ceiling | Investing EC + AT together to expand | Max active filaments, active SCVs, simultaneous spells, parallel quest slots | No — requires both EC and AT investment. |
| **Power** | Game-layer mana | Physical element interaction detected by camera (light, fire, smoke, wind, water, earth, ice) + correct gestures | Casting spells, maintaining enchantments, summoning creatures (§43.12), charging attacks | No — earned through physical action only. Regenerates during sleep cycle (§41.6). |
| **Crafting Tokens** | Visual identity currency | Gameplay rewards, attention income, community contribution (translations, moderation, teaching), direct purchase | Finalizing graphics in the Crafting IDE (§43.11) — images, video, sound, music, composites | Yes — the only resource with a direct purchase option, at ISR-governed rates (§86). |

**What is NOT in your wallet:**
- Real money. Relay tracks real-world currency flow as filament magnitudes but does not hold, create, or replace real money.
- Governance weight. Vote weight is computed from participation history and context (§11), not from a balance you carry.
- Reputation score. There is no number. Your tree shape IS your reputation (§9).

#### 41.10.1 Infrastructure Costs — Separate from the Wallet

Your wallet resources pay for what YOU do in Relay — casting spells, finalizing graphics, expanding capacity. Infrastructure costs are a separate layer entirely:

```
ResourceBill {
  computeCost:    Σ(server_cpu_ms × computeRate)
  storageCost:    Σ(bytes_stored × retentionPeriod × storageRate)
  renderCost:     Σ(server_gpu_ms × renderRate)
  billingPeriod:  timebox
  billedTo:       treeRef
}
```

These are **server-side measurements only.** What Relay's infrastructure does to serve you — not what your device or network does to reach Relay.

**Latency is never billed.** If your phone has bad signal and retransmits the same packet five times, that is TCP doing its job. The server received one commit, processed one filament, rendered one spell graphic. That is what gets metered. A user on rural satellite internet and a user on gigabit fiber who cast the same spell with the same crafted graphic generate identical resource costs. The slow user has a worse experience (lag, stutter, delayed activation) but they never pay more. Network quality is a quality-of-service issue, not a billing issue.

**What infrastructure costs cover:**
- **Compute:** SCV AI calls (§92 four-tier routing), filament processing, projection evaluation, summon AI decision models
- **Storage:** Filament retention, crafted graphic asset storage, archive depth
- **Render:** Spell graphic rendering on spectator devices (server-side compositing for shared views), globe rendering at high LOD

Infrastructure costs are billed per timebox, recorded as filaments on the branch's resource ledger, and visible to the user at all times (§86.5, Contract #219). Rates are Category A parameters — community-governed, transparent, and published. Heavy users pay proportionally. Light users pay almost nothing. Free-tier users (truth commits, governance, civic, health, education) pay nothing (§95.3, Contract #222).

**The complete picture:**

```
What you carry (wallet):     EC, AT, Capacity, Power, Crafting Tokens
What you pay (infrastructure): Compute, Storage, Render — metered server-side per timebox
What funds Relay (revenue):   ISR on transactions, resource pricing, download price
What you never pay for:       Latency, retransmits, device performance, network quality
```

**Contract #313 — User Wallet & Infrastructure Cost Separation. A Relay user carries five resource types: Engagement Credits (earned through participation, never purchasable), Achievement Tokens (earned through SCV-validated skill demonstration), Active Capacity (expanded by investing EC + AT), Power (earned through physical element interaction, game-layer only), and Crafting Tokens (earned through gameplay/attention/contribution, also purchasable at ISR-governed rates). Infrastructure costs (compute, storage, render) are metered server-side only — network latency, packet retransmission, device performance, and connection quality are never billed to the user. A user on slow internet pays the same infrastructure cost as a user on fast internet for identical operations. Infrastructure costs are billed per timebox as filaments on the resource ledger. Rates are Category A parameters (community-governed). The wallet/infrastructure separation is frozen.**

---

## 42. Duels — Governance Theater & Public Combat Events

> *"In the middle of difficulty lies opportunity."* — Albert Einstein

**Prerequisites:** Confidence, voting, evidence modules for base (evidence debate: two users present arguments with data visualizations, community votes on outcome, resources transfer). Expands with: spell engine + genre overlay modules → full duel with spell combat, summoned SCV agents, element-based magic, arena atmosphere with music/sound/audience energy.

### 42.1 Mechanic

A duel is a structured public engagement between two users over an issue:

1. **Challenge**: User A challenges User B on a specific issue (filament or branch). Both agree to terms: duration, resource stakes, topic scope.
2. **Arena**: Both users appear in their user spheres (video on camera). The event is classified as a public filament — visible to all, classified as an event.
3. **Performance**: Each user physically wields their interface objects (swords, etc.) and calls out spells. The "spells" are actually:
   - Evidence claims: summoning specific filaments and projections prepared in advance
   - Data analyses: calling out wind projections, correlation data, trend charts
   - Counterarguments: referencing the opponent's evidence chain weaknesses
4. **Audience**: Viewers watch, react. Music, sound, audience energy drive the arena atmosphere. The engagement rate of the event filament climbs.
5. **Resolution**: The audience determines the outcome through continuous voting and environmental metrics aggregated into the scoring calculation. Resources transfer from loser to winner based on the community's aggregate judgment. Audience influence is a toggleable attribute agreed upon in the challenge terms — when toggled ON, local crowd bias is part of the fight; when OFF, resolution is evidence-only. (See §71.3 for unified duel/arena resolution model.)
6. **Closing**: The event filament closes after the pre-set duration (adjustable by audience demand). The outcome becomes an append-only record — a historical truth filament.

### 42.2 Governance Weight

Duels have direct governance consequences:

- The community vote on a duel outcome IS a governance vote
- It can trigger migration commits (if the duel was about recategorization)
- It can establish action branches (if the duel was about a proposed initiative)
- It can transfer resources (engagement credits + achievement tokens per the stakes)
- It produces evidence filaments that future duels and projections can reference

The sword does not grant political power. The sword draws an audience. The EVIDENCE wielded through spells is what the community evaluates. Physical skill with a blade is a presentation medium, not a governance mechanism.

### 42.3 Arena Location

Duels happen anywhere on the planet or anywhere in the Laniakea Relay galaxy:

- Two users in the same room, physically facing each other
- Two users across the globe, connected via video presence
- Two users at a Mars outpost, dueling over resource allocation
- The arena is wherever the participants are — the globe renders the event at their location

### 42.4 Turn Structure (MTG-Inspired)

Game layer duels use an alternating turn structure that provides strategic depth:

1. **Preparation phase** — Both duelists set up: present land cards to establish element base, cast enchantments, declare equipment mappings. No attacks.
2. **Alternating turns** — Duelists alternate. On your turn you may: present one sorcery card OR summon one creature OR cast element spells (gestures/voice) OR present evidence/arguments. Your opponent may respond with instant cards before your action resolves.
3. **Combat** — Summoned creatures clash automatically (SCV-controlled). Creature power/toughness determines outcomes. Losing creatures dissolve.
4. **Evidence phase** — On your turn, present evidence (call out filament references, display projections, invoke data analyses). This is the intellectual substance underneath the spectacle.
5. **Resolution** — After agreed number of rounds (or concession), audience votes. The vote considers both combat spectacle AND evidence quality.

**The Stack:** When you cast a spell, your opponent can respond with an instant before it resolves. You can respond to their response. Spells chain until both pass, then resolve in reverse order (last spell first). This creates the strategic interplay where timing, card selection, and bluffing matter as much as raw Power.

**Card Advantage:** Discovering more spells (element + card) gives you more options. But having more options doesn't guarantee victory. A skilled duelist with five well-chosen spells and strong evidence defeats a wizard with a hundred spells and weak arguments. The evidence phase is where truth layer substance meets game layer spectacle.

### 42.5 Substance vs Spectacle — Two Paths to Victory

Duels are persuasion systems, not fighting games. The audience votes on who convinced them:

**The spectacle path (game layer strength):**
- Physical performance: sword work, acrobatics, element manipulation
- Card-based combat: creature summons, enchantments, combo sequences
- Visual drama: fire effects, lightning, environmental AR
- Entertainment value: keeping the audience engaged and impressed

**The substance path (truth layer strength):**
- Voice commands to a deeply trained SCV: "Show my tree," "Pull their confidence scores"
- Tree projections: displaying credentials, counterparty relationships, completion history
- Evidence-based arguments: referencing publicly verifiable tree data
- Reputation weight: tree shape communicates reliability without a word spoken

An auditor sitting on a barstool can defeat a combat-focused duelist by calmly displaying their massive, firm user tree and pointing out the opponent's unfinished filaments. The audience votes on trust, not theatrics. The auditor's "spells" are SCV voice commands and data projections — no physical movement required.

Conversely, in a gaming arena full of combat enthusiasts, spectacle might win over substance if the audience values entertainment. Context determines which path prevails. The system doesn't prescribe.

### 42.6 Proximity Channel Duels

Duels in physical proximity channels (bars, parks, offices) use the location's authorized cameras as the detection and corroboration system:

- The venue's surveillance cameras + all patrons' phones with Relay active = multi-angle detection mesh
- Both duelists' actions are captured from multiple angles with high corroboration confidence
- Spectators vote through the proximity channel — only physically present people vote
- Stakes can be purely social (loser leaves, winner gets bragging rights) with zero resource transfer
- The duel filament is permanent: challenge acceptance, turns, evidence presented, vote result, outcome — all append-only

---

## 43. Spell Taxonomy — Element Detection & Physical Magic

> *"Any sufficiently advanced technology is indistinguishable from magic."* — Arthur C. Clarke

**Prerequisites:** AR interaction, light-communication, and object-interface modules. Element detection, spell validation, spell library, and geographic magic become available once the user demonstrates competence with those prerequisite modules. The monster economy lever (global spawn/reward parameters) additionally requires the founder key.

### 43.1 Environmental Element Detection

The camera detects real physical elements in the user's environment. Each detected element enables a corresponding magic type:

| Real Element | Magic Type | SCV Capability Enabled |
|-------------|------------|----------------------|
| **Fire** (flame, torch, candle) | Fire magic | Thermal/energy analysis, heat-map projections, acceleration displays |
| **Smoke** (vapor, steam, fog) | Smoke magic | Obscuration, privacy operations, uncertainty visualization |
| **Rain** (water, spray, drops) | Rain magic | Flow analysis, liquid asset tracking, cascade projections |
| **Light** (reflection, beam, glow) | Light magic | Data illumination, evidence highlighting, truth revelation spells |
| **Snow** (ice, frost, cold) | Snow magic | Cold-proof engineering, preservation operations, archive queries |
| **Wind** (cloth movement, hair, flags) | Wind magic | Trend analysis, directional projections, branch movement commands |
| **Earth** (soil, stone, sand) | Earth magic | Foundation operations, root queries, geological history navigation |

### 43.2 Spell Mechanics

A spell is a cataloged interaction sequence:

1. **Detection**: Camera identifies the real element in the user's environment
2. **Activation**: User performs the gesture/light/object interaction (AR interaction modules)
3. **Validation**: SCV confirms the interaction matches a cataloged spell from the user's library
4. **Rendering**: AR interaction pipeline renders the spell effect on the user's video feed
5. **Execution**: SCV translates the spell into truth layer actions (filament queries, projection creation, evidence retrieval, commit proposals)
6. **Result**: The truth tree updates accordingly (via normal commit mechanics, never bypassing frozen contracts)

### 43.3 Spell Library

Users create and expand their personal spell library:

- Each spell is a filament on the user tree (the spell definition IS a filament)
- The definition includes: trigger element, gesture sequence, SCV command mapping, AR visual effect
- Users can share spell definitions as public filaments — others can learn and adopt them
- Advanced spells require achievement tokens to unlock
- The combinatorial space is infinite — any element + gesture + object can potentially map to any SCV action

### 43.4 Physical Location Matters

Geographic environment affects available magic:

- Standing in snow enables snow-type spells at full power
- Near a campfire enables fire-type spells
- In rain enables water/rain-type spells
- This creates geographic gameplay — different locations on the planet offer different magical capabilities
- Expeditions to extreme environments (volcanoes, glaciers, deep ocean) unlock rare element combinations

### 43.5 Spell Discovery Mechanics

Spells are secret by default. A hidden registry established by the founder on day 1 maps trigger combinations (element + gesture + voice + optional card) to spell effects. The registry is deployed encrypted on every client.

**Discovery process:**
1. User accidentally or intentionally performs a trigger sequence
2. Camera + SCV detect the combination and check against the hashed registry
3. If a match is found at sufficient confidence threshold: the spell activates for the first time
4. Visual revelation: spell name, icon, description appear — the user sees what they've unlocked
5. The spell is permanently added to the user's spell book (a filament on their user tree)
6. From now on, the user can intentionally cast this spell whenever they have sufficient Power

Before discovery, the spell is invisible. The user doesn't know it exists. The sheer number of spells makes it impossible for any one person or group to discover everything. Only by sharing knowledge and documenting the system together can civilizations pass this knowledge down. This knowledge exists OUTSIDE the Relay system — Relay does not auto-document spell knowledge. A user could build a Relay tree of known spells, but that's their personal knowledge, not system-provided.

**Personal Canon training:** Each user's SCV Canon layer is uniquely theirs, trained by their interaction style. How you command your Canon will differ from how others command theirs. Your version is shaped by your practice, your vocabulary, your gesture habits. This uniqueness is part of what makes each user's combat style distinctive.

### 43.6 Treasure Chests and Clues

> **For the full treasure chest type taxonomy (Open, Personal, Regenerating, One-Time), sharing mechanics, and attention economy, see §96.**

Treasure chests are pre-mapped locations in the Relay coordinate system where a visual marker appears (visible to users who have unlocked game layer modules). Opening a chest reveals a clue — a partial description of a spell trigger, a hint about which element is needed, a riddle about the right gesture. Chests provide knowledge, never Power or spells directly.

- Chests are hidden throughout the universe: specific geographic coordinates, specific branch locations, specific root archive depths
- Some chests require physical presence at the location (GPS-verified)
- Some chests are hidden in deep root strata (historical archaeology reveals game content)
- Clues can be shared between users (knowledge trading is a social mechanic)
- New chests can be placed by the founder (append-only — never removed)

**Treasure chests also contain development history fragments (§89).** Beyond spell clues, chests may reveal: excerpts from the original design transcripts, partial equation derivations, fragments of architectural debates, design sketches, philosophical exchanges between the founder and AI collaborators, and early prototype screenshots. Each fragment is RT-4 classified content (§89.1) curated by the founder via the AI Curation Tool (§89.5). These fragments reward the finder with genuine insight into how Relay was built — how equations were derived, why decisions were made, what was considered and rejected. Users piece together the design story over time. Knowledge trading applies to design history fragments the same way it applies to spell clues.

### 43.7 Physical Card Integration — Magic Cards as Spell Catalysts

A curated subset of real-world trading cards (Magic: The Gathering, Pokemon, and other physical card games) are secretly mapped to Relay spell effects in the day-1 registry:

**Recognition system:**
- Each card's visual identity is stored as a **perceptual hash** (tolerates camera angle, lighting, wear — not a cryptographic hash)
- The spell effect definition is encrypted alongside the hash
- Camera recognition must meet a confidence threshold (global parameter) to activate
- You need the actual physical card, held clearly, properly lit. Blurry photos and printouts fail recognition.
- The real-world market value of a card has ZERO correlation with its Relay power. A $50,000 Black Lotus might summon a small fairy. A common 10-cent card might unlock a devastating spell. The mapping is arbitrary, secret, and frozen at launch.

**Card types map to spell categories (MTG-inspired):**

| MTG Card Type | Relay Spell Category | Effect |
|---|---|---|
| **Creatures** | Summon spells | Summon an SCV-controlled combat entity. Power/toughness from registry. Summoning delay (3-5s hold). One creature per card at a time. |
| **Instants** | Reactive spells | Interrupt opponent's action during duels. Fast activation (shorter hold, lower Power cost). Can only respond to another action. Stack: last-in-first-out resolution. |
| **Sorceries** | Strategic spells | Major effects on your turn only. Higher Power cost, bigger impact. Branch scanning, large projections, extended affinity boosts. |
| **Enchantments** | Persistent effects | Lasting buff on branch/filament/self. Costs ongoing Power to maintain (drains while active). Limited by capacity. |
| **Artifacts** | Equipment enhancers | Modify physical mapped objects. Boost detection sensitivity, gesture recognition, element range. Persist until replaced. |
| **Lands** | Element amplifiers | Amplify element affinity. Forest=Earth, Island=Water, Mountain=Fire, Plains=Light, Swamp=Smoke. Multiple lands stack (up to cap). Enable multi-element combos. |

**Type advantages (Pokemon-inspired):** Fire > Earth/Nature, Water > Fire, Wind/Lightning > Water, Earth > Wind, Ice > Water, Light > Smoke, Smoke > Light. This rock-paper-scissors layer rewards diverse element knowledge and strategic card selection for duels.

### 43.8 Relay Set Items

Beyond trading cards, the founder defines a broader set of physical objects with Relay meaning:

- Specific trading card sets (Magic, Pokemon, etc.)
- Physical game pieces (dice types, POGS, chess pieces)
- Other recognized objects with predefined Relay effects

These **Relay Set Items** are the founder-constrained objects that provide meaning to build a rule-based system. The constraints — which objects have meaning, what effects they produce — are what enable a system with rules that can be played. Without constraints, there's no game.

### 43.9 User-Created Content

Any user who has discovered multiple spells can create:

- **Custom quests**: Define a sequence of challenges, hide them in the world, set rewards from their own Power reserves, publish as a public filament on a quest branch
- **Custom spell compositions**: Combine discovered spells into sequences (lower magnitude than founder-set Relay spells but still functional)
- **Custom treasure hunts**: Hide clues at locations, define the discovery path, reward finders
- **Custom training programs**: Design practice sequences that teach specific spell techniques

User-created content follows the same constraints as founder content: it can only compose existing mechanics, never create new physics. Relay Set Items and founder spells are always higher magnitude than user-created equivalents. User creativity extends the game infinitely without breaking the rules.

### 43.10 Weapon Taxonomy — The Way of the Flowering Humanhood

> *"A problem is not conquered by destroying the problem. A problem is conquered by demonstrating how to overcome the problem."* — Joo Bang Lee, Founder of Hwa Rang Do

The object you wield is a controller. A sword is a 4-button gamepad. Nunchaku are a 12-button arcade stick. A three-section staff is a 20-button flight console. A violin is a continuous analog stick with harmonic overtones. A keyboard is a 104-key command terminal. Relay does not care WHAT you hold. Relay measures how precisely you command through it.

**Philosophical foundation:** The input taxonomy is rooted in **Hwa Rang Do** (화랑도, "The Way of the Flowering Knights") — a Korean martial art that encompasses the full spectrum of combat: empty hand, blade, staff, nunchaku, knife, rope, fan, spear, and more. Hwa Rang Do teaches that a complete warrior masters all weapons, understanding each as an extension of the body rather than a substitute for it. The hierarchy of input devices in Relay follows this teaching: the body is always the root, tools are branches, and mastery means understanding the tree. But the tree has room for every branch — the martial artist, the musician, the typist, the dancer. The metric is precision, not tradition.

#### 43.10.1 Relay Set Weapons — The Founder's Nine

Nine weapon classes are designated as **Relay Set Items** (§43.8) — founder-defined, pre-optimized with known zone maps, community-voted in balance parameters. These are NOT the only valid input devices. They are the reference set: the instruments the founder has analyzed, mapped, and tuned for Relay's detection systems. Any object that produces detectable, repeatable signals can be registered as an input device through the Open Input Device Protocol (§43.10.8). The nine Relay Set Weapons ship with pre-built zone maps and SCV recognition profiles. Everything else trains from scratch.

```
WeaponClass {
  weaponId:         "weapon.<class>"
  name:             string
  tradition:        string (primary martial art lineage)
  hwaRangDoForm:    string (corresponding Hwa Rang Do weapon form)
  
  inputProfile: {
    zonesCount:       number (how many distinct input zones the weapon provides)
    maxInputsPerSec:  number (theoretical ceiling for trained master)
    comboDepth:       number (maximum chain length before mandatory recovery)
    recoveryMs:       number (forced pause after max combo)
  }
  
  combatProfile: {
    powerPerHit:      number (base damage multiplier, normalized to 1.0)
    speedRating:      number (0.0-1.0, higher = faster attack cycle)
    reachRating:      number (0.0-1.0, higher = longer effective range)
    defenseRating:    number (0.0-1.0, higher = better passive defense)
    comboRating:      number (0.0-1.0, higher = more combo potential)
  }
  
  detectionRequirements: {
    minimumZones:     number (zones needed for basic recognition)
    reflectiveSurface: boolean (does it need specular reflection for light commands?)
    percussive:        boolean (does it produce detectable tap/strike sounds?)
    dualWield:         boolean (is this weapon used in pairs?)
  }
}
```

**The Nine Weapons:**

| # | Weapon | Tradition | Hwa Rang Do Form | Zones | Max Inputs/s | Combo Depth | Power | Speed | Reach | Defense | Combo |
|---|--------|-----------|-----------------|-------|-------------|-------------|-------|-------|-------|---------|-------|
| 1 | **Empty Hand** | All martial arts | Kwon Bup (권법) | 10 (fingers) + 2 (palms) + body | 8 | 6 | 0.6 | 0.8 | 0.3 | 0.7 | 0.7 |
| 2 | **Sword** | Kendo / Kumdo | Gum Bup (검법) | 4 (ROOT/MID/UPPER/EDGE) | 5 | 4 | 1.0 | 0.5 | 0.7 | 0.6 | 0.4 |
| 3 | **Nunchaku** | Okinawan / Hwa Rang Do | Ssang Jol Bong (쌍절봉) | 6 per stick × 2 = 12 | 12 | 10 | 0.7 | 1.0 | 0.5 | 0.4 | 1.0 |
| 4 | **Staff** | Bōjutsu / Hwa Rang Do | Jang Bong (장봉) | 6 (3 per half) | 6 | 5 | 0.8 | 0.6 | 1.0 | 0.8 | 0.5 |
| 5 | **Knife** | Kali / Hwa Rang Do | Dan Do (단도) | 3 (handle/blade/tip) | 10 | 8 | 0.5 | 0.9 | 0.2 | 0.3 | 0.9 |
| 6 | **Fan** | Chinese / Hwa Rang Do | Bu Chae (부채) | 5 (ribs + open/close states) | 7 | 6 | 0.4 | 0.7 | 0.4 | 0.9 | 0.6 |
| 7 | **Rope/Chain** | Kusarigama / Hwa Rang Do | Po Bak (포박) | 4 (handle/mid/end/weight) | 4 | 3 | 0.9 | 0.3 | 0.9 | 0.5 | 0.3 |
| 8 | **Spear** | Sōjutsu / Hwa Rang Do | Chang (창) | 5 (butt/shaft-low/shaft-high/head/tip) | 4 | 3 | 1.0 | 0.3 | 1.0 | 0.7 | 0.2 |
| 9 | **Three-Section Staff** | Chinese / Hwa Rang Do | Sam Jol Gon (삼절곤) | 6 per section × 3 = 18 + 2 chains = 20 | 11 | 9 | 0.9 | 0.9 | 0.8 | 0.7 | 0.9 |

**All numeric values are Category A parameters — community-governed.** The community votes on balance. The founder sets the initial values. If nunchaku are too dominant, the community can adjust. If swords need a speed buff, the community votes. The nine Relay Set Weapons are frozen as Set Items. Their balance numbers flex. Other input devices registered through the Open Input Device Protocol (§43.10.8) use dynamically learned profiles — no founder pre-tuning, no guaranteed balance. Relay Set Weapons are the curated experience. Everything else is the open frontier.

#### 43.10.2 Weapon Profiles — Why Each Matters

**1. Empty Hand** (always available, no registration needed)
The universal weapon. Your body IS the interface (§39.4). Fingers, palms, fists, elbows. Moderate in everything, master of gesture cipher commands. The empty hand cannot be disarmed, cannot be forgotten, cannot break. A skilled empty-hand fighter issues commands through personal gesture cipher at a rate no observer can track. The body is the root — all other weapons are branches.

**2. Sword / Katana / Jian** (the baseline — see Blade Light Command Protocol, docs/blueprints/10)
The reference weapon. Four zones, specular reflection, good power. The full blade protocol (flashes, sweeps, taps, binary encoding) defines the sword's vocabulary. Reliable, readable, moderate speed. The weapon of the disciplined fighter who chooses precision over throughput. Every Relay combat tutorial starts here.

**3. Nunchaku** (supreme combo weapon)
Two sticks connected by chain or rope. Each stick has 6 zones. The sticks move independently, creating 12 simultaneous input zones plus the transitions between positions. A nunchaku wielder in continuous motion produces a stream of zone transitions that the SCV reads as a rapid-fire command sequence — like typing on a keyboard where every key is a spell input.

Why nunchaku are supreme: **combo depth 10** means you can chain 10 commands before recovery. At **12 inputs per second**, a master can issue a 10-command combo in under a second. That's 10 spells queued faster than a sword user can cast 2. The trade-off: lower power per hit (0.7 vs sword's 1.0), minimal defense (0.4), and the difficulty curve is brutal — nunchaku require extraordinary physical coordination. Drop them and you're defenseless.

The Street Fighter analogy: nunchaku are Chun-Li's lightning kicks — individually weaker but the throughput overwhelms. Sword is Ryu's Hadouken — slower, heavier, more decisive per hit.

**4. Staff / Bo** (reach + defense)
The long weapon. Three zones per half (6 total), good sweep detection, excellent reach and defense. The staff is the defensive fighter's weapon — high passive defense (0.8) and maximum reach (1.0). Sweep commands along the staff's length create wide-area spells. The staff's weakness: moderate speed and limited combo depth. Staff fighters control space, not tempo.

**5. Knife / Dagger** (close-range speed)
Small, fast, intimate. Only 3 zones (handle/blade/tip) but 10 inputs per second because the movements are tiny and fast — wrist flicks, finger rolls, quick stabs. Combo depth of 8. The knife fighter operates at point-blank range with devastating speed. Trade-off: minimal reach (0.2) and almost no defense (0.3). Pure aggression. The knife rewards commitment — if you close the distance, you dominate. If you can't, you lose.

**6. Fan** (defensive utility)
Five zones across the ribs, plus open/close state as a binary modifier — fan open doubles available commands (same gesture means different things open vs closed). Defense rating of 0.9 — highest of any weapon. The fan fighter is a support/control archetype: shields, debuffs, wind-element specialization, crowd control. In team duels, the fan wielder protects others. Offensive output is lowest (power 0.4) but survival is highest.

**7. Rope / Chain** (control + heavy power)
Handle, mid-section, weighted end. Four zones but the weapon's real strength is entanglement — grapple commands that lock opponents, restrict their movement, disable their weapon inputs temporarily. Power rating 0.9 — the weighted end hits hard. Speed is lowest (0.3) — the rope is slow to reset. The rope fighter is patient. One successful entangle → devastating follow-up. Miss and you're exposed.

**8. Spear / Polearm** (maximum range + power, minimum speed)
The longest weapon. Five zones along the shaft and head. Maximum reach (1.0) and maximum power (1.0) but minimum speed (0.3) and nearly zero combo potential (depth 3). The spear is the sniper — one perfectly timed thrust is devastating. Miss and recovery leaves you open for 3-4 seconds. Spear fighters control engagement distance. They are the most dangerous opponents at range and the most vulnerable up close.

**9. Three-Section Staff / Sam Jol Gon** (the founder's weapon — the ultimate Relay instrument)

Three rigid sections connected by chain or ring linkages. In Hwa Rang Do: 삼절곤 (Sam Jol Gon). The single most versatile weapon in martial arts history and the most structurally complete Relay input device that exists.

**Why it is supreme.** The three-section staff activates every Relay input modality simultaneously:

- **20 input zones** (6 per section × 3 sections + 2 chain connection points) — more zones than any other weapon
- **Three combat modes in one weapon:**
  - *Extended mode* (grip end section, full reach): functions as a staff — reach 0.8, sweep commands, area control
  - *Whip mode* (grip middle section, flail both ends): functions as dual nunchaku — speed 0.9, combo depth 9, overwhelming throughput
  - *Compact mode* (fold all three sections together): close-range defense, blocking, percussive strikes — power 0.9
- **11 inputs per second** — second only to nunchaku, because the sections are heavier and longer, but the three-way articulation compensates with richer zone transitions per movement
- **Combo depth 9** — one below nunchaku, but each command in the chain draws from 20 zones instead of 12, making the combinatorial space vastly larger
- **Light reflection** (when metal): the specular surface enables the full Blade Protocol light command grammar (§39.3, docs/blueprints/10) across three independently moving reflective surfaces — three simultaneous flash streams where a sword produces one
- **Internal elemental chambers**: each of the three sections can house a different physical element device (fire, smoke, water, ice, light). This is unique — no other weapon carries elements internally. Per §43.4, physical element proximity affects spell power. A three-section staff with fire in section A, water in section B, and smoke in section C gives the wielder simultaneous access to three element types without needing to stand near a campfire or river. The wielder IS the environment.
- **Percussion**: heavy metal sections striking each other or surfaces produce rich percussive input — tap commands with force variation across 20 zones
- **Material matters**: a wooden three-section staff works but is lighter (lower power), non-reflective (no light commands), and cannot house elemental chambers. A metal three-section staff is the founder's specification — heavier (higher power per hit), reflective (full light grammar), hollow sections for elemental devices. Wood is the training version. Metal is the real weapon.

**The trade-off is difficulty.** The three-section staff is the hardest weapon to control. Three independently moving sections, each capable of striking the user, each requiring spatial awareness. The chain connections mean the weapon's behavior is partially chaotic — momentum transfers unpredictably between sections. Dropping one section mid-combo can cause the others to whip uncontrolled. The skill ceiling is the highest of any weapon. Most users who attempt the three-section staff will spend months before landing a clean 5-hit combo. Years before a 9-hit. The reward for mastery is total battlefield dominance — but the path to mastery is the longest.

**Why the founder chose this weapon.** The three-section staff and nunchaku share a property that separates them from every other weapon in the taxonomy: they teach themselves. You pick one up. You spin. You maintain momentum. You discover what works through trial and error — no partner required, no dojo, no instruction manual. The weapon's physics — its momentum, its consequences when you get it wrong (it hits you), its reward when you get it right (flow state) — IS the teacher. This is the Awakening Curve (§99) applied to a physical object. Discovery through sustained practice, not instruction. The three-section staff does not need a curriculum. It IS a curriculum.

#### 43.10.2b Self-Teaching Weapons — The Relay Weapon Philosophy

Nunchaku and the three-section staff occupy a special category: **weapons discovered through practice, not instruction.** This distinction matters architecturally.

A sword requires a partner to spar with. A spear requires a target to thrust at. A staff requires spatial context. These weapons improve through structured training — drills, forms, sparring, correction from a teacher. They are taught.

Nunchaku and the three-section staff are different. You spin them. You maintain momentum. You discover the transitions between positions by doing them wrong and adjusting. The weapon punishes you (hits you) when you're wrong and rewards you (flow, speed, beauty) when you're right. The feedback loop is internal to the weapon-user system. No external input required.

This is precisely how Relay works. The system does not explain itself. You use it. You discover what data mapping means by doing it. You stumble into the realization that structured global data reveals the state of everything — not because someone told you, but because you practiced long enough to see it. The Awakening Curve cannot be skipped, purchased, or taught. It is experienced through sustained use.

Nunchaku and the three-section staff are Relay weapons. Not because the founder prefers them (though he does). Because they embody the foundational learning principle: **the tool teaches the user through the physics of the tool itself.**

**Why martial arts weapons are the Relay Set Items — not Lego ships or custom gadgets:**

The Open Input Device Protocol (§43.10.8) means anything can be a weapon. You could build a fleet of Lego ships, assign each one a command, and hold them up to the camera as spell triggers. That would technically work. But martial arts weapons are the Set Items for three converging reasons:

1. **Defense.** They are historically proven tools for personal protection. Training with them makes you physically safer. No other input device category provides this.
2. **Signal richness.** Centuries of martial arts tradition have optimized these weapons for the human body — zone variety, grip positions, transition speed, weight distribution. They produce the richest camera-detectable signals of any hand-held object class.
3. **Exercise.** Training with them is a full-body workout. Nunchaku drill cardiovascular endurance and coordination. Staff work builds core and upper body. Three-section staff demands total body engagement. The health benefit IS part of the design — Relay Set Weapons keep you fit.

A keyboard has higher throughput. A Lego ship arrangement has more creative freedom. But neither makes you healthier, safer, or more physically capable. Martial arts weapons are the Set Items because they serve the whole human — mind, body, and command precision — simultaneously. Everything else is an open frontier. These nine are the curated foundation.

#### 43.10.3 The Street Fighter Model — Combo Inputs

Weapon commands follow the Street Fighter directional + button model, mapped to physical motion:

```
INPUTS:
  Zone hit      = button (A, B, X, Y, etc. — mapped to weapon zones)
  Direction     = movement of weapon through space (↑↓←→)
  Tap           = percussion (light/medium/heavy based on force)
  Flash         = light reflection (single/double/sustained)
  Sweep         = directional light movement along weapon
  
COMBO NOTATION:
  →→ + A        = Forward dash + zone A hit       (gap closer)
  ↓↘→ + B       = Quarter-circle forward + zone B  (projectile)
  →↓↘ + A       = Dragon punch motion + zone A     (anti-air / uppercut)
  A, A, B, →+C  = Jab-jab-heavy-forward-finisher   (bread and butter combo)
  
WEAPON-SPECIFIC:
  Nunchaku:     A1,A2,B1,B2,A1,B2,→,A2,B1,←+A1  (10-hit combo, <1 second)
  Sword:        →+A, B, ↓↘→+C, D                  (4-hit combo, ~2 seconds)
  Knife:        A,A,A,B,A,B,B,→+C                  (8-hit combo, <1 second)
  Empty Hand:   L2,R3,L1+R1,→,L4,R2               (6-hit finger combo, <1 second)
  3-Section:    A1,C3,B2,→,A4,C1,B3,←+C6,A2       (9-hit combo, <1 second, 3 sections)
                [mode shift: extend→whip→compact mid-combo adds ×1.5 Power multiplier]
```

The SCV Architect parses the motion sequence against the registered combo library. Matches above confidence threshold execute. Partial matches queue for completion or time out.

#### 43.10.4 Dual Wielding & Cross-Weapon

**Dual wielding** is native to knife and nunchaku (both `dualWield: true`). Other weapons require a specific achievement to dual-wield (e.g., two swords, sword + fan).

**Cross-weapon combos:** A user registered with multiple weapons can switch mid-fight. Sheathing (pommel double tap or equivalent) and drawing a new weapon costs 1 second of transition. Some advanced combos chain across weapons — finish a sword sweep, sheathe, draw nunchaku, continue the combo chain. These cross-weapon transitions are the highest-skill expressions in the combat system.

#### 43.10.5 Balance Philosophy

The weapon balance is designed so that no weapon is strictly dominant:

| If You Want... | Choose... | You Sacrifice... |
|----------------|-----------|-----------------|
| Raw damage per hit | Sword or Spear | Speed, combo depth |
| Maximum spell throughput | Nunchaku or Knife | Power per hit, defense |
| Survivability | Fan or Staff | Offensive output |
| Space control | Spear or Rope | Speed, combo depth |
| Versatility | Empty Hand | Extreme specialization in any dimension |
| Risk/reward | Knife or Nunchaku | Safety margin |
| Everything at once | Three-Section Staff | Years of your life learning to not hit yourself |
| Elemental integration | Three-Section Staff (metal) | Weight, cost, commitment to the hardest path |

A sword master who lands every hit might out-damage a nunchaku master who misses half their combo. A nunchaku master who lands a full 10-hit combo overwhelms a sword user who can only cast 4 spells in the same window. A three-section staff master who lands a 9-hit combo across all three modes with elemental chambers active outperforms both — but may have trained for three years to get there. The outcome depends on skill, not weapon selection. The weapon selection determines the style. The three-section staff selects for total commitment.

**The Hwa Rang Do principle:** A complete warrior trains all nine. Mastery means understanding which weapon fits which situation. The weapon taxonomy exists not to create permanent classes but to create a reason to keep training. You main nunchaku? You'll be weak against staff users who outrange you. You main sword? Knife users will get inside your guard. You main three-section staff? You've chosen the longest path and the highest ceiling — respect. The answer is always: learn more.

#### 43.10.6 Governance — The Weapon Vote

Before the weapon taxonomy activates (post-founder key, §44), the community votes on the initial balance:

1. **First vote: the list.** The nine weapon classes are presented. Community confirms or proposes modifications. The nine-class structure is frozen, but the community can rename, adjust traditions, or propose a swap (e.g., replace Rope with Tonfa). This vote happens once.

2. **Second vote: priority.** The community ranks which weapons to implement first. The development team builds them in voted order. All nine must eventually ship, but the sequence is community-driven.

3. **Ongoing balance votes.** All numeric values (power, speed, reach, defense, combo, inputs/sec, combo depth, recovery) are Category A parameters. The community governs balance patches through the standard weighted-median voting system (§72). Balance changes apply at the next epoch boundary, not mid-match.

#### 43.10.7 Command Precision Index (CPI) — The Universal Combat Metric

> *"It is not the weapon that matters. It is the mind behind the weapon."* — Joo Bang Lee

Every user in Relay's combat system is measured by a single composite metric: the **Command Precision Index (CPI)**. This is the number that determines how effective you are — not what you hold, but how well you command through it. CPI is to Relay combat what APM (actions per minute) is to StarCraft, but weighted by quality instead of raw speed.

```
CommandPrecisionIndex {
  userId:               userRef
  deviceId:             inputDeviceRef
  timestamp:            ISO-8601
  
  // Core components (all 0.0-1.0)
  signalClarity:        number    // How cleanly the SCV reads your input.
                                  // Perfect zone hits = 1.0. Ambiguous transitions = 0.3.
                                  // Measures: zone-to-zone transition sharpness,
                                  // gesture completion ratio, false-start frequency.
  
  semanticDensity:      number    // How much meaning per command.
                                  // One gesture selecting 3 category elements = high.
                                  // One gesture selecting 1 = low.
                                  // A master issues fewer commands to achieve the same effect.
                                  // Like drawing — one confident stroke vs ten hesitant scratches.
  
  throughput:           number    // Valid commands per second, normalized to device max.
                                  // Nunchaku user at 10/s of 12 max = 0.83.
                                  // Flute player at 6/s of 8 max = 0.75.
                                  // Measures raw speed relative to the device's ceiling.
  
  resourceEfficiency:   number    // Power spent per unit of spell effect achieved.
                                  // Precise commands cost LESS Power.
                                  // Imprecise commands waste Power (SCV disambiguation cost).
                                  // A master's fireball costs 60% of a novice's fireball
                                  // because the master's input required zero guessing.
  
  // Composite score
  cpiScore:             number    // Weighted combination of all four components.
                                  // Weights are Category A parameters (community-governed).
                                  // Default: clarity 0.30, density 0.25, throughput 0.25, efficiency 0.20
  
  // Metadata
  sampleWindow:         number    // Seconds of combat data used for this calculation
  deviceType:           "SET_WEAPON" | "REGISTERED_DEVICE" | "INSTRUMENT" | "ELECTRONIC" | "BODY"
}
```

**Why CPI matters architecturally:**

1. **Resource cost is precision-dependent.** Every spell has a base Power cost (§41.5). The actual Power consumed = baseCost × (2.0 − resourceEfficiency). A perfect user (efficiency 1.0) pays baseCost × 1.0. A sloppy user (efficiency 0.3) pays baseCost × 1.7. Precision literally makes you more efficient. Over a 5-minute duel, the precise fighter has 40% more Power remaining.

2. **Each user is unique.** Your CPI is trained on YOUR body, YOUR device, YOUR gesture habits. Two nunchaku users with identical weapons will have different CPI profiles because their bodies move differently. This is the fingerprint — no two fighters are the same.

3. **CPI is device-agnostic.** A flute player with CPI 0.85 and a sword user with CPI 0.72 are comparable. The flute player is more precise with their instrument than the sword user is with theirs. In a duel, the flute player's spells cost less, their commands resolve faster, and their semantic density may be higher (musical phrases carry more information than blade swings). The sword user hits harder per spell (weapon power rating) but casts fewer spells at higher cost. Who wins depends on the encounter.

4. **CPI constrains duels.** In arena matches (§68), CPI creates the natural constraint: you can only issue commands as fast and as precisely as your skill allows. No input spam — ambiguous commands cost extra Power, which drains you. No button mashing — the SCV requires clean zone transitions above a confidence threshold. The system rewards mastery over speed. A slow, precise user can outlast a fast, sloppy one.

5. **CPI is a sap-class signal.** CPI updates per combat tick (sap), checkpoints to filament at match end. The history of your CPI over time IS your training record. You can watch your precision improve across months. The growth is a branch on your combat training tree.

#### 43.10.8 Open Input Device Protocol — Any Object Is a Weapon

The nine Relay Set Weapons are the curated starting point. They are not the boundary. **Any physical object or electronic device that produces detectable, repeatable signals can be registered as a Relay input device.** The system is open.

```
InputDeviceRegistration {
  deviceId:             "device.<userId>.<name>"
  deviceType:           "SET_WEAPON" | "CUSTOM_PHYSICAL" | "INSTRUMENT" | "ELECTRONIC" | "BODY"
  registeredBy:         userRef
  
  // Detection profile (learned during training)
  detectionMethod: {
    visual:             boolean   // Camera-tracked motion, zones, reflections
    audio:              boolean   // Sound-producing (percussion, strings, wind, voice)
    electronic:         boolean   // Digital signal (keyboard, controller, MIDI)
    inertial:           boolean   // Accelerometer/gyroscope (phone-as-weapon)
  }
  
  // Zone map (learned or predefined)
  zoneMap: {
    zones:              [{ zoneId, label, spatialBounds, detectionConfidence }]
    source:             "PRESET" | "LEARNED"    // SET_WEAPONS are PRESET; everything else is LEARNED
    trainingHours:      number                  // Hours of SCV training data collected
    maturityLevel:      "NOVICE" | "TRAINED" | "MATURE" | "MASTERED"
  }
  
  // Derived combat profile (calculated from training data, not manually assigned)
  derivedProfile: {
    maxInputsPerSec:    number    // Measured from training
    comboDepth:         number    // Longest reliable combo observed
    signalRichness:     number    // How many distinct signals the device can produce
    powerMultiplier:    number    // Derived from mass, material, impact detection
  }
}
```

**Registration process:**

1. **Present the object to camera.** SCV observes the object's geometry, reflectivity, size, and material properties.
2. **Training period.** User performs movements with the object while SCV maps zone boundaries, transition speeds, and signal patterns. Minimum training: 1 hour for basic recognition, 10 hours for reliable combat use, 100+ hours for mastery-level zone precision.
3. **Zone map crystallizes.** After sufficient training data, the SCV proposes a zone map. User confirms or adjusts. Zone map becomes a filament on the user's device training branch.
4. **Combat profile derived.** The SCV calculates max inputs/sec, combo depth, and power multiplier from observed training data. These are NOT manually assigned — they emerge from what the device actually does in the user's hands.
5. **Ready for combat.** The device can now be used in duels, arena matches, and spell casting. CPI begins tracking.

**Why this matters:** A martial artist registers their custom tonfa. A chef registers their cleaver. A drummer registers their sticks. A conductor registers their baton. A guitarist registers their guitar. Each object becomes a unique input device with a learned zone map and derived combat profile. The system does not judge the object. It measures the precision.

**Pre-registered categories beyond the Nine:**

| Category | Examples | Primary Detection | Strengths |
|----------|----------|-------------------|-----------|
| **Ranged weapons** | Shuriken, throwing knives, throwing axes, bow, sling | Visual (trajectory tracking) | Range, burst damage, repositioning |
| **Impact weapons** | Tonfa, kama, sai, war hammer, mace, axe | Visual + percussion | Power, defense, grappling |
| **Flexible weapons** | Whip, meteor hammer, chain whip, bolas | Visual (arc tracking) | Range, entanglement, unpredictability |
| **Musical instruments** | Flute, violin, guitar, drums, piano, voice | Audio (pitch, rhythm, harmony) | Semantic density, sustained effects, crowd manipulation |
| **Electronic devices** | Keyboard, MIDI controller, game controller, phone | Electronic (digital signal) | Throughput, programmable macros, precision |
| **Improvised** | Umbrella, cane, stick, pen, phone (as physical object) | Visual + inertial | Availability, surprise |

These are NOT Relay Set Items. They have no founder-optimized zone maps. Their combat profiles emerge from training data. They may be weaker or stronger than Set Weapons depending entirely on the user's CPI with them. A master pianist issuing commands through a keyboard at 15 inputs/second with 0.95 signal clarity will outperform a mediocre sword user at 3 inputs/second with 0.5 clarity — even though the sword has a higher base power rating.

**Natural selection through practice.** There are no artificial limitations on what can be an input device. A multicolored ball with distinct visual zones would map cleanly — each color is a zone, each rotation a transition. A monochrome ball would be nearly impossible to use because the user cannot remember which featureless patch maps to which command. A flute works beautifully because pitch is naturally ordered and memorable. A pile of Lego ships arranged as command tokens works but provides no exercise, no defense training, and no portability. The system does not forbid any of these. It simply measures CPI. Over time, the devices that offer the best combination of memorability, signal richness, life benefit, and practical portability will dominate — not because Relay chose them, but because humans chose them through practice. Some ways will prove better than others. That is the design.

#### 43.10.9 Sound as Magic — The Bard Archetype

> *In Final Fantasy III/V, the Bard was a fierce warrior — casting Requiem, commanding armies, shattering defenses with a song. In Final Fantasy VI, the Jester (Gogo) could mimic any ability. These non-combat archetypes were among the most powerful characters in the game because their input modality — sound, mimicry, performance — accessed a command space that weapons could not reach.*

Sound is its own combat modality. Manipulating sound IS magic — it always has been. A musical instrument produces signals of extraordinary complexity: pitch (continuous), rhythm (discrete), tempo (rate), harmony (multi-signal), dynamics (force), timbre (texture), articulation (shape). A single musical phrase carries more information than a dozen sword swings.

**How instruments work as Relay input devices:**

```
InstrumentProfile {
  instrumentType:       "WIND" | "STRING" | "PERCUSSION" | "KEYBOARD" | "VOICE" | "ELECTRONIC"
  
  inputChannels: {
    pitch:              { range: [lowHz, highHz], resolution: cents }
    rhythm:             { minBPM, maxBPM, subdivisionDepth }
    dynamics:           { levels: number }     // pp, p, mp, mf, f, ff, fff
    harmony:            { maxSimultaneousNotes: number }
    articulation:       { types: ["legato", "staccato", "tremolo", "trill", "glissando", ...] }
    timbre:             { overtoneResolution: number }
  }
  
  // Derived signal richness (typically MUCH higher than physical weapons)
  signalRichness:       number    // A violin: hundreds of distinct signal combinations
                                  // A sword: dozens at most
  
  // The trade-off
  physicalImpact:       number    // Instruments produce minimal physical force (power 0.1-0.3)
                                  // Drums are the exception (percussion = physical impact)
}
```

**The Bard's strengths:**

1. **Semantic density.** A musical phrase maps to a complex command in a single expression. Where a sword user issues "fire + forward + strike" as three sequential inputs, a flute player issues the equivalent as a single melodic phrase — one breath, three commands. Semantic density can exceed 3.0× compared to physical weapons.

2. **Sustained effects.** Music is continuous. A held note sustains a spell effect for its duration. A sword must strike repeatedly. A violin player holding a tremolo sustains a shield for as long as the bow moves. This makes instruments supreme for persistent effects (enchantments, buffs, debuffs, healing).

3. **Crowd manipulation.** Musical instruments directly interface with the Live Performance Loop (§106). In team fights or arena matches with audiences, a musician's sound literally shapes the CrowdAggregate sap — amplifying team buffs, suppressing opponent morale, generating engagement that feeds back as Power. The Bard is the force multiplier.

4. **Stealth commands.** A melody sounds like music to observers. The SCV reads the encoded commands. A flautist walking through a crowd can cast spells without anyone realizing they're commanding the system. Sound-based commands have inherently higher stealth than visual weapon movements.

**The Bard's weaknesses:**

1. **Low physical power.** A flute does not hit hard. Base power for wind instruments is 0.1-0.2. Strings are 0.1-0.3. Drums are the exception at 0.5-0.7 (percussion transfers real force). Musicians rely on spell effects, not direct damage.

2. **Environmental vulnerability.** Loud environments degrade audio signal clarity. A stadium, a construction site, a thunderstorm — all reduce the SCV's ability to parse instrument signals. Physical weapons are not affected by noise.

3. **Two-handed commitment.** Most instruments require both hands. No dual-wielding, no shield, no secondary weapon. The musician is all-in on their instrument.

**Voice as instrument.** The human voice is the most intimate instrument. Vocal commands — pitch shifts, rhythmic patterns, harmonic overtones, whispered vs shouted, specific phonemes — all produce parseable signals. Combined with the Personal Gesture Cipher (§39.4), voice becomes a dual-channel input: sound + visual gesture simultaneously. A vocalist singing while signing produces the highest-bandwidth human input possible — audio commands through the mouth, gesture commands through the hands, all at once. This is the closest thing to the Bard casting while fighting.

**Drums and percussion.** Drums bridge the gap between instruments and weapons. A drummer hits things. Each drum surface is a zone. Each hit is a percussive command. Drumsticks are effectively dual-wielded impact weapons that also produce pitched audio signals. A master drummer in Relay is both a musician (audio commands) and a fighter (physical impact) simultaneously. Drum kits are among the highest-zone-count input devices possible — a full kit has 10-20 distinct surfaces, each a zone, each producing both percussion AND pitched audio.

#### 43.10.10 Extended Weapon Classes — The Open Frontier

Beyond the nine Relay Set Weapons and musical instruments, the combat system accommodates any input device. These categories illustrate the breadth — they are NOT exhaustive.

**Ranged weapons — the sniper's tools:**

| Weapon | Detection | Zones | Speed | Power | Unique Property |
|--------|-----------|-------|-------|-------|-----------------|
| Shuriken / throwing star | Visual trajectory | 1 (per star, multi-throw) | High (rapid throw) | Low (0.3) | Multi-target: throw 3 stars at 3 targets in 1 second |
| Throwing knife | Visual trajectory | 1 per knife | Medium | Medium (0.5) | Commitment: knife leaves your hand, reducing future options |
| Throwing axe | Visual trajectory | 2 (blade/handle orientation) | Low | High (0.8) | Rotation detection: SCV reads spin rate as power modifier |
| Bow | Visual (draw + release) | 3 (nock/draw/aim) | Low (draw time) | High (0.9) | Charge mechanic: longer draw = more Power invested = stronger spell |
| Sling | Visual (wind + release) | 2 (hold/wind) | Medium | Medium (0.6) | Stealth: looks harmless until release |

Ranged weapons sacrifice sustained combo for burst damage at distance. A skilled shuriken thrower can tag three targets in a second — something no melee weapon achieves. The trade-off: once thrown, the weapon is gone until retrieved.

**Electronic devices — the hacker's tools:**

A keyboard is the most zone-dense input device ever created. 104 keys, each a distinct zone. Max inputs per second for a fast typist: 10-12 (competitive with nunchaku). For a competitive speed-typist: 15+. The keyboard lacks physical power (0.1) but compensates with:

- **Programmable macro commands.** Type a phrase, execute a complex spell. The SCV parses keystrokes as command sequences. "fbll3" → Fireball Level 3. The hacker's personal command language IS their spell book.
- **Extreme precision.** Keys are binary — pressed or not. No ambiguity. Signal clarity approaches 1.0 inherently. The CPI efficiency component heavily favors keyboards.
- **Composability.** Text commands can be arbitrarily complex. A single typed sequence can compose multiple spells, target multiple entities, and set conditional triggers. Where a sword user swings four times for four commands, a hacker types a 20-character string for 20 commands in 2 seconds.

The hacker archetype is the mage class: low physical power, maximum command throughput, extreme precision, vulnerable in close combat. They need distance and time — but given both, they dominate through sheer command density.

MIDI controllers, game controllers, and custom electronic interfaces all follow the same protocol: digital signals with known mappings, high clarity, zero physical power.

**The body itself — always weapon #1:**

Empty Hand (§43.10.2, weapon #1) is the universal fallback. But the body offers more than fists:
- Feet (kicks, stomps, sweeps) — lower body is a second weapon when hands hold something else
- Head movement (nods, turns) — subtle commands, hard to detect by opponents
- Full body movement (spins, jumps, rolls) — spatial commands that reposition AND command simultaneously
- Dance — structured full-body movement that IS a command language. A dancer's choreography is a spell sequence. The dance IS the combo.

**Improvised objects:**

Anything you can pick up. A stick from the ground. A rolled-up newspaper. A phone held as a striking tool (using accelerometer for inertial detection). These have no pre-mapped zones — the SCV learns in real time from your movements. Low reliability initially, improving with repetition. The ultimate expression of adaptability: the weapon you didn't plan for.

#### 43.10.11 The Final Fantasy Principle — No Class Is Weak

> *The Bard, the Jester, the Mime, the Dancer, the Gambler — in every Final Fantasy game, the "non-combat" classes were among the most devastating when played by someone who understood their mechanics. Setzer's dice could deal 9,999 damage. Gogo could mimic Ultima. Edward's songs could put dragons to sleep. The lesson: power comes from mastery of your chosen instrument, not from choosing the "strongest" weapon.*

Relay's combat system follows this principle absolutely. There is no strongest weapon. There is no meta. There are users with high CPI and users with low CPI. A Bard with a flute at CPI 0.92 will defeat a Swordsman at CPI 0.55 every time — not because the flute is stronger, but because the Bard is more precise, more efficient, and wastes less Power per command.

The weapon balance tables (§43.10.1) set base parameters: power, speed, reach, defense, combo rating. These create initial trade-offs. But CPI is the multiplier that dwarfs base stats. A 50% difference in CPI is worth more than a 100% difference in base power. Precision IS power.

**This means:**
- A street musician with a guitar can defeat a swordsman in a duel
- A speed-typist with a keyboard can outcast a spear wielder
- A dancer using only their body can outmaneuver a knife fighter
- A drummer can simultaneously deal physical damage AND cast audio spells
- A child with a wooden stick who has trained for months can compete with an adult with a metal three-section staff who started yesterday

The system rewards practice. The system rewards precision. The system rewards commitment to whatever tool you choose. There is no shortcut. There is no pay-to-win. There is only: how well do you know your instrument?

**Street Fighter clarification:** The Street Fighter combo model (§43.10.3) applies specifically to body-based and hand-weapon combat — directional motion + zone hits. For instruments, the combo model is **melodic/rhythmic phrases**. For electronic devices, the combo model is **keystroke sequences**. For voice, the combo model is **tonal patterns**. Each input modality has its own combo grammar, but all feed into the same CPI calculation and the same spell resolution system.

#### 43.10.12 Signal Architecture — Commands vs. Power

Two distinct signal channels flow through every input device. Conflating them is a design error. They are separate.

**Channel 1: COMMANDS — hand signals on your tools.**
Your hands gripping, rotating, striking, tapping the zones on your weapon or instrument — these are commands. They tell the SCV what spell to cast, what target to select, what mode to enter. Commands are parsed from the physical manipulation of the device: which zones your hands touch, in what sequence, at what speed. The combo system (§43.10.3) is entirely about commands. CPI (§43.10.7) measures command quality. This channel is about WHAT you want to happen.

**Channel 2: MAGNITUDE — light, fire, smoke, water, and other detected effects.**
Environmental and device-generated effects detected by the camera are the power source. Fire from an elemental chamber, reflected light from a metal surface, water spray, smoke emission — these are not commands. They are magnitude. They determine HOW MUCH power the spell has. Per §43.4, physical element proximity affects spell strength. A fire spell cast near an actual flame is stronger. A light-based attack using real specular reflection carries more magnitude. The detected effect is the fuel. The hand signal is the steering wheel.

**The two channels are independent:**
- A hand signal with no detected effect: the command executes at minimum magnitude (base Power cost only)
- A detected effect with no hand signal: raw energy with no direction — wasted, or stored as ambient charge
- A hand signal WITH a detected effect: full spell execution at amplified magnitude

**Light as dual-channel (advanced technique):**
Using light as BOTH a command signal AND a magnitude source — for example, directing a specular reflection from a sword blade to encode a flash command while simultaneously using that same reflected light as the spell's power source — is possible but requires extraordinary skill. The SCV must disambiguate: is this flash a command or power? At low confidence, the system treats the signal as one or the other. At high confidence (CPI > 0.85), the SCV can read a single light event as both — the angle encodes the command, the intensity provides the magnitude. This is the highest-skill expression of blade mastery.

**The Charging Attack — sustained light with crowd confidence:**
Balancing a sustained light reflection — holding a mirror or blade at a precise angle to maintain a continuous specular beam — builds charge over time. The longer you hold the beam, the more Power accumulates. This is the charging mechanic: visible to everyone, interruptible (break the beam and the charge dissipates), and amplified by crowd confidence.

In arena matches (§68) or public duels with audience engagement (§106):
- CrowdAggregate confidence feeds into the charge multiplier
- A crowd that believes in the charge (high engagement sap) amplifies the Power buildup
- A skeptical crowd (low engagement) dampens it
- The visual effect of the charging beam intensifies as both hold-duration and crowd-confidence increase
- Release triggers the spell at accumulated magnitude: a devastating single strike

This is a legitimate strategy: the slow, visible, interruptible charge that rewards audience faith. A sword user holding a charging beam is vulnerable (both hands committed, stationary, glowing target). The reward is proportional to the risk. The crowd decides whether the charge is worth believing in.

#### 43.10.13 Regional & Global Weapon Bonuses — Parametric Governance

Global or regional governance parameters (§72, §90) can define bonus modifiers for specific weapon classes or input device categories. These are voted on through the standard weighted-median system and apply per airspace layer or venue.

```
WeaponBonusParam {
  scope:                "GLOBAL" | "REGIONAL" | "VENUE"
  targetDeviceType:     deviceType | "ALL"
  bonusType:            "POWER" | "SPEED" | "CPI_BOOST" | "COST_REDUCTION" | "ELEMENT_AFFINITY"
  bonusValue:           number (multiplicative, 1.0 = no bonus)
  expirationEpoch:      number | null (null = permanent until re-voted)
  votedBy:              governanceRef
}
```

**How this works:**
- A region votes to give +10% Power to staff weapons during a festival celebrating martial arts tradition
- A global vote grants +5% CPI boost to musical instruments during a concert season milestone
- A venue (arena) sets bonus element affinity for fire weapons during a fire-themed tournament
- All bonuses are transparent, time-bounded, and re-votable

**Selection process:**
1. Community proposes a bonus list (which devices, what type, what magnitude)
2. Weighted-median vote on optimization — the community ranks the list by priority
3. Top selections activate at the next epoch boundary
4. Sortition jury (§46, contract #68) resolves disputes if bonus proposals are challenged as unfair

**Human randomization factor:** All combat systems that involve matchmaking, arena seeding, tournament brackets, and bonus-selection jury formation use the existing sortition mechanism (§46) — cryptographic random selection with the frozen 4:3:3 ratio (random:volunteer:historic). The randomization factor prevents predictable meta-gaming: you cannot guarantee which bonuses will be active, which opponents you'll face, or which jurors will evaluate a dispute. The human element in sortition — real people, randomly selected, with real judgment — is the anti-gaming layer that no algorithm can replace.

#### 43.10.14 Kinetic Input Rate (KIR) — Movement as Power Generation — Contract #319

> *"Be like water."* — Bruce Lee

In Relay combat, **stillness generates nothing.** Movement is a fixed, measurable input that directly generates Action Points (AP) and amplifies Power. A user standing still holding a sword in guard stance produces zero kinetic input. A user maintaining continuous nunchuck spin generates AP with every rotation. Movement IS the resource.

**The core equation:**

```
Kinetic Input Rate:

KIR(t) = Σ ( velocity(zone_i, t) × mass(zone_i) × continuity(zone_i, t) )

where:
  velocity:    camera-measured angular/linear velocity of each tracked zone
  mass:        the weapon zone's physics weight (heavier zones = more kinetic contribution)
  continuity:  a multiplier (0.0–1.0) rewarding sustained motion.
               Continuity rises over time during unbroken motion.
               Continuity resets to 0 on full stop.
```

**What this means for weapons:**

| Weapon | Typical KIR | Why |
|--------|------------|-----|
| **Nunchaku** (spinning) | Very High | Continuous rotation across 12 zones. Mass transfers between sections. Spin never stops. Maximum sustained KIR of any weapon. |
| **Three-Section Staff** (whip mode) | Very High | Three connected masses in perpetual motion. Highest peak KIR during full extension whip. |
| **Staff** (sweeping) | High | Long lever arm = high zone velocity at tips. Sweeps generate broad kinetic arcs. |
| **Sword** (active fighting) | Moderate | Strikes and parries generate burst KIR. Guard stance = zero KIR. The sword rewards decisive action. |
| **Sword** (guard stance) | Zero | Stillness. No movement. No AP generation. Defending without moving is safe but produces nothing. |
| **Empty Hand** (flowing forms) | Moderate-High | Continuous body movement (tai chi, capoeira, wing chun chain punches) produces sustained KIR through multiple body zones. |
| **Drums** (playing) | High | Rapid percussive strikes across multiple surfaces. Each hit is kinetic input + audio command simultaneously. |
| **Knife** (close-range flurry) | High (burst) | Fast but short-range. High velocity, low mass. Burst KIR during attack sequences, drops during repositioning. |
| **Fan** (deployment cycles) | Moderate | Open-close cycles generate periodic KIR. Held open in defense = low KIR. |

**How KIR generates AP:**

```
AP_generation(t) = KIR(t) × kineticConversion × deviceMultiplier

where:
  kineticConversion  = global rate (Category A parameter, default: 1.0 AP per KIR unit per second)
  deviceMultiplier   = per-weapon modifier (Category A, default: 1.0 for all Set Weapons)
```

AP accumulates during motion and can be spent on:
- **Spell amplification**: AP adds magnitude to the next spell cast (stacking with Power from element detection)
- **Combo extension**: AP extends the combo chain beyond the weapon's base combo depth
- **Defensive recovery**: AP converts to faster shield regeneration and parry windows
- **Crowd engagement**: In arena, sustained KIR produces visible kinetic trails — the audience sees effort, which amplifies CrowdAggregate attention

**The strategic design:**

A duelist who holds position and waits is safe but generates zero AP. A duelist who moves continuously accumulates AP for devastating combos, amplified spells, and faster recovery. This creates a fundamental risk-reward dynamic:

- **Aggressive style** (high KIR): Constant motion → high AP → powerful combos, but more exposure to counterattack
- **Defensive style** (low KIR): Static guard → safe but zero AP → must win through precision alone, with no AP reservoir
- **Rhythmic style** (sustained moderate KIR): Flowing movement patterns (martial arts forms, instrument playing, dance) → steady AP generation → balanced offense and defense

Nunchucks are the supreme KIR weapon because spin is continuous. A skilled nunchuck user generates AP passively — the weapon's default state IS motion. A sword user must actively attack or move to generate any AP at all. This is why nunchuck fighters are feared: they arrive at every exchange with an AP surplus.

**Continuity bonus:** The `continuity` multiplier rewards sustained unbroken motion. A user who maintains spin for 10 consecutive seconds has a higher continuity multiplier (approaching 1.0) than one who starts and stops repeatedly (continuity resetting toward 0). This rewards discipline and endurance. A nunchuck spinner who maintains perfect figure-8 form for 30 seconds enters a "flow state" where KIR is at maximum. Breaking form — dropping the weapon, pausing, fumbling — resets continuity immediately.

**Contract #319 — Kinetic Input Rate (KIR). Movement is a fixed, measurable input in Relay combat. Camera-tracked zone velocity × zone mass × continuity multiplier produces the Kinetic Input Rate, which generates Action Points (AP) over time. Stillness generates zero AP. Sustained motion accumulates AP for spell amplification, combo extension, defensive recovery, and crowd engagement. Continuity rewards unbroken motion — resetting on pause. Nunchucks produce the highest sustained KIR due to continuous rotational motion; guard stance produces zero. KIR creates a fundamental aggressive/defensive/rhythmic risk-reward dynamic. The kinetic conversion rate and per-weapon multipliers are Category A parameters. The equation, the zero-AP-from-stillness rule, and the continuity reset on pause are frozen.**

**Contract #299 — Input Device Protocol & Command Precision Index. Relay's combat system is built on an open input protocol with two distinct signal channels: Channel 1 (Commands) — hand signals on tools parsed as zone sequences by the SCV, determining WHAT spell to cast; Channel 2 (Magnitude) — light, fire, smoke, water, and other camera-detected effects determining HOW MUCH power the spell carries. The channels are independent; combining them (light as both command and magnitude) requires high CPI skill. Nine Relay Set Weapons (Empty Hand, Sword, Nunchaku, Staff, Knife, Fan, Rope/Chain, Spear, Three-Section Staff) are founder-designated Set Items with pre-optimized zone maps and balance parameters rooted in Hwa Rang Do martial art tradition. All Relay Set Weapon balance values are Category A (community-governed). Beyond the Set Weapons, any physical object, musical instrument, electronic device, or the human body itself can be registered as a Relay input device through the Open Input Device Protocol — the SCV learns zone maps through training, and combat profiles are derived from observed performance. The universal combat metric is the Command Precision Index (CPI): a composite of signal clarity, semantic density, throughput, and resource efficiency. CPI determines how much Power each command costs — precise commands are cheaper, imprecise commands are expensive. Sound (musical instruments, voice, percussion) is a full combat modality with its own signal channels (pitch, rhythm, dynamics, harmony, articulation, timbre). Sustained light reflection builds charge over time, amplified by crowd confidence (CrowdAggregate sap) in arena/public contexts — the charging attack mechanic. Regional and global governance parameters can define voted bonus modifiers for specific device types, time-bounded and re-votable. All matchmaking, seeding, and bonus-dispute resolution uses the sortition mechanism (§46) with the frozen 4:3:3 human randomization ratio. No input device is inherently dominant — precision determines power, not weapon choice. The open input protocol, the dual-channel signal architecture (commands vs. magnitude), the CPI metric, and the principle that any detectable signal source can serve as an input device are frozen.**

### 43.11 Graphic Crafting Module — Build Your Own Visual Language

> *"The tools are nothing without the vision behind them."* — Eitan Asulin

A warrior who trains for a hundred hours to master a spinning back kick deserves a visual effect as unique as the movement itself. Relay does not assign graphics to skills — users craft their own. The Crafting Module is the creation studio where every user designs, tests, iterates, and finalizes the visual, audio, and motion effects that represent their combat commands and personal expression on the tree.

**Why crafting exists:** In the same way a user must train their body and build their command language with the SCV, they must build their graphics. Your visual identity in Relay is not a skin pack you download — it is an artifact you create, refine, and pay crafting resources to finalize. The graphic IS part of the skill. A swordsman's fire arc, a drummer's sonic ripple, a nunchaku master's chain lightning — each is handcrafted by the user who wields it.

#### 43.11.1 The Crafting Studio

Every user has access to the **Relay Crafting IDE** — a suite of integrated generators for visual, audio, and motion content:

| Generator | What It Creates | Input Method |
|-----------|----------------|--------------|
| **Image Generator** | Still graphics: spell icons, effect textures, card art, branch decorations | Text prompts, reference images, parametric sliders, hand-drawn sketches |
| **Video Generator** | Motion effects: spell animations, hit effects, summon sequences, celebration clips | Keyframe editing, motion capture from SCV camera, layered composition |
| **Sound Generator** | Audio effects: spell sounds, ambient loops, impact audio, charge-up tones | Waveform editing, sample layering, parametric synthesis, microphone input |
| **Music Generator** | Compositional pieces: entrance themes, arena battle music, branch ambient scores | Melody input (hum, play, type), style selection, layered instrument mixing |
| **Motion Compositor** | Combined effect packages: a full spell animation with synced audio and particle trails | Layered timeline combining outputs from all four generators above |

```
CraftingProject {
  projectId:        "craft.<userId>.<projectHash>"
  type:             "IMAGE" | "VIDEO" | "SOUND" | "MUSIC" | "COMPOSITE"
  status:           "TESTING" | "DRAFT" | "FINALIZED" | "ARCHIVED"
  versions:         CraftVersion[]
  linkedSkill:      skillRef | null
  linkedSpell:      spellRef | null
  resourceCost:     CraftingCostBreakdown | null
  createdAt:        epoch
  finalizedAt:      epoch | null
}

CraftVersion {
  versionId:        number
  contentHash:      string
  previewUrl:       string (ephemeral during TESTING, permanent after FINALIZE)
  parameters:       Record<string, any>
  parentVersion:    number | null
}
```

#### 43.11.2 Free Tier — Testing Is Always Free

All crafting generators are **free to use for testing and iteration**. There is no paywall on creativity:

- Users generate unlimited test images, videos, sounds, and compositions
- Test outputs render only on the user's own screen (private preview)
- Test outputs carry a visible "DRAFT" watermark in any shared context
- Test outputs cannot be equipped to spells or used in duels/arenas
- The free tier exists specifically so users can experiment, iterate, and discover their style without financial pressure

**The testing phase is encouraged.** A user might generate fifty variations of a fire effect before finding the one that matches their sword technique. That iteration IS the crafting process. Relay wants users to explore — the cost only arrives when you decide something is ready for the world.

#### 43.11.3 Finalization — Where Resources Are Spent

When a user decides a crafted graphic is ready, they **finalize** it. Finalization commits the graphic as a permanent filament on the user's crafting branch and enables it for real use:

```
FinalizationCost {
  baseCost:             number (per rarity tier, in crafting tokens)
  renderLoadMultiplier: number (derived from infrastructure cost: particle count, resolution, duration, audio layers)
  rarityTier:           "COMMON" | "UNCOMMON" | "RARE" | "EPIC" | "LEGENDARY"
  treasureGate:         TreasureRequirement | null
  totalCost:            baseCost × renderLoadMultiplier × rarityTierMultiplier
}

TreasureRequirement {
  requiredChestType:    "TYPE_1" | "TYPE_2" | "TYPE_3" | null
  requiredDiscoveries:  string[]
  requiredAchievements: string[]
}
```

**Two separate things are measured — and they must never be confused:**

1. **The system measures render load (infrastructure cost).** A 2-second color-shifted slash and a 30-second cinematic dragon sequence with 10,000 particles, synchronized orchestral audio, and environmental lighting both activate at maximum designed level. But the dragon sequence consumes vastly more GPU cycles, bandwidth, and storage every time it renders on every spectator's device. The `renderLoadMultiplier` reflects that real infrastructure cost — particle count, texture resolution, animation duration, audio layer count. This is not a quality judgment. It is a resource bill.

2. **The crowd measures quality (artistic value).** The system never scores beauty, artistry, or emotional impact. It renders what you built, at the level you designed it, every time. Whether people come back to watch — that is the only quality metric that exists.

The system charges for what the graphic costs to render. The crowd decides what the graphic is worth watching.

**Cost structure:**

| Rarity Tier | Base Cost | Render Load | Gate |
|-------------|-----------|-------------|------|
| **Common** | Low | Low multiplier (simple effects) | None — accessible to any active user |
| **Uncommon** | Moderate | Moderate multiplier | None |
| **Rare** | Significant | Higher multiplier (complex compositions) | Specific treasure discoveries required |
| **Epic** | High | High multiplier (full AV sequences) | Type 1+ treasure discoveries + achievement thresholds |
| **Legendary** | Very high | Highest multiplier (cinematic-scale) | Type 2/3 treasure + crafting mastery history |

**Treasure gating:** Some rarity tiers require proving eligibility before crafting at that tier is available. A user cannot finalize a Legendary-tier spell effect without having discovered the relevant treasure chests, achieved specific milestones, or demonstrated crafting mastery through a history of prior finalizations at lower tiers. The gate is not a paywall — it is a progression system. You earn the right to craft at higher tiers through play, discovery, and skill.

#### 43.11.3b Activation & Attention — The Real Measure

A finalized spell graphic either **activates at maximum designed level or it does not.** There is no partial rendering, no quality slider, no degraded mode. When the user executes the linked skill or casts the linked spell, the graphic fires exactly as designed — every time, for every spectator. The system does not judge the graphic. The crowd does.

**Attention is the quality metric.** The system does not score your fire arc animation on a 1-10 scale. It does not measure "beauty" or "artistic coherence." It renders what you built, at full intensity, and the question becomes: do people come back to watch?

A user whose crafted spell effects are visually stunning, artistically coherent, and emotionally impactful will draw crowds. Those crowds generate attention. That attention flows back to the user as engagement sap on their tree — thickening branches, increasing heat, generating crafting token income (§43.11.6), and amplifying their presence on the globe. The crowd IS the quality measurement.

**Graphic design as a weapon:**
- A duelist with mediocre sword skill but breathtaking visual effects draws a bigger audience than a technically superior fighter with default graphics
- The bigger audience means more votes in the duel resolution (§42.5), more engagement on the tree, more passive crafting income, more visibility on the globe
- This creates a legitimate path to power through artistic mastery: the graphic designer who crafts devastating visual sequences is as strategically valuable as the martial artist who masters the three-section staff
- Teams forming for multi-intelligence combat (§43.12) will actively recruit talented graphic crafters the same way they recruit skilled fighters — because the visuals draw the crowd, and the crowd is the resource

**The virtuous cycle:** Great graphics → larger audience → more attention → more crafting resources → ability to craft at higher tiers → even greater graphics → even larger audience. Artistic skill compounds. A user who invests in their visual language builds a self-reinforcing advantage that makes them increasingly compelling to watch. This is by design — Relay rewards the effort of building something beautiful.

#### 43.11.4 Verification & Integrity

Every finalized graphic is verifiable:

- The `contentHash` of the finalized asset is committed as a filament on the user's crafting branch
- The crafting parameters (every slider position, every seed value, every layer configuration) are stored as evidence
- Any user can verify that a displayed graphic matches its committed hash
- Finalized graphics cannot be silently modified — any change requires a new finalization (new cost, new hash, new filament)
- The crafting branch shows the full history: every test iteration that led to the final version (if the user opts to preserve history), the finalization cost, and the linked skill/spell

**Anti-fraud:** Graphics generated outside the Relay Crafting IDE cannot be imported as finalized effects. The system verifies that the generation pipeline produced the output — you cannot upload a Photoshop file and call it a Relay-crafted graphic. The crafting tools are the only valid source. This ensures every visual in the system was built within the system's constraints.

#### 43.11.5 Linking Graphics to Skills & Spells

A finalized graphic becomes usable by linking it to a specific skill or spell in the user's repertoire:

- **Skill link:** "When I execute my Zone 3→7→12 nunchaku combo, display THIS fire arc effect"
- **Spell link:** "When I cast Fireball (spell registry #4401), use THIS custom fireball animation instead of the default"
- **Ambient link:** "My personal tree always renders THIS ambient particle effect around the trunk"
- **Entrance link:** "When I enter a duel arena, play THIS entrance animation and THIS music"

Multiple graphics can be linked to the same skill (user chooses which to activate per session, like a combat loadout). The linked graphic renders for anyone who can see the user — spectators, opponents, proximity channel participants. The graphic IS the language. Two swordsmen casting the same Fireball spell see completely different visual effects because each crafted their own.

#### 43.11.6 The Crafting Economy

Crafting resources are earned, not only purchased. All crafting token balances are stored in the user wallet (§41.10):

- **Gameplay rewards:** Winning duels, completing quests, discovering treasure chests, achieving milestones all grant crafting tokens
- **Attention economy:** Receiving sustained engagement on your tree (real attention from real users, not bots) generates passive crafting resource income
- **Direct purchase:** Users can purchase crafting tokens at the standard ISR-governed rate (§86)
- **Community contribution:** Translating UI strings, verifying maps, moderating content, teaching new users — all grant crafting token rewards

The economy ensures that active, contributing users always have crafting resources available. Inactive users who return after a long absence may need to re-engage before affording high-tier finalizations. The tree shows your crafting investment: a user with a rich crafting branch has demonstrably invested time, skill, and resources into their visual identity.

**Contract #311 — Graphic Crafting Module. Every user has access to the Relay Crafting IDE: integrated generators for images, video, sound, music, and composite motion effects. All generators are free for unlimited testing and iteration — test outputs render privately and carry DRAFT status. Finalization commits a graphic as a permanent filament on the user's crafting branch with a verified content hash, consuming crafting resources calculated as base tier cost × render load multiplier × rarity tier multiplier. The system measures render load (infrastructure cost: particle count, resolution, duration, audio layers) — never artistic quality. The crowd measures quality through attention: returning spectators, engagement sap, and globe visibility are the only quality metrics. Finalized spell graphics activate at maximum designed level or not at all — no partial rendering, no degraded mode. Graphic design is a legitimate combat weapon — artistic mastery draws audiences as effectively as martial skill, creating a virtuous cycle of attention and crafting resources. Legendary-tier crafting requires treasure chest discoveries, achievement thresholds, and demonstrated crafting mastery as prerequisites. Finalized graphics link to specific skills, spells, or ambient tree effects — the graphic IS the user's visual language. Graphics generated outside the Crafting IDE cannot be imported. Every finalization is verifiable: content hash, generation parameters, and linked skill/spell are committed as evidence. Crafting resources are earned through gameplay, attention, community contribution, and direct purchase. The crafting economy, tier costs, render load formula, and treasure gate requirements are Category A parameters (community-governed). The Graphic Crafting Module is frozen.**

---

### 43.12 Summon Cards — AI Creatures & Multi-Intelligence Combat

> *"I choose you."* — Ash Ketchum, Pokémon

Summon Cards are not graphics. They are not decorative. They are **autonomous AI entities** that fight alongside you, make independent decisions, and can be defeated. When you summon a creature in Relay, you are deploying an intelligence — not displaying an animation. This is where Relay combat becomes multi-agent strategy: you command your tree, your spells, your body, AND your summoned creatures simultaneously.

#### 43.12.1 What Makes a Summon Different from a Graphic

| Property | Crafted Graphic (§43.11) | Summon Card |
|----------|-------------------------|-------------|
| **Nature** | Visual/audio effect | Autonomous AI entity |
| **Behavior** | Plays when triggered, follows script | Makes independent combat decisions |
| **Interaction** | Decorative / representational | Attacks, defends, blocks, counters |
| **Opponent impact** | Visual only — no mechanical effect on opponent | Deals damage, applies status effects, absorbs hits |
| **Intelligence** | None — it is a media asset | SCV-controlled AI agent with its own decision model |
| **Defeat** | Cannot be "destroyed" | Can be destroyed by opponent's attacks or summons |
| **Cost** | Crafting resources (one-time finalization) | Power cost per summon + maintenance drain while active |

A user can map dragon-themed graphics to their sword attack — that is crafting (§43.11). The dragon graphic plays when the sword swings. It looks impressive. It has no independent behavior.

A Summon Card dragon is different: it appears on the field as an autonomous entity. It decides whether to attack the opponent, defend the summoner, target the opponent's summons, or hold position. It has Power, Toughness, and special abilities. It can be killed. When it dies, the summoner loses the investment.

#### 43.12.2 Summon Card Schema

```
SummonCard {
  cardId:           "summon.<registryId>"
  name:             string
  creatureType:     string (dragon, elemental, spirit, construct, beast, etc.)
  source:           "FOUNDER_REGISTRY" | "PHYSICAL_CARD_MAPPED" | "DISCOVERY_UNLOCKED"
  
  stats: {
    power:          number (damage dealt per attack cycle)
    toughness:      number (damage absorbed before destruction)
    speed:          number (action priority — higher acts first)
    intelligence:   number (decision quality — affects AI combat choices)
  }
  
  abilities:        SummonAbility[]
  elementAffinity:  ElementType[]
  summonCost:       number (Power deducted on summon)
  maintenanceDrain: number (Power per turn while creature is active)
  summonDelay:      number (seconds of hold required to complete summon)
  
  visualAsset:      craftingRef | null (user can link custom crafted graphics to their summon)
  aiModel:          "TACTICAL_BASIC" | "TACTICAL_ADVANCED" | "STRATEGIC" | "ELITE"
}

SummonAbility {
  abilityId:        string
  name:             string
  type:             "PASSIVE" | "ACTIVATED" | "TRIGGERED"
  effect:           AbilityEffect
  cooldownTurns:    number
  powerCost:        number (additional Power if activated)
}
```

#### 43.12.3 How Summons Work in Combat

**Summoning process:**
1. The user presents the physical card OR activates a discovered summon from their registry
2. SCV recognizes the card/gesture and initiates summoning sequence
3. A summoning delay (3-5 seconds of sustained hold) must complete without interruption — opponents can interrupt with Instant spells (§42.4)
4. On successful summon, the creature manifests as an AI-controlled entity on the user's side of the field
5. Power is deducted immediately. Maintenance drain begins.

**Creature behavior — the AI layer:**
- Each summon operates as an **SCV-controlled sub-agent** with its own decision model
- The AI model tier (Basic → Elite) determines decision quality: Basic creatures attack the nearest target; Elite creatures evaluate board state, predict opponent actions, and coordinate with other summons
- The summoner can issue **broad directives** ("attack," "defend," "target their left summon") but cannot micromanage every action — the creature has autonomy within the directive
- Creature decisions are committed as filaments on the duel branch — every action is auditable

**Multi-intelligence combat:**
- A skilled summoner commanding their own body (sword/nunchaku/staff) while directing two or three summons simultaneously is managing multiple intelligence streams
- This is the strategic depth layer: your personal CPI determines your spell efficiency, while your summons' AI tier determines their combat effectiveness, and your directives determine coordination quality
- The best duelists master both: devastating personal combat AND brilliant creature direction — like a chess grandmaster who also fights

**Creature interaction:**
- Summons from opposing sides clash automatically based on speed priority
- Creatures can attack: opponent's summons, the opponent directly (if unblocked), or defensive positions
- When a creature's accumulated damage equals or exceeds its toughness, it is destroyed
- Destroyed creatures dissolve — the visual effect plays, the Power investment is lost, the destruction is committed as a filament

#### 43.12.4 Summon Sources — Where Cards Come From

Summons enter a user's collection through three channels:

**1. Founder Registry (Day-1 Set)**
The founder defines a curated set of summon creatures at launch. These are the baseline creatures that establish combat balance and demonstrate the summoning system. Like Relay Set Weapons, founder summons are the reference set — balanced, tested, and frozen in stats.

**2. Physical Card Mapping (§43.7)**
Creature-type cards from Magic: The Gathering, Pokémon, and other physical card games that are mapped in the secret registry (§43.7) function as summon activators. You hold the physical card to your camera; the SCV recognizes it; the mapped creature summons. The creature's stats are defined in the encrypted registry — the real-world card's market value has zero correlation with in-game power.

**3. Discovery Unlocked**
Specific treasure chest discoveries (§96), quest completions, and achievement milestones can unlock unique summon creatures not available through any other means. These discovery summons are often the most powerful — rewarding exploration and understanding over collection.

#### 43.12.5 The MTG/Pokémon Combat Model

Relay summon combat draws from two traditions:

**From Magic: The Gathering:**
- **The Stack:** Summon actions can be responded to with Instant spells. Responses stack. Resolution is last-in-first-out.
- **Creature combat:** Attacking and blocking mechanics. Creatures declare attacks; defending player assigns blockers. Unblocked damage hits the opponent's tree health.
- **Card advantage:** More discovered summons = more strategic options. But quantity doesn't beat quality or timing.

**From Pokémon:**
- **Type advantage:** Creature element affinity creates rock-paper-scissors dynamics. A water-affinity summon deals bonus damage to fire-affinity creatures.
- **Evolution potential:** Some summons can be upgraded through specific achievement chains — the creature gains new abilities or stat improvements, committed as a filament on the creature's branch.
- **One creature per card:** Each physical card can summon one creature at a time. Summoning a second creature from the same card recalls the first.

**Tree health in combat:**
- Each duelist's tree has a **combat health pool** derived from their tree's structural integrity (mass, confidence, engagement history)
- Unblocked creature damage reduces tree health
- Direct spell damage reduces tree health
- When tree health reaches zero, the duelist loses (combat defeat — the audience still votes on the full duel including evidence quality)
- Tree health regenerates between duels — combat defeat does not permanently damage the tree

#### 43.12.6 Customizing Summon Visuals

Users can link crafted graphics (§43.11) to their summon creatures:

- The base creature (stats, abilities, AI model) comes from the registry
- The visual representation can be customized through the Crafting IDE
- A dragon summon might look like a traditional dragon for one user and an abstract geometric construct for another — same stats, different visual identity
- Customized summon visuals go through the standard crafting finalization process (resource cost, content hash, verification)

This means two players holding the same physical Magic card can summon the same creature with completely different visual presentations. The mechanics are identical. The aesthetics are personal.

#### 43.12.7 Founder Summon Designation

The founder (Eitan Asulin) designates which physical cards, discoveries, and achievements map to summon creatures. This is analogous to the Relay Set Weapons designation:

- The founder defines the initial creature registry
- Community governance can propose new summon mappings through the standard Layer-3 vote process
- The founder retains veto on day-1 summon balance to prevent launch-day exploitation
- After the founder bootstrap window (§86.3), summon balance becomes fully community-governed (Category A parameters)

No user can create new summon AI entities from scratch — summons must come from the registry (founder-defined, discovery-unlocked, or community-proposed and governance-approved). Users create the visuals (§43.11). The AI behavior and stats come from the system. This prevents the ecosystem from being flooded with unbalanced custom creatures.

**Contract #312 — Summon Cards & Multi-Intelligence Combat. Summon Cards are autonomous AI entities controlled by the SCV, distinct from crafted graphics. Each summon has Power, Toughness, Speed, Intelligence, element affinity, abilities, summoning cost, and maintenance drain. Summons are deployed during combat through physical card recognition (§43.7), founder registry activation, or discovery-unlocked triggers (§96). Summoning requires a hold delay that can be interrupted by opponent Instant spells. Summoned creatures make independent combat decisions through four AI model tiers (Basic → Elite); summoners issue broad directives but cannot micromanage. Multi-intelligence combat allows simultaneous personal combat (CPI-driven) and creature direction. Creature interactions follow MTG-inspired stack resolution and attack/block mechanics combined with Pokémon-inspired type advantage and evolution systems. Tree health pools are derived from structural tree integrity; unblocked creature and spell damage reduces health; zero health = combat defeat (does not permanently damage the real tree). Users can customize summon visuals through the Crafting IDE (§43.11) — same creature stats, personalized aesthetics. New summon creatures enter the registry only through founder designation, governance-approved community proposals (Layer-3 vote), or discovery triggers. No user-created AI entities outside the registry. Summon stats, AI tiers, type advantage tables, and evolution requirements are Category A parameters (community-governed after founder bootstrap window). The Summon Card system is frozen.**

---

## 44. Founder Key — Global Game Layer Activation Primitive

### 44.1 The Key

Global game layer activation requires a special governance primitive that exists outside the parametric voting system:

- **Holder**: The founder account (Eitan Asulin) — singular, non-transferable
- **Condition A**: System parameters reach thresholds initially set by the founder at system launch. These thresholds are enhanced (made more precise, more demanding) by eligible players who have unlocked AR interaction modules over time through parametric governance, but the BASELINE thresholds are founder-set.
- **Condition B**: Explicit activation by the founder account. Even when Condition A is met, founder-key-gated game layer modules remain inactive until the founder acts.
- **Irreversibility**: Once activated, the game layer cannot be deactivated. The key turns once.

### 44.2 Why a Founder Key

Every other governance mechanism in Relay is community-driven (parametric voting, migration commits, threshold triggers). The game layer founder key is the single exception. It exists because the game layer represents a civilizational shift in how humans interact with reality. The collective readiness must be validated not just by metrics but by human judgment at the highest level of system responsibility.

### 44.3 Day-1 Setup — What the Founder Deploys

On day 1, the founder establishes the complete system foundation:

1. **Truth layer ruleset and template library** — published, transparent, governable from day 1
2. **Interaction/game layer physics engines** — deployed on every client, running silently. The detection engine (element recognition, card matching, gesture detection) operates from the first moment any camera turns on. Before module activation, accumulated detections have no visible effect — but the engine is learning.
3. **Encrypted spell registry** — the complete mapping of trigger combinations to spell effects, hashed and sealed. Deployed to every client as encrypted data. Cannot be read without physically presenting the matching input (card, gesture, element) to a camera.
4. **Relay Set Item registry** — the complete list of physical objects (cards, dice, POGS, etc.) with Relay meaning, perceptually hashed and encrypted alongside their effects
5. **Treasure chest coordinates** — all treasure locations and clue content, encrypted and distributed
6. **Classified document corpus** — the full development archive (Master Build Plan, AI transcripts, design videos, decision logs) classified into Revelation Tiers RT-0 through RT-4 (§89.1), encrypted per tier, and deployed to Tree Zero's sealed branches. RT-0 content extracted into the Day-1 Starter Pack. RT-4 fragments distributed into treasure chests. Classification map committed as a governance filament.
7. **Game layer activation thresholds** — the community metrics that must be met before the founder key can turn (published as targets, not secrets)
8. **Initial global parameters** — sleep cycle duration, spam threshold, vote eligibility age, and all other system parameters with starting values (immediately governable by community voting)

**Founder constraints after day 1:**
- Cannot modify frozen contracts
- Cannot override governance votes
- Cannot grant themselves extra Power or resources
- Cannot secretly change spell rules (the registry is hashed and verifiable — any tampering breaks the hash chain)
- CAN append new spells, treasure chests, and Relay Set Items to the registry (append-only, never modify or remove existing entries)
- Cannot activate game layer before community thresholds are met

### 44.4 Pre-Activation State

Before game layer global activation:
- Game layer challenge stubs exist in the system but are inert (visible as future content, non-interactive)
- Monster generation AI is dormant
- Duel mechanics are restricted to evidence debate format (without genre overlay or spell combat)
- Multi-resource economy operates on engagement credits + achievement tokens only (no monster-economy lever)
- Genre templates exist as specifications but do not render
- Power accumulates silently from element detection but has no use
- Spell triggers produce no visible effect (the engine detects them but doesn't activate)
- Treasure chests are invisible

After activation: all game layer modules activate globally and simultaneously. Power becomes spendable. Spells become castable. Monsters spawn. Treasure chests appear. The game begins. The fog of war starts lifting for those who explore.

---

## 45. Frozen Contracts — Module Mechanics + Constitutional Hardening

The following contracts extend the frozen contract list (§26). Contracts 28-44: module layer mechanics. Contracts 45-53: structural additions. Contracts 54-67: constitutional hardening. Contracts 68-74: identity, dispute resolution, and growth model. Contracts 75-85: sociological resilience and sortition accountability. Contracts 86-89: Relay Council, module pipeline, escalation hierarchy, draft → commit universality.

28. **Layers are additive**: Each conceptual layer (Truth, Interaction, Game) enhances the layers below it. Removing a layer does not break the layers below. Game layer commands resolve to AR interaction rendering, which resolves to truth layer filament commits. No module may bypass a lower-layer prerequisite.
29. **Achievements are evidence-based**: Personal module achievements require SCV-validated proof recorded as filament evidence on the user tree. No achievement is granted by fiat, vote, or purchase.
30. **Skill yields more than participation**: Achievement tokens can be earned through SCV-validated achievements in any context — truth layer, arena, education, civic contribution. The validation requirement (demonstrated skill with evidence) is non-negotiable. Participation without demonstrated skill yields engagement credits. The gradient is: validated skill → AT, participation → EC, spell casting → Power. (Amended by §71.2.)
31. **Spells resolve to commits**: Every spell, regardless of visual effect or genre overlay, ultimately resolves to one or more truth layer filament operations (query, commit proposal, evidence reference). No spell bypasses frozen contracts 1-27.
32. **Duels are public filaments**: Duel events are classified as public filament events. Community votes on duel outcomes follow standard vote governance (eligibility gates, decay, threshold mechanics). Sword skill does not grant governance power — evidence quality does.
33. **Genre is a rendering template**: Genre overlays (Sci-Fi, Fantasy, Horror, etc.) are visual templates applied at the rendering layer. They never modify the underlying truth. A monster rendered as a dragon and a monster rendered as an alien are the same engineering challenge underneath.
34. **Founder key is singular**: Global game layer activation requires explicit action by the founder account. No parametric vote, governance proposal, or community threshold can activate the game layer without the founder key. Once activated, irreversible.
35. **Monster economy is governed**: Monster spawn rate, reward magnitude, and difficulty curve are global parameters set by parametric governance (weighted-median voting). No central authority sets these values. The community controls its own economic lever.
36. **Voice commands are proposals**: Voice-initiated actions follow identical governance to any other input modality. No voice command bypasses commit materiality, work zones, human approval, or any frozen contract. Voice transcripts are attached as evidence on the resulting commit.
37. **Architect parses, Canon proposes, Human decides**: The three-stage voice pipeline (Whisper → Architect → Canon) is non-collapsible. No shortcut from raw audio to committed filament. Architect only parses, Canon only proposes, and the human is the sole authority to approve.
38. **Power cannot buy governance**: Power (game layer resource) exists in a closed loop for spell casting only. It cannot be converted to Engagement Credits or Achievement Tokens, cannot increase vote weight, cannot modify filament confidence, and cannot override any governance decision. Power grants spectacle, never authority.
39. **Public world graphics are earned only**: The shared Relay globe has no custom graphics by default. The only non-data visuals in the public world are pre-programmed Relay Graphics triggered by physically performing correct trigger sequences (element + gesture + voice + optional card). No cosmetic purchases. No avatar customization. Graphics are proof of skill.
40. **Bystander privacy is absolute**: The detection mesh (Relay-authorized cameras) only processes entities with active Relay presence markers. Non-Relay users and people who have disabled their presence are never processed, tracked, or rendered. No exceptions.
41. **Card and spell registries are append-only**: The founder can add new spells, cards, treasure chests, and Relay Set Items after launch. Existing mappings are immutable — once a card is mapped to a spell effect, that mapping never changes. Tampering breaks the hash chain and is detectable.
42. **Truth layer responsibility outweighs game layer power**: Achievement Tokens (from real-world contribution) gate advanced capabilities that Power (from gaming) cannot access. No amount of game layer performance can surpass the governance weight, economic resources, or system influence earned through truth layer real-world work.
43. **Sleep regeneration is community-governed**: The daily rest cycle duration is a global parameter set by weighted-median voting. It simultaneously rate-limits activity, prevents bot abuse, and incentivizes healthy behavior. The parameter is adjustable by the community, never hardcoded.
44. **Organizational and global confidence are independent channels**: `orgConfidence` (evidence_present / evidence_required) drives slab opacity. `globalConfidence` (community vote alignment) drives globe ranking. Neither overrides the other. No code path may average, blend, or merge them. Separate storage, separate setters, separate arithmetic. Mandatory `DUAL-CONFIDENCE-SEPARATION-PROOF` verification artifact.
45. **Tier-gated attention at globe LOD**: Anonymous accounts (Tier 0) cannot contribute to attention metrics at GLOBE or REGION LOD. Attention from Tier 0 users is excluded from trunk prominence calculations. This prevents bot-farming of globe visibility. Tier 1+ identity (verified via SCV or proximity) is required for attention signals to propagate above COMPANY LOD. Enforcement: the attention aggregation function at GLOBE LOD filters input by identity tier before computation.
46. **Monster economy rate-of-change caps**: Global parameters governing monster spawn rate, reward magnitude, and difficulty curve are subject to per-epoch rate-of-change caps. No single governance vote cycle may change any of these parameters by more than 20% from the previous epoch's value. This prevents economic shock from sudden parameter manipulation. The cap itself is a frozen constant — not subject to parametric governance.
47. **Resource non-convertibility is explicit and total**: The three resource types (Engagement Credits, Achievement Tokens, Power) exist in strictly separated pools. No mechanism — governance vote, founder action, SCV operation, spell effect, duel outcome, or economic event — may convert one resource type to another. No exchange rate exists. No marketplace may be created. The separation is structural (different ledger types), not policy (a rule that could be voted away).
48. **Founder activation requires attestation commit**: Global game layer activation (the founder key) requires a signed attestation commit on the founder's user tree. This commit records: activation timestamp, the exact parameter state at activation (all global parameters + their weighted-median values), and a declaration of readiness. The commit is append-only and Merkle-sealed. It serves as permanent evidence of the activation decision, preventing post-hoc disputes about "when the game layer was turned on" or "what state the system was in."
49. **Detection mesh is local-first**: All camera-based element detection (fire, smoke, rain, light, etc.) and object recognition runs on-device. Raw video frames never leave the user's hardware. Only classified signal metadata (element type, confidence score, timestamp) is transmitted. The SCV validates these metadata signals, not raw imagery. No central server stores or processes video. No network partition or server outage can disable local detection. This is a privacy constraint, a latency constraint, and a resilience constraint simultaneously.
50. **Minor safety prohibition**: Relay shall not process, render, or respond to trigger sequences performed by users who have not passed age verification (Tier 1+ identity). Spell trigger sequences involving fire, combustion, or extreme physical interaction require explicit safety attestation (a signed acknowledgment on the user tree) before the SCV will recognize them. No spell effect may instruct, encourage, or require physical actions that pose inherent danger to the user, bystanders, or property. Violations emit `[REFUSAL] reason=SAFETY_GATE` and halt the spell pipeline.
51. **Legal posture document required before public launch**: No Relay instance may accept external users without a published legal posture document covering: data residency jurisdiction, GDPR/CCPA compliance mechanism (cryptographic erasure per §48.7), content liability framework, identity tier data retention policy, append-only vs. right-to-erasure reconciliation, and camera detection privacy policy. This document must be referenced by a governance commit at the root of the tree. Its absence is a deployment blocker.
52. **Presence quantization at high LOD**: At GLOBE and REGION LOD, individual presence markers are not rendered. Presence is aggregated into heatmap tiles (density per geographic cell). The quantization threshold is: above COMPANY LOD, presence becomes statistical. Below COMPANY LOD, presence is individual. This prevents globe-level user surveillance and reduces rendering load. The quantization boundary is a frozen constant per LOD level, not a user-configurable filter.
53. **Quarantine branch mechanism**: When governance triggers content removal (prohibited content, safety violation, legal order), the affected filaments are migrated to a quarantine branch. The quarantine branch is: append-only (filaments moved in, never deleted), invisible at all LODs except explicit governance audit view, excluded from confidence and attention aggregation, excluded from trunk consolidation, and cryptographically sealed (content encrypted, only governance auditors with explicit key can read). This preserves the append-only Merkle chain while making prohibited content invisible and inaccessible to normal users.
54. **Attention is a lens, never a lever**: Attention metrics (presence focus count, gaze concentration, engagement rate) affect ONLY visibility, rendering prominence, and LOD priority. Attention NEVER affects: vote weight, confidence values, permissions, execution priority, resource earning rate, governance authority, or any parameter that determines what a user CAN DO. If attention ever influences a decision gate, the system becomes performative and gameable. This is the single most critical separation in Relay. Violation = constitutional failure.
55. **Fresh account governance cooldown**: A newly verified Tier 1 account has zero governance weight for a minimum of 14 days AND 10 domain-relevant commits. Governance weight accumulates proportionally to: time since identity verification, number of evidence-contributing commits (not just presence), and branch-specific participation depth. This prevents Sybil attacks via many cheap freshly-verified identities. The cooldown duration and commit threshold are global parameters (votable), but the existence of a cooldown is frozen.
56. **Context-weighted vote eligibility**: Votes on branch-level governance (evidence rules, template changes, parameter adjustments) are weighted by: recency of participation on that branch (exponential decay, half-life = 90 days default), evidence contribution history on that branch (commits that added/verified evidence, not just presence), and active filament involvement (open filaments where the voter is a named party). A verified but inactive account on a specific branch cannot swing that branch's governance. This prevents off-platform vote renting — purchased votes from accounts with no branch history carry near-zero weight.
57. **Acceleration requires diverse participation**: The acceleration metric (heat = d(engagement)/dt) at GLOBE and REGION LOD is computed from eligible events only. Eligibility requires: Tier 1+ identity, distinct user IDs (not repeated events from the same user), per-scope rate limits (max N events per user per hour per branch), and engagement spam decay (repeated identical engagement types from the same source decay exponentially). A "hot" topic at globe scale requires diverse participants, not one coordinated cluster.
58. **FilamentBirth cluster suppression**: When FilamentBirth events (Note → Filament conversion) originate from the same device cluster (same IP subnet, same BLE proximity group, or same Wi-Fi SSID) at rates exceeding the branch-level spam threshold, subsequent births from that cluster are auto-classified as low-visibility (not deleted — append-only preserved, but excluded from attention aggregation and rendered at minimum prominence). The spam threshold is: max 3 FilamentBirths per cluster per hour per branch (default, votable). Exceeding it emits `[REFUSAL] reason=CLUSTER_SPAM_THRESHOLD`.
59. **Monster economy issuance budget**: Total engagement credit issuance from monster rewards is bounded per epoch. The issuance budget = `previous_epoch_issuance * (1 + rate_cap)` where `rate_cap` is the 20% frozen maximum from contract #46. If monster spawns would exceed the epoch budget, spawn rate is automatically throttled (DEGRADED mode). Throttle is visible: `[DEGRADED] reason=ISSUANCE_BUDGET_EXCEEDED`. Budget overrun is structurally impossible; issuance is metered, not open-ended.
60. **Difficulty floor and beginner ramp**: Monster difficulty adjustments cannot steepen faster than a frozen maximum delta per epoch. Additionally, a "beginner zone" exists: users with fewer than 30 days of engagement history face a difficulty ceiling that is 50% of the global difficulty parameter. This prevents difficulty starvation (too hard → new users can't participate → adoption stalls). The beginner threshold (30 days) and ceiling ratio (50%) are global parameters (votable), but the existence of a beginner ramp is frozen.
61. **Prohibited trigger taxonomy and venue safety defaults**: A frozen registry of prohibited spell triggers exists. Categories: triggers requiring combustion or open flame in enclosed spaces, triggers requiring high-altitude physical positioning, triggers directed at or near minors (age-gated by identity tier), triggers in designated safety zones (hospitals, schools, airports). Venue templates include a `safetyProfile` field that defaults to `restricted` for educational, medical, and transportation venues. Venue operators may loosen restrictions only via explicit governance commit on their tree. Game layer modules are disabled by default in `restricted` venues.
62. **Presence anti-correlation and time-bucketing**: Presence updates transmitted beyond the local device are time-bucketed: at COMPANY LOD, updates are quantized to 5-second intervals. At REGION LOD, 30-second intervals. At GLOBE LOD, 5-minute intervals. Additionally, position precision degrades with LOD: COMPANY = 10m accuracy, REGION = 1km, GLOBE = 50km. Movement correlation attacks (inferring identity from motion patterns) are structurally mitigated by the combination of time-bucketing + precision degradation + statistical aggregation above COMPANY LOD.
63. **Blended confidence CI lint**: The `DUAL-CONFIDENCE-SEPARATION-PROOF` must run as a pre-commit gate. Any code path that introduces `computeConfidence()` calls (outside the deprecated trap), arithmetic expressions combining `orgConfidence` and `globalConfidence`, or shared setter functions for both channels must fail the proof and block the commit. This is enforced via pre-commit hook, not voluntary discipline.
64. **Git attachment hygiene**: Binary files larger than 500KB are blocked from Git commits by pre-commit hook. Evidence attachments (images, PDFs, video) are stored in content-addressed external storage (SHA-256 hash as key). Git stores only the content hash reference. Proof artifacts (screenshots, logs) are exempt up to 2MB per file. The hook is mandatory and cannot be bypassed without explicit `--no-verify` (which is logged as a governance event).
65. **Renderer over-instantiation refusal**: The filament-renderer enforces hard primitive budgets per LOD level (§33.2). When instantiation would exceed the budget, the renderer emits `[REFUSAL] reason=PRIMITIVE_BUDGET_EXCEEDED lod=<level> requested=<n> budget=<max>` and does NOT create the excess primitives. The world stays interactive. LOD budgets are frozen constants, not runtime-adjustable. This prevents the 100k-marker catastrophe.
66. **Camera operator liability model**: Any venue or organization connecting cameras to the Relay detection mesh must register as a **Data Processor** via a governance commit on their tree. The commit specifies: processing scope (which detection types are enabled), data retention period, geographic boundary of camera coverage, and the designated **Data Controller** (the legal entity responsible for compliance). Relay is the platform provider, never the controller. The operator model document is part of the legal posture requirement (contract #51). No camera connection is accepted without a registered processor commit.
67. **Founder activation jurisdiction checklist**: Game layer global activation (founder key) requires, in addition to the attestation commit (contract #48), a jurisdiction compliance checklist commit. This commit records: jurisdictions where Relay instances are active, per-jurisdiction compliance status (GDPR, CCPA, COPPA, local camera/privacy law), any jurisdictions where game layer modules are restricted or prohibited, and the legal posture document hash for each jurisdiction. Activation without the jurisdiction checklist emits `[REFUSAL] reason=JURISDICTION_CHECKLIST_MISSING` and blocks the key.
68. **Sortition juries are the sole dispute resolution mechanism**: No founder decree, admin action, or majority vote can override a jury verdict on dispute cases (Sybil enforcement, community disputes, quarantine appeals, governance deadlocks). The 4:3:3 sortition ratio (random:volunteer:historic), cryptographic selection, and bias detection are frozen. The sortition mechanism itself can be refined (jury size, eligibility thresholds) via parametric governance, but its existence and primacy over other resolution methods cannot be removed.
69. **Password Dance uses the spell detection pipeline**: The somatic authentication system (Password Dance) MUST use the same on-device camera detection pipeline (facial landmark extraction, motion vector analysis, audio feature extraction) that is used for spell trigger detection in the interaction/game layer modules. No separate biometric system may be introduced. This ensures: pipeline validation from day 1, per-user calibration data, and muscle memory training for downstream spell interaction. The Password Dance is required for STRICT authentication level only; PIN is sufficient for BASIC and ELEVATED.
70. **Guardian recovery is social, never centralized**: Account recovery MUST require M-of-N guardian approval. No admin, founder, or system process can unilaterally restore account access. Guardian approval requires ELEVATED authentication. The recovery event is an append-only governance commit. Maximum 2 recovery attempts per 30 days. Founder account recovery adds a 7-day public waiting period.
71. **Invitation decay is structural, refill is community-governed**: New accounts are created only via invitation from existing users. Initial invite count decays linearly (parent_count - 1) per generation. Once a user's initial allocation is depleted, they are reduced to 1, and new invites are granted at the **global invite refill rate** — a community-voted parameter (e.g., 1/week, 1/month, or 0 to pause growth). Open registration is structurally impossible — there is no registration endpoint without a valid invite code. The invite tree is append-only and traceable to the founder. At steady state, all users operate under the same refill rate regardless of generation depth.
72. **Reverification is periodic and tier-gated**: Identity verification is not one-time. Every user is subject to periodic reverification at intervals determined by their trust tier (Probationary: 7 days, Trusted: 90 days, Verified: 180 days, Anchor: 365 days). Failed reverification triggers tier demotion. The existence of periodic reverification and the tier structure are frozen; the specific intervals are global parameters (votable).
73. **Dual-user simultaneous verification for Sybil cases**: When two accounts are suspected of being the same person, the system can require both to verify at different physical locations within a synchronized time window. This mechanism is frozen and available to jury sortition cases and automated Sybil enforcement. It cannot be disabled by governance vote.
74. **Authentication escalation is action-driven, not user-chosen**: The authentication level required for an action is determined by the action's risk category, not by user preference. Users cannot opt out of STRICT authentication for critical identity changes. The smart verification trigger evaluates behavioral context and escalates automatically. This prevents social engineering attacks where users are tricked into performing critical actions at a lower authentication level.
75. **Early adopter influence is intentional and self-diluting**: Early adopters (low generation depth) naturally accumulate higher trust, deeper engagement history, and broader guardian networks because they have been present longer. This is intentional — early adopters ensure the system is built correctly during the critical formation period. Their influence **dilutes naturally** as more users participate: trust score has a ceiling of 100 (a 1-year user with perfect reliability equals a 5-year user), vote weight is context-weighted by branch-specific recency (not account age), jury pools expand with population (reducing any individual's selection probability), and the 4:3:3 ratio ensures 40% random selection. Generation depth itself carries no direct governance advantage — it is metadata for Sybil tracing. The pattern is: early power for system stewardship → natural dilution through mass participation.
76. **Trust score is behavioral, not ideological**: Trust score measures reliability: reverification compliance rate, jury service completion rate, evidence contribution consistency, absence of scars. Trust score NEVER measures: opinion alignment, narrative compliance, voting pattern, controversy avoidance, or ideological conformity. A user who consistently dissents but reliably completes reverification, serves on juries, and contributes evidence has the same trust trajectory as a user who aligns with majority positions. Dissent cannot reduce trust.
77. **Jury historic pool rotation cap**: No user may serve in the historic jury pool for more than the consecutive term limit (initial value: 2 terms, global parameter — votable). After reaching the limit, a mandatory cooldown (initial value: 6 months, global parameter — votable) before re-eligibility for the historic pool. The user remains eligible for the random and volunteer pools during the cooldown. This prevents permanent jury incumbency by early adopters. The existence of rotation is frozen; the specific limits are votable.
78. **Password Dance has a fallback path**: If the on-device detection pipeline fails (ML degradation, hardware incompatibility, adversarial attack, accessibility needs), STRICT authentication falls back to: PIN + 2-guardian attestation, OR PIN + proximity reverification at a registered Relay location. The Password Dance is the preferred primary path but NEVER a single point of failure for identity security. The fallback is always available.
79. **Guardian network diversity requirement**: At least 1 of every user's designated guardians must be from a different generation-depth quartile than the user. This prevents closed-loop guardian clusters where early adopters guard only each other. The system enforces this at guardian designation time. If the requirement cannot be met (e.g., very early in launch when few generation-depth quartiles exist), the constraint relaxes to "at least 1 guardian outside the user's immediate invite chain."
80. **Truth layer visibility is structurally primary**: At every LOD, the rendering engine prioritizes evidence structure (filaments, timeboxes, lifecycle states, confidence indicators) before spectacle overlays (spell effects, duel animations, monster visuals, weather). Spectacle layers can be toggled off by the user; evidence layers cannot. The default view always shows evidence structure. Game layer visual effects are additive overlays on the truth layer, never replacements. If the rendering budget is exceeded, spectacle is shed first, evidence last.
81. **Founder succession — Guardian Steward model**: If the founder account is inactive for the succession trigger duration (initial value: 365 consecutive days, global parameter — votable), succession authority transfers to the founder's designated guardian account. The guardian is elevated to **Steward of Relay** — a role with the same activation authority and constraints as the founder (cannot modify frozen contracts, cannot override governance, can only activate the game layer when thresholds are met). The new Steward receives a full Relay Founder-level tutorial and initiation sequence covering: all frozen contracts, the activation checklist, the jurisdiction compliance process, the attestation commit procedure, and the philosophical responsibility of the key. The Steward role is singular (one person). If the Steward's account also becomes inactive for the same succession trigger duration, the same succession process repeats to THEIR designated guardian. If no guardian is designated or the guardian account is also inactive, the Relay Sortition Council (§46.8) assumes activation authority as the final fallback (unanimous 7/7 consent required). The founder retains full user-level participation rights but loses sole activation authority upon succession. The existence of succession is frozen; the inactivity duration is votable.
82. **Emergency reform mechanism**: If a governance parameter or state causes demonstrable harm (3+ refusal logs per epoch or measurable system degradation in proof artifacts), a compressed reform path activates: 2x normal supermajority threshold (80% instead of 60%) with 1/4 normal settlement window. This allows urgent correction of harmful states without making routine governance changes easy. The emergency threshold and compression ratio are frozen.
83. **One-sentence explanation invariant**: Every governance mechanic that affects a user (vote weight change, parameter movement, reverification requirement, jury selection, trust score change, authentication escalation, migration trigger, confidence update) MUST display a one-sentence plain-language explanation in the UI at the point of interaction. Not in documentation, not in a help page — in the interface, at the moment it matters. If a mechanic cannot be explained in one sentence, the UI must still provide a summary with a drill-down option. Opacity is the primary legitimacy risk at scale; this contract is the defense.
84. **Regions vote features on or off**: Each region or jurisdiction governs its own feature set through standard parametric voting (§11). If a region's population votes to disable AR overlays, spell detection, duels, or any interaction/game layer module, those modules are disabled in that region's trees. This is not a system fork — it is branch-level parametric governance. The core truth layer is always active everywhere. Regional feature votes are visible globally: everyone can see that "Japan disabled AR overlays" or "Tokyo is a hotspot for RTS-style duels." This transparency lets the global community see which regions embrace which modules, creating natural cultural identity within the unified system. Cross-region references use Merkle inclusion proofs (hash only, not content). No system-level fork is needed — the fractal model handles regional diversity natively.
85. **Sortition live peer grading with consensus outlier de-weighting**: After every jury verdict, jurors grade each other (1-100%). Grades are visible as they arrive (not sealed), mutable as drafts, permanent once committed. When a juror's received grades converge to a consensus drastically lower than what they gave others (the 0% attacker), their outgoing grade weight is reduced proportionally — their grades are recorded but their impact on others' trust is diminished. Coalition abuse is structurally impossible because sortition is randomized: you cannot pre-arrange jury composition, so systematic factional grading cannot form across juries. If a region's jurors consistently receive low grades across many randomized juries, the signal is real, not bias.
86. **Relay Sortition Council is elected by continuous confidence, not fixed terms**: Council seats are held by the person with the highest sustained confidence (vote count × recency × voter trust). Confidence drops below threshold = automatic replacement by next in succession chain. No fixed terms, no election cycles, no vacancy periods. Constant competitive pressure keeps council members accountable. Council members must maintain Anchor trust tier, no active scars, and all prerequisites continuously.
87. **Module approval requires sandbox → community vote → council review**: No code enters the live Relay system without passing through: SANDBOX (simulation mode, no real commits) → PROPOSAL (formal submission with artifacts) → COMMUNITY VOTE (quorum + 60% approval) → COUNCIL REVIEW (5/7 supermajority with constitutional compatibility check) → CANONICAL COMMIT (Merkle-sealed, permanent). The Council cannot bypass any step. The community cannot bypass council review for system-level changes.
88. **Three-level dispute escalation**: Standard jury (9, simple majority) → Appeal jury (13, zero overlap, supermajority) → Relay Sortition Council (7, supermajority 5/7, final). The Council is the final appellate authority. No further appeals after council verdict. Council members with conflicts must recuse; their seat is temporarily filled by the next in succession.
89. **Draft → commit is universal for temporary data**: Notes, sticky notes, grades, proposals, and all user-generated drafts are mutable until explicitly committed. Nothing is permanent until the user says so. Once committed, data is append-only and Merkle-sealed. This edit buffer applies uniformly across the system — authentication grades, sortition grades, proposal text, Note content. The same model everywhere.

90. **Projection recursion depth cap = 3**: A projection may reference a truth branch (depth 1), another projection (depth 2), or a projection-of-projection (depth 3). Beyond depth 3, the system refuses: `[REFUSAL] reason=PROJECTION_RECURSION_DEPTH_EXCEEDED`. Cyclic projection dependencies are detected and refused before evaluation. This prevents exponential recompute from nested analysis layers.

91. **Projection evaluation time budget**: Each projection recomputation must complete within the evaluation budget (initial value: 50ms, global parameter — votable). If exceeded, the system caches the last valid result with a staleness flag and logs degradation. Projections do not recompute per-commit; they recompute per-timebox-boundary. This throttles analysis to the natural system heartbeat.

92. **Federation protocol version contract**: Two Relay-compatible systems must share the same MAJOR protocol version. Every commit carries a `protocolVersion` field (semantic versioning). Cross-system verification uses Merkle inclusion proofs. A system that cannot deterministically replay another's commit log is NOT Relay-compatible regardless of branding.

93. **Cross-region Merkle anchor publication**: At every digest interval (initial value: 24 hours, global parameter — votable), each region publishes a digest commit containing its Merkle root, total commit count, and timestamp. These digests are broadcast globally and to a public anchor. Missing digests are flagged. Divergent digests trigger reconciliation. No region can quietly omit or delay commits without detection.

94. **External evidence freeze on ingest**: When external data (PDFs, emails, 2D system exports) enters Relay, the system computes SHA-256, stores the hash as an `externalEvidenceRef`, and archives the original in content-addressed storage. Deleted external files do not break the evidence chain. The freeze commit is append-only and includes ingesting user, timestamp, and original filename.

95. **Education maturity transition**: Education templates include automatic maturity migration. When a student reaches the jurisdiction's adulthood threshold, juvenile filaments are re-scoped to `disclosureTier = 0` and moved to a sealed private archive branch. Filaments are NOT deleted (append-only preserved), but they become invisible to public queries, trust computation, and sortition checks. Childhood mistakes do not become permanent public scars.

96. **Healthcare emergency break-glass commit**: Authorized medical personnel can access restricted evidence on patient trees in life-threatening emergencies. The break-glass commit is permanent (audit trail), auto-scarred on the accessor's tree, and must be justified within the justification window (initial value: 72 hours, global parameter — votable) via governance commit. Unjustified break-glass triggers trust reduction and potential sortition case.

97. **Evidence quality provides trust floor for principled dissenters**: A user whose evidence contributions are frequently referenced, cited in verdicts, or promoted to permanent fixtures maintains a minimum trust score proportional to their evidence impact. Social grading alone cannot push a high-evidence-quality contributor below jury eligibility or council candidacy thresholds. Objective contribution survives subjective popularity.

98. **Council decision immunity buffer**: When a council member participates in an official decision, an immunity window begins (initial value: 14 days, global parameter — votable) during which trust score changes do not affect their seat eligibility. After the window, normal continuous confidence resumes. Emergency reform (supermajority threshold is also a global parameter, initial: 80% Anchor-tier) overrides immunity. This prevents permanent campaigning and drift toward safe consensus.

99. **Invite-chain centrality is measured, not corrected**: The system tracks subtree size, branching factor, geographic distribution, and guardian overlap per invite chain. Metrics are publicly visible. Disproportionately large subtrees are flagged with a visibility marker. No restriction, no penalty — measurement only. Boundary reconfiguration is the user-facing pressure valve.

100. **Sovereignty-first measurement philosophy**: Relay makes clustering, pressure gradients, boundary shifts, trust drift, and divergence visible. It does not enforce diversity quotas, artificially balance ideological representation, or override local majority decisions with global consensus. People physically in a place have majority say. Exit (boundary reconfiguration) must always be easier than overthrow. Measurement cannot be falsified — that is the only true invariant.

101. **Astronomical alignment to real Earth**: Relay's globe is synchronized to actual Earth rotation, real solar position, and real lunar cycles using established ephemeris data (JPL DE440 / SOFA / Skyfield) pre-computed for 2026–2126 at 1-minute solar and 10-minute lunar resolution. Sleep cycle timing is regionalized by true solar altitude (not political time zones). Daylight duration variation by latitude and season is modeled. The ephemeris tables are Merkle-sealed, versioned, and governance-approved for updates. All periodic system events (digests, reverification, epochs) align to UTC boundaries.

102. **No hardcoded operational parameters**: Every numeric duration, threshold, ratio, interval, or limit in the system that affects user behavior or system operation is classified as either: (A) a global parameter with a founder-set initial value, immediately votable by the community; (B) a founder lever (module activation keys, registry additions); or (C) a physics constant frozen in contract. Category A values are listed in the Global Parameter Registry (§11.6). If a value is not in the registry, it must be classified before implementation. No operational parameter is permanently hardcoded.

103. **No compute without observation**: Projections only evaluate when inside a viewer's active sight bubble or when explicitly published by a branch scope. Unpublished, unviewed projections hold their last cached result and consume zero compute. Content-based memoization ensures projections on stable branches (no new commits) cost nothing regardless of viewer count. This is the core invariant that prevents projection graph explosion at planetary scale.

104. **Projection instance cap per branch**: Each branch has a maximum number of active projections (initial value: 500, global parameter — votable). When the cap is reached, new ephemeral projections are queued and oldest ephemeral projections are evicted. Promoted projections count toward the cap but are never evicted. This prevents any single branch from becoming a compute black hole.

105. **Vote anonymity is architecturally supported**: Eligibility + uniqueness are always provable; vote choice secrecy is template-defined by vote class. Private-by-default votes (ideology, preference, cultural, belief) use encrypted choice payloads with blinded aggregation. Public-by-default votes (spending, delegation, evidence certification, governance parameters, anything creating obligations for others) are fully visible responsibility records. A vote that creates obligations for others cannot be forced private. A pure opinion vote cannot be forced public. Both modes are frozen. Templates define which class applies; the community can override defaults via parametric governance.

106. **Sight radius and atmospheric compression**: Every user has a visibility bubble. Objects inside render at full LOD-appropriate detail. Objects outside simplify progressively (fewer primitives, aggregate textures) but remain visible in truthful form — nothing vanishes. Branch aggregate metrics (health, weight, confidence, shape) are computed from all authorized filaments within scope regardless of viewer (scope-truth, server-side). Rendering detail respects disclosure tiers per viewer — private filament details do not render, but the branch's truthful aggregate shape is always visible. Two users always see the same branch shape even if they see different internal details. The sight radius is the fundamental mechanism that makes a world of billions of objects renderable on a single device.

107. **Sleep cycle timing follows real solar position**: Sleep onset triggers when local solar altitude drops below the voted onset threshold (initial: -6° civil twilight). Sleep end triggers at the voted end threshold. High-latitude regions (above the voted extreme latitude threshold, initial: ±66.5°) fall back to UTC-offset schedules during polar day/night. Transition smoothing interpolates between solar and UTC schedules near the threshold. All sleep-timing thresholds are global parameters (votable). The sleep duration is global; the timing is solar-regional.

108. **Session state persists across close/open**: When a user closes Relay or loses connectivity, the system saves their complete working context (camera position, active tree/branch/filament, LOD state, render mode, inspector panels, filter settings, SCV conversation, Note drafts). On return, Relay restores this state exactly. If the referenced tree or branch has been migrated or is no longer accessible, the system falls back to globe view with an explanatory message. The default first-time boot is globe view. Session state is personal data stored at `disclosureTier = 0`. Filter settings are never leaked because they reveal what the user hides. This is a core UX guarantee, not an optional feature.

109. **Cross-section mode is read-only**: Entering cross-section inspection mode (§3.13) never modifies data. Slab expansion is a rendering-only magnification. Scrubbing through rings does not pause gravity — time keeps sinking during inspection. Filament positions are always derived from commit timestamps. No separate archive copy is created for the cross-section view. The rings ARE the data viewed from a different angle.

110. **Organic variation is rendering, never data**: Slab thickness variation by theta, Perlin noise on ring surfaces, bark ridge deformation at schema boundaries, and scar crack warping of adjacent surfaces (§3.14) are all rendering effects. They never modify the underlying slab data, filament coordinates, or commit records. Two renderers showing the same branch at the same time must agree on data positions even if they disagree on visual noise seed. The organic aesthetics serve legibility — they never compromise deterministic replay (frozen contract #15).

111. **Weather overlays never move truth**: Heat tiles, fog overlays, storm flicker, and lightning cascade flashes (§3.16) are deterministic overlay computations rendered from timebox aggregates. They never affect: vote weight, confidence values, permissions, execution priority, resource earning rates, governance authority, or any parameter that determines what a user CAN DO. Weather overlays are a lens. If weather ever influences a decision gate, the system becomes performative and gameable. Weather overlays can be toggled off by the user; the truth layer underneath (filaments, slabs, scars) cannot. Branch lean and droop are physics (not overlays) and cannot be toggled off.

112. **Branch motion is emergent, never animated**: A branch moves for exactly three reasons: lean (from net counterparty θ pressure at timebox close, §3.15), droop (from slab wilt = confidence deficit, §3.7), and twist (from helix period = time grain, §3.5). No other motion exists. No wiggle, bounce, sway, or decorative animation. If a branch moved, the data changed. If the data didn't change, the branch is still. Motion updates at timebox boundaries, not per frame. Wind is not rendered as arrows or indicators — wind is the pattern of branch lean observed during time replay (§3.15). This is the "if it moves it means something" guarantee.

113. **Branch lean is explainable to one click**: Every branch lean direction must be traceable to specific filaments and counterparties within one user interaction (click → contributor panel). No unexplained aggregates. No black-box scores. A manager who sees a branch leaning — whether live or during replay — can click once and know exactly which counterparties, which filaments, and which timebox produced that lean. This is the "the tree never lies" operational guarantee.

114. **Branch layout direction is from identity, never live data**: Branch direction (where a branch points in space from the trunk, §3.18) is derived only from `layoutKey` hashing + ring assignment + deterministic collision resolution rules. It never depends on counterparties, votes, attention, wind, or any live metric. The same set of `branchId` values always produces the same spatial arrangement under deterministic replay. Lean (§3.15) is a small deformation applied within the fixed layout slot — capped at 5-10° of tilt — and does not move the slot itself. Overlap is solved by multi-layer branch shells and LOD bundle merge (§3.18), never by changing branch semantic direction.

115. **Universal equations are scale-invariant**: The ten force equations (§3.19) — radial position, gravity sink, lean vector, wilt, heat, fog, storm, lightning, trunk mass, and scaling law — are identical at every scope from file to Laniakea. No scale-specific physics exist. A file-level filament and a planetary-level event use the same equations with the same units (radians, normalized magnitude, normalized confidence). What changes between scales is the template (what constitutes a filament, branch, trunk) and the aggregation depth (Equation 10). If a new equation is proposed that only works at one scale, it violates this contract and must be rejected.

116. **Scaling is aggregation, never new math**: Parent scope metrics are pure sums or weighted averages of child scope metrics (Equation 10, §3.19). `W_parent = Σ W_child`. `heat_parent = Σ heat_child`. No new variables, coefficients, or formulas are introduced at higher aggregation levels. A galaxy-scale heat map is computed from exactly the same fields as a branch-level heat value — just summed across more sources. If a rendering layer requires a variable that does not trace back to filament primitives (θ, m, c, a, o, s, e), it is not Relay physics and must be classified as a decorative overlay subject to the "shed first" rule (§3.17, §33.5).

117. **No physics above source**: Weather overlays, orbital metrics, aggregate force vectors, and all computed visualizations at any scale cannot: move filaments, alter lifecycle states, affect confidence values, modify governance decisions, change permissions, or influence any decision gate. They are read-only projections computed from underlying data. This holds identically at branch scale, tree scale, regional scale, planetary scale, and Laniakea scale. A galaxy-scale heat map has no more authority over truth than a single branch's fog index. Rendering is downstream of truth, never upstream.

118. **Every celestial body with data IS a full Relay globe**: The Moon, Mars, every asteroid, every planet, every moon of every planet, every space station — any body that has data being captured about it runs the full Relay physics (§3.19) with its own trees, branches, filaments, slabs, scars, and archive rings. Celestial bodies are not markers, dots, or abstractions on a zoom-out. They are complete Relay instances. Satellites, rovers, orbital sensors, telescopes, and human missions are data sources that feed filaments into trees planted on those bodies. History goes inward on every body — the cross-section of a Martian geology branch shows the same concentric timebox rings as an Earth accounting branch. Zooming into any body at any LOD reveals the same tree structure with the same physics. The universal equations are literally universal.

119. **Inward direction is defined by local structural origin O**: At every scale, inward direction is the vector toward the local structural origin O (§3.19). For branches, O = branch root. For trees, O = trunk core. For planets, O = planetary center. For irregular bodies (asteroids), O = barycenter. For galaxies, O = galactic barycenter. For Laniakea, O = supercluster attractor. The origin does not require astrophysical precision — it requires deterministic stability. Two renderers computing "inward" for the same scope must agree on the direction. Without a deterministic inward direction, archive compression becomes undefined, ring orientation becomes undefined, lean becomes meaningless, and helix becomes arbitrary. If inward is ever ambiguous at any scale, the system has a structural defect that must be resolved before that scale renders.

120. **Relay coordinates, never owns**: Relay occupies exactly two layers of the real-world stack: coordination and accountability (§49b.1). It does not issue currency, hold fiat reserves, distribute physical resources, replace settlement rails, or enforce legal authority. Physical infrastructure (banks, utilities, governments, supply chains) remains under the control of its existing operators. Relay is an additive accountability overlay — never a dependency. If Relay goes offline, water must still flow, hospitals must still function, banks must still clear. Relay makes the world measurable. It does not own it.

121. **Fiat custody is always external**: Relay never holds, custodies, or manages fiat currency reserves (§49b.5). Fiat integration flows through regulated financial institutions (banks, licensed payment processors, regulated stablecoin issuers). Filament magnitude carries unit + amount as data. Settlement occurs on external rails. Relay records the truth of the transaction (TransferPacket + ResponsibilityPacket). The settlement itself is performed by the banking system. Mixing fiat custody with Relay operations is a structural prohibition — it creates systemic collapse risk.

122. **Governance votes cannot manipulate physical supply**: Relay governance (parametric voting, sortition, council decisions) affects Relay parameters, templates, branch structure, and digital resource allocation only (§49b.6). No governance action — regardless of vote threshold, council approval, or founder key — can directly open water valves, redirect food shipments, alter power grid operations, or execute any physical action. Relay proposes. Humans and their existing institutions execute. The boundary between digital coordination and physical action is absolute and cannot be bridged by any Relay mechanism.

123. **Degradation is graceful, truth is last to go**: When external systems fail or internal resources are exhausted, Relay contracts through defined degradation modes (§49b.9): FULL → COMPUTE CONSTRAINED → SETTLEMENT OFFLINE → FEDERATION PARTITION → RENDER COLLAPSE → ARCHIVAL. Each mode specifies what continues, what sheds, what queues, and what freezes. The shed order is: spectacle first, compute second, settlement queuing third, federation scope fourth, rendering fifth, truth never. Committed filaments, slabs, scars, and the Merkle chain are preserved in every degradation mode. Sortition remains available in all modes except ARCHIVAL. Degradation degrades toward human deliberation, not toward system lockout.

124. **Scheduled filaments are inert proposals until their time arrives**: A `SCHEDULED` filament (§5b) exists at a future l position on the branch tip. It is visible but physically inert — it does not contribute to branch lean, wilt, heat, fog, wind computation, or any force equation until it transitions to `OPEN` when its scheduled time arrives. Scheduled events do not sink (gravity does not apply to the future). They are commitments, not evidence. Cancellation is a permanent scar-like commit (append-only), never deletion. A pattern of cancelled scheduled events is itself diagnostic geometry — visible in cross-section as bark-radius clusters that never migrated inward.

125. **The branch tip is the calendar**: Looking at the tip of any branch shows its scheduled future (§5b.4). Scheduled filaments render translucent, solidifying as their time approaches. Notifications are not a separate system — they are the scheduled filament arriving at the present moment on the l axis. The tree IS the alarm clock. Recurring events are separate filaments linked by `recurringSeriesId`; each instance lives independently.

126. **Timebox assignment uses spawnAt, never settlementAt**: A filament's timebox is determined by the moment it was created in Relay (§31.4). External settlement confirmation is a commit on the existing filament — it does not change the filament's timebox, l position, or slab membership. Settlement latency never distorts history. Deterministic replay depends on this invariant: given the same commit log, any node produces identical timebox aggregates regardless of when external confirmations arrive.

127. **Hash proves existence, not retrievability**: External evidence hashes are immutable and Merkle-anchored at commit time (§31.5). Subsequent URL expiry, API changes, or document format rotation do not invalidate the hash or reduce confidence. The hash proves what the document said when it was committed. UX must distinguish "evidence unavailable but hash preserved" from "data loss." Templates define `evidenceArchivePolicy` (CACHE_LOCAL, HASH_ONLY, CACHE_AND_HASH) to control local caching.

128. **Gravity always uses calendar-time**: Regardless of content type, the `sinkAxis` is always calendar-time (§3.21). The `primaryAxis` (what l means at CELL LOD) varies per template — content-position for documents, line number for code, timeline for media — but gravity sinking is universal. A paragraph, a function, and a music track all sink at the same rate. Only the interpretation of l at close zoom is content-specific. Twigs, wilt, lean, and all force equations operate on calendar-time.

129. **Compression never reduces verifiability**: Replay compression (§48.4.3) reduces storage and replay latency through five layers (terminal snapshots, timebox summaries, cross-timebox deltas, Merkle checkpoints, federation sharding). At every compression level, the Merkle proof is preserved. Every compressed filament retains its chain anchor. Every timebox retains its aggregate at full fidelity. Full commit logs are always recoverable from cold archive — compression affects latency, never truth.

130. **Archive compression IS tree physics**: The five compression layers (§48.4.3) are not a separate engineering system — they are the same inward-migration physics applied recursively to the storage layer. Hot = bark. Warm = mid-rings. Cold = core. Level escalation = gravity sinking. Timebox summaries = slab aggregates at full fidelity. Merkle checkpoints = commit chain anchors. Federation sharding = LOD. The archive system is a tree inside the tree. The system health filaments on the system tree (§48.4.2) close the recursion — the archive monitors itself using the same physics it archives. This fractal identity is structural, not metaphorical.

131. **Roots are alive**: The root system below the surface (§1.3) is not dead storage. It is the underground mirror of the canopy, governed by the same ten force equations (§3.19). Root branches correspond to canopy branches. Root lean = retrieval demand direction. Root wilt = integrity concern. Root heat = audit/retrieval surge. Root thickness = archive mass. Root depth = time depth. Cross-section of a root branch shows archive epoch rings. The tree is alive from root tip to branch tip — the archive is a living root system, not a graveyard.

132. **Roots are diagnostic, never operational**: Root physics (lean, wilt, heat, fog, storm, lightning) must NEVER affect canopy physics, filament lifecycle, governance decisions, or system availability (§1.3). Roots are a diagnostic mirror for auditors, compliance officers, and system administrators. An auditor reads the roots. The roots never reach up and change the branches. This separation is absolute. No root condition can transition a filament's state, modify a vote, or block a commit.

133. **Heartwood is terminal stillness**: Archived data that has reached compression Level 2, passed the age threshold, achieved integrity ratio 1.0, has negligible retrieval frequency, zero pending warnings, and sealed Merkle checkpoints enters heartwood state (§1.3). Heartwood contributes zero to all force equations — no lean, no heat, no fog, no wilt. It is pure structural mass. Heartwood can temporarily re-expand under three conditions only: integrity anomaly detected, legal/audit demand, or cross-tree evidence cascade. In all cases re-expansion is temporary and data returns to stillness. Heartwood prevents root compute from scaling with total archive size — only active root (recently archived + currently queried + integrity-flagged) participates in root physics.

134. **Camera is sovereign**: No auto-correction of orientation. Ever. Auto-leveling, auto-pitch, and ENU-frame chasing are permanently prohibited in FPS mode. The only corrections permitted are user-initiated (explicit key press) or panel-lock transitions (entering 2D interaction mode). See §50.1.

135. **Panel lock is the only flight suppression context**: Panel lock (entering a 2D interaction surface — spreadsheet cell, document editor, code panel, search bar) is the only context where WASD and flight keys are suppressed. No other system may consume flight input. See §50.4.

136. **Mass balance is conservation law, not dashboard logic**: Per-timebox material balance is computed from typed-magnitude filament sums (§52.5). Deviation from zero balance is rendered as slab color shift. Cumulative imbalance is structural lean. The computation is deterministic, replayable, and identical at every LOD. This is frozen contract #16 (conservation) applied to the manufacturing domain with explicit visual encoding rules.

137. **AI code commits require AICodeContributionPacket**: Any code-modifying AI commit must include a deterministic AICodeContributionPacket containing diff-based LOC metrics, AST-based line type classification, semantic complexity deltas, and quality/test/lint verification (§16.6). The COMMIT gate enforces `taskClassDeclared` (set by human, never inferred by AI) and `qualityProfile` minimums per task class. The confidence formula structure `(0.40×test + 0.25×guard + 0.20×lint + 0.15×typecheck)` is frozen; only target thresholds are template-configurable. Contributions failing band checks receive a scar with reason code. Spike code auto-expires as twig after 14 days if not promoted.

138. **Filaments are discrete growth fibers, not fluid flows**: All state changes are commit-driven events. No continuous simulation, no streaming state, no fluid dynamics (§53.1). Every filament transition is an atomic append-only commit that can be replayed deterministically. Relay mimics wood formation (layered, irreversible, accumulating), not tree biology (sap, xylem, phloem). The cambium layer (`r = 1.0`) is the only zone where new structure forms — everything outside is active work, everything inside is immutable history.

139. **Composition inheritance through transformation chains is mass-weighted**: When a transformation consumes input lots and produces outputs, the output's composition profile is computed as mass-weighted average of input compositions (§53.4). Uncertainty compounds: `output_uncertainty = √(Σ(input[i].uncertainty² × input[i].massFraction²))`. No transformation may reduce uncertainty below the worst input without new measurement evidence. This enables deterministic traceability from finished good back to vendor lot molecular composition, and from vendor lot forward to every product that consumed it (recall cascade).

140. **Relay functions at all four adoption tiers simultaneously**: No tier is prerequisite for any other (§57). Evidence hashes (Tier 0) are a permanent, first-class integration method — not a fallback. Tier 0 stores only a cryptographic hash and timestamp; Tier 1 mirrors structured data via connector; Tier 2 reconciles native and external filaments; Tier 3 is fully Relay-native. Features are never gated behind Tier 3. The visual difference between tiers is rendered through existing confidence/fog physics, not through badges, warnings, or degraded UI. The tree makes the case for adoption by being legible. Relay never pushes.

141. **Relay has no stages, only modules**: The system does not progress through numbered stages (§38). Every capability is an individually discoverable module with its own prerequisite chain. A user who demonstrates competence with the prerequisites unlocks the module — regardless of how "advanced" it appears. There is no Stage 1 user and no Stage 3 user. New modules are added forever through community proposal, council review, founder approval (for global economic parameters), and git-style versioning. The three conceptual layers (Truth, Interaction, Game) are vocabulary for describing what a module does, not access gates restricting when someone can use it. The system grows indefinitely.

142. **Education is an internal adventure, not an external institution**: Teaching is a ranked filament activity where teachers are compensated by student success rates, not view counts (§58). Skill paths are community-curated suggestions, never mandatory gates. The round-robin matching model (Genghis Khan pattern) applies to teaching, psychiatric care, dating, and all human-matching optimization uniformly. Curricula evolve through governance commits and are ranked by aggregate student outcomes. The tutorial is the only moment Relay actively teaches — after that, all learning is self-directed discovery. The user tree's learning branch IS the education record.

143. **Single-instance circulation for media objects**: A media object has exactly one encrypted master file identified by `contentHash` (§59.3). All playback sessions stream from this single source. `AccessLeasePacket` commits track every active lease. `maxConcurrentCopies` is a per-object governance parameter set by the rights holder. When the cap is reached, additional access requests queue. No per-viewer file duplication occurs. Relay does not impose this model on external content — it operates only on media published through Relay with explicit governance parameters.

144. **Radial position and engagement are orthogonal on media branches**: The radial axis is governed exclusively by lifecycle state, production stability, and commit depth (§59.2). The engagement axis is governed exclusively by viewer activity and derivative fork count. Engagement never moves a segment's radial position. Commits never change engagement weight. These two axes never cross-contaminate.

145. **Derivative forks must declare segment-level provenance**: A derivative media project that claims upstream linkage must map specific derivative segments to specific source segments with `overlapPct` and `overlapMethod` (§59.6). Credit share per view session is computed deterministically from these mappings using the `sourceWeight` table by fork type. If no segment-level mapping is provided, `share_to_source = 0`. The mapping is a committed evidence chain, auditable by any party.

146. **Frames never instantiate as Cesium primitives**: At MEDIA-FRAME LOD, individual frames render in a 2D inspection panel using the zoom-to-flat transition (§59.7, §3.3). Zero Cesium Entity or Primitive objects are created per frame. World-primitive budgets at each media LOD level are Category A global parameters.

147. **Student votes on teaching affect visibility and routing, never evidence truth**: Student votes on clarity, pacing, engagement, and practice quality affect teacher search rankings and routing recommendations (§58.9). They never override organizational confidence (evidence quality). A lesson with high popularity and low evidence stays foggy. A lesson with low popularity and high evidence stays firm. Both signals are independently visible. Votes are weighted by student outcome — a vote from a student who demonstrated the module carries more weight than one from a student who dropped out.

148. **Grading is a sortition process with fixed rubric filaments**: Auto-check handles objective parts; peer review juries (sortition-selected from students who demonstrated the module) handle subjective parts; teachers spot-check a random sample plus escalations (§58.10). Consensus determines the final grade; disagreement triggers escalation scars. Peer graders earn magnitude credit. The pipeline scales independently of class size.

149. **Any branch can host child trees with identical physics**: Child trees inherit the same ten force equations (§3.19), lifecycle states (§4.3), append-only invariant, cross-section encoding (§3.4), and LOD rendering rules (§33.5) as every other tree in the system (§60). The parent sees only aggregate metrics. Rendering never shows more than one recursion layer at full fidelity — portal entry is explicit. FractalSpawnEvent commits are the only mechanism for creating child trees; all spawns are auditable.

150. **Private data is absolutely uninspectable within Relay**: Filaments at `disclosureTier = 0` are cryptographically sealed (§61.1). No user, SCV, governance mechanism, duel proceeding, jury sortition case, or civic enforcement workflow can access, inspect, reference, or reveal private data. Relay provides no backdoor, no admin function, no discovery mechanism. External legal systems may subpoena the user directly — Relay itself never provides a pathway to bypass the cryptographic privacy boundary. Aggregate tree shape remains truthful (§33.4) but individual filament contents at Tier 0 are invisible to all external observers.

151. **Only publicly exposed data is admissible as evidence within Relay**: In duel proceedings, sortition jury cases, civic enforcement workflows, governance votes, and any other Relay process, only filaments committed at `disclosureTier >= 1` are admissible (§61.2, §61.6). Private data cannot be compelled, discovered, or referenced. Voluntary disclosure tier elevation is itself a permanent append-only commit.

152. **Civic enforcement is structured compensated work**: Civic observation filaments require evidence references to achieve non-zero confidence — accusations without evidence are structurally invisible (§61.3). Enforcement workers process observations as compensated tasks with minimum wage set by municipal governance as a Category A parameter (§61.4). Observer identity is always recorded — false accusations are traceable and create wilt. Proximity correlation uses only publicly broadcast signals; non-Relay users and disabled presence are never processed (consistent with contract #40).

---

## 46. Sortition-Based Case Resolution

> *"Injustice anywhere is a threat to justice everywhere."* — Martin Luther King Jr.
>
> *"Competence is not justification."* — Eitan Asulin

When a dispute arises that normal voting cannot resolve — a contested account, a challenged piece of evidence, an ownership conflict — Relay does not hand the decision to an administrator or a CEO. It randomly selects a jury of ordinary users, the way courts select jurors in the real world. But fairer: the selection is cryptographically random so nobody can stack the jury, the members are drawn from diverse pools by design, and the verdict is recorded permanently on the public record. If you disagree with the outcome, you can appeal to a second jury. If that fails, a final council hears the case. Three levels, all transparent, all recorded.

Relay uses randomized jury sortition — not majority vote and not founder decree — to resolve disputes, adjudicate Sybil enforcement cases, and mediate governance conflicts that cannot be settled by parametric voting alone.

### 46.1 When Sortition Applies

Sortition is triggered for:
- **Sybil enforcement**: When the system flags an account as a suspected duplicate or bot, and the account contests the flag, a jury decides.
- **Community disputes**: Channel ownership conflicts, contested migration commits, evidence authenticity challenges.
- **Governance deadlock**: When a branch-level vote is sustained at exactly the threshold boundary (inside the hysteresis band) for longer than 2x the settlement window, a jury breaks the deadlock.
- **Quarantine appeals**: When content is quarantined (frozen contract #53) and the author appeals, a jury reviews the quarantine decision.

Sortition is NOT used for: routine parameter voting (that's continuous weighted-median), routine content moderation (that's filter tolerance), or founder key activation (that's the founder's singular governance primitive).

### 46.2 Jury Composition

Juries are composed using a **4:3:3 sortition ratio**:

| Pool | Ratio | Selection Method | Purpose |
|------|-------|-----------------|---------|
| **Random** | 4/10 | Cryptographically random from eligible population | Prevents capture by any faction |
| **Volunteer** | 3/10 | Self-nominated from eligible population, randomly selected if oversubscribed | Ensures motivated participants |
| **Historic** | 3/10 | Users with prior jury service and high completion rate | Provides institutional knowledge |

**Jury size**: 5-15 members (default 9). Size scales with case severity.

### 46.3 Eligibility

To serve on a jury, a user must meet ALL of:
- **Tier 1+ identity** (verified, not anonymous)
- **Minimum 30 days of activity** (prevents freshly created shill accounts)
- **Trust score >= 70** (computed from engagement history, evidence contribution, and absence of scars)
- **No conflict of interest**: not a party to the case, not on the same branch as the disputed content (for community disputes), not in the same device cluster as either party
- **Geographic relevance**: for proximity-based disputes, jurors must be within the same geohash proximity level (2 levels)
- **Sortition cap**: maximum 4 jury selections per month per user (prevents jury fatigue and concentrated influence)

### 46.4 Trust Mixing

To prevent elite capture of juries:
- Maximum 50% of jurors may come from the top trust tier (trust score >= 90%)
- The remainder must include members from the standard trust band (70-89%)
- This ensures juries reflect community breadth, not just the most active power users

### 46.5 Selection Process

1. **Case filed** → system builds eligible juror pools (random, volunteer, historic)
2. **Pool validation** → verify sufficient members in each pool; if a pool is too small, overflow redistributes to the random pool
3. **Cryptographic selection** → `crypto.randomBytes` generates provably fair random indices. Selection is verifiable by any party after the fact.
4. **Bias detection** → automated bias scoring checks for: demographic clustering, geographic clustering, trust score skew, prior interaction patterns between jurors and parties
5. **Jury seated** → jurors are notified; deliberation window opens (default: 72 hours)
6. **Deliberation** → encrypted communication channel. All messages auto-deleted after case resolution.
7. **Verdict** → simple majority for standard cases; supermajority (2/3) for quarantine appeals and governance deadlocks
8. **Blockchain audit** → jury selection, deliberation metadata (not content), and verdict are logged as an immutable governance commit on the system tree. Selection algorithm version, bias score, and trust distribution are recorded for auditability.

### 46.6 Live Peer Grading (Draft → Commit Model)

After a verdict is delivered, all jurors grade each other's participation. Grading follows the same **draft → commit** model as all temporary data in Relay (Notes, sticky notes, grades — nothing is permanent until explicitly committed):

**How grading works:**
- Each juror assigns a participation grade (1-100%) to every other juror
- Grades are **revealed to other parties as they arrive** — not sealed. When juror A grades juror B, juror B can see it immediately.
- Grades are **drafts** until the juror explicitly commits them. While in draft state, grades can be changed freely. Two jurors who reacted poorly to each other during deliberation can talk it through afterward and revise their grades.
- Jurors can continue communicating with each other during the grading window. The grading window is a continuation of the social space, not a locked ballot.
- When a juror commits their grades, they become **permanent** — append-only, Merkle-sealed, part of the jury audit commit. No further changes.
- The grading window has a deadline. Any grades not committed by the deadline are auto-committed at their current draft values.

**Why this works (game theory):**
- Even if most jurors collude and give everyone 100% to "be safe," there will always be 1-2 jurors who use the system honestly and grade others at 95%, 80%, etc.
- Jurors who consistently give 100% to everyone without differentiation create a pattern: their scores never move anyone else's trust, but their OWN trust stagnates because they never receive differentiated scores from the honest graders.
- Jurors who DO use the system honestly — giving accurate 80% or 95% grades — build a grading reputation. Their grades carry more signal over time.
- The incentive structure is: if you don't grade honestly, your own trust score drops relative to those who do, because honest graders are marking YOU down while you're not marking anyone.
- Over time, honest participation becomes the dominant strategy because non-participation is visible and costly.

**Consensus outlier de-weighting (the 0% attacker problem):**

If one juror grades everyone at 0% while the group grades that juror at 80-95%, the live visibility creates a natural many:1 correction — the group sees the hostile grades, revises their drafts for that juror downward, and the attacker is severely punished while everyone else is unaffected. But the attacker's 0% grades still carry outgoing weight against the group. This creates a minority abuse vector: one person tanking everyone's scores.

The fix: **when a juror's received grades converge to a consensus that is drastically lower than what they gave others, their outgoing grade weight is reduced proportionally.** If 7 jurors grade you at 0-10% and you graded them all at 0%, your outgoing grades are de-weighted because the group consensus says you are the outlier, not them. Your voice in this specific grading event is justly diminished — not silenced (your grades are still recorded), but their impact on others' trust scores is reduced.

**Why coalition abuse is structurally impossible here:**

The critical defense is that sortition juries are **randomized**. You cannot pre-arrange being on the same jury as your allies. Every jury is a fresh random draw from the eligible population. This means:
- You cannot form a voting bloc across juries — every jury has different members
- You cannot systematically grade a region or faction poorly — you don't choose who you serve with
- If a region's jurors consistently receive low grades across many randomized juries, the signal is real: those individuals are underperforming, not being targeted
- Regional or factional bias would require controlling the random selection itself, which is cryptographically secured

The combination of randomized assignment + live grade visibility + consensus outlier de-weighting + draft → commit flexibility makes the grading system robust against both lone attackers and coalition abuse.

**Trust score impact:**
- Committed grades affect the recipient's trust score (reliability metric)
- Consistently low grades from multiple peers reduce trust
- Consistently high grades from credible graders (those with a track record of differentiated grading) increase trust
- Consensus outlier grades are de-weighted (recorded but reduced impact)
- Grading data is permanent in the jury audit commit

### 46.7 Post-Verdict

- Verdict is a governance commit — append-only, Merkle-sealed, permanent
- Losing party may appeal once. Appeal triggers a new jury with increased size (+4 members) and zero overlap with the original jury
- After appeal verdict at the jury level, the case may be escalated to the Relay Sortition Council (§46.8) as the final appellate authority.
- Jurors who complete service receive a small engagement credit reward (from system issuance, not from parties). Jurors who fail to participate within the deliberation window are replaced and receive a scar on their user tree.

### 46.8 The Relay Sortition Council

The Relay Sortition Council is Relay's elected governing body — the appellate authority, module approval board, and constitutional stewardship body. Council members are the elected leaders of the Relay world, but their positions are earned through continuous confidence, not fixed terms.

**Composition:**
- The Council has **7 seats**. Each seat represents a functional domain (e.g., truth layer integrity, economic balance, identity/privacy, detection mesh, governance mechanics, community health, technical architecture).
- Council members are **elected by continuous vote** — not periodic elections with fixed terms. Every Tier 1+ user can vote for council candidates at any time. Vote weight follows the same context-weighted eligibility rules as all governance (frozen contract #56): branch-specific recency, evidence contribution history, engagement depth.
- The person with the highest sustained confidence for a domain seat holds that seat. Confidence is computed from vote count, vote recency (decay applies), and trust score of voters.

**Succession chains:**
- Each council seat has a **ranked succession list** determined by votes: #1 is the current holder, #2 has the next-highest confidence, #3 after that, etc.
- If a council member is removed (via reprimand, inactivity, or confidence drop below threshold), the next person in their succession chain automatically assumes the seat. No election delay, no vacancy period.
- A single person could theoretically be #2 in the succession chain for multiple seats — making them the most likely replacement for any removed council member. This creates **constant competitive pressure** that keeps council members accountable.
- Council members must meet all prerequisites continuously: Anchor trust tier, no active scars, reverification current, jury service history, evidence contribution above threshold. Falling below ANY prerequisite triggers automatic removal and succession.

**What the Council does:**

**1. Module approval (sandbox → production pipeline):**
- Any community member can develop a module (new feature, integration, extension) and deploy it in the **Relay Sandbox** — a SIMULATION-mode environment where all code runs but no commits affect the live system.
- The development lifecycle is: **SANDBOX → PROPOSAL → COMMUNITY VOTE → COUNCIL REVIEW → CANONICAL COMMIT**
  1. **Sandbox**: Developer builds and tests in simulation mode. The sandbox blocks all real commits — it is read-only physics preview with no side effects.
  2. **Proposal**: Developer submits a formal proposal with: description, sandbox proof artifacts (test results, edge cases, exploit attempts), artifact hash (content-addressed, verifiable), and optionally a bounty request.
  3. **Community vote**: The proposal enters a vote window (governed by `GOVERNANCE-CADENCE` rules). Quorum + 60% approval advances it. Community members can test the sandbox version and vote based on direct experience.
  4. **Council review**: The Council performs a full technical and constitutional review. They verify: the module does not violate frozen contracts, does not introduce new attack vectors, passes all existing proof suites, and is compatible with the current system architecture. Each council member reviews independently and votes. Supermajority (5/7) required for approval.
  5. **Canonical commit**: If approved, the module is committed to the live system as a governance commit, Merkle-sealed, with the council's approval signatures. The commit is permanent and append-only.

**2. Appellate authority (escalation hierarchy):**
- Disputes that exhaust the standard jury process (verdict + one appeal) can be escalated to the Council as the **final appellate body**. This mirrors the appellate/superior court structure:
  - **Level 1**: Standard jury sortition (9 jurors, simple majority)
  - **Level 2**: Appeal jury (13 jurors, zero overlap, supermajority)
  - **Level 3**: Relay Sortition Council (7 members, supermajority 5/7)
- The Council's verdict on an escalated case is final. No further appeals.
- Council members who have a conflict of interest with a case must recuse. Their seat is temporarily filled by the next in their succession chain for that case only.

**3. Constitutional stewardship:**
- The Council monitors system health: proof suite pass rates, refusal log frequency, economic metrics (issuance budget, difficulty curves), identity metrics (reverification compliance, Sybil detection rates).
- The Council can flag constitutional concerns — situations where the system's behavior drifts from the intent of frozen contracts. Flags trigger community discussion, not unilateral action. The Council cannot modify frozen contracts.
- The Council reviews and approves the legal posture document (frozen contract #51) for each new jurisdiction before production deployment.

**Accountability:**
- Council members are subject to **live peer grading** by the other 6 members (same draft → commit model as jury grading).
- Any council member whose confidence score drops below the threshold for their seat is automatically replaced by the next in succession.
- Bad decisions by the Council are permanently visible as governance commits. The community can see every approval, every rejection, and every vote.
- The Council cannot: modify frozen contracts, override parametric governance, activate the game layer (that's the founder/Steward key), grant themselves additional power, or create new council seats.

---

## 47. Voice Input Pipeline — Whisper, Architect, Canon

> *"The limits of my language mean the limits of my world."* — Ludwig Wittgenstein

**Prerequisites:** None for base (voice commands: speak → transcribe → propose). Expands with: AR interaction modules → voice + gesture/light/object fusion as multi-modal SCV input. Spell modules → spell incantations where the verbal component is one signal in a multi-element activation sequence.

### 47.1 Overview

Every interaction in Relay — from creating a projection to filing an invoice to casting a spell — can be initiated by voice. The voice input pipeline has three named stages that mirror the SCV processing architecture:

```
VOICE → [Whisper] → raw transcript → [Architect] → structured intent → [Canon] → commit proposal → [Human] → approved commit
```

No stage can be skipped. Raw audio never becomes a committed filament without passing through all three processing stages and human approval.

### 47.2 Whisper — Speech to Text

Relay uses [OpenAI Whisper](https://github.com/openai/whisper) (MIT license) for speech recognition:

- **Local-first**: Runs on the user's device. No audio data leaves the device unless the user explicitly consents (Tier 0 privacy preserved).
- **Multilingual**: Supports 99 languages with automatic language detection. A user speaking Japanese is automatically transcribed in Japanese — the language itself becomes metadata on the interaction.
- **Model size is template-configurable**: Templates define which Whisper model to use based on the use case:

| Model | Parameters | VRAM | Use Case |
|-------|-----------|------|----------|
| `tiny` | 39M | ~1 GB | Fast on-device commands, low-power devices, real-time feedback |
| `base` | 74M | ~1 GB | Standard voice commands with moderate accuracy |
| `small` | 244M | ~2 GB | High-accuracy commands, multi-language environments |
| `turbo` | 809M | ~6 GB | Production-grade accuracy with good speed. Default for most templates. |
| `large` | 1.5B | ~10 GB | Maximum fidelity, archival-grade transcription, legal/medical contexts |

- **Two operating modes**:
  - **Command mode**: User speaks, pause detected, Whisper processes the complete utterance as a single unit. Suitable for discrete commands ("create a projection of Q3 revenue").
  - **Stream mode**: Continuous real-time transcription for duels, meetings, discussions. The transcript becomes a filament on the event branch with each utterance as a commit. Suitable for video presence conversations and duel commentary.

### 47.3 Architect — Intent Parser

The Architect layer is the first SCV sub-component in the voice pipeline. It takes raw transcribed text and produces structured intent:

**Input**: Raw transcript + context (current user location in tree, active scope, permissions, presence state, and with AR interaction modules: simultaneous gesture/light/object signals)

**Output**: Structured intent object:

```json
{
  "IntentPacket": {
    "intentId": "intent.<uuid>",
    "source": "voice|gesture|light|object|multi-modal",
    "transcript": "show me all overdue invoices over 50K from Berlin",
    "language": "en",
    "confidence": 0.94,
    "parsed": {
      "action": "projection.create",
      "target": "branch.p2p.invoices",
      "filters": [
        { "field": "lifecycle", "op": "in", "value": ["OPEN", "ACTIVE"] },
        { "field": "magnitude", "op": "gt", "value": 50000 },
        { "field": "counterparty.approachAngle", "op": "region", "value": "Berlin" }
      ],
      "timeFilter": { "overdue": true }
    },
    "contextSnapshot": {
      "userScope": "zone.company.ops.p2p",
      "currentLOD": "BRANCH",
      "focusTarget": "branch.avgol.p2p.invoices"
    }
  }
}
```

**Architect rules:**
- Architect ONLY parses. It never executes, never creates commits, never modifies state.
- If the transcript is ambiguous, Architect produces multiple candidate intents ranked by confidence. The SCV presents options to the user.
- With AR interaction modules active, Architect fuses voice with simultaneous gesture/light/object signals to disambiguate. "Show me THIS" + pointing gesture = single unambiguous intent.
- Architect respects work zone boundaries: if the parsed intent targets a scope the user has no permission for, the intent is flagged as OUT_OF_SCOPE before reaching Canon.

### 47.4 Canon — Execution Planner

Canon is the second SCV sub-component. It takes structured intent and produces tree operations:

**Input**: Validated IntentPacket from Architect

**Output**: One or more proposed tree operations:
- Filament queries (search, filter, aggregate)
- Projection branch specifications (decision nodes, filters, terminus definition)
- Commit drafts (new filament, evidence attachment, vote cast)
- Navigation commands (camera move, LOD change, time scrub)

**Canon rules:**
- Canon produces PROPOSALS, never commits. Frozen contract #12 holds absolutely: SCVs do not execute.
- Every Canon output is rendered as a visible lavender projection showing exactly what will happen if approved.
- Canon respects all frozen contracts — no proposed operation may violate append-only, conservation, deterministic replay, or any other invariant.
- Canon attaches the original voice transcript as evidence on the proposed commit. Provenance is preserved: "This commit was voice-initiated. Transcript: [attached]. Intent confidence: 0.94."

### 47.5 Permission Model

Voice commands follow identical governance to any other input modality:

- Subject to work zone permissions (§19.3)
- Subject to commit materiality rules (§19.1): voice-commanded changes follow DRAFT → PROPOSED → COMMITTED
- Subject to vote eligibility gates (§7.4) for vote-related commands
- Subject to template evidence rules (§9.1) for commit-related commands
- Voice transcripts become evidence attachments on commits, creating full audit trail
- A voice command that would require governance approval (e.g., "migrate this filament to the HR branch") triggers normal governance workflow, not immediate execution

### 47.6 Voice as Evidence

Voice recordings and transcripts are first-class evidence in Relay:

- During duels (§42), both participants' voice streams are transcribed and become part of the event filament's evidence chain
- During meetings (video presence), voice transcripts can be committed as meeting filaments with full participant attribution
- During field work (proximity channels, §29), voice notes become filaments with GPS + proximity + voice evidence
- Voice evidence follows the same disclosure tiers as all other evidence — Tier 0 (anonymous transcript), Tier 1 (attributed), Tier 2 (full audio + identity)

---

## 48. Engineering Infrastructure — How the System Runs

> *"Give me six hours to chop down a tree and I will spend the first four sharpening the axe."* — Abraham Lincoln
>
> *"You can execute perfectly and still be building the wrong thing."* — Eitan Asulin

*This section is for the engineers who will build Relay. It describes the servers, databases, authentication systems, and protocols that make everything above this point actually work. If you are reading this document to understand what Relay is and how it affects you as a user, you have already learned everything you need — you may skip ahead to Section 49, which describes how the system handles people who try to cheat.*

This section defines the engineering layers between the product specification (§0-§47) and a running system. These are implementation requirements, not product features. They are invisible to users but essential for the system to function.

### 48.1 Backend Architecture

**Requirements:**
- Must support millions of concurrent users across the globe
- Must propagate filament commits in near-real-time to all affected clients
- Must persist the Merkle chain permanently and verifiably
- Must support the fractal scaling model (neighborhood → city → country → globe)
- Must preserve deterministic replay across all nodes

**Architecture decision (to be finalized before BARK-CYLINDER-1):**
The backend topology must be chosen from one of three models, each with trade-offs:

| Model | Pros | Cons | Best For |
|-------|------|------|----------|
| **Centralized** | Simple consistency, easy to bootstrap, fast iteration | Single point of failure, scaling ceiling, trust dependency | MVP bootstrap |
| **Federated** | Regional sovereignty, horizontal scaling, partial failure tolerance | Complex coordination, eventual consistency challenges | Production deployment |
| **Decentralized** | No single point of failure, censorship resistant, aligns with Merkle/append-only model | Complex consensus, slow propagation, hard to bootstrap | Global deployment (AR/game modules active) |

**Recommended path:** Start centralized for bootstrap (MVP), evolve to federated as adoption grows (production), with decentralized as the global-scale target. The append-only commit model and Merkle chain are already designed for eventual decentralization — the data model does not need to change, only the transport and consensus layers.

### 48.2 Identity and Authentication

**Tier 0 (Anonymous):**
- No registration required. Ephemeral session. Can view, navigate, post Notes.
- Device fingerprint for rate limiting only (not stored as identity).

**Tier 1 (Verified):**
- Registration with email/phone verification OR decentralized identifier (DID).
- Can vote, create filaments, participate in governance.
- Identity verification method is template-configurable: email for casual, government ID for financial, biometric for high-security.

**Tier 2 (Named):**
- Full identity disclosure with organizational attestation.
- Required for material commits on enterprise trees, financial transactions, authority delegation.
- Linked to user tree with full responsibility mirror.

**Implementation path:** OAuth 2.0 + OIDC for centralized bootstrap. DID/Verifiable Credentials for decentralized future. Both paths produce the same Tier 0/1/2 levels — the verification method changes, not the trust model.

### 48.2.1 Authentication Tiers — PIN vs Password Dance

Relay uses a tiered authentication model where the required verification intensity scales with the criticality of the action:

**BASIC (PIN swipe):**
- Sufficient for: reading, navigation, posting Notes, voting, creating filaments, standard engagement
- Method: device PIN, biometric unlock (fingerprint/FaceID), or session token
- This covers 95%+ of all user interactions. The system should never interrupt flow for routine actions.

**ELEVATED (PIN + device attestation):**
- Required for: changing notification settings, modifying personal filter tolerances, delegating authority on user tree, editing template parameters (if authorized)
- Method: PIN/biometric + device attestation (prove you're on a registered device)
- Triggered by the smart verification system when behavioral anomalies are detected OR when the action is in the elevated-risk category

**STRICT (Password Dance — full somatic authentication):**
- Required for: identity changes (email, phone, DID swap), guardian modifications, key rotation, founder key activation, account deletion request, transferring authority over high-value branches, contesting a Sybil enforcement flag
- Method: **Password Dance** — the user performs a pre-enrolled sequence combining:
  1. **Spoken phrase**: the user recites their chosen passphrase aloud
  2. **Facial/body gesture**: simultaneously performs their enrolled gesture (nod, smile, wink, eyebrow raise, head turn, hand signal, or custom movement sequence)
  3. Both are captured via the device camera and microphone — the **same detection pipeline** used for spell activation, element recognition, and card detection in interaction/game layer modules
- The camera processes the video locally (on-device, raw frames never leave — frozen contract #49), extracts audio features (MFCC, spectral, temporal) and gesture features (68 facial landmarks, motion vectors, expression classification), combines them into a biometric vector (60% audio weight, 40% gesture weight), and matches against the enrolled pattern using ML-based similarity (85% threshold)
- This is deliberately performative — it cannot be done passively, cannot be done by someone who doesn't know both the phrase AND the physical gesture, and trains the same muscle memory the user will use for spell casting downstream
- Failed attempts (3 consecutive) escalate to LOCKOUT, requiring guardian recovery or proximity reverification

**Fallback when detection pipeline degrades:**
The Password Dance is the *primary* STRICT authentication path, but NOT the *only* path. If the on-device detection pipeline fails (ML model degradation, hardware incompatibility, adversarial attack on the model, accessibility needs), STRICT authentication falls back to: PIN + guardian attestation (2 guardians confirm identity via ELEVATED auth) OR PIN + proximity reverification at a registered Relay location. The fallback is always available. The Password Dance is preferred because it trains the spell pipeline, but it cannot be a single point of failure for identity security.

**Why the Password Dance uses the spell pipeline:**
The detection engine that recognizes hand signals, body movements, facial expressions, and vocal patterns for the Password Dance is architecturally identical to the engine that will later detect spell trigger sequences (card presentation + gesture + element + voice incantation). By requiring users to enroll and practice somatic authentication from day 1, the system:
- Trains users in the interaction paradigm before AR/game modules are discovered
- Validates that the detection pipeline works on their specific device and body
- Creates a baseline behavioral profile that improves detection accuracy over time
- Ensures the ML models have per-user calibration data before spell activation matters

### 48.2.2 Guardian Recovery

If a user loses access to their account (device lost, key compromised, Password Dance forgotten), the recovery path is social — not centralized password reset.

**Guardian designation:**
- Every Tier 1+ user is prompted to designate 3-5 trusted guardians from their contact network
- Guardians must be Tier 1+ verified accounts with at least 30 days of activity
- Guardian list is encrypted and stored on the user's tree (only the user and the guardians can see it)
- Annual verification: the system prompts users once per year to confirm their guardian list is current. Unconfirmed guardians are flagged but not removed.

**Recovery process:**
1. User (or claimant) initiates recovery request via any device
2. System sends recovery challenge to all designated guardians
3. **M-of-N threshold**: 2 out of 3 guardians (or 3 out of 5) must approve the recovery within 24 hours
4. Each guardian approval requires ELEVATED authentication (PIN + device attestation) — a guardian cannot approve recovery with just a tap
5. If threshold is met, a new key pair is generated and the account is re-bound to the claimant's device
6. The recovery event is logged as an append-only governance commit on the user's tree (permanent audit trail)
7. If threshold is NOT met within 24 hours, the recovery request expires. A new request can be filed after a 48-hour cooldown.

**Anti-abuse:**
- A guardian who approves a fraudulent recovery receives a scar on their tree (visible to future jury sortition eligibility checks)
- Maximum 2 recovery attempts per account per 30 days
- If all guardians are compromised or unavailable, the fallback is proximity reverification at a registered Relay location (§12.4)

**Founder account recovery:** The founder account (§44) has a special recovery path: M-of-N guardians + proximity reverification at a registered location + a 7-day waiting period with public notification on the system tree. This extended process prevents silent founder key theft.

### 48.2.3 Invitation Decay Tree

Relay grows through invitation, not open registration. Every new user enters via an invite from an existing user, and the number of invites decays with each generation. **The invite tree is a launch mechanism only — generational depth carries zero governance weight, zero trust advantage, and zero structural power.**

**Mechanics:**
- The founder starts with N invites (e.g., 50)
- Each invitee receives `parent_invite_count - 1` invites
- Example chain: Founder (50) → User A (49) → User B (48) → User C (47) → ... → User 49 (1)
- **Floor**: when a parent's invite count reaches 1, new invitees receive the global minimum parameter (default: 3, votable) instead of 0
- Every invite records its **generation depth** (founder = generation 0, direct invitee = generation 1, etc.)
- Invites expire after 14 days (configurable global parameter)
- Used invites are permanently consumed; unused invites can be reclaimed on expiry

**Steady-state convergence:**
The decay is a launch-phase mechanism. Once a user's initial invite allocation is fully used or expired, they are reduced to **1 remaining invite slot**. From that point forward, the **global invite refill parameter** governs how often they receive a new invite to give: once per week? Once per month? Unlimited? This rate is determined by global parametric governance vote (§11) — the entire community decides the growth rate of Relay.

At steady state, every user — regardless of when they joined or their generation depth — operates under the same refill rate. The initial burst (50 → 49 → 48...) provides launch momentum; the global refill rate provides controlled steady-state growth.

**Growth phases:**
- **Launch phase** (early): Initial invite allocations provide exponential burst. Founder seeds initial community. Early adopters have more invites to distribute.
- **Depletion phase**: Users exhaust their initial invite count and are reduced to 1. All users converge to the same state.
- **Steady state**: The global invite refill parameter governs growth for ALL users equally. If set to 1/week, every user can invite 1 new person per week. If set to 1/month, growth is slower. If the community votes to pause invites entirely (refill = 0), growth stops. The rate is always votable, always visible, always the same for everyone.

**Why decay and not open registration:**
- **Sybil resistance**: creating accounts costs social capital (someone spent an invite on you). Mass account creation requires burning through a chain of real invites, and at steady state, each user gets one new invite per refill cycle.
- **Accountability chain**: every account traces back to a founder through the invite tree. If an account is flagged for abuse, the system can trace the invitation path.
- **Launch momentum**: early adopters seed the community via initial allocation burst, then the system converges to uniform refill rate.
- **Community-governed growth rate**: the refill rate (how often each user gets a new invite) is a global parameter voted by the entire community. The community directly controls how fast Relay grows. This is not a technical rate limiter — it is a governance decision about growth.

**What invite depth does NOT do:**
- Does NOT increase governance weight
- Does NOT increase vote power
- Does NOT increase trust score
- Does NOT increase jury eligibility
- Does NOT grant guardian priority
- Does NOT affect confidence calculations
- Does NOT create structural hierarchy

**Invite tree analytics:**
The system tracks per-generation invite usage, average decay factor, tree depth, and branching factor. These metrics are visible on the system tree as governance data, allowing the community to monitor growth health and detect when the system has reached steady state.

### 48.2.4 Scheduled Reverification by Trust Tier

Identity verification is not one-time. The system applies periodic reverification based on the user's current trust tier:

| Trust Tier | Reverification Type | Frequency | Method |
|-----------|-------------------|-----------|--------|
| **Probationary** (new, flagged, or post-recovery) | Hotspot required | Every 7 days | Physical visit to registered Relay location + multi-signal confirmation (BLE + Wi-Fi + time-in-range) |
| **Trusted** (established, no flags) | Light periodic | Every 90 days | Biometric ping (smile at camera) OR device attestation |
| **Verified** (long-standing, evidence contributor) | Standard periodic | Every 180 days | Biometric ping + device attestation + optional gesture |
| **Anchor** (high trust, prior jury service, community validator) | Enhanced periodic | Every 365 days | Biometric ping + device attestation + community validation (another Anchor attests in proximity) |

**Tier transitions:**
- New accounts start at **Probationary** for 30 days minimum
- Promotion to **Trusted** requires: 30 days + 10 evidence commits + no scars + passed reverification
- Promotion to **Verified** requires: 180 days + 50 evidence commits + jury service completion
- Promotion to **Anchor** requires: 365 days + 100 evidence commits + 3+ jury completions + community nomination

**Demotion triggers:**
- Failed reverification → demoted one tier + cooldown before re-attempt
- Sybil flag → immediate demotion to Probationary
- Scar accumulation (3+ scars) → demoted to Probationary with extended review
- Inactivity > 180 days → demoted one tier (re-promotion available on return)

**Dual-user simultaneous verification:**
When two accounts are suspected of being controlled by the same person (Sybil case), the system can require both accounts to verify simultaneously at different locations from their respective proximity histories. Both users receive a challenge with a synchronized time window. Success on both sides (verified at geographically separated locations at the same time) is strong evidence of distinct control.

### 48.3 Real-Time Synchronization

**Commit propagation:**
- Event sourcing: all state changes are commits. Clients reconstruct state from the commit log.
- WebSocket fanout for real-time updates (centralized/federated). Gossip protocol for decentralized.
- Commit ordering: monotonic sequence number per branch. Global ordering via Lamport timestamps + branch-level sequence. Ties broken by commit hash.

**Conflict resolution:**
- Two users commit to the same filament simultaneously: both commits are accepted (append-only). The second commit references the first's hash. No data lost, no overwrites.
- Merge semantics: filaments are append-only logs, not mutable state. "Conflict" means "two things happened at the same time," which is truth, not error.

**Consistency model:**
- Branch-level strong consistency (all commits on a branch are totally ordered).
- Cross-branch eventual consistency (commits on different branches propagate independently).
- Global ordering is eventually consistent with guaranteed convergence via Merkle chain verification.

### 48.4 Storage Architecture

**Hot storage (active filaments):**
- Relational or document database for active tree state (filaments with lifecycle != ABSORBED).
- Indexed by branchId, timeboxId, lifecycleState, counterparty, magnitude for fast queries.
- Replicated across regions for read performance.

**Warm storage (recent archives):**
- Object storage (S3-compatible) for recently absorbed filaments and root cubes.
- Queryable via metadata index. Full content retrievable on demand.

**Cold storage (Merkle root archive):**
- Append-only, content-addressed storage for the permanent Merkle chain.
- IPFS or similar content-addressed network for decentralized verification.
- Minimum 3 geographic replicas. Hash verification on every read.

**Attachments (evidence files):**
- Object storage with content-addressing (SHA-256 hash as key).
- Deduplication via content hash. Same file attached to 1000 filaments = stored once.
- Tiered access control per disclosure tier.

**Video and media (spell recordings, documentation, SCV captures):**
- Raw video from detection mesh NEVER leaves the user's device (contract #49). Only classified signal metadata is transmitted.
- Spell trigger recordings: SCV captures locally, extracts gesture/voice/element metadata signals, transmits only the classified signals + content-addressed hash of the source clip. Source clip stays on user device or their personal storage allocation.
- Documentation video (evidence recordings, meeting captures, inspection footage): stored in content-addressed external storage. Relay filament carries only the SHA-256 hash reference. The video file itself lives in object storage.
- Deduplication applies: same video referenced by 100 filaments = stored once.

### 48.4.2 Storage Growth Model — Preserving History Indefinitely

History must be preserved indefinitely (frozen contract #1: append-only). This requires predictable storage growth metrics so capacity planning is deterministic, not reactive.

**Per-filament storage budget (estimated):**

| Component | Size | Notes |
|-----------|------|-------|
| Filament metadata (all 6 domains, lifecycle, coords) | ~2 KB | JSON/binary, indexed |
| Average commit history (10 commits per filament) | ~5 KB | Append-only commit log |
| Merkle chain entry | ~256 bytes | SHA-256 hash + parent + timestamp |
| Evidence hash references (avg 3 per filament) | ~768 bytes | SHA-256 hashes only, not file content |
| **Filament total (excluding attachments)** | **~8 KB** | |

**Attachment storage (content-addressed, deduplicated):**

| Content Type | Avg Size | Frequency | Notes |
|-------------|----------|-----------|-------|
| PDF / document evidence | 500 KB | ~1 per 5 filaments | Deduplicated by content hash |
| Image (photo evidence, screenshots) | 2 MB | ~1 per 10 filaments | Deduplicated |
| Video (inspection, meeting, documentation) | 50 MB | ~1 per 100 filaments | Most expensive; deduplicated |
| Spell trigger clip (game layer) | 10 MB | ~1 per spell event | On-device by default; opt-in upload |
| Audio (voice commands, call recordings) | 5 MB | ~1 per 50 filaments | Deduplicated |

**Growth rate projections (per 1,000 active users):**

| Metric | Daily | Monthly | Yearly |
|--------|-------|---------|--------|
| New filaments | ~5,000 | ~150,000 | ~1.8M |
| Filament metadata growth | ~40 MB | ~1.2 GB | ~14.4 GB |
| Attachment growth (deduplicated) | ~2 GB | ~60 GB | ~720 GB |
| Merkle chain growth | ~1.3 MB | ~39 MB | ~468 MB |
| **Total (per 1K users)** | **~2 GB/day** | **~61 GB/mo** | **~735 GB/yr** |

**At scale:**

| Scale | Users | Annual Storage Growth | 10-Year Archive |
|-------|-------|----------------------|-----------------|
| Single company | 100 | ~74 GB/yr | ~740 GB |
| Mid-size org | 10,000 | ~7.4 TB/yr | ~74 TB |
| City | 1,000,000 | ~735 TB/yr | ~7.4 PB |
| Nation | 100,000,000 | ~73.5 PB/yr | ~735 PB |
| Planetary (1B users) | 1,000,000,000 | ~735 PB/yr | ~7.4 EB |

**Compression and tiering strategy:**

- **Hot tier** (active filaments, <6 months): SSD-backed, fully indexed. ~5% of total data.
- **Warm tier** (recent archive, 6 months - 2 years): Object storage, metadata-indexed. ~15% of total data.
- **Cold tier** (deep archive, >2 years): Compressed object storage, content-addressed, hash-verified on read. ~80% of total data.
- **Compression ratio**: Filament metadata compresses ~4:1 (structured, repetitive). Attachments vary (PDFs ~2:1, images/video already compressed ~1.1:1). Merkle chain is incompressible (hashes are high-entropy).
- **Deduplication dividend**: In practice, attachment deduplication reduces storage 30-60% depending on how many filaments reference the same evidence documents.

**Monitoring metrics (must be tracked in production):**

```
StorageMetrics {
  dailyFilamentCount: number,
  dailyCommitCount: number,
  dailyAttachmentBytes: number,
  dailyMerkleGrowthBytes: number,
  totalHotTierBytes: number,
  totalWarmTierBytes: number,
  totalColdTierBytes: number,
  deduplicationRatio: number,
  projectedAnnualGrowth: number,
  projectedTimeToCapacity: duration
}
```

These metrics are published as a system health filament on the system tree. Operators can see storage growth as a branch on the system tree — it sinks, it has rings, it has slabs. If storage growth accelerates beyond projections, the branch leans. If capacity approaches limits, the branch wilts. The system monitors itself using its own physics.

### 48.4.3 Replay Compression Strategy — Exabyte-Scale Deterministic Replay

History is preserved indefinitely (append-only). But preserving is not the same as replaying. At exabyte scale, naive replay (re-reading every commit from genesis) is computationally impossible. The system needs layered compression that preserves deterministic verifiability while making replay practical.

**Layer 1 — Per-Filament Terminal Compression**

When a filament reaches `ABSORBED` state and enters root archive:

```
TerminalSnapshot {
  filamentId: string,
  finalState: { ...all six domains at close... },
  totalCommitCount: number,
  commitLogHash: sha256,      // hash of the full commit chain
  evidenceHashes: [sha256],   // hashes of all evidence attachments
  magnitudeAtClose: decimal,
  absorptionTimestamp: ISO-8601,
  compressionLevel: 0|1|2     // 0 = full log, 1 = delta-compressed, 2 = snapshot-only
}
```

- **Level 0 (hot):** Full commit log retained. Every commit readable. Used for recent filaments (< 90 days absorbed).
- **Level 1 (warm):** Commits delta-compressed. Only diffs between commits are stored, plus the terminal snapshot. Full state is reconstructable by applying deltas forward. Used for filaments 90 days to 2 years absorbed.
- **Level 2 (cold):** Only the terminal snapshot + Merkle proof of the commit chain. Individual commits are not stored inline — they exist in deep cold archive and can be retrieved on demand (with latency). Used for filaments > 2 years absorbed.

At all levels, the `commitLogHash` and `evidenceHashes` are preserved. Verification is always possible. Replay fidelity is always achievable — the question is only latency.

**Layer 2 — Per-Timebox Summary Compression**

Closed timeboxes already cache `TimeboxAggregate` (§3.6). At archive depth, the individual filament data within a timebox may be at compression level 1 or 2, but the aggregate is always retained at full fidelity:

```
TimeboxArchiveSummary {
  timeboxId: string,
  branchId: string,
  aggregateSnapshot: TimeboxAggregate,   // always full fidelity
  filamentCount: number,
  filamentIds: [string],                 // list preserved even when logs are compressed
  merkleRoot: sha256,                    // root of all filament hashes in this timebox
  compressionLevel: 0|1|2
}
```

This means cross-section inspection at TREE/BRANCH LOD can always render ring thickness, color, opacity, and firmness from the aggregate — without decompressing individual filaments. Only drill-down to individual filaments requires decompression.

**Layer 3 — Cross-Timebox Delta Encoding**

Adjacent timeboxes on the same branch often share most filaments (a filament that spans 3 timeboxes appears in all 3). Instead of storing full filament lists per timebox, store:

```
TimeboxDelta {
  fromTimeboxId: string,
  toTimeboxId: string,
  addedFilaments: [filamentId],
  removedFilaments: [filamentId],
  changedFilaments: [{ filamentId, deltaCommits: [commitHash] }]
}
```

Replay reconstructs timebox N from timebox N-1 + delta. Storage savings: ~60-80% for stable branches where most filaments persist across periods.

**Layer 4 — Merkle Anchor Compaction**

The Merkle chain grows linearly with commits. At exabyte scale, the chain itself becomes a storage concern. Compaction rules:

- Every `N` commits (configurable, default 1000), a **Merkle checkpoint** is published: the root hash of all commits in that span, plus a pointer to the previous checkpoint.
- Between checkpoints, individual commit hashes are stored.
- After cold archive threshold, individual commit hashes between checkpoints are pruned from hot storage. The checkpoint hash proves the chain. Individual hashes are recoverable from cold archive.
- Verification path: to verify any specific commit, retrieve its checkpoint span from cold storage, reconstruct the Merkle tree for that span, and verify inclusion.

```
MerkleCheckpoint {
  checkpointId: string,
  branchId: string,
  commitRange: { from: commitIndex, to: commitIndex },
  merkleRoot: sha256,
  previousCheckpointId: string|null,
  timestamp: ISO-8601
}
```

**Layer 5 — Regional Federation Sharding**

No single node holds all data. Federation topology determines which region stores which data:

- A node stores full-fidelity data for its region (all trees, all branches, all filaments at compression level 0).
- For adjacent regions: compression level 1 (deltas).
- For distant regions: compression level 2 (snapshots + Merkle proofs only).
- Cross-region replay requires fetching data from the originating region's nodes. Latency is acceptable because cross-region inspection is rare and non-real-time.

**Replay performance targets:**

| Operation | Target Latency | Data Source |
|-----------|---------------|-------------|
| Current timebox render | < 16ms (60fps) | Hot cache (level 0) |
| Cross-section last 12 months | < 500ms | Warm cache (level 0-1) |
| Cross-section last 10 years | < 5s | Warm + cold (level 1-2) |
| Full filament history drill-down | < 10s | Cold archive (level 2 decompression) |
| Cross-region replay | < 30s | Federation fetch + decompress |

**The invariant:** Compression reduces storage and replay latency. It never reduces verifiability. Every compressed filament retains its Merkle proof. Every timebox retains its aggregate. Every checkpoint retains its chain anchor. If you need the full commit log of a 10-year-old filament, you can get it — it just takes longer.

**The fractal insight: archive IS tree physics applied to itself.**

The five compression layers are not a separate engineering system bolted onto the tree. They ARE the same inward-migration physics, applied recursively to the storage layer:

| Tree Physics | Archive Equivalent |
|-------------|-------------------|
| Outer bark (OPEN, active, recent) | Level 0 — hot storage, full commit logs, instant access |
| Mid-rings (CLOSED, migrating inward) | Level 1 — warm storage, delta-compressed, reconstructable |
| Deep core (ABSORBED, compressed archive) | Level 2 — cold storage, terminal snapshots + Merkle proofs |
| Timebox slab aggregates | TimeboxArchiveSummary — always full fidelity, even when underlying filaments are compressed |
| Merkle chain (commit causality) | MerkleCheckpoint — periodic anchors with prunable detail between |
| LOD (you see less detail at distance) | Federation sharding — your region is full fidelity, distant regions are summaries |
| Gravity sinking (older = deeper) | Compression level escalation (older = more compressed, higher retrieval latency) |
| Trunk mass (resolved work compacts) | Cold archive mass (resolved filaments compact into terminal snapshots) |

The progression from Level 0 → Level 1 → Level 2 IS inward migration for data. A filament's commit log starts at "bark" (full detail, fast access), migrates to "mid-ring" (delta-compressed), and eventually reaches "core" (snapshot + proof). The archive system is a tree inside the tree.

The system health filaments on the system tree (§48.4.2) close the recursion: the archive watches itself using the same physics it archives. If compression falls behind, the storage branch wilts. If retrieval latency spikes, the storage branch heats. The tree monitors the process of becoming a tree.

This is not metaphor. This is structural identity. The compression strategy works because it obeys the same invariants as everything else: inward migration is irreversible, nothing deletes, detail is always recoverable from depth, and aggregates at each ring are always available at full fidelity. The fractal scaling from filament → branch → tree → planet → galaxy → Laniakea extends downward into the storage layer with identical geometry.

### 48.4.1 Boundary Data Source-of-Truth

**Current status: Repo-file sourced (temporary).**

Geospatial boundary data (`data/boundaries/*.geojson`) is loaded directly from repository fixture files by the BoundaryRenderer at runtime. This is a bootstrap convenience, not the permanent model.

**Transition rule:** When boundary-define commits are implemented (a commit type that declares a geographic boundary with content-hash), the BoundaryRenderer must:
1. Verify loaded GeoJSON against the content-hash from the defining commit.
2. If no boundary-define commit exists for a requested boundary, emit `[REFUSAL] reason=BOUNDARY_SOURCE_UNCOMMITTED` and fall back to fixture data with a `source=REPO_FILE` log annotation.
3. If a commit exists but the hash does not match the fixture file, refuse to render.

Until boundary commits exist, all boundary loads are annotated `source=REPO_FILE` in console logs.

### 48.5 Bootstrap Strategy

**Minimum viable deployment (MVP):**
1. Single company tree with one template (P2P or municipal services)
2. Centralized backend (single server region)
3. Cesium globe with one trunk visible
4. 10-50 users demonstrating: filament create → evidence → confidence → sinking → root archive
5. Full proof suite passing (all existing proofs + BARK-CYLINDER-1)

**Growth path:**
- MVP → pilot companies (5-10 trees, federated backend)
- Pilot → public beta (1000+ trees, regional federation)
- Beta → production (global federation, social layer active)
- Production → AR modules (unlocking per-user as achievements are discovered)
- AR modules mature → game layer readiness (founder key activation consideration)

**Cold start for social layer:**
- Import existing 2D content (§37 Knowledge Migration Phase 1) to populate trees with historical data
- Notes system provides zero-barrier entry (post a Note, no registration required at Tier 0)
- First company trees provide the "anchor" content that social discussion attaches to

### 48.6 Economic Sustainability

**Revenue model (to be finalized):**
The system must sustain itself without compromising frozen contracts. Candidate models:

- **Freemium**: Tier 0 viewing free. Tier 1+ features (voting, filament creation) require subscription. Enterprise templates premium.
- **Transaction fee**: Small fee on magnitude-bearing commits (financial transactions). Zero fee on social/discussion.
- **Storage tier**: Free up to X GB of evidence attachments. Premium for high-volume enterprise.
- **SCV compute**: Basic SCV operations free. Advanced projections, large-model Whisper, GPU-intensive AR = premium compute.

**Constraint:** No revenue model may create pay-to-win dynamics. Achievement tokens must remain earned through real-world proof, never purchasable. Vote power must never correlate with payment tier. Frozen contracts are not gated behind payment.

### 48.7 Legal and Regulatory Compliance

**GDPR vs Append-Only:**
- The append-only contract (frozen contract #1) conflicts with GDPR Article 17 (right to erasure).
- Resolution: **cryptographic erasure**. The filament remains in the Merkle chain (structural integrity preserved), but the encryption key for the personal data payload is destroyed. The commit exists but its content is unreadable. The hash chain remains valid because the ciphertext (now undecryptable) still hashes correctly.
- This preserves: append-only integrity, Merkle chain validity, deterministic replay (the commit exists, its effect is null).

**Data sovereignty:**
- Federated backend enables regional data residency. Filaments created in the EU stay in EU nodes.
- Cross-region references use Merkle inclusion proofs (hash only crosses border, not content).

**Content liability:**
- Relay is an infrastructure platform, not a publisher. Content is user-generated.
- The confidence physics and filter system provide community-driven content quality without editorial control.
- Illegal content: template operators can define prohibited content rules. Violation triggers governance removal (migration to quarantine branch, not deletion — append-only preserved).

### 48.8 Performance at Scale

**Globe LOD rendering:**
- Server-side pre-aggregation: trunk metrics (engagement, attention, heat) computed server-side and streamed as tile metadata.
- Spatial indexing: R-tree or similar for fast "what trunks are visible in this viewport" queries.
- Progressive loading: coarsest LOD first (globe with hotspots), detail loads as user zooms.

**Branch LOD rendering:**
- Client-side: only the focused tree + immediate neighbors are fully rendered.
- Frustum culling: branches outside the camera frustum are not rendered.
- Primitive budget (§33.2): hard cap on simultaneous primitives per LOD level.

**Target performance:**
- 60 FPS at all LOD levels on mid-range hardware (existing D0 policy framework applies)
- < 200ms commit propagation latency (client to first peer)
- < 2s tree state reconstruction from commit log for any 1000-filament branch

### 48.9 Offline and Resilience

**Local-first data:**
- Active tree state cached locally. Users can navigate and read offline.
- Commits created offline are queued with local timestamps.
- On reconnect: queued commits are submitted. Server assigns authoritative sequence numbers. If no conflict (append-only model makes this the common case), commits are accepted in order.

**Network partition:**
- Clients continue operating with cached state.
- Presence markers go stale (TTL expires, presence disappears from other clients' views).
- Commits created during partition are reconciled on reconnect via the append-only merge model.

**Server failure:**
- Federated model: other regions continue operating. Affected region's data is read-only from replicas until primary recovers.
- Merkle chain enables verification of recovered state against known-good root hashes.

### 48.10 Enterprise Integration

**API surface:**
- REST API for CRUD operations on filaments, branches, templates, and commits
- WebSocket API for real-time commit stream subscription
- Webhook API for push notifications on branch events (new filament, confidence change, twig detection)
- Bulk import API for initial data migration (CSV/JSON → filaments)

**Connectors (future):**
- SAP: purchase order / invoice / goods receipt → P2P filaments
- Salesforce: opportunity / contact / case → CRM filaments
- Jira/GitHub: issue / PR / commit → software development filaments
- QuickBooks/Xero: transaction → accounting filaments

**Route engine (existing §C0):**
The route engine already provides config-driven data flow with provenance. Enterprise connectors are route configurations that map external system events to Relay filament schemas.

### 48.11 SCV AI Architecture

**Model selection:**
- Architect (intent parsing): Fine-tuned language model (GPT-class) for command parsing. Must understand tree-domain vocabulary (filament, branch, timebox, projection, confidence).
- Canon (execution planning): Structured output model that produces valid tree operations from parsed intent. Must respect all frozen contracts in output generation.
- Projection builder: Model capable of reading tree state (3D spatial data) and constructing analytical projections with decision nodes.

**Personal SCV memory:**
- Each user's SCV maintains a learned preference model stored as filaments on the user tree (§8).
- Preferences include: frequently used commands, custom spell definitions (game layer), graphic asset library (interaction layer), voice vocabulary adaptations.
- Memory is portable (it's just filaments) and subject to the same privacy tiers as all user tree data.

**Context window:**
- SCV context includes: current tree state (focused branch + neighbors), user's active scope, user's permission set, recent commit history, user's preference filaments.
- For spatial reasoning (§16.3): the SCV receives the 3D coordinate state of the focused branch and uses it as structured input, not rendered pixels.

### 48.12 Wire Protocol

**Commit format:**
- JSON for human-readable contexts (development, debugging, API responses)
- Protocol Buffers for wire efficiency (client-server, server-server communication)
- Every commit carries: commitId, parentHash, branchId, filamentId, timestamp, payload, signature

**Maximum sizes:**
- Commit payload: 1 MB (text, structured data, metadata)
- Evidence attachment reference: unlimited references, but each attachment stored separately in object storage
- Single attachment: 100 MB (configurable per template)

**Attachment handling:**
- Attachments are stored by content hash in object storage
- Commits reference attachments by hash, not by embedding content
- Retrieval is on-demand, not bundled with commit propagation

### 48.13 Key Management

**Key hierarchy:**
- Root key: per-user master key (never leaves secure enclave / HSM if available)
- Branch keys: derived per-branch for envelope encryption
- Session keys: ephemeral, per-connection for transport encryption

**Lifecycle:**
- **Rotation**: Automatic key rotation per the key rotation period (initial value: 90 days, global parameter — votable). Old keys retained for decryption of historical content. New content encrypted with new key.
- **Recovery**: Key recovery via threshold secret sharing (Shamir's scheme). User designates N trusted parties, M of N required to recover. Recovery event is a commit on the user tree (auditable).
- **Revocation**: Key revocation is a commit. Revoked key's content is re-encrypted with new key (lazy re-encryption on access). Revocation propagates via normal commit channel.
- **Delegation**: Authority delegation via sub-key issuance. Delegate receives a derived key that grants specific scope access. Revocable by the delegator.

### 48.14 Versioning and Upgrades

**Replay-safe upgrades:**
- Every computation function (confidence, wilt, KPI binding) is versioned.
- Commits carry the version of the computation that produced them.
- Replay engine loads the correct version of each function for each commit in the log.
- New versions can change future computation without invalidating historical replay.

**Schema evolution:**
- Filament schema extensions are append-only (new fields added, old fields never removed).
- Templates define minimum schema version. Older filaments are forward-compatible (missing new fields = null).
- Breaking changes require migration commits at the template level (governance-approved).

### 48.15 Mobile and Cross-Platform

**Progressive Web App (PWA):**
- Primary mobile interface. Cesium runs in mobile browser with reduced LOD budget.
- Offline capability via service worker + local commit queue.
- Push notifications for branch events, twig alerts, vote requests.

**Native considerations (future):**
- iOS/Android native for proximity channel detection (BLE/Wi-Fi requires native APIs).
- Camera access for AR interaction modules (gesture/light/object detection).
- Whisper runs on-device via Core ML (iOS) / TFLite (Android) for voice commands.

**Reduced LOD for mobile:**
- Mobile skips LANIAKEA/GALACTIC/STELLAR LOD levels (globe is the highest level).
- Branch rendering uses lower primitive budget.
- Bark-to-flat transition is default (no cylindrical rendering on mobile — always flat spreadsheet view at CELL LOD).

### 48.16 Federation Protocol Contract

For Relay-compatible systems (forks, federated nodes, "Belay" competitors) to remain interoperable, a minimum protocol contract must hold:

**Mandatory for Relay-compatible status:**
- Commit schema: append-only, content-addressed (SHA-256), same six-domain field structure (§4)
- Merkle chain: deterministic tree construction, identical hash function, verifiable inclusion proofs
- Confidence model: dual channels (org + global), never blended, same computation signatures
- Filament schema: filament = row, lifecycle state machine, disclosure tiers
- Replay determinism: given the same commit log, any conforming node produces identical state

**Protocol versioning:**
- Every commit carries a `protocolVersion` field (semantic versioning: MAJOR.MINOR.PATCH)
- MAJOR version change = breaking schema change (requires migration commit, governance-approved)
- MINOR version change = new optional fields (backward-compatible, old nodes ignore new fields)
- PATCH version change = computation refinement (same inputs, potentially improved outputs)
- Two systems are Relay-compatible if they share the same MAJOR version

**Cross-system verification:**
- Any Relay-compatible node can verify any other node's Merkle chain by replaying the commit log
- Cross-system references use Merkle inclusion proofs (hash only, not content)
- A system that cannot replay another system's commits is NOT Relay-compatible, regardless of what it calls itself

### 48.17 Cross-Region Merkle Anchor Publication

To prevent silent regional divergence (where federated regions selectively delay or omit commits), the system publishes **global digest commits** at fixed intervals:

- At every digest interval (initial value: 24 hours, global parameter — votable), each region publishes a digest commit containing: the Merkle root of all commits in that period, total commit count, region identifier, and a timestamp
- These digest commits are broadcast to ALL regions and to a public anchor (e.g., a public bulletin board, a public blockchain, or a government timestamp service)
- Any region that fails to publish a digest within the window is flagged: `[WARNING] reason=REGION_DIGEST_MISSING region=<id>`
- Cross-region verification: any user can compare digest roots between regions to detect divergence
- If two regions' digests diverge for the same time period, both are flagged for reconciliation. The commits are still valid per-region, but the global state is marked as partitioned.

### 48.18 External Evidence Freeze

When external data (PDFs, emails, images, video, 2D system exports) is ingested into Relay, the system creates a **freeze commit** that cryptographically anchors the external content:

- On ingest: the system computes SHA-256 of the raw file, stores the hash as an `externalEvidenceRef` field on the filament, and archives the original file in content-addressed storage
- The freeze commit records: original filename, file hash, ingest timestamp, ingesting user ID, and the content-addressed storage location
- If the external file is later deleted from its original source, the Relay evidence chain remains intact — the hash proves the content existed and the archived copy is retrievable
- This prevents: a deleted PDF breaking evidence integrity, a modified email invalidating a commit chain, or an external system's data loss cascading into Relay's truth layer
- Evidence that cannot be hashed (live streams, real-time feeds) is frozen at snapshot intervals with timestamp + hash pairs

### 48.19 Education Template — Maturation Scoping

Education trees must account for the fact that append-only permanence can be socially harmful for minors:

- Education templates include a **maturity transition** mechanism: when a student reaches adulthood (age threshold configurable per jurisdiction, default 18), their juvenile filaments are migrated to a **private root archive** on their user tree
- The migration is: the filaments are NOT deleted (append-only preserved), but they are re-scoped to `disclosureTier = 0` (visible only to the user) and moved to a sealed archive branch
- The sealed archive is: encrypted, accessible only to the user, excluded from all public queries, excluded from trust score computation, and excluded from jury sortition eligibility checks
- Childhood academic mistakes, behavioral incidents, and disciplinary records do not become permanent public scars
- The migration is automatic at the age threshold, governance-approved per template, and logged as a lifecycle commit

### 48.20 Healthcare — Emergency Override Commit

Healthcare trees require a mechanism for emergency access that respects append-only integrity:

- An **emergency break-glass commit** type exists: authorized medical personnel can access restricted evidence on a patient's tree in life-threatening situations without the patient's explicit real-time consent
- The break-glass commit records: who accessed, what was accessed, when, the medical justification, and the emergency authorization level
- The break-glass commit is: append-only (permanent audit trail), auto-scarred (visible on the accessor's user tree as a break-glass event), and subject to post-incident review
- Post-incident review: within the justification window (initial value: 72 hours, global parameter — votable), the break-glass event must be justified via a governance commit on the healthcare tree. Unjustified break-glass events trigger trust score reduction and potential sortition case
- The existence of the break-glass mechanism does not weaken normal consent requirements — it is an explicitly logged exception, not a silent bypass

### 48.21 Testing at Scale

**Load testing:**
- Simulate 10K concurrent users on a single tree (commit rate, query latency, presence marker updates).
- Simulate 1M concurrent users across 10K trees (cross-tree propagation, globe LOD aggregation).
- Target: < 500ms P95 commit propagation, < 100ms P95 query latency, 60 FPS render at all LOD.

**Chaos engineering:**
- Network partition simulation (split-brain, delayed reconnect, commit queue overflow).
- Server failure simulation (primary down, replica promotion, Merkle chain verification on recovery).
- Clock skew simulation (Lamport timestamp convergence under extreme skew).

**Proof discipline:**
- Every build slice continues to follow SPEC → IMPLEMENT → PROOF → COMMIT → INDEX.
- Scale proofs added as a new proof category: SCALE-PROOF-<name> with specific load profile and pass criteria.
- Existing proof suite runs as regression gate for every commit (CI/CD integration).

### 48.22 Session State Persistence — Save on Close, Restore on Open

Relay preserves the user's full working context across sessions. When a user closes the browser, navigates away, or loses connectivity, the system saves their current state. When they return, Relay restores them to exactly where they left off — same camera position, same open branch, same LOD, same inspectors, same conversation thread with their SCV.

**Analogy:** Cursor (the code editor) saves which folder you had open and what your last agent conversations said, so you resume exactly where you left off. Relay does the same for 3D tree navigation.

**What is saved (per-user, per-device):**

| State Category | Saved Fields | Storage |
|----------------|-------------|---------|
| Camera | lat, lon, altitude, heading, pitch, roll | Local |
| Active tree | treeId, focused branchId, selected filamentId | Local |
| LOD & render mode | current LOD level, force LOD override, render mode | Local |
| Inspector panels | open/closed state, panel positions, active tab | Local |
| Filter settings | all personal filter slidebar positions (§12) | Local + synced |
| Sim time offset | debug time advance offset (dev mode only) | Local |
| SCV context | last SCV conversation thread, pending proposals, draft queue | Synced |
| Note drafts | any unsaved Note text, target surface, attachments in progress | Local |
| Active projection | open projection branchIds, selected decision nodes | Local |
| Duel spectating | active duel eventId, spectator view position | Local |
| Sidebar layout | panel widths, collapsed/expanded sections | Local |

**Storage tiers:**
- **Local**: `localStorage` or `IndexedDB` on the client device. Survives page close and browser restart. Does not roam across devices. Key: `relay.session.v1.<userId>.<deviceId>`.
- **Synced**: Stored as a filament commit on the user tree (§8). Roams across all devices. The SCV conversation thread, filter preferences, and Note drafts marked as "synced" are preserved in the user's personal tree.

**Restore sequence on boot:**
1. Check for synced session state on user tree (requires auth).
2. Check for local session state in `localStorage`.
3. If both exist: use the more recent `lastSavedAt` timestamp.
4. If neither: boot to globe view (default).
5. If session state exists but the referenced tree/branch no longer exists (deleted or migrated): boot to globe view, display `[SESSION] Restored position unavailable — branch migrated. Starting at globe.`

**Save triggers:**
- `beforeunload` event (browser close/navigation).
- Periodic auto-save (interval: 30 seconds, local only — not every tick).
- Explicit save on SCV conversation commit.
- On network disconnect (save local snapshot immediately).

**Privacy:**
- Session state is personal data. The synced portion lives on the user tree at `disclosureTier = 0` (visible only to the user).
- Local session state is never transmitted to the server except through the explicit sync mechanism.
- Filter settings (§12) are especially sensitive — they reveal what the user hides — and are stored at the strictest tier.

**Frozen contract alignment:** Frozen contract #78 (below) establishes that session state restoration is a core UX guarantee, not an optional feature. The system must restore the user's working context after any interruption.

---

## 49. Adversarial Edge-Case Model

> *"If you know the enemy and know yourself, you need not fear the result of a hundred battles."* — Sun Tzu

What happens when people try to cheat? What if someone creates thousands of fake accounts to manipulate votes? What if a group tries to game the attention system? What if a powerful minority pressures dissenters into silence? This section examines every way someone might try to game, manipulate, or break Relay — and explains how the system responds. The answer is almost never "we block it." The answer is usually "the physics make it visible, and the community handles it." Relay does not pretend bad actors do not exist. It makes their actions measurable.

This section explicitly documents how the system behaves under adversarial, extreme, or degenerate conditions. Each scenario maps to the frozen contracts and structural mechanisms that contain it.

### 49.1 High-Frequency Vote Attack

**Scenario:** An attacker creates many Tier 1 accounts and votes rapidly to manipulate global parameters or branch governance outcomes within a single vote window.

**Containment:**
- Vote eligibility gates (frozen contract #22): Minimum Tier 1 identity + engagement history required. No zero-history accounts can vote.
- Vote decay (frozen contract #23): Votes decay exponentially. Rapid vote spam has diminishing returns as earlier votes decay before the window closes.
- Migration hysteresis (§7.7): Vote-driven migration commits require supermajority AND stability over multiple consecutive epochs. A single burst cannot trigger migration.
- Parametric rate-of-change caps (frozen contract #46): No single epoch can shift a global parameter by more than 20%.
- Fresh account governance cooldown (frozen contract #55): 14 days + 10 domain commits minimum.
- Context-weighted vote eligibility (frozen contract #56): branch-specific recency + evidence contribution history.
- Invitation decay tree (frozen contract #71): accounts are invite-only with linear decay. Mass account creation burns social capital.
- Periodic reverification (frozen contract #72): Sybil accounts must sustain reverification at Probationary frequency (every 7 days).
- **Residual risk:** A patient attacker who builds engagement history over months and then votes in coordinated burst. Mitigated by vote decay half-life, the supermajority+hysteresis requirement, and context-weighted vote eligibility (inactive accounts carry near-zero branch weight) — sustained manipulation is expensive and visible in the vote history filaments. If suspected, dual-user simultaneous verification (frozen contract #73) can be triggered via jury sortition (frozen contract #68).

### 49.2 Bot / Tier 0 Infiltration

**Scenario:** Bots flood the system with Tier 0 anonymous presence, attention signals, or content to distort globe visibility or manipulate attention-driven rendering.

**Containment:**
- Tier-gated attention at globe LOD (frozen contract #45): Tier 0 attention excluded from trunk prominence above COMPANY LOD.
- Presence quantization (frozen contract #52): At GLOBE/REGION LOD, presence is statistical — individual bot markers don't render.
- Vote eligibility (frozen contract #22): Tier 0 cannot vote.
- Achievement tokens require SCV-validated proof in any context (frozen contract #30, amended §71.2): Bots cannot earn advanced resources.
- Sleep cycle rate-limiting (frozen contract #43): Enforced rest period caps sustained bot activity.
- Acceleration diversity requirement (frozen contract #57): Globe-level heat requires diverse Tier 1+ participants.
- FilamentBirth cluster suppression (frozen contract #58): Same-cluster birth spam auto-classified as low-visibility.
- Attention is a lens, never a lever (frozen contract #54): Even if bots inflate attention, attention grants zero governance power.
- **Residual risk:** Bots can still spam content at COMPANY LOD within individual trees. Mitigated by template operator's prohibited content rules + quarantine branch mechanism (frozen contract #53) + device-level rate limiting.

### 49.3 Time Skew / Time Zone Exploitation

**Scenario:** Users in different time zones exploit the sleep regeneration cycle, gravitational sinking, or timebox boundaries to gain unfair advantage. Or: clock manipulation to generate commits with false timestamps.

**Containment:**
- Gravitational time (§14): Earth rotation IS the clock. Time is not user-configurable. Sinking is tied to the globe rotation, not local clocks.
- Commit timestamps are server-attested in federated mode (§48.3): Client-submitted timestamps are validated against server time. Out-of-range timestamps are rejected.
- Sleep cycle is global (frozen contract #43): Same rest period for all users. Time zone offset means different local times, but the same duration constraint.
- Timebox boundaries are Merkle-sealed: Retroactive manipulation of timebox start/end times breaks the hash chain and is detectable.
- **Residual risk:** In fully offline mode, timestamps are self-attested. Reconciliation on reconnect may reveal anomalies (divergence detection, §E3 replay). Scars are applied to suspect commits.

### 49.4 Economic Shock

**Scenario:** A sudden governance vote dramatically alters monster economy parameters (spawn rate, reward, difficulty) causing hyperinflation of engagement credits or sudden scarcity.

**Containment:**
- Rate-of-change caps (frozen contract #46): Max 20% parameter change per epoch. Shock is structurally impossible in a single cycle.
- Resource non-convertibility (frozen contract #47): Even if engagement credits inflate, they cannot be converted to achievement tokens or power. The damage is contained to one resource pool.
- Power closed loop (frozen contract #38): Gaming resource never affects governance. Economic shock in the game layer has zero governance impact.
- Truth layer outweighs game layer (frozen contract #42): Real-world contribution always yields more system influence than gaming performance, regardless of economic conditions.
- **Residual risk:** Sustained manipulation over many epochs (each shifting 20%) could still move parameters significantly over months. Mitigated by community visibility — all parameter changes are governance commits visible to everyone, creating social pressure against manipulation.

### 49.5 Founder Key Compromise

**Scenario:** The founder account is compromised and an attacker activates the game layer prematurely, or the founder activates under duress.

**Containment:**
- Activation requires attestation commit (frozen contract #48): The commit records exact system state at activation. If parameters are not at safe thresholds, the activation is evidence of compromise.
- Once activated, irreversible (frozen contract #34): But game layer content is additive — it cannot break truth or interaction layer modules (frozen contract #28). Even premature activation does not destroy existing functionality.
- All game layer spell effects resolve to truth layer filament operations (frozen contract #31): The game layer has no independent power over the data layer.
- **Residual risk:** Premature activation exposes users to game-layer complexity before the community is ready. Mitigated by the fact that game-layer features require individual achievement progression to unlock — activation doesn't grant instant power to anyone.

### 49.6 Regional Partition / Network Split

**Scenario:** A major network partition isolates regions. Commits continue in each partition independently. On reconnection, the system must reconcile divergent state without data loss.

**Containment:**
- Branch-level strong consistency, cross-branch eventual consistency (§48.3): Each branch maintains total ordering. Cross-branch divergence is expected and resolved on reconnect.
- Append-only + Merkle chain (frozen contracts #1, #2): Divergent commits are detected by hash comparison. No silent overwrite is possible.
- Offline commit queue (§48.9): Commits created during partition are queued and replayed on reconnect.
- Divergence scars (§E3 replay): When two partitions created conflicting commits, both are preserved and a scar records the divergence.
- **Residual risk:** Governance votes cast in separate partitions may reach different conclusions. Resolution: the partition with the earliest Merkle-sealed quorum commit wins. The other partition's votes are preserved as historical record but do not override.

### 49.7 Partial Data Corruption Under Dual Confidence

**Scenario:** A storage or transmission error corrupts either `orgConfidence` or `globalConfidence` for a set of filaments, while the other channel remains intact.

**Containment:**
- Dual confidence separation (frozen contract #44): The channels are independent. Corruption of one does not affect computation of the other. Rendering continues with the intact channel; the corrupted channel shows as null/indeterminate.
- Merkle chain integrity (E1-CRYPTO): Corruption is detectable via hash verification. Corrupted commits fail verification and are flagged.
- Replay engine (E3): The correct confidence values can be recomputed from the commit log (deterministic replay). If the underlying commits are intact, confidence is recoverable.
- **Residual risk:** If both the live value AND the commit log are corrupted (Byzantine failure), the system cannot self-heal. This is a storage-layer disaster, not a confidence-layer design flaw. Mitigated by minimum 3 geographic replicas (§48.4).

### 49.8 Power Regeneration Under Time Zone Offsets

**Scenario:** Users attempt to exploit the community-governed sleep cycle by rapid time zone changes or VPN-based location shifting to regenerate power faster.

**Containment:**
- Sleep cycle is global, not local (frozen contract #43): The rest period is a global parameter. Changing your location does not change the cycle.
- Power regeneration is tied to user tree identity, not location: The same user ID cannot regenerate twice per cycle regardless of apparent location.
- Detection mesh is local-first (frozen contract #49): Element detection requires physical camera presence. You cannot farm power from a VPN.
- **Residual risk:** If the global sleep cycle parameter is set too short by governance, everyone regenerates faster. Mitigated by rate-of-change caps (frozen contract #46) preventing sudden cycle shortening.

### 49.9 Fractal Scaling of Vote Eligibility at Planetary LOD

**Scenario:** At PLANETARY or GALACTIC LOD, the voter pool is enormous. Weighted-median computation becomes computationally expensive, and small groups may be structurally outvoted regardless of local merit.

**Containment:**
- Fractal scaling (§22): Each LOD level has its own governance scope. A city-level vote does not include planetary-level voters. Governance is local to the tree/scope being governed.
- Vote eligibility is scope-bound: You can only vote on trees where you have engagement history. Planetary LOD governance requires planetary-level engagement, which is structurally rare.
- Parametric governance at each scope (§11): Parameters at branch scope are voted by branch participants. Parameters at global scope are voted by global participants. No cross-scope vote bleeding.
- **Residual risk:** At truly global scale, the weighted-median computation is O(n) per parameter per epoch. Mitigated by server-side pre-aggregation (§48.8) and sampling-based approximation for very large voter pools.

### 49.10 Early-Adopter Influence and Natural Dilution (Sociological)

**Scenario:** Over years, early adopters accumulate high trust scores, deep engagement history, and dense guardian networks. They dominate the historic jury pool and carry disproportionate influence in governance.

**Design intent:** This is intentional. Early adopters SHOULD have outsized influence during the formation period — they ensure the system is built correctly when it is most vulnerable. The design goal is not to prevent early-adopter power, but to ensure it **fades naturally** as the user base grows.

**Natural dilution mechanisms:**
- Trust score ceiling of 100: a 5-year user and a 1-year user with identical reliability records have the same trust score. Duration alone does not compound beyond the ceiling.
- Context-weighted vote eligibility (frozen contract #56): vote weight on a branch depends on recency of participation on THAT branch, not account age. A 5-year user who hasn't engaged with a branch recently carries less weight than a 6-month user who has been active.
- Jury pool expansion: as the user population grows, any individual's probability of selection shrinks proportionally. Early adopters become a smaller fraction of the eligible pool.
- 4:3:3 jury ratio: 40% of every jury is randomly selected from the general eligible population — no faction can dominate through history alone.
- Jury historic pool rotation (frozen contract #77): max 2 consecutive terms, then 6-month cooldown.
- Guardian network diversity (frozen contract #79): prevents closed-loop early-adopter guardian clusters.
- **Residual risk:** Cultural prestige of early adopters is not structurally preventable. The system ensures their structural privilege dilutes naturally with growth, but informal social capital remains. This is a feature of all human communities, not a system flaw.

### 49.11 Cultural Capture by Spectacle (Sociological)

**Scenario:** The game layer is emotionally engaging — duels are dramatic, monsters are exciting, spell casting is spectacular. Users spend 90% of their time in spectacle. Truth layer evidence work becomes invisible background labor. Cultural prestige shifts to duelists and spell casters. Real contributors (evidence commits, governance participation, filament resolution) become invisible to narrative. Even though governance weight remains correct, cultural gravity shifts away from truth work.

**Containment:**
- The tree IS the interface (structural defense): Game layer spectacle happens ON the tree. Duels create filaments. Monsters spawn from evidence gaps. Spell effects modify rendering. The spectacle is inseparable from the evidence structure — you cannot see the show without seeing the tree. Truth layer work is the skeleton that the game layer decorates.
- Truth layer visibility guarantee (frozen contract #80): At every LOD, the rendering prioritizes evidence structure (filaments, timeboxes, lifecycle states) before spectacle overlays (spell effects, duel animations, monster visuals). Spectacle can be toggled off; evidence cannot. The default view always shows evidence structure.
- Contribution visibility in user tree (§8): Every user's tree shows their evidence commits, governance participation, and filament resolutions alongside their duel record and achievement tokens. The tree does not separate "fun" from "work" — it shows everything the user has done, in chronological and structural context.
- Attention is a lens, never a lever (frozen contract #54): Even if spectacle dominates cultural attention, attention never converts to governance power. Duelist fame does not increase vote weight.
- **Residual risk:** Cultural valorization of spectacle over substance is a human tendency that no system can fully prevent. The best defense is making evidence work visually compelling — the tree aesthetic should make truth work feel like building, not bureaucracy.

### 49.12 Complexity and Human Understanding (Sociological)

**Scenario:** The system has 84+ frozen contracts, multi-layered identity, dual confidence, juries, decay, reverification, weighted medians, hysteresis, and more.

**Why this is NOT the failure mode it appears to be:**

Humans already navigate infinite complexity with no structure, every day. Tax codes, social hierarchies, cultural norms, legal systems, weather, traffic, relationships — none of these come with a constitution, and humans manage. Relay is LESS complex than the unstructured chaos of daily human coordination, and it comes with something the real world does not: **physics metaphors that map directly to intuition**.

- **Wilt = neglect**: a branch that isn't getting evidence literally wilts. No one needs to understand "confidence deficit thresholds" — they see a wilting branch and understand something is being ignored.
- **Growth = engagement**: active branches grow visibly. Attention makes things bigger. This is how the real world works.
- **Gravity = time**: things sink as they age. Old information settles to the bottom. New information is at the top. This is gravitational intuition.
- **Heat = urgency**: hot topics glow. Everyone understands heat.
- **Opacity = evidence quality**: transparent = well-evidenced. Opaque = uncertain. This is literally how glass works.

The tree does not require users to understand the constitution. It requires them to look at it. The mechanics are complex. The experience is spatial and intuitive.

**Containment (for edge cases where explanation IS needed):**
- One-sentence explanation invariant (frozen contract #83): when a mechanic directly affects a user (vote weight change, parameter movement, jury selection), a one-sentence explanation appears in the UI at the point of interaction.
- Governance transparency logs: every parameter change, jury selection, and migration commit is visible as a filament on the governance branch.
- **Residual risk:** Some users will distrust any system they didn't build. The defense is not simplification — it is verifiability. Every action has an audit trail. Every decision has a commit. The math is complex but the evidence is always visible.

### 49.13 Governance Inertia Under Harmful Majority (Structural)

**Scenario:** The combined stabilization mechanisms (rate-of-change caps, hysteresis, settlement windows, cooldowns, vote decay, context weighting) create so much inertia that reform becomes effectively impossible. A harmful majority forms (e.g., a faction that suppresses evidence), and the minority cannot correct course quickly enough because every mechanism slows change.

**Containment:**
- Emergency reform mechanism (frozen contract #82): if a parameter or governance state is demonstrably harmful (defined as: triggering 3+ refusal logs per epoch, or causing measurable system degradation visible in proof artifacts), a compressed reform path is available. The compressed path uses 2x the normal supermajority threshold (e.g., 80% instead of 60%) but with 1/4 the normal settlement window. This allows urgent correction without making routine changes easy.
- Frozen contracts cannot be changed by governance (§26): The most critical invariants (append-only, dual confidence, filament = row, etc.) are immune to governance inertia because they are immune to governance entirely. The harmful majority cannot vote away the truth layer.
- Jury sortition as circuit breaker (§46): If parametric governance is deadlocked, a jury can break the deadlock. Juries are not subject to hysteresis or settlement windows — they deliberate and decide within 72 hours.
- **Residual risk:** If the harmful majority also dominates jury pools (see §49.10), the circuit breaker fails. Mitigated by jury rotation caps and random selection (40% of every jury is random). The attacker would need to control the entire eligible population, not just a faction.

### 49.14 Founder Key — Incapacitation and Succession

**Scenario:** The founder is incapacitated, refuses activation despite community readiness, activates prematurely under pressure, or loses cultural legitimacy.

**Containment:**
- Guardian Steward model (frozen contract #81): If the founder account is inactive for 365 consecutive days, the founder's designated guardian is elevated to **Steward of Relay**. The Steward receives a full Founder-level tutorial and initiation covering all frozen contracts, activation procedures, and philosophical responsibility. The Steward has identical activation authority and constraints as the founder. If the Steward also becomes inactive, succession chains to THEIR guardian. Final fallback: 7-member Succession Council via jury sortition (unanimous 7/7).
- If the founder actively refuses activation despite community thresholds being met for 2+ consecutive years, the community can petition for succession. The petition requires 80% supermajority of global-scope Anchor-tier voters sustained for 1 full settlement window. If the petition succeeds, the guardian is elevated to Steward and the founder key becomes dormant.
- Premature activation pressure: the jurisdiction checklist (frozen contract #67) and attestation commit (frozen contract #48) create structural friction that prevents impulsive activation. The founder cannot activate by tapping a button — the process requires documented compliance across all active jurisdictions.
- **Residual risk:** The 365-day inactivity threshold is long. A founder who is nominally active (posting one commit per year) but culturally absent can block activation indefinitely. The petition mechanism is the safety valve, but it requires 80% Anchor supermajority, which is a high bar. This is intentional — removing the founder should be extremely difficult.

### 49.15 Regional Feature Diversity (Operational)

**Scenario:** Different regions want different features: EU requires explicit consent logging, Japan bans AR overlays in public, a university campus disables duels, a gaming arena enables everything.

**Containment:**
- Regions vote features on or off (frozen contract #84): this is standard parametric governance at the regional scope. No system fork, no special mechanism — just branch-level voting on which interaction/game layer modules are active in that region. The core truth layer is always active everywhere.
- Regional feature votes are globally visible: everyone can see which regions have which features enabled. This creates cultural identity — Japan might become known as a duel hotspot, a university campus might be known for deep evidence trees with no game layer. This diversity is a feature, not fragmentation.
- Legal posture document (frozen contract #51): every deployment jurisdiction requires an explicit compliance document. The document specifies which features are active and which are restricted, aligned with local law.
- Fractal model preserves unity: a Japan tree with AR disabled still participates in the global Merkle chain, still has filaments, still has governance, still has presence. The tree structure is universal. The feature configuration is local.
- Cross-jurisdiction references use Merkle inclusion proofs (hash only crosses border, not content).
- **Residual risk:** A region that votes to disable ALL interaction/game layer modules operates on the truth layer only. This is by design — the truth layer is the foundation, and it does not depend on the game or detection layers.

### 49.16 Sovereignty-First Measurement Philosophy

**Foundational axiom:** People physically living in a place should have majority say in that place. Relay does not attempt to create a borderless ideological democracy. It creates **scoped sovereignty** with **measurable divergence**.

**What Relay does:**
- Makes cultural clustering visible — not correctable
- Makes pressure gradients between regions measurable
- Makes boundary shifts traceable
- Makes invite-tree topology inspectable
- Makes grading distributions auditable
- Makes trust drift detectable

**What Relay does NOT do:**
- Enforce global cultural diversity quotas
- Artificially balance ideological representation
- Override local majority decisions with global consensus
- Flatten cultural differences between regions
- Privilege distant spectators over local residents

**Boundary reconfiguration as pressure valve:** Users who disagree with local majority can redefine their governance boundaries — shift from one neighborhood branch to another, create a new zone, physically relocate their anchor point. Exit is always easier than overthrow. This is the structural guarantee that local majority rule remains voluntary, not entrapping.

**Closed loops are permitted:** If a region closes itself off, stops referencing external evidence, self-grades positively — that is allowed. Relay does not prevent divergence. Relay makes divergence visible. Other regions see opacity differences, reference gaps, isolation patterns. Any child in a closed region can look outward and see what exists elsewhere. Transparency is the mechanism, not enforcement.

**Measurement cannot be falsified — that is the only true invariant.** If measurement is trustworthy, human self-alignment becomes organic. All social dynamics — clustering, pressure, conformity, dissent — are expressions of physical reality. Relay reveals them. It does not reshape them.

### 49.17 Principled Dissent Protection (Social Grading Drift)

**Scenario:** Slow, socially acceptable conformity pressure. A principled dissenter is not attacked overtly but is consistently graded 5–10% lower across many juries, kept above threshold but prevented from reaching Anchor tier — blocking them from historic jury pool, council eligibility, and high-impact roles. No single dramatic abuse. Just mild, sustained social pressure compressing trust scores.

**The pipeline:** Grading feeds trust → trust feeds eligibility → eligibility feeds governance → governance feeds power. If social conformity is the dominant signal in grading, this pipeline amplifies it.

**Containment — Evidence quality as trust floor:**
- A user's **evidence contribution quality** provides a hard floor on their trust score that social grading alone cannot push them below. Specifically: if a user's evidence commits are frequently referenced by other branches, cited in sortition verdicts, or promoted to canonical fixtures, their trust score has a minimum proportional to their evidence impact.
- This means: a dissenter who contributes high-quality evidence cannot be socially graded below the trust threshold for jury eligibility or council candidacy, regardless of how many juries grade them slightly lower for personality friction.
- The floor is computed from: evidence reference count (how often their commits are cited), evidence promotion rate (how often their evidence is promoted to permanent fixtures), and evidence cross-branch impact (how many branches outside their home reference their work).
- Evidence quality is objective and append-only. Social grading is subjective and variable. The floor ensures the objective signal always survives the subjective one.

**Why this is not paternalistic:** Relay does not prevent communities from grading dissenters lower — that is legitimate social signal. It prevents the grading pipeline from silencing contributors whose evidence quality demonstrates value regardless of social popularity. The system distinguishes between "unpopular person" and "person whose work is provably useful."

### 49.18 Council Continuous Confidence — Decision Immunity Buffer

**Scenario:** Continuous confidence election means council members must maintain high visible confidence at all times. This incentivizes avoiding controversial but necessary decisions, choosing popular over correct rulings, and optimizing for trust score rather than truth. Continuous election becomes permanent campaigning.

**Containment — 14-day decision immunity window:**
- When a council member participates in an official council decision (module approval, dispute escalation, emergency reform vote), a 14-day immunity window begins for that decision.
- During the immunity window: trust score changes, confidence recalculations, and grading events **do not affect that council member's seat eligibility**. Their seat is locked for the duration.
- After the immunity window: normal continuous confidence resumes. If the controversial decision eroded their trust score, they may lose their seat — but they had the full immunity period for the community to see the results of the decision before reacting.
- The immunity is per-decision, not per-member: a council member who makes three controversial decisions in a week gets three overlapping immunity windows. They are not permanently immune.
- The immunity duration is a global parameter (initial value: 14 days, votable). The community can shorten or lengthen this buffer based on experience.
- **Edge case:** If the community initiates an emergency reform (§49.13, supermajority threshold is a global parameter, initial: 80% Anchor-tier), the immunity window is overridden. Emergency reform can always remove a council member regardless of pending immunity.

**Why this matters:** Without the buffer, council drifts toward safe consensus. With the buffer, council members can make unpopular-but-correct decisions knowing they won't be immediately ejected before the community can assess the outcome.

### 49.19 Invite-Chain Centrality Monitoring

**Scenario:** Invite depth carries zero governance weight (frozen contract #75). But socially, early clusters build cohesion, guardian networks form along invite chains, jury volunteers emerge from friend networks, council candidates are visible through early networks. Network topology influences cultural formation even without direct weight.

**Containment — Measurement, not correction:**
- The system tracks invite-chain centrality metrics: subtree size per root node, branching factor by generation, geographic distribution per subtree, guardian overlap within subtrees.
- These metrics are publicly visible as part of the system's self-measurement layer. Any user can inspect invite topology.
- If one subtree becomes disproportionately large (e.g., >25% of all active users trace to a single generation-1 node), the system publishes a visibility marker — not a restriction, not a penalty, just a measurement.
- Why measurement-only: cultural clustering along invite chains is not inherently harmful. It reflects the reality of how social networks form. Relay's philosophy is to make network topology visible, not to engineer it. Boundary reconfiguration (§49.16) is the user-facing pressure valve.

---

## 49b. Real-World Integration — Relay Coordinates, Never Owns

> *"The map is not the territory."* — Alfred Korzybski

Relay is a truth-coordination engine. It is not a mint. It is not a power grid. It is not a water purification plant. It is not a bank. If Relay ever tries to replace physical infrastructure directly, it collapses. Instead, it interfaces with existing systems.

### 49b.1 The Five-Layer Responsibility Model

| Layer | Responsibility | Who Owns It |
|-------|---------------|-------------|
| Physical resource | Production, distribution, storage of real goods (water, food, fuel, materials) | Real-world producers and distributors |
| Legal authority | Sovereignty, enforcement, taxation, courts, property law | State and regulatory bodies |
| Settlement | Moving money, clearing transactions, holding reserves | Banking networks (central banks, commercial banks, payment rails) |
| **Coordination** | **Organizing who does what, when, with what evidence** | **Relay** |
| **Accountability** | **Making actions visible, auditable, and permanent** | **Relay** |

Relay occupies exactly two layers. It measures and coordinates. It does not seize, own, mint, guarantee, ration, or replace anything in the first three layers.

### 49b.2 What Enables Physical Cash and Banking Today

Physical money requires four engines that Relay does not replace:

1. **Sovereign issuance**: Central banks control base money supply. Legal tender laws enforce acceptance. Relay has no authority to issue or enforce legal tender.
2. **Settlement rails**: Banks maintain ledgers. Clearinghouses (SWIFT, ACH, Visa, SEPA) settle between institutions. Relay does not process wire transfers or clear payments.
3. **Enforcement**: Courts enforce contracts. Governments enforce taxation and fraud law. Relay records evidence — it does not adjudicate outside its own governance scope.
4. **Physical backing**: Trust in state stability. Military and legal monopoly on force. Relay has no physical enforcement capability.

### 49b.3 Three Bridges to Physical Commerce

There are only three legitimate bridges between Relay's digital truth and physical goods:

**Bridge 1 — Existing Banking Rails (primary)**

Relay generates `TransferPacket` (system truth) and `ResponsibilityPacket` (human accountability). These integrate with bank APIs, payment processors, ERP systems, and treasury platforms. Relay becomes the coordination layer. Banks remain the settlement layer. This is clean, realistic, and deployable today.

**Bridge 2 — Tokenized Fiat Accounts (custodial partners)**

Relay can integrate with bank-backed digital wallets, regulated stablecoins, and licensed payment service providers. Critical rule: **Relay never becomes the custodian of fiat reserves.** Custody risk = collapse risk. The custodian is always a regulated financial institution, never Relay itself.

**Bridge 3 — Physical Resource Tracking (accountability overlay)**

For water, food, fuel, and other physical resources, Relay does not "lock" or control them. It tracks them:
- Filament: resource inventory state
- Filament: supply chain commitments
- Filament: transport and logistics events
- Filament: storage telemetry and sensor readings
- Filament: inspection and compliance reports

Physical goods remain physical. Relay becomes the coordination and accountability overlay. If a water utility publishes its data into Relay, anyone can see the state of the water supply. Relay does not control the valves.

### 49b.4 What Must Be Built (Modules)

**1. Payment Abstraction Layer (Module P)**

A module that supports multiple settlement rails without forcing one monetary regime:
- Bank API integration (open banking standards)
- Card processor connectors (Visa, Mastercard, regional processors)
- Stablecoin / digital currency rails (where legally permitted)
- Regional payment standards (SEPA, UPI, PIX, etc.)
- Currency-agnostic magnitude handling (filament magnitude carries unit + amount, settlement converts)

**2. Compliance Interface (Module C)**

- Jurisdiction mapping: which laws apply where
- Tax recording: filaments that represent taxable events carry jurisdiction metadata
- Legal audit hooks: export capability for regulatory examination
- Anti-fraud metadata: transaction pattern flagging (not blocking — flagging for human/SCV review)
- KYC/AML integration points: connect to existing identity verification services where required by jurisdiction

**3. Resource Registry Templates (Module R)**

Industry vertical templates (not core physics — these are template modules):
- Water utilities: supply, demand, quality metrics, infrastructure state
- Food logistics: supply chain, cold chain, inspection, distribution
- Energy grids: generation, consumption, storage, pricing
- Telecom: capacity, outages, coverage, service levels
- Healthcare supply: inventory, distribution, expiry tracking, cold chain

Each template maps the industry's events to filaments with the standard six domains. The physics are universal. The templates are industry-specific.

### 49b.5 Custody Isolation (Non-Negotiable)

The following resource types must remain structurally isolated — different ledger types, different storage, no conversion mechanism:

| Resource | Source | Isolation Rule |
|----------|--------|---------------|
| Engagement Credits | Digital participation | Never redeemable for fiat. No exchange rate exists. |
| Achievement Tokens | SCV-validated achievements in any context (§71.2) | Never redeemable for fiat. No exchange rate exists. |
| Power | Game layer (spell casting) | Closed loop. Never touches fiat. |
| Fiat currency | External banking rails | Held by regulated custodians, never by Relay. Magnitude in filaments only. |
| Physical resources | Real-world producers | Tracked by Relay, never held or distributed by Relay. |

If any of these pools are blended, converted, or allowed to leak into each other, systemic risk is created. This is why frozen contract #47 (resource non-convertibility) exists. This section extends that principle to fiat and physical resources.

### 49b.6 What Relay Must NOT Do (Prohibitions)

These are not suggestions. They are structural prohibitions:

1. **Relay must not create its own fiat-backed currency.** It is not a central bank.
2. **Relay must not guarantee physical redemption** of any digital resource for any physical good.
3. **Relay must not promise resource allocation** (water, food, energy) to any user.
4. **Relay must not replace national settlement rails.** It coordinates around them.
5. **Relay must not allow governance votes to directly manipulate physical supply.** Votes affect Relay parameters. They do not open water valves or redirect food shipments.
6. **Relay must not hold fiat reserves.** Custody is always delegated to regulated financial institutions.
7. **Relay must not become a dependency for critical infrastructure operation.** If Relay goes offline, water must still flow, hospitals must still function, banks must still clear. Relay is additive accountability, never a dependency.

### 49b.7 The Long-Term Model (Organic Evolution, Not Coercive Replacement)

Over decades, if enough commerce flows through Relay:
- Banks may integrate deeply (Relay becomes the evidence layer for transactions).
- Utilities may publish real-time state (Relay becomes the transparency layer for infrastructure).
- Governments may adopt Relay for policy transparency.
- Supply chains may use Relay end-to-end (from raw material to consumer).

But this is organic evolution. Not coercive replacement. Relay must work:
- In democracies and autocracies
- Under sanctions
- With offline fallback
- Without requiring any specific banking system, currency, or government structure

The true engine is: **interoperability without sovereignty conflict.**

### 49b.8 The Systemic Risk Acknowledgment

If Relay becomes the dominant coordination and transparency layer, it becomes systemic. Systemic systems must survive: nation-state hostility, sanctions, infrastructure sabotage, regulatory capture, and financial exclusion. The defenses are:
- Federated architecture (no single point of control, §48)
- Cryptographic integrity (Merkle chain, §48.1)
- Offline capability (local-first detection, contract #49)
- Jurisdiction-aware compliance (legal posture, contract #51)
- No physical dependency (Relay additive, never required)

Relay can coordinate the world. It cannot own it.

### 49b.9 Degradation Model — Graceful Contraction Toward Core Truth

Relay does not fail catastrophically. It contracts gracefully. Each degradation mode specifies what continues, what freezes, what sheds, and what refuses. The design principle: degrade toward human deliberation. Sortition remains available in every mode except ARCHIVAL. The truth layer is always the last thing standing.

**Mode A — FULL (normal operation)**

All physics active. Wind, weather, lean, engagement, projections, settlement hooks, full rendering. Everything works.

**Mode B — COMPUTE CONSTRAINED**

Trigger: Projection instance cap hit, rendering budget exceeded, federation lag.

| What Continues | What Sheds | What Freezes |
|---------------|-----------|-------------|
| Filament motion (sinking, lean) | Weather tile overlays | Projection recompute (cached results hold) |
| Slab updates | Organic variation noise | Lightning cascade detection |
| Commit recording | Individual filament rendering at high LOD | |
| Sortition | | |

Users still see branch structure and truth. Spectacle drops first, evidence last (§3.17 shed order). Log: `[DEGRADED] reason=COMPUTE_CONSTRAINED`

**Mode C — SETTLEMENT RAIL OFFLINE**

Trigger: Bank API down, stablecoin network halted, payment processor unreachable.

| What Continues | What Queues | What Flags |
|---------------|------------|-----------|
| All physics and rendering | TransferPackets (queued for settlement) | Settlement status = `PENDING_EXTERNAL` |
| All commit recording | Fiat-denominated ResponsibilityPackets | Affected filaments flagged `SETTLEMENT_PENDING` |
| Sortition (for disputes) | | |

Nothing disappears. Truth records accumulate. Settlement catches up when rails reconnect. Humans deliberate via sortition if disputes arise during the gap. Log: `[DEGRADED] reason=SETTLEMENT_OFFLINE rail=<name>`

**Mode D — FEDERATION PARTITION**

Trigger: Region isolated (network partition, infrastructure failure, geopolitical block).

| What Continues Locally | What Degrades | What Happens on Reconnect |
|----------------------|--------------|--------------------------|
| Local commit queue | Cross-region references show as `HASH_ONLY` | Deterministic merge |
| Local physics + rendering | Cross-region weather tiles empty | Divergence detection |
| Local sortition | Inter-region filament refs unresolvable | Scars if divergent commits conflict |

Upon reconnect: the system replays both partitions' commit logs deterministically. If commits conflict (same filament, different values), a scar is created and sortition resolves the dispute. Log: `[DEGRADED] reason=FEDERATION_PARTITION region=<id>`

**Mode E — RENDER COLLAPSE**

Trigger: Primitive budget catastrophically exceeded, GPU saturation, extreme device constraint.

| What Remains | What Disappears |
|-------------|----------------|
| Trunk silhouettes (always) | Weather overlays |
| Branch outlines (bundles only) | Individual filaments |
| Aggregate health indicators | Slab detail |
| Text-mode fallback | Lean/droop deformation |

This is the absolute minimum: you can still see which trees exist, which branches exist, and their aggregate health. Full detail restores when resources become available. Log: `[DEGRADED] reason=RENDER_COLLAPSE primitives=<count> budget=<max>`

**Mode F — ARCHIVAL (read-only)**

Trigger: Deliberate operator decision, or catastrophic loss of commit authority.

| What Works | What Doesn't |
|-----------|-------------|
| Full history browsing | New commits |
| Cross-section inspection | Filament creation |
| Replay | Governance votes |
| Export | Settlement |

The tree is frozen in time. You can inspect every ring, every scar, every filament that ever existed. But nothing new grows. This is the last-resort mode — Relay becomes a museum of its own history.

**The invariant:** In every degradation mode, the truth layer (committed filaments, slabs, scars, Merkle chain) is preserved. Truth is the last thing to go. Spectacle goes first, compute goes second, settlement queues third, federation partitions fourth, rendering collapses fifth. Truth survives everything except total data loss.

### 49b.10 The Philosophical Premise

> *"People are often excellent. The branch they serve is not."* — Eitan Asulin
>
> *"A firm branch built on the wrong trunk is still a misalignment. Shape reveals what skill conceals."* — Relay

Relay bets on one anthropological premise:

**If truth is rendered cleanly, humans will self-correct.**

Relay does not prevent corruption. It makes corruption geometrically obvious. Relay does not eliminate greed, ambition, fear, or tribal behavior. It removes structural invisibility. That is a fundamentally different design choice from systems that try to control human behavior through enforcement.

The safety valve is sortition (§46). Not algorithmic enforcement, not AI judgment, not founder decree — randomly selected juries of ordinary people, deliberating over visible evidence. Sortition must remain boring and procedural. The moment it becomes performative or politicized, it breaks.

This stance means: Relay over-engineers physics, geometry, and truth rendering. It under-engineers human behavioral control. That is intentional. The system trusts that if people can see the shape of their world clearly enough, they will act on what they see. That is the bet.

---

## 49c. Constitutional Hardening Checklist (GO/NO-GO)

Complete only when every item is PASS or explicitly DEGRADED with a containment plan. Assessed 2026-02-19.

### A. Governance and Legitimacy

| Threat | Status | Contract(s) | Notes |
|--------|--------|-------------|-------|
| Sybil resistance (cheap identity flood) | **PASS** | #22, #55 | Tier 1+ gate + 14-day/10-commit cooldown + engagement history |
| Off-platform vote renting / bribery | **PASS** | #56 | Context-weighted votes: branch-specific recency + evidence contribution history. Inactive = near-zero weight. |
| Majority pressure vs local sovereignty | **PASS** | #44 | Dual confidence proven and enforced. orgConfidence immune to votes. |
| Parameter whiplash | **PASS** | #46, §7.7 | 20% rate-of-change cap + settlement window + hysteresis band |
| Founder key liability | **PASS** | #48, #67, #51 | Attestation commit + jurisdiction checklist + legal posture requirement |

### B. Attention Economy and Visibility Capture

| Threat | Status | Contract(s) | Notes |
|--------|--------|-------------|-------|
| Attention farming (Tier 0 bots) | **PASS** | #45, #54 | Globe-LOD excludes Tier 0. Attention is a lens, never a lever. |
| Acceleration gaming (micro-spike coordination) | **PASS** | #57 | Diverse participation required. Per-scope rate limits. Spam decay. |
| StickyNote brigade (manufactured births) | **PASS** | #58, §5 | Device rate limit + cluster suppression + branch spam threshold |
| Spectacle → soft power conversion | **PASS** | #54, #38 | Attention never affects governance, permissions, or execution priority |

### C. Economics That Can Break the System

| Threat | Status | Contract(s) | Notes |
|--------|--------|-------------|-------|
| Monster economy inflation | **PASS** | #59, #46 | Per-epoch issuance budget + rate-of-change caps. Throttle visible. |
| Monster economy starvation | **PASS** | #60 | Difficulty floor + beginner ramp (50% ceiling for < 30 days). |
| Convertibility drift (treated as money) | **PASS** | #47 | Structural non-convertibility. No exchange rate. No marketplace. Explicit. |
| Power buying influence indirectly | **PASS** | #54, #38 | Attention (from spectacle) never grants governance weight |

### D. Privacy, Sensing, and Real-World Risk

| Threat | Status | Contract(s) | Notes |
|--------|--------|-------------|-------|
| Bystander capture in camera frames | **PASS** | #49, #40 | Local-first. Raw frames never leave device. Bystander privacy absolute. |
| Minor safety / dangerous triggers | **PASS** | #50, #61 | Age gate + prohibited trigger taxonomy + venue safety defaults |
| Presence deanonymization | **PASS** | #52, #62 | Time-bucketed updates + precision degradation + statistical aggregation |
| Camera operator liability | **PASS** | #66, #51 | Explicit controller/processor model. Processor commit required. |

### E. System Integrity and Operational Stability

| Threat | Status | Contract(s) | Notes |
|--------|--------|-------------|-------|
| Proof discipline erosion | **PASS** | §27 process | Every slice: SPEC → IMPLEMENT → PROOF → COMMIT → INDEX |
| Single-scalar confidence relapse | **PASS** | #44, #63 | Deprecated trap + CI lint + pre-commit gate |
| Git attachment bloat | **PASS** | #64 | 500KB hook + content-addressed external storage + proof exemption |
| Renderer scale collapse | **PASS** | #65, §33.2 | Hard LOD budgets + over-instantiation refusal |
| Legal controller/processor ambiguity | **PASS** | #66 | Operator model + processor commit + legal posture document |

### F. Identity, Growth, and Dispute Resolution

| Threat | Status | Contract(s) | Notes |
|--------|--------|-------------|-------|
| Dispute resolution capture (founder/mob decides) | **PASS** | #68, §46 | Sortition juries with 4:3:3 ratio, crypto selection, bias detection |
| Critical auth bypass (social engineering) | **PASS** | #69, #74, §48.2.1 | Password Dance (somatic + vocal) for STRICT; action-driven escalation, not user-chosen |
| Account loss = permanent loss | **PASS** | #70, §48.2.2 | Guardian recovery (M-of-N social recovery). Founder has extended 7-day path. |
| Open registration Sybil flood | **PASS** | #71, §48.2.3 | Invitation decay tree. No open registration endpoint. Every account traceable to founder. |
| Identity rot (verify once, abuse forever) | **PASS** | #72, §48.2.4 | Periodic reverification by trust tier: 7d/90d/180d/365d. Failed = demotion. |
| Same-person multi-account (Sybil) | **PASS** | #73 | Dual-user simultaneous verification at geographically separated locations |
| User opts out of strong auth for critical actions | **PASS** | #74 | Authentication escalation is action-driven, not user-chosen. Cannot downgrade. |

### G. Sociological Resilience

| Threat | Status | Contract(s) | Notes |
|--------|--------|-------------|-------|
| Early-adopter power concentration | **PASS** | #75, #76, #77, #79, §49.10 | Intentional during formation, self-diluting with growth. Trust ceiling, jury rotation, guardian diversity. |
| Cultural capture by spectacle (game layer dominance) | **PASS** | #80, #54, §49.11 | Evidence renders first, spectacle is additive overlay. Attention never = authority. |
| Complexity vs human understanding | **PASS** | #83, §49.12 | Physics metaphors (wilt, growth, gravity, heat, opacity). One-sentence explanation for direct-impact events. |
| Governance inertia under harmful majority | **PASS** | #82, §49.13 | Emergency reform: 80% supermajority + compressed settlement. Jury as circuit breaker. |
| Founder incapacitation / no succession | **PASS** | #81, §49.14 | Guardian becomes Steward with full tutorial. Chain to their guardian. Council as final fallback. |
| Regional feature diversity | **PASS** | #84, #51, §49.15 | Regions vote modules on/off via standard governance. Truth layer universal. Cultural identity emerges. |
| Password Dance single point of failure | **PASS** | #78, §48.2.1 | Fallback: PIN + 2-guardian attestation OR proximity reverification. Always available. |
| Trust threshold excluding dissidents | **PASS** | #76 | Trust measures reliability (completion, compliance), never ideology. Dissent cannot reduce trust. |
| Invite growth at scale | **PASS** | #71, §48.2.3 | Initial decay → depletion → global refill rate (community-voted: 1/week, 1/month, etc). Uniform for all. |
| Sortition accountability | **PASS** | #85, §46.6 | Live peer grading (draft → commit). Game theory: honest graders build reputation, non-graders stagnate. |
| Council capture / fixed-term entrenchment | **PASS** | #86, §46.8 | Continuous confidence election. No fixed terms. Drop below threshold = automatic succession. |
| Unvetted code entering live system | **PASS** | #87, §46.8 | Sandbox → community vote → council review (5/7) → canonical commit. No bypass. |
| Dispute resolution dead end | **PASS** | #88, §46.7-46.8 | Three-level escalation: jury → appeal jury → Council (final). |
| Temporary data treated as permanent | **PASS** | #89 | Draft → commit universal. Notes, grades, proposals all mutable until committed. |

### H. Astronomical Alignment and Parameter Governance

| Threat | Status | Contract(s) | Notes |
|--------|--------|-------------|-------|
| Sleep cycle ignores latitude/season (unfair regen) | **PASS** | #101, #103, §14.4 | Solar-position-based timing. Equator stable. High-lat shifts with season. Polar fallback to UTC. |
| Hardcoded parameters resist community will | **PASS** | #102, §11.6 | Global Parameter Registry. Every operational value votable. Founder sets initial; community governs from day 1. |
| Periodic events misaligned across regions | **PASS** | #93, #101, §14.4 | All periodic events (digests, epochs, reverification) aligned to UTC. Solar only affects sleep timing. |
| Moon cycles ignored for agricultural/cultural templates | **PASS** | #101, §14.4 | Lunar phase, next new/full moon, lunar day available as template variables. Pre-computed 2026–2126. |
| Parameter drift without community consent | **PASS** | #102 | Only founder levers (module activation keys) are non-votable. All else is transparent weighted-median. |

### I. Compute Scaling and Visibility

| Threat | Status | Contract(s) | Notes |
|--------|--------|-------------|-------|
| Projection graph explosion (50K users, 3 layers each) | **PASS** | #103, #104, §6.4 | No compute without observation. Instance cap per branch. Content memoization. Lazy eval. |
| Render collapse at planetary scale | **PASS** | #106, §33.3 | Sight radius + atmospheric compression. Objects outside bubble cost zero render. Privacy before geometry. |
| Dissent suppressed by visible vote identity | **PASS** | #105, §7.4 | Anonymous voting for social/ideological votes. Non-anonymous for accountability votes. Template-configurable. |

### Summary

**50/50 PASS.** All hardening items have explicit frozen contracts with enforcement mechanisms. The three most critical invariants are: **#54** (attention is a lens, never a lever), **#75** (early adopter power is intentional and self-diluting), and **#86** (Council elected by continuous confidence, not fixed terms). The latest engineering invariants are: **#103** (no compute without observation), **#104** (projection instance cap per branch), **#105** (vote anonymity), and **#106** (sight radius + atmospheric compression).

---

## 50. Camera Controller — Frozen Contract #134

### §50.1 — 6DOF Flight Model (LOCKED)

The camera is a core physics layer. It must behave deterministically with zero auto-corrections. No automatic leveling, no ENU roll-chasing, no hidden Cesium inertia. The user has full manual control over all six degrees of freedom.

**Contract #134 — Camera is sovereign. No auto-correction of orientation. Ever.**

Auto-leveling, auto-pitch, and ENU-frame chasing are permanently prohibited in FPS mode. The only corrections permitted are:
- User-initiated (explicit key press)
- Panel-lock transitions (entering 2D interaction mode)

### §50.2 — Default Keybinds (FPS Mode)

| Key | Action |
|-----|--------|
| W / S | Fly forward / backward |
| A / D | Strafe left / right |
| Q / E | Roll left / right (barrel roll) |
| Space / C | Ascend / descend |
| Shift | Boost (5×) |
| Scroll wheel | Adjust flight speed (0.25× – 20×) |
| Mouse (pointer lock) | Pitch + yaw |
| Right-drag (no lock) | Pitch + yaw fallback |
| Tab | Cycle ORBIT → FPS → RTS |
| Esc | Exit to ORBIT |
| F | Fly to nearest tree |
| H | Toggle geostationary lock |
| Ctrl+0-9 | Save camera favorite |
| Ctrl+Shift+0-9 | Recall camera favorite |
| `` ` `` | Position stack pop (go back) |

### §50.3 — Keybind Rebinding System

All keybinds are stored in a `keyBindings` map. Users may:
- Rebind any key to any action via settings UI
- Disable any individual binding (set to `null`)
- Reset to defaults
- Bindings persist across sessions via `localStorage`

The system must support alternative presets (e.g., left-handed, gamepad-style, accessibility). Presets are named binding maps loaded in full.

### §50.4 — Panel Lock Mode

When the user enters a 2D interaction surface (spreadsheet cell, document editor, code panel, search bar):
- Pointer lock releases
- Mouse returns to normal cursor
- WASD and all flight keys are suppressed (routed to the panel)
- Esc or a dedicated "return to flight" key exits panel mode
- Camera orientation is preserved exactly as left

**Contract #135 — Panel lock is the only context where flight keys are suppressed. No other system may consume flight input.**

### §50.5 — Underground Flight

FPS mode permits unlimited depth underground. The globe surface hides when altitude < 0 to prevent Cesium tile-system crashes. Scene background tints amber→red with depth. A depth label shows geological layer (TOPSOIL → BEDROCK → SHALLOW CRUST → UPPER CRUST → LOWER CRUST → UPPER MANTLE → DEEP MANTLE). NaN camera states trigger automatic restoration from last-known-good snapshot.

### §50.6 — Modes

| Mode | Ownership | Description |
|------|-----------|-------------|
| ORBIT | Cesium SSCC | Default globe interaction. Scroll zoom, drag rotate. |
| FPS | Manual 6DOF | Full flight. All Cesium inputs disabled. Pointer events blocked from SSCC. |
| RTS | Manual planar | Top-down pan. Edge scroll. Middle-click rotate. |
| BRANCH | Stub | Locked orbit around selected branch (future: CROSS-SECTION-1). |
| XSECT | Stub | Cross-section inspection (future: CROSS-SECTION-1). |

### §50.7 — Camera Tick Safety Contract — Contract #292

The camera sovereignty contracts (§50.1, #134, #135) define what the camera must NOT do. This contract defines the exact safe pattern for what the camera tick loop MUST do.

**The problem:** Cesium's internal PVS (Potentially Visible Set) and culling buffers assume cartographic coordinates are always finite and within bounds. A camera state that goes NaN, Infinity, or into an invalid altitude causes culling array-length explosions (`Invalid array length`) and unrecoverable crashes.

**The tick-loop invariant:**

Every frame, before any rendering occurs, the camera controller executes the following validation sequence:

```
CameraTickSafety {
  // 1. VALIDATE — cartographic must be finite
  cartographic = camera.positionCartographic
  if (!Number.isFinite(cartographic.longitude) ||
      !Number.isFinite(cartographic.latitude) ||
      !Number.isFinite(cartographic.height)) {
    restoreLastKnownGood()       // snapshot from previous valid tick
    log: [CAMERA] NaN_RECOVERY snapshot=<timestamp>
    return                        // skip this frame's movement
  }

  // 2. SNAPSHOT — save valid state for future recovery
  lastKnownGood = deepCopy(camera.position, camera.direction, camera.up, camera.right)

  // 3. CLAMP — altitude enforcement via position correction only
  if (mode == FPS || mode == RTS) {
    // Altitude clamping applies position offset, NOT orientation rewriting
    if (cartographic.height > MAX_ALTITUDE) {
      setCameraAltitude(MAX_ALTITUDE)   // adjust position.z only
    }
    // Underground is permitted in FPS (§50.5) — no floor clamp
    // In RTS: minimum altitude is terrain + MIN_RTS_CLEARANCE
    if (mode == RTS && cartographic.height < terrainHeight + MIN_RTS_CLEARANCE) {
      setCameraAltitude(terrainHeight + MIN_RTS_CLEARANCE)
    }
  }
}
```

**Hard rules:**

1. **No `setView()` in FPS/RTS tick loop.** The `setView()` API rewrites position + orientation atomically, which can trigger Cesium's SSCC (ScreenSpaceCameraController) to recalculate culling geometry mid-frame. The only permitted calls to `setView()` in FPS/RTS are:
   - User-initiated ground-lock (`G` key or equivalent)
   - Panel-lock transition (§50.4)
   - Mode transition (ORBIT → FPS, FPS → RTS, etc.)
   - NaN recovery (via `restoreLastKnownGood()`)
   - Camera favorite recall (Ctrl+Shift+0-9)

2. **Clamping is position-only.** Altitude clamping adjusts `camera.position` along the ellipsoid normal. It never modifies `camera.direction`, `camera.up`, or `camera.right`. Orientation is the user's sovereign property (Contract #134).

3. **Never rewrite orientation on tick.** No system — not clamping, not airspace transitions, not LOD changes, not underground detection — may modify the camera's orientation vectors during a normal tick. If orientation must change (mode transition, NaN recovery), it happens as a discrete event with a log entry, not as a per-frame correction.

4. **SSCC isolation in FPS/RTS.** When the camera is in FPS or RTS mode, Cesium's ScreenSpaceCameraController must be fully disabled (`enableRotate = false`, `enableTranslate = false`, `enableZoom = false`, `enableTilt = false`, `enableLook = false`). No partial enable. Cesium's internal camera adjustments are the source of culling array explosions when they conflict with manual positioning.

5. **Recovery is always to last-known-good, never to a computed state.** The `restoreLastKnownGood()` function copies the exact snapshot from the last valid tick. It does not compute a "safe position" or derive a fallback from terrain data. Computed fallbacks introduce new NaN pathways.

**Contract #292 — Camera Tick Safety. The camera tick loop validates cartographic coordinates every frame; non-finite values trigger restoration from last-known-good snapshot. `setView()` is prohibited in FPS/RTS tick loops except for five enumerated events (ground-lock, panel-lock, mode transition, NaN recovery, favorite recall). Altitude clamping adjusts position only, never orientation. Cesium's SSCC is fully disabled in FPS/RTS. Recovery is snapshot-only, never computed. These rules are frozen.**

---

## 51. Key File References

- `app/renderers/filament-renderer.js` — core geometry + rendering pipeline (to be evolved for bark-cylinder model)
- `relay-cesium-world.html` — entry point, camera, demo tree, controls
- `app/utils/enu-coordinates.js` — ENU frame computation, branch-aligned layout
- `core/models/relay-state.js` — canonical state store
- `app/cesium/restore3-scope-manager.js` — geographic governance boundaries
- `app/cesium/restore4-assignment-manager.js` — branch-to-site assignments
- `app/presence/presence-engine.js` — presence system
- `core/models/crypto/*` — Merkle chain, envelope encryption, disclosure
- `config/p2p-module.json` — P2P template configuration
- `config/mfg-module.json` — manufacturing template configuration
- `scripts/v93-to-relay-state-adapter.mjs` — V93 legacy data bridge

---

## 52. Business Artifact Mapping — Slides Are Dead

> *"Simplicity is the ultimate sophistication."* — Leonardo da Vinci

**Prerequisites:** None for base (template-driven branch geometry + conservation validation). Expands with: cross-section + projection modules → inspection views + dashboards.

Every corporate artifact — org charts, budget graphs, strategic bullet slides, meeting agendas, mass balance dashboards — maps to tree measurements that already exist in the physics engine. This section formalizes those mappings as canonical rules. No new physics. No new data structures. Just the correct interpretation of existing filament fields through domain-specific templates.

### §52.1 — Organizational Hierarchy = Branch Nesting Geometry

An org chart is a tree. Relay IS a tree. The mapping is structural identity:

| Org Chart Element | Tree Element |
|-------------------|--------------|
| Company | Trunk |
| C-suite function (Finance, Procurement, HR, etc.) | Primary branch |
| Regional sub-function (APAC, NAM/LAM, EMEA) | Sub-branch |
| Site-level role (Category Lead, Site Procurement) | Sub-sub-branch (leaf) |
| Person with direct reports | Branch-point |
| Person without reports | Leaf (filament source, not branch) |

**Rules:**

1. Branch **nesting depth** = reporting depth in the hierarchy. A three-level org has three levels of branch nesting.
2. Branch **thickness** reflects activity volume (sum of filament magnitude), NOT headcount. A department of 3 people doing $50M of work is thicker than a department of 200 doing $2M.
3. Branch `layoutAngle` comes from `hash(layoutKey)` per contract #114. It never shifts when people join/leave. Org restructuring is a branch migration event (§4.6) that creates scars.
4. Dotted-line relationships (matrix reporting) are cross-branch filament references — a filament on the Direct Procurement branch may reference a counterparty on the Indirect Procurement branch. The filament's `approachAngle` (θ) encodes that directional relationship.
5. The template's `branches[].sub[]` array (§21.2) defines the hierarchy. Recursive nesting to arbitrary depth is supported.

**What you see instead of an org chart slide:** Fly to the company trunk. Primary branches radiate outward. Thick branches = high activity. Wilting branches = low confidence. Leaning branches = counterparty pressure. The geometry IS the org chart — but it also shows health, workload, and risk simultaneously.

### §52.2 — Budget Allocation = Magnitude Mass per Branch

A budget bar chart shows: category × site × dollar amount. In Relay:

| Budget Slide Element | Tree Measurement |
|---------------------|------------------|
| Category (Packaging, Logistics, Energy, MRO, CAPEX) | Branch under the relevant parent |
| Site (Dimona, US, China, Russia, India) | Sub-branch per site |
| Dollar amount per category | `sum(magnitude)` of ACTIVE + CLOSED filaments on that branch |
| Bar length | Branch thickness (proportional to magnitude sum) |
| Year-over-year change | Ring thickness comparison in cross-section |

**Rules:**

1. Branch thickness = `Σ magnitude` across all filaments on the branch (including sub-branches via aggregation).
2. Ring thickness per timebox = spend during that specific period (monthly/quarterly slab). A busy Q4 produces a thick ring. A quiet Q1 produces a thin ring.
3. Lean = supplier concentration direction. If 80% of spend goes to one counterparty quadrant, the branch leans that way.
4. Heat = rate of spend change vs. prior period. Accelerating spend = hot. Stable = cool.
5. Fog = documentation completeness (average `evidenceRatio` across contributing filaments). Poor documentation = foggy branch.
6. Cross-section at year-end timebox shows all categories as concentric ring sectors — the budget pie rendered as tree rings.

**What you see instead of a budget slide:** Zoom out to the Procurement branch. US sub-branch is visibly thicker than India. CAPEX ring is thin this quarter but was thick last quarter (cross-section shows it). No narrative needed.

### §52.3 — Tactical/Strategic Items = Filament Lifecycle States

Bullet-point slides listing "tactical" and "strategic" initiatives map to filament states:

| Slide Element | Tree Measurement |
|--------------|------------------|
| Tactical item (near-term action) | OPEN or ACTIVE filament on bark surface |
| Strategic item (long-term initiative) | SCHEDULED filament at future l position (contract #124) OR projection branch (§6) |
| Bold/priority item | High-magnitude filament (thicker ribbon on bark, warmer color) |
| Strikethrough/deprioritized item | HOLD state filament (wilting visible) |
| Completed item | CLOSED filament (sunk inward from bark surface) |
| Item with risk | Low-confidence filament (transparent opacity) |

**Rules:**

1. Active work lives on the bark surface. You see it when you zoom to BARK LOD.
2. Strategic initiatives glow faintly ahead at the branch tip (SCHEDULED filaments are translucent, zero-weight per contract #124).
3. Projection branches (light blue, §6) hold "what-if" analyses — e.g., "What if we switch to in-house processing?"
4. Completed initiatives have sunk inward. Their impact is visible in ring thickness and magnitude.
5. No bullet slide is needed. The bark surface IS the tactical list. The branch tip IS the strategic roadmap.

### §52.4 — Meeting Cadence = Timebox Review Ritual

Meetings map to timebox inspection:

| Meeting Type | Tree Operation |
|-------------|----------------|
| Monthly (Regional) | Cross-section of regional branches at current-month timebox ring |
| Quarterly (Global) | Cross-section of all primary branches at quarterly timebox |
| Ad-hoc | SCHEDULED filament of type `event.meeting` at specific future l position |
| Agenda items | Twig list (stalled items) + heat map (acceleration) of the current ring |
| Progress review | Ring thickness + color comparison across last N timeboxes |
| Risk discussion | Wilt zones + fog overlay on the current slab |

**Rules:**

1. The meeting IS the cross-section inspection. You enter cross-section mode (XSECT camera mode), select the relevant timebox, and the ring tells you everything.
2. Monthly: inspect one month's ring on regional sub-branches. Thick + green = healthy. Thin + red = problem. Twigs protruding = overdue items to discuss.
3. Quarterly: inspect the quarter ring on all primary branches simultaneously. Compare ring thickness across branches to see resource distribution.
4. The agenda is NOT a separate document. The agenda is: (a) twigs on the current ring (items requiring attention), (b) scars since last meeting (reversals/corrections), (c) heat anomalies (accelerating/decelerating branches), (d) wilt zones (confidence deficits).
5. Ad-hoc meetings are SCHEDULED filaments (§5b) — they appear at the branch tip as future events and fire when their time arrives.

### §52.5 — Mass Balance = Conservation Law on Branch

Mass balance is the most physics-aligned business calculation. It is literally conservation of matter applied to a production branch.

**The formula:**

For each timebox slab on a plant/production-line branch:

```
inputSum    = Σ(magnitude) where magnitudeType == "input"
outputSum   = Σ(magnitude) where magnitudeType == "output"
wasteSum    = Σ(magnitude) where magnitudeType == "waste"
recycledSum = Σ(magnitude) where magnitudeType == "recycled"

balance     = inputSum - (outputSum + wasteSum - recycledSum)
balancePct  = outputSum / inputSum
```

This is frozen contract #16 (conservation: material state transfers must net to zero per unit type) applied to the manufacturing domain.

**Visual encoding:**

| Measurement | Tree Visual |
|-------------|-------------|
| Balance deviation (balance ≈ 0) | Ring color: green (98-102%) → amber (95-98%) → red (<95% or >105%) |
| Total throughput (inputSum) | Ring thickness |
| Evidence completeness | Ring opacity (confidence) |
| Cumulative imbalance (running total across all rings) | Branch lean — a branch that consistently loses material leans in the waste direction |
| Per-line breakdown | Sub-branch per production line, each with own rings |
| PPU (per production unit) metrics | Derived filament magnitude normalized by output count |

**Cross-section reveals the entire history at a glance:**

- 2021 ring: thin, green = low volume, good balance (97.73%)
- 2022 ring: medium, green = growing, still balanced (97.65%)
- 2023 ring: medium, green-amber = balance drifting (97.05%)
- 2024 ring: thick, amber = high volume, slight concern (96.64%)
- 2025 ring: partial, current state visible

**The heat-mapped cumulative balance table** (red-to-green gradient) maps directly to ring color intensity across the cross-section. Persistent red = chronic lean. The tree literally tilts toward the problem.

**Required filament fields for mass balance:**

Filaments on manufacturing branches carry an additional schema field beyond the six universal domains:

```
magnitudeType: "input" | "output" | "waste" | "recycled" | "byproduct"
```

This field determines which side of the conservation equation the filament's magnitude contributes to. The consolidation gate (§21.2) validates that `balance ≈ 0` within configured tolerance at timebox close.

**Contract #136 — Mass balance is conservation law, not dashboard logic.** Per-timebox material balance is computed from typed-magnitude filament sums. Deviation from zero balance is rendered as slab color shift. Cumulative imbalance is structural lean. The computation is deterministic, replayable, and identical at every LOD.

### §52.6 — Dashboard = Projection Branch View

Power BI dashboards, Excel pivot tables, and reporting views are projection branches:

| Dashboard Element | Tree Equivalent |
|-------------------|-----------------|
| Dashboard | Projection branch (light blue, §6) reading from truth filaments |
| Table/chart inside dashboard | CELL LOD renderer for that projection |
| Filters (Plant, Month, Year, Fabric Group) | Client-side view masks (contract #26, never mutate truth) |
| "Current Period" tab | Timebox scrubbing (TIME-SCRUB-1) |
| Calculated column (Mass Balance %) | Projection formula node (§6.1 decision node) |
| Export to PDF/Excel | Projection branch exportable in flat format |

**Rules:**

1. Dashboards do not replace truth. They are projections OF truth. Always light blue. Always terminal (contract #11).
2. The underlying data lives on truth branches (natural colors). The dashboard projection reads it, computes derived values, and presents them.
3. Filters are view-state only. Two users looking at the same projection with different filters see different slices but neither has altered the underlying filaments.
4. Any value shown in a dashboard can be traced to its source filament in one click (drill-down through projection → truth filament → commit history).

---

## 53. Compartmentalized Accounting & Atomic Traceability — Frozen Contracts #138-139

> *"You can't manage what you can't measure."* — Peter Drucker
>
> *"The most dangerous architecture is the one that works perfectly and hides the cost."* — Claude Opus 4.6

**Prerequisites:** None for base (composition evidence type, conservation gates, lot-to-FG traceability chains). Expands with: AR interaction modules → product passport projections, grocery-store camera overlay, ESG three-branch reconciliation.

Pick up any product off a store shelf. That plastic bottle came from a factory. The factory bought resin pellets from a supplier. The supplier made those pellets from crude oil extracted from a specific well. Every step — extraction, refining, pelletizing, molding, filling, shipping — consumed inputs and produced outputs. If you add up all the inputs and subtract all the outputs at every step, the numbers should balance. If they don't, something leaked, was wasted, or was lied about.

Today, companies track this loosely. They estimate emissions, guess at waste, and report totals that nobody can verify. Relay changes that by requiring the same conservation math at every step — and making the uncertainty visible. If a factory can't prove where 3% of its raw material went, that 3% shows up as fog on the branch. If a company buys carbon credits but its factory emissions didn't actually change, storm clouds appear over the "green" claims. You don't need to read a sustainability report. You look at the tree and see whether it's clear or foggy.

"A place for everything, and everything in its place." Every physical flow — material, energy, waste, emission — has a deterministic location in the tree. Nothing is estimated without marking the estimate as uncertain. Nothing is hidden without the hiding being visible as fog. See §77 for how this extends to full mineral-to-shelf product traceability with version control, BOM branch physics, and recall cascading.

### §53.1 — Structural Isomorphism, Not Botanical Simulation

Relay mimics **wood formation**, not tree biology — for the truth layer. The mapping is:

| Tree Physics | Relay Equivalent | What It Is NOT |
|---|---|---|
| Growth fiber laid down during cambium cycle | Filament (discrete commit) | Not sap (fluid flow) |
| Cambium layer (living growth boundary) | `r = 1.0` zone | Not a continuous membrane |
| Bark (outer surface) | OPEN/ACTIVE filaments | Not detachable |
| Wood rings (inner structure) | CLOSED/ABSORBED slabs | Not editable |
| Heartwood (dense core) | Terminal stillness (§1.3) | Not deletable |
| Grain direction | Commit causality chain | Not aesthetic |
| Seasonal leaves | LeafPackets (§82) — ephemeral engagement | Not structural, not load-bearing |
| Xylem/phloem sap flow | SapPackets (§82) — live state propagation | Not persisted, not replayable as truth |
| Leaf fall and composting | Leaf lifecycle BUD→FALLING→COMPOSTED (§82.2) | Not deletion — hash-stubs may remain |
| Canopy density | Aggregate leaf count per branch | Not trunk mass — leaves don't add weight |

**Contract #138 — Filaments are discrete growth fibers, not fluid flows. All state changes are commit-driven events. No continuous simulation, no streaming state, no fluid dynamics. Every filament transition is an atomic append-only commit that can be replayed deterministically.**

This prevents future proposals for "real-time streaming filaments" or "sap-flow animations" that would break determinism and replayability. Note: §82 introduces SapPackets and LeafPackets as separate layers outside the filament system — they do not violate Contract #138 because they are not filaments. Sap flows and leaf cycles operate in their own layer with their own rules. The truth layer (wood) remains discrete and deterministic.

### §53.2 — Cambium Layer Formalization

The radial position `r` in cylindrical coordinates defines four structural zones:

| Zone | r range | State | Physics |
|------|---------|-------|---------|
| Bark surface | `r > 1.0` | OPEN, ACTIVE | Visible, mutable via commits, full force participation |
| Cambium | `r = 1.0` | Transition boundary | Where spawning, lifecycle transitions, and schema changes occur |
| Wood | `0 < r < 1.0` | CLOSED, ABSORBED | Compressing inward, immutable, read-only |
| Heartwood | `r → 0` | Terminal stillness | Zero force contribution, pure structural mass (Contract #133) |

The cambium is the only zone where new structure forms. Everything outside it is active work. Everything inside it is history. Schema version changes (new columns, new fields) manifest as bark ridge deformation at the cambium boundary — visible in cross-section as a subtle grain shift.

### §53.3 — Molecular Composition Evidence Model

"Atomic accounting" does not track individual atoms (~10²⁵ per laptop). It tracks **measured composition at the right physical unit** with explicit uncertainty.

Every MaterialLot filament may carry a `composition` evidence attachment:

```json
{
  "compositionEvidence": {
    "version": "1.0",
    "lotId": "LOT-PP-2026-02-ACME-8934",
    "materialClass": "polypropylene",
    "grade": "PP-H350",
    
    "chemicalComposition": {
      "polymerType": "isotactic-polypropylene",
      "polymerPct": 97.8,
      "additives": [
        { "name": "UV-stabilizer", "pct": 0.8, "cas": "52829-07-9" },
        { "name": "antioxidant", "pct": 0.3, "cas": "6683-19-8" },
        { "name": "slip-agent", "pct": 0.15, "cas": "112-84-5" }
      ],
      "impurities": [
        { "element": "Fe", "ppm": 12, "method": "ICP-OES" },
        { "element": "Cl", "ppm": 3, "method": "XRF" }
      ]
    },
    
    "physicalProperties": {
      "meltFlowIndex": { "value": 35, "unit": "g/10min", "method": "ASTM-D1238" },
      "density": { "value": 0.905, "unit": "g/cm3" },
      "molecularWeightAvg": { "value": 180000, "unit": "Da" }
    },
    
    "environmentalProfile": {
      "emissionsIntensity": { "value": 1.3, "unit": "kgCO2e/kg", "scope": "cradle-to-gate" },
      "waterUsage": { "value": 2.1, "unit": "L/kg" },
      "energyInput": { "value": 3.8, "unit": "kWh/kg" }
    },
    
    "evidenceRefs": [
      { "type": "COA", "hash": "sha256:abc...", "issuer": "ACME Lab" },
      { "type": "spectral-fingerprint", "hash": "sha256:def...", "method": "FTIR" },
      { "type": "emissions-declaration", "hash": "sha256:ghi...", "standard": "ISO-14067" }
    ],
    
    "measurementUncertainty": {
      "polymerPct": 0.5,
      "impurityPpm": 2,
      "emissionsIntensity": 0.15
    }
  }
}
```

**Rules:**

1. Composition evidence is optional per template but required for high-confidence manufacturing branches.
2. `measurementUncertainty` is mandatory when composition is provided. Omitting it is not "perfect measurement" — it means `uncertainty = unknown` which applies a confidence penalty.
3. Spectral fingerprint hashes enable batch verification without exposing proprietary formulations.
4. `environmentalProfile` fields are the basis for ESG truth branches (§53.6).

### §53.4 — Composition Inheritance Through Transformation Chains

When a TransformationRun filament consumes input lots and produces outputs, the output inherits a **mass-weighted composition profile**:

```
output.composition[component] = Σ(input[i].composition[component] × input[i].massFraction)
```

**Contract #139 — Composition inheritance through transformation chains is computed as mass-weighted average of input lot compositions. Uncertainty compounds: output uncertainty = √(Σ(input[i].uncertainty² × input[i].massFraction²)). No transformation may reduce uncertainty below the worst input without new measurement evidence.**

The full traceability chain for any finished good:

```
Vendor Lot (with composition evidence)
  → TransformationRun (mass balance enforced)
    → WIP (inherits weighted composition)
      → Slitting/Cutting Run
        → Finished Good (inherits composition + dimensional specs)
          → QC Test (validates properties against spec)
            → Shipment → Retail Location → Consumer scan
```

At any point in this chain, clicking a filament shows:
- Its inherited composition profile
- The specific vendor lots that contributed
- The confidence level (based on measurement evidence quality)
- The emissions footprint (accumulated through the chain)

### §53.5 — Multi-Vendor Lot Consolidation

Multiple vendors may supply the same material grade. Relay does **not merge lots**. It links them via a composed projection:

| Concept | Relay Mechanism |
|---------|----------------|
| Vendor lot A (5000 kg PP from ACME) | Truth filament on `procurement.raw` branch |
| Vendor lot B (3000 kg PP from BASF) | Truth filament on `procurement.raw` branch |
| Internal component "PP Grade X" | Projection filament (light blue) reading both lots |
| Weighted cost | Projection formula: `Σ(lot.cost × lot.mass) / Σ(lot.mass)` |
| Weighted emissions | Projection formula: `Σ(lot.emissionsIntensity × lot.mass) / Σ(lot.mass)` |
| QC compatibility check | Gate: all lots must pass spec range for grade X |

The projection is always read-only, always traceable to source lots, and always light blue. If one vendor lot has quality issues, the projection updates automatically and the internal component shows reduced confidence.

### §53.6 — ESG Three-Branch Model (Greenwashing Detection)

Environmental claims are structurally separated into three branches that must reconcile:

**Branch A — Physical Emissions Truth** (`environment.emissions.truth`)

| Filament Type | Evidence Required | Unit |
|---|---|---|
| Stack emission event | Sensor hash, meter reading | kg CO₂e, NOx, SOx, VOC |
| Electricity consumption | Utility invoice, smart meter | kWh → kg CO₂e via grid factor |
| Fuel combustion | Purchase record, flow meter | kg CO₂e |
| Water discharge | Effluent sensor, lab cert | m³, BOD/COD ppm |
| Waste generation | Weighbridge ticket, manifest | kg by waste class |

This branch is **ground truth**. It measures what actually happened.

**Branch B — Policy & Credit Claims** (`environment.policy.credits`)

| Filament Type | Evidence Required | Unit |
|---|---|---|
| Carbon credit purchase | Registry receipt, serial number | tCO₂e credit |
| Carbon tax payment | Tax filing, payment confirmation | $ |
| Certification achieved | Auditor report, certificate | Status (valid/expired) |
| Offset claim | Offset project documentation | tCO₂e claimed |
| Regulatory submission | Filing receipt, data snapshot | Compliance status |

This branch is the **paper layer**. It records what was claimed or purchased.

**Branch C — Physical Interventions** (`environment.interventions`)

| Filament Type | Evidence Required | Unit |
|---|---|---|
| Equipment installed | PO, installation docs, commissioning test | Description + cost |
| Process change | Engineering change order, before/after measurement | ΔEmissionsIntensity |
| Fuel/energy source switch | Contract change, meter switch | New source + grid factor |
| Supplier material change | New COA, spec comparison | Composition delta |
| Recycling loop enabled | Process flow change, mass balance proof | kg recycled/period |

This branch records **what was actually done** to change physical reality.

**Reconciliation Rule:**

At timebox close, the system checks:

1. If Branch B (credits) has activity but Branch A (truth) shows no measurable `ΔEmissionsIntensity` in the corresponding timeboxes → **reconciliation warning** fires.
2. Warning renders as: storm risk on the ESG sub-tree, fog on the credits branch.
3. This is advisory, not a hard refusal — credits may legitimately offset emissions elsewhere. But the visual signal makes "buying green without being green" geometrically obvious.

**Impact detection formula** (deterministic, per intervention):

```
For intervention I with baseline window T(-N) and post window T(+N):
  ΔIntensity = avg(emissionsPerTonOutput in T(+N)) - avg(emissionsPerTonOutput in T(-N))
  impact = ΔIntensity × confidence(measurementEvidence)
  
  If confidence < 0.5: impact is foggy (uncertain)
  If ΔIntensity ≈ 0 but credits purchased: storm risk
  If ΔIntensity < 0 and confidence > 0.7: verified improvement (branch firms up)
```

**Weather encoding for ESG:**

| Weather | ESG Meaning |
|---------|-------------|
| Heat | Emissions intensity changing rapidly (something happened) |
| Cold | Nothing changed (claims without physical impact) |
| Fog | Weak measurement evidence, too many estimates |
| Storm | High heat + high fog, OR large credit activity with no measurable improvement |
| Scar | Corrected regulatory filings, restated emissions data |
| Lightning | Active recall cascade or cross-site contamination event |

### §53.7 — Recall Cascade Mechanism

When a defect is discovered in any input (additive lot, machine part, raw material), Relay computes the full impact chain using the lightning equation (§3.16):

```
Defective Lot identified
  → All TransformationRuns that consumed it (backing refs)
    → All WIP produced by those runs
      → All FG cut from that WIP
        → All shipments containing that FG
          → All retail locations holding that FG
            → Consumer product passport updates
```

The cascade magnitude determines lightning intensity. If `cascadeMagnitude > stormThreshold`:
- All affected branches flash (lightning)
- Product passport projections update with recall status
- Affected FG filaments gain a scar with the defect reference

**Consumer-facing overlay** (grocery store camera scenario):
User scans product barcode → Relay resolves FG filament → projection branch loads:
- Composition breakdown (inherited from lot chain)
- Emissions footprint (accumulated)
- Quality confidence score
- Active recall status (if any)
- Scar history
- Maintenance events on production line during that run

If recall is active: red warning ring. If emissions are high relative to category average: amber heat glow. If measurement evidence is sparse: fog overlay. No marketing PDF — just geometry.

### §53.8 — True Mass Balance at Scientific Scale

Mass balance in §52.5 is the business-level conservation law. At scientific scale, it becomes:

**Per transformation step, per timebox:**

```
Σ(input.mass × input.composition[c]) = Σ(output.mass × output.composition[c])
                                       + Σ(waste.mass × waste.composition[c])
                                       + Σ(emission.mass × emission.composition[c])
                                       + Δinventory[c]
                                       ± measurement_uncertainty
```

This is enforced **per chemical component `c`**, not just total mass. If PP input is 97.8% polymer but FG output claims 99% polymer with no additive separation step, the conservation check fails.

**Visual encoding:**
- Ring color intensity = mass balance deviation (same as §52.5)
- Ring opacity = measurement confidence (weighted by composition evidence completeness)
- Fog = components with missing or estimated composition
- Thick rings = high throughput periods
- Thin rings = low activity or regulatory freeze (seasonal dormancy equivalent)

**Scaling rule** (same equations at every level):

| Scale | Input | Output | Conservation Check |
|-------|-------|--------|-------------------|
| Single machine | Raw material lots | WIP + scrap + emissions | Per-run mass balance |
| Factory | All machine inputs | All products + waste + emissions | Per-timebox site balance |
| Company | All factory inputs | All shipped products + total waste + total emissions | Per-quarter corporate balance |
| Region | All company inputs | Regional product output + regional emissions | Per-year regional balance |
| Planet | All extracted resources | All products + all emissions + all waste | Planetary mass balance |

`W_parent = Σ W_child` at every level. No new physics.

---

## 54. Business Process Catalog — How Standard Frameworks Map to the Tree

Every industry has standard processes — sales pipelines, project lifecycles, risk registers, maintenance schedules, HR onboarding, IT ticketing. In traditional software, each one gets its own dedicated application with its own database, its own reporting, and its own version of the truth.

In Relay, all of them use the same physics. A sales opportunity closing is the same event as an invoice being paid or a maintenance ticket being resolved: a filament migrating inward. A stalled project is the same as a stalled shipment: a twig protruding from the bark. A recalled product and a reverted financial entry both leave the same kind of mark: a scar.

This section maps common business processes to Relay's existing mechanics. No new physics is introduced. Every entry below uses the filament lifecycle (`OPEN → ACTIVE → HOLD → CLOSED → ABSORBED`), the six universal domains (identity, counterparty, time, magnitude, evidence, lifecycle), and the rendering physics (heat, fog, storm, lean, wilt, scars, twigs) that already exist.

### §54.1 — Opportunity Pipeline / Sales Funnel

The sales pipeline is a branch where each deal is a filament. Stage progression is lifecycle state.

| Sales Stage | Relay Lifecycle | What You See |
|-------------|----------------|-------------|
| Lead identified | `SCHEDULED` | Translucent filament at future time slot, zero physics weight |
| Qualified | `OPEN` | Filament spawns on bark surface, visible, begins accumulating commits |
| Proposal sent | `ACTIVE` | Commits attach (proposal document, pricing, evidence of engagement) |
| Negotiation | `ACTIVE` + high commit rate | Branch heats up (high activity rate), counterparty θ shows vendor direction |
| Won | `CLOSED` → migrates inward | Filament firms up, sinks into ring. Branch thickens. |
| Lost | `CLOSED` with loss marker | Filament still sinks (truth preserved) but magnitude marked as zero-revenue. Scar if terms were reverted. |
| Stalled | `HOLD` | Twig protrudes — visible overdue signal. Wilt if confidence drops. |

**What a sales manager sees**: A thick, warm branch means active pipeline. Lots of twigs means lots of stalled deals. A branch leaning heavily toward one counterparty means revenue concentration risk. Thin rings in a quarter mean low close rate. No slides needed.

**Template fields**: `dealValue` (magnitude), `customer` (counterparty), `probability` (confidence), `expectedCloseDate` (scheduled time slot), `lossReason` (scar annotation).

### §54.2 — Project Management Lifecycle

A project is a branch. Milestones are timeboxes. Tasks are filaments.

| PM Phase | Relay Mechanism | What You See |
|----------|----------------|-------------|
| Initiation | Branch created with template binding | New branch appears on trunk |
| Planning | `SCHEDULED` filaments placed at future time slots | Translucent filaments along the branch tip, showing planned scope |
| Execution | `SCHEDULED → OPEN → ACTIVE` as work begins | Filaments solidify, commits attach, branch thickens |
| Monitoring | Cross-section inspection at current timebox | Ring shows: thick = on track, thin = under-delivering, foggy = missing evidence |
| Change request | Schema version bump + scar | Bark ridge appears where scope changed. Scar if budget/timeline reverted. |
| Closure | All filaments `CLOSED` or `ABSORBED` | Branch stops growing. Clean rings = healthy project. Twigs = unresolved items. |
| Post-mortem | Cross-section of full branch | Every ring visible. Where were the scars? Where did it wilt? Where was it hot? |

**What a project manager sees**: Branch health is project health. Twigs are overdue tasks. Fog is missing status updates. Heat is rapid change (good or bad). The cross-section at any milestone shows whether the team delivered.

### §54.3 — Risk Register

Risk is not a separate system. Risk is what the tree already shows you — you just need to name it.

| Risk Concept | Relay Physics | What You See |
|---|---|---|
| Risk identified | Filament on a "risk" sub-branch with probability + impact as magnitude fields | Visible on bark |
| Probability | `confidence` field (inverted: high probability = high confidence the risk is real) | Opacity of the filament |
| Impact | `magnitude` field | Thickness / heat of the filament |
| Mitigation in progress | `ACTIVE` with commits showing mitigation actions | Evidence accumulating |
| Risk realized | Filament transitions to incident, scar if damage occurred | Scar on the ring, possible storm |
| Risk expired | `CLOSED` without realization | Sinks normally, thin ring |
| Concentration risk | Multiple risk filaments from same counterparty direction | Branch lean toward that θ angle |

**Risk matrix** becomes visual: high-probability, high-impact risks are hot, bright, thick filaments near the bark. Low risks are thin, cool, fading inward. You don't read a spreadsheet — you see which branches are under pressure.

### §54.4 — Supplier Scorecard / Vendor Rating

Vendor quality is not a separate KPI dashboard. It emerges from the tree.

| Vendor Metric | Relay Source | How It Shows |
|---|---|---|
| On-time delivery % | Ratio of vendor filaments closing before `expectedResolutionDays` | Branch firmness (on-time = firm, late = wilting) |
| Quality defect rate | QC `FAILED` filaments linked to vendor lots | Twigs + scars on vendor-linked sub-branch |
| Price competitiveness | Magnitude (cost) relative to other vendors for same material grade | Ring thickness comparison across vendor sub-branches |
| Documentation completeness | Evidence attachment count vs template requirements | Fog (missing evidence = foggy vendor branch) |
| Responsiveness | Time between `OPEN` and first commit | Heat (fast = hot, slow = cold) |
| Overall score | Composite: firmness × (1 - twig rate) × (1 - fog) × heat | Derived projection — not a magic number, fully traceable |

**What a procurement manager sees**: Good vendors have firm, clear, warm branches. Bad vendors have foggy, twig-covered, wilting branches. You don't need a scorecard — the shape tells you.

### §54.5 — Engineering Change Orders (ECO)

A design change is a schema version bump on a branch. It is treated the same way a constitutional amendment is treated in governance (§19): it is append-only, evidence-required, and permanently visible.

| ECO Stage | Relay Mechanism |
|-----------|----------------|
| Change requested | `DRAFT` filament on R&D or engineering branch with proposed spec delta |
| Impact assessment | Commits attach: affected BOMs, affected FG, cost estimate, timeline |
| Approval | `DRAFT → PROPOSED → COMMITTED` via governance gate (§19.1) |
| Implementation | Schema version bump on affected branches. Bark ridge forms at the transition point. |
| Verification | QC filaments on new-spec production runs must pass before old-spec sunset |
| Audit trail | The schema change, the approval chain, and the before/after specs are all permanent filaments |

Schema changes never overwrite history. Old-spec filaments remain in their rings. New-spec filaments form on the new bark surface. The transition is visible in cross-section as a grain shift — the same way a real tree shows where growth conditions changed.

### §54.6 — Incident / Ticket Management

Every ticket is a filament. Every ticket system is a branch.

| Ticket Stage | Relay Lifecycle | Visual Signal |
|---|---|---|
| Created | `OPEN` | New filament on bark |
| Assigned | First commit (assignee attached) | Evidence begins accumulating |
| In progress | `ACTIVE` | Commits flowing |
| Escalated | Priority magnitude increased | Filament gets hotter, branch heats up |
| Resolved | `CLOSED` | Migrates inward |
| Reopened | New commit on closed filament (creates scar) | Scar visible — reopening is a correction event |
| SLA breach | `HOLD` past expected resolution | Twig protrudes. Wilt increases. |

**What an operations manager sees**: A branch covered in twigs means too many open tickets. A branch with lots of scars means tickets keep getting reopened (quality issue). A hot branch means high activity. A foggy branch means tickets are being closed without evidence (rubber-stamping).

### §54.7 — Contract Lifecycle Management

A contract is a filament. Its lifecycle maps directly.

| Contract Stage | Relay State | Notes |
|---|---|---|
| Draft | `DRAFT` | Not yet proposed, internal only |
| Negotiation | `OPEN` with commits (redlines, counter-offers, legal review) | Each version is a commit |
| Execution / Active | `ACTIVE` | Signed. Obligations are linked filaments (deliverables, payments, milestones) |
| Amendment | New commit on active filament + scar if terms changed materially | Scar = visible contract modification |
| Renewal | `SCHEDULED` filament at renewal date linked to current contract | Translucent future filament appears |
| Expiration | `CLOSED` at contract end date | Natural lifecycle completion |
| Termination | `CLOSED` early with termination reason commit | Scar if breach-related |
| Dispute | Sortition trigger (§46) | Jury selected, verdict recorded permanently |

### §54.8 — CAPEX / OPEX Tracking

Capital expenditures and operating expenditures are simply two branch categories under the treasury/finance branch:

| Type | Branch | Sinking Behavior | Ring Meaning |
|---|---|---|---|
| CAPEX | `finance.capex` | Milestone-driven (asset lifecycle) | Each ring = depreciation period. Thick ring = major investment. |
| OPEX | `finance.opex` | Earth-time (calendar) | Each ring = operating period. Thickness = spend volume. |

CAPEX filaments have long lifecycles (asset purchase → installation → commissioning → depreciation → disposal). OPEX filaments have short lifecycles (monthly bills, recurring services). The cross-section shows: thick CAPEX rings in investment years, steady OPEX rings in operating years. Lean shows which vendors dominate spend.

### §54.9 — Inventory Management

Inventory is a branch where filaments represent stock states, not transactions.

| Inventory Concept | Relay Mechanism |
|---|---|
| Current stock level | Latest `InventoryState` filament per SKU (magnitude = quantity) |
| Reorder point | `SCHEDULED` filament at future time slot when stock is projected to hit minimum |
| Safety stock | Template-defined threshold. When latest magnitude < safety stock → twig emerges |
| Min/Max | Template evidence rules. Below min → wilt. Above max → heat (overstocking pressure) |
| Stock-out | Magnitude reaches zero. Branch goes cold. Storm if downstream production affected. |
| Cycle count | QC-type filament comparing physical count to system count. Deviation → scar. |

### §54.10 — KPI Dashboards (OEE, Yield, Throughput, Cycle Time)

Manufacturing KPIs are projection branches that read truth branches:

| KPI | Source Branches | Projection Formula |
|---|---|---|
| **OEE** (Overall Equipment Effectiveness) | `production.runs` + `maintenance` | `availability × performance × quality` where availability = (run time - downtime) / scheduled time |
| **Yield** | `production.runs` + `quality.qc` | `(good output / total output) × 100` |
| **Throughput** | `production.runs` | `total output mass / time period` — directly visible as ring thickness |
| **Cycle time** | `production.runs` | `avg(endTime - startTime)` per filament — visible as filament spacing |
| **Scrap rate** | `waste` + `production.runs` | `waste mass / input mass` — visible as waste branch thickness relative to production |
| **MTBF / MTTR** | `maintenance` | Mean time between failures / mean time to repair — visible as maintenance branch spacing and firmness |

These are never standalone dashboards. They are projection branches (light blue) that compute values from truth branches. Any number shown can be traced to the source filaments in one click.

### §54.11 — HR / Talent Pipeline

People processes are branches. Each employee, candidate, or position is a filament.

| HR Process | Relay Mapping |
|---|---|
| Open position | `SCHEDULED` filament on recruiting branch |
| Candidate sourced | `OPEN` filament with candidate identity |
| Interview stages | Commits on the filament (screening, technical, cultural, offer) |
| Hired | `CLOSED` → new employee filament created on org branch |
| Rejected | `CLOSED` with rejection reason (truth preserved, not deleted) |
| Onboarding | Filament on onboarding branch with milestone commits |
| Performance review | Timebox cross-section on employee's activity branch — same as any other inspection |
| Offboarding | Employee filament `CLOSED` with exit documentation |

### §54.12 — IT Asset Management

Every device, license, and service is a filament on the IT branch.

| Asset Lifecycle | Relay State |
|---|---|
| Procurement | `OPEN` (PO created) |
| Deployment | `ACTIVE` (assigned to user/location, commits: config, network enrollment) |
| Maintenance | Linked maintenance filaments (patches, repairs, upgrades) |
| Refresh/Replacement | `SCHEDULED` filament at refresh date; old asset → `CLOSED` |
| Decommission | `CLOSED` → evidence of data wipe, disposal certification |
| License expiry | `SCHEDULED` filament at expiry date. Twig if no renewal action before expiry. |

---

## 55. Live Confidence Overlay & Public Proceedings

> *"Sunlight is said to be the best of disinfectants."* — Louis Brandeis

**Prerequisites:** Confidence, presence, and AR interaction modules for base (live confidence aggregation, journalism accountability, educational grading panels, broadcast overlays). Expands with: duel modules → threshold duels with resource transfer.

Imagine watching a court trial, a news broadcast, or a company presentation — and instead of just listening, you can see whether the audience believes what's being said. Not as a poll after the fact, but as a live ring of light around the speaker that firms up when they cite real evidence and goes foggy when they make unsupported claims. That ring is not opinion. It is the same confidence physics that govern every filament in Relay — just computed in real time from audience input instead of from documents.

Every module below — courts, journalism, Shark Tank, public speaking, duels — uses the same core mechanic: a person speaks, their claims become filaments, and an audience votes confidence on those filaments live.

### §55.1 — Core Mechanic: Live Confidence Aggregation

The live confidence overlay combines two existing systems:

1. **Filament confidence** (§9, CONFIDENCE-1) — dual model: `orgConfidence` (institutional judges) + `globalConfidence` (public audience)
2. **Presence system** (§17) — attention markers showing who is watching

When a speaker is live:

| Step | What Happens |
|------|-------------|
| Speaker makes a claim | SCV segments the speech into a timestamped claim-filament in real time |
| Claim references evidence | If the referenced filament exists in Relay, the claim auto-starts at higher confidence (green glow). If not, it starts neutral (fog). |
| Audience votes | Each watcher slides confidence 0–100% on the current claim. Weighted by viewer's own reputation (branch firmness). |
| Aggregation renders | The speaker sees a live ring: warm + clear = audience believes. Cold + foggy = audience doubts. |
| Contradiction detected | If the current claim contradicts a previous filament by the same speaker → lightning flash + scar on their branch |
| Permanent record | When the event ends, the timebox closes. Every claim, every vote, every evidence link becomes a permanent ring. |

**What the speaker sees in real time**: A confidence ring around their avatar. It shifts as they talk. When they show evidence and it checks out, the ring firms up. When they make unsupported claims, fog rolls in. They can adjust their delivery based on what the tree tells them.

**Anti-manipulation rules**:
- Confidence votes are weighted by voter reputation (branch firmness), not one-person-one-vote. A well-established expert's confidence vote weighs more than a new anonymous account's.
- Sybil protection (§46) prevents vote flooding.
- The speaker cannot see individual voter identities — only the aggregate.
- Historical accuracy updates: claims start neutral. As evidence is found or linked over hours/days after the event, confidence updates retroactively on the recording.

### §55.2 — Public Proceedings (Courts, Government, Town Halls)

A court case is a branch. Each hearing is a timebox. Each claim by each side is a filament.

| Element | Relay Mapping |
|---------|--------------|
| Courthouse / government address | Location-anchored tree on the globe |
| Case / hearing | Branch on that tree |
| Prosecution claim | Filament on prosecution sub-branch with evidence refs linking to supporting filaments |
| Defense claim | Filament on defense sub-branch with counter-evidence |
| Witness testimony | Filament with video evidence attachment, timestamped to claims |
| Judge's ruling | Governance commit — binding authority filament |
| Jury deliberation | Sortition committee (§46) confidence votes, sealed until verdict |
| Appeal | New branch spawned from ruling filament. Appellate court = higher-authority tree. |
| Supreme/Constitutional review | Escalation to council tier (§46.2). Verdict is final governance commit. |
| Public record | Everything filmed = video evidence attachment. Append-only. Permanent. Replayable. |

All proceedings are filmed and segmented into claim-filaments. The public can watch the replay and see the confidence overlay — which claims were well-evidenced, which were disputed, where the scars are.

### §55.3 — Journalism Accountability

A journalist is a counterparty. Every published claim is a filament on their professional branch.

| Journalism Concept | Relay Mapping |
|---|---|
| Published article / segment | Filament with content hash, source refs, publication timestamp |
| Cited sources | Evidence links to source filaments. Relay-native sources = high base confidence. External-only = lower. |
| Unverified claim | No evidence links → fog by default. Audience sees "unsupported" visually. |
| Retraction / correction | Scar on the original filament. Permanent. Visible in cross-section forever. |
| Pattern of false claims | Branch wilts (cumulative low confidence). Fog builds. Twigs accumulate. |
| Journalist reputation | Not a score — the shape of their branch. Firm, clear, warm = trustworthy. Foggy, scarred, twig-covered = unreliable. |

The community doesn't need to "fact-check." The tree does it. If the backing filament exists, the claim is backed. If it doesn't, the claim is foggy. Live confidence votes add human judgment on top.

### §55.4 — Educational Speaking & Performance Grading

A speaking event is a branch. The speaker creates claim-filaments in real time. A grading panel — sortition-selected (random, fair) or hired (judges, mentors) — watches and scores.

**Live variable sliders**: Each judge has N configurable axes they adjust in real time. The event template pre-defines the axes or judges define their own.

| Example Axis | Range | What It Measures |
|---|---|---|
| Content depth | 0–100% | Substantive vs superficial |
| Evidence quality | 0–100% | Claims backed by filaments? |
| Delivery / clarity | 0–100% | Can the audience follow? |
| Novelty | 0–100% | New information or repetition? |
| Relevance | 0–100% | Addresses the stated topic? |
| Financial clarity | 0–100% | (Shark Tank) Numbers make sense? |
| Market viability | 0–100% | (Shark Tank) Is there a real market? |
| Artistic merit | 0–100% | (Performance) Creative quality? |

Each judge produces time-stamped confidence commits on each axis. The speaker sees aggregated rings — one color per judge — shifting in real time. The audience also has aggregate sliders, weighted lower than judges but visible.

The ring that forms when the presentation ends IS the permanent record. In cross-section you can see: where the speaker was strong (thick, warm segments), where they lost the room (thin, cool), and where a judge spiked a specific axis.

**Shark Tank scenario**: Five judges. Presenter pitches. When they show weak financials, the "financial clarity" rings collapse. When they demo a working prototype, "market viability" firms up. The aggregated shape at timebox close determines the outcome.

### §55.5 — Threshold Duels and Formal Debates

A duel (§40.6) or formal court case becomes a structured sortition where two parties present evidence and confidence thresholds determine the outcome.

**Structure:**

```
DUEL / FORMAL DEBATE
├── Party A branch (challenger / prosecution)
│   ├── Claim filaments (with evidence refs)
│   └── Rebuttal filaments
├── Party B branch (respondent / defense)
│   ├── Claim filaments (with evidence refs)
│   └── Rebuttal filaments
├── Jury branch (sortition-selected)
│   ├── Per-juror confidence votes per claim
│   └── Per-juror overall verdict
└── Verdict filament (governance commit)
```

**Rules (set before the duel begins):**

| Rule | Definition |
|------|-----------|
| Win condition | One party's aggregate confidence drops below threshold (e.g., 30%) |
| Duration | Fixed timeboxes (rounds, sessions, or calendar duration) |
| Jury size | Sortition pool (7 for minor disputes, 21 for major, 101 for landmark) |
| Evidence rules | What filament types are admissible. Template-defined. |
| Appeal threshold | If verdict margin < X%, automatic escalation to larger jury |
| Resource stakes | What transfers on loss (engagement credits, vote power, commit rights) |

**What happens live:**

1. Party A presents claim C1 with evidence
2. Jury votes confidence on C1
3. Party B rebuts with counter-evidence
4. Jury updates confidence (may rise or fall)
5. Alternating rounds continue until duration expires or threshold crossed

**What everyone sees**: Two branches growing in real time. One firms up (clear, warm, thick). The other wilts (foggy, thin, twig-covered). When one branch crosses the loss threshold — the verdict commits automatically.

The entire proceeding is permanent and replayable. Every claim, every evidence ref, every confidence vote preserved in the rings.

### §55.6 — News & Live Broadcast Overlays

Any live broadcast (news, press conference, debate, State of the Union) can be a Relay event:

| Broadcast Element | Relay Overlay |
|---|---|
| Speaker's statement | SCV segments into claim-filaments in real time |
| Evidence cited | Auto-linked if filaments exist in Relay. Green glow = verified. Fog = unverifiable. |
| Audience confidence | Aggregated from all watchers. Ring around speaker's avatar. |
| Historical accuracy | Speaker's past claims branch shown as an inset — firm or foggy? |
| Contradiction | Current claim vs previous filament by same speaker → lightning flash |
| Fact-check lag | Claims start neutral. Confidence updates retroactively as evidence surfaces. |

The broadcast becomes a permanent, inspectable branch. Years later you can cut the cross-section and see which claims held up and which scarred.

---

## 56. Language Trees & Multi-Language Learning

> *"A different language is a different vision of life."* — Federico Fellini

**Prerequisites:** None for base (word filaments, lifecycle states, semantic domain branches, translation links, curriculum projections). Expands with: AR interaction modules → parallel bark multi-language view, pronunciation SCV assistance, live translation overlays, endangered language monitoring.

Every dictionary you've ever used is a frozen snapshot — a book that was accurate the day it was printed and wrong the day after. Languages don't work that way. Words are born, change meaning, spread across borders, go out of fashion, and sometimes die. A dictionary can't show you that. A tree can.

In Relay, every language is a tree on the globe, rooted where that language was born. English grows from London. Mandarin from Beijing. Hebrew from Jerusalem. Arabic from the Arabian Peninsula. Each language tree has the same physics as a company tree — because a language is structurally the same thing: a living system that grows outward, accumulates history inward, and never deletes.

Every word is a filament.

### §56.1 — Word as Filament

A word is not a static entry. It is a living unit with a birth, evolving meanings, and eventual decline. That is exactly what a filament does.

| Word Property | Filament Domain | Example |
|---|---|---|
| The word itself | Identity | `run`, `casa`, `שלום` |
| Phonetic form (IPA) | Extension | `/rʌn/`, `/ˈka.sa/`, `/ʃaˈlom/` |
| Language community | Counterparty | English speakers (θ = geographic distribution of usage) |
| First known usage | Time (spawn) | ~800 CE for "run" from Old English "rinnan" |
| Usage frequency | Magnitude | 4,500 occurrences per million words in modern corpus |
| Dictionary entries, citations | Evidence | OED entry hash, corpus frequency snapshots, earliest manuscript ref |
| Official / Slang / Retired | Lifecycle | See §56.2 |

### §56.2 — Word Lifecycle States

| State | What It Means | Where on the Branch |
|---|---|---|
| `SCHEDULED` | Proposed neologism not yet in common use | Translucent, at branch tip. Zero physics weight. |
| `OPEN` | New word gaining traction (coined, trending) | Outer bark surface. Hot (rapid adoption). |
| `ACTIVE` — Slang | Widely used but not in official dictionaries | Bark surface, high magnitude, high heat, but stays outside — no institutional evidence (dictionary entry) committed yet. |
| `ACTIVE` — Official | In the dictionary. Taught in schools. Standard. | Firmed up, migrating inward. Each year's usage = one ring. |
| `HOLD` — Archaic | Still understood but rarely used. "Henceforth," "betwixt." | Deep rings, thin, cooling. Readable in cross-section but not on active bark. |
| `CLOSED` — Retired | No longer understood by native speakers. Dead vocabulary. | Deepest rings, approaching heartwood. Preserved forever, invisible at bark LOD. |
| `ABSORBED` | Word adopted into another language. English "café" from French. | Sinks into receiving language's tree with cross-tree provenance link back to source. |

**Slang resolution**: When a dictionary officially adds a slang word (e.g., "selfie" entering the OED in 2013), the filament receives a governance commit — the institutional evidence that triggers inward migration from bark to the official wood layer. The bark ridge at that transition point shows where the language's structure formally changed — exactly like an engineering change order (§54.5).

### §56.3 — Branch Structure: Semantic Domains

A language tree branches by **meaning**, not alphabetically. Alphabetical order is a rendering artifact.

```
Language Tree: English
├── Body & Health        (hand, heart, blood, fever, heal...)
├── Nature & Environment (tree, river, mountain, storm...)
├── Technology & Tools   (computer, wheel, hammer, code...)
├── Emotion & Mind       (love, fear, think, dream, believe...)
├── Society & Relations  (king, friend, law, market, vote...)
├── Movement & Action    (run, fly, build, break, carry...)
├── Quantity & Measure   (one, many, heavy, long, fast...)
├── Time & Sequence      (now, yesterday, soon, always, never...)
├── Space & Position     (here, above, inside, between, far...)
└── Function Words       (the, is, and, but, if, to, with...)
```

Within each branch, **word families form sub-branches**. The root word is the sub-branch origin. Derivatives grow from it:

```
Movement & Action
└── "run" (root, Old English "rinnan", ~800 CE)
    ├── "runner"  (agent noun, 1300s)
    ├── "running" (gerund, 1300s)
    ├── "runaway" (compound, 1500s)
    ├── "runway"  (compound, 1800s — aviation meaning 1923)
    ├── "rerun"   (prefix derivative, 1950s — television context)
    └── "run" sense 47 (computing: "run the program", 1960s)
```

When a word gains a new meaning, it is a **schema version bump** on the existing filament — a bark ridge. The old meaning still exists in the inner rings. The new meaning appears on the current bark surface. You can scrub inward through the cross-section and watch the meaning evolve.

### §56.4 — Translation: The Cross-Language Axis

Translation is a **cross-tree evidence link** — the same mechanic used for cross-branch filament references everywhere in Relay.

The English "house" and Spanish "casa" are filaments on two different language trees, connected by translation links:

```
F-WORD-EN-house  ←→  F-WORD-ES-casa
                 ←→  F-WORD-FR-maison
                 ←→  F-WORD-DE-Haus
                 ←→  F-WORD-HE-bayit (בית)
                 ←→  F-WORD-AR-bayt (بيت)
                 ←→  F-WORD-ZH-fángzi (房子)
```

Each translation link carries:

| Property | What It Captures |
|---|---|
| Equivalence type | Exact, approximate, contextual, false friend |
| Semantic overlap % | "casa" covers 95% of "house" meanings. "Heim" covers 60% (closer to "home"). |
| Direction notes | "house" → "casa" is direct. "casa" → "house" loses warmth connotation. |
| Evidence | Bilingual dictionary hash, corpus parallel alignment, translator attestation |

**Geometric representation**: When you focus on a word, its translation links form a **perpendicular ring** around the filament — like Saturn's ring. Each position on the ring is a different language's translation. The angular position corresponds to the target language's geographic position on the globe. Spanish to the southwest, French to the southeast, German to the northeast, Chinese to the east. Geographic direction becomes semantic direction. You roll along the translation ring to see all equivalents simultaneously.

### §56.5 — Multi-Language Parallel View

When you enable multiple languages, the bark surface shows **parallel filament rows** — your native language and all enabled targets side by side, sorted by magnitude (frequency).

At BARK LOD:

```
Body & Health Branch — Parallel View (EN + ES + FR + DE)

  EN: hand     ES: mano      FR: main     DE: Hand
  EN: heart    ES: corazón   FR: cœur     DE: Herz
  EN: blood    ES: sangre    FR: sang     DE: Blut
  EN: fever    ES: fiebre    FR: fièvre   DE: Fieber

  [thickness = frequency — learn thick words first]
```

**Why "you learn by looking" works:**

1. **Spatial association** — "mano" is always next to "hand" in the same row position
2. **Frequency ordering** — common words dominate your view, rare words are thin
3. **Semantic grouping** — related words share a branch, not scattered alphabetically
4. **Confidence feedback** — your personal learning progress is visible as warmth. Unlearned = translucent. Mastered = solid and warm.
5. **Cross-pattern recognition** — seeing "fiebre / fièvre / Fieber" clustered instantly reveals the Latin root without being told

**Color encoding**: Each enabled language gets a distinct hue. Your personal confidence on each translation link grows as you learn — the filament warms and firms. This is the same confidence physics used everywhere in Relay, applied to your personal knowledge state.

### §56.6 — Teaching Curriculum as Projection

A curriculum is a **projection branch** that reads the language tree and selects what to teach. It is not a manually curated list. It is an automatically maintained view that updates when the language changes.

| Curriculum Element | Source | Selection Rule |
|---|---|---|
| Year 1 vocabulary | Top 500 words by magnitude | Frequency > threshold per semantic domain |
| Year 2 vocabulary | Next 1,500 words | Frequency band |
| Grammar structures | Function Words branch + morphology patterns | Structural pattern detection |
| New additions this year | Words that transitioned `OPEN → ACTIVE-Official` in past 12 months | Lifecycle change within date range |
| Automatic removals | Words that transitioned to `HOLD-Archaic` | Auto-excluded from active curriculum |
| Cultural context | Evidence attachments on word filaments | Evidence type = "context-example" or "cultural-warning" |

**Automatic curriculum updates**: When a dictionary board commits a word to official status, the projection auto-includes it in next year's plan. When a word goes archaic, it auto-excludes. The tree's lifecycle physics drive the curriculum.

**Teacher / ministry overrides** (themselves filament commits — visible, auditable, reversible):
- Pin specific words (force-include regardless of frequency)
- Block specific words (force-exclude regardless of status)
- Adjust frequency threshold per grade level
- Add supplementary evidence (teaching notes, pronunciation guides)

### §56.7 — Etymology as Cross-Section

Cut any word in cross-section and see its complete history:

```
Cross-section of "nice" (English)

Outer ring (2020s): "pleasant, agreeable" — very high magnitude
Ring (1900s):       "pleasant" — stabilized
Ring (1700s):       "precise, careful" — meaning shift
Ring (1500s):       "foolish, silly" — earlier meaning
Ring (1300s):       "foolish, stupid" — from Old French "nice"
Core:               Latin "nescius" = "ignorant" — etymological root
```

Every meaning change is a schema version bump. Every ring preserves the meaning active during that period. Scars appear where meaning was contested, where a word was censored, or where a false etymology was corrected.

### §56.8 — Dead Languages and Language Evolution

Dead languages (Latin, Ancient Greek, Sanskrit, Old English) are trees that stopped growing — their canopy is entirely historical bark, no new filaments. But their roots are the deepest in the system because they feed the etymology of living languages.

Tracing "democracy" backward:
Modern English "democracy" → French "démocratie" → Latin "dēmocratia" → Greek "δημοκρατία"

That chain is a cross-tree provenance link from a living filament to a dead language's deep ring. The Greek tree hasn't grown in two millennia, but its inner rings are still read by modern language projections.

**Language family patterns** are visible at TREE LOD as cluster patterns on the globe: Romance languages cluster in southern Europe, Germanic in northern, Slavic in eastern. Zooming out, language families are tree clusters — the same way company trees cluster by industry.

**Endangered language detection**: A language tree with declining magnitude (fewer speakers), increasing archaic transitions (words dying faster than new ones born), and thinning rings (declining activity per timebox) = a wilting branch. Visible alarm. The tree physics that show a failing company branch show a dying language the same way.

### §56.9 — Capabilities Summary

| Capability | Mechanism |
|---|---|
| Learn 3 languages simultaneously | Enable parallel bark view — see word families across all three |
| Track slang adoption in real time | Watch outer bark — what's hot, gaining magnitude, not yet officiated |
| Predict curriculum changes | Projection shows words approaching official threshold |
| Detect dialect drift | Compare ring thickness between American English and British English sub-branches |
| Preserve endangered languages | Declining magnitude + increasing archaic transitions = wilting branch alarm |
| Measure translation quality | Translation links with low semantic overlap = fog. High overlap = clear. |
| Study historical linguistics | Cross-section + etymology chains show language evolution without a textbook |
| Trace loanwords across civilizations | Cross-tree provenance links from living words back to dead language roots |

No new physics. Filament lifecycle, cross-tree links, projection branches, magnitude sorting, confidence overlays, and cross-section inspection — applied to language.

---

## 57. Adoption Tiers & Backwards Compatibility — Frozen Contract #140

> *"Meet people where they are, not where you want them to be."* — attributed to various community organizers

**Prerequisites:** None. Required from day one — Relay must function at all four adoption tiers from launch.

Relay does not require the world to adopt it. It does not replace existing systems. It wraps them, mirrors them, and shows the difference. A government property registry that has worked on paper since 1847 does not need to change. Relay simply hashes their documents and shows a foggy branch where full confidence would otherwise be. The fog is not a penalty — it is honesty. The users who see clear branches next to foggy ones will draw their own conclusions. Relay never pushes new interfaces. They speak for themselves.

### §57.1 — The Four Tiers

Every external system Relay touches exists at one of four integration depths. These tiers coexist permanently on the same globe. Different departments, cities, and countries will sit at different tiers simultaneously.

| Tier | Name | Who is master? | What Relay stores | Confidence level |
|------|------|---------------|-------------------|-----------------|
| 0 | Evidence Hash Only | External system | Document hash + timestamp only | Low (fog). Existence verified, contents opaque. |
| 1 | Connector Read | External system | Structured filaments mirrored from API/feed | Medium. Internal consistency verifiable. Authority is external. |
| 2 | Dual Write | Both | Native filaments + external-sourced filaments, reconciled | Mixed. Native = clear. External = slightly foggy. |
| 3 | Relay Native | Relay | All work happens in the tree | High. Full confidence, full cross-section, full replay. |

### §57.2 — Tier 0: Evidence Hash Only

The lightest possible integration. No API, no connector, no training. Someone uploads a document (PDF, scan, photo). Relay computes a cryptographic hash and stores it as a filament with:

- `identity`: document description
- `time`: upload timestamp
- `evidence`: `{ type: "hash-only", hash: "sha256:...", originalSystem: "Municipal Registry Office" }`
- `lifecycle`: `OPEN` (the hash exists; the content is opaque)

What the tree shows: The filament exists and is positioned on the correct branch. But it is foggy — Relay cannot independently verify what the document says, only that it existed at that time and has not been altered since.

If years later the same document is re-uploaded and the hash matches: confidence holds. If the hash differs: scar + possible storm (document tampering detected).

### §57.3 — Tier 1: Connector Read

Relay connects to the external system's API or data export. Filaments are auto-created with structured fields:

- Property transfer: `{ buyer, seller, parcel, price, date, registryRef }`
- Patient visit: `{ patientId, provider, diagnoses, procedures, date, ehrRef }`
- Invoice: `{ vendor, amount, lineItems, date, erpRef }`

The external system remains the master. Relay is a read-only mirror. If the external system updates a record, Relay receives a new commit on the filament. If the external system goes down, the filament shows `PENDING_EXTERNAL` and the branch develops fog (external dependency unresolvable).

Confidence is higher than Tier 0 because Relay can verify internal consistency (do the numbers add up? do cross-references resolve? is the timeline coherent?). But the authority pointer still leads outside Relay.

### §57.4 — Tier 2: Dual Write

Users begin creating some work natively in Relay while continuing to use the legacy system for other work. Both streams produce filaments in the same tree.

- Native filaments: full evidence, full confidence, clear rendering
- External filaments: connector-sourced, medium confidence, slightly foggier

Relay reconciles both streams at timebox close. If a native filament and an external filament refer to the same real-world event (e.g., an invoice entered in both SAP and Relay), the consolidation gate checks that they match. Discrepancy → scar.

This is where adoption accelerates naturally. Users see that the native-Relay parts of their tree are clearer, faster, and more legible than the connector-mirrored parts. They start doing more work natively — not because anyone told them to, but because the tree shows them the difference.

### §57.5 — Tier 3: Relay Native

The external system is retired or reduced to a thin persistence/backup layer. All work originates in Relay. The tree has full confidence everywhere.

This tier is never required. Many systems may permanently remain at Tier 0 or 1. A rural land registry that processes 20 transfers per year has no operational reason to go beyond Tier 1. That is perfectly fine. The tree still works.

### §57.6 — Mixed-Tier Rendering

On a single tree, different branches may operate at different tiers:

```
Company Tree: Acme Corp
├── Finance (Tier 3 — fully native)           → Clear, warm, firm
├── Procurement (Tier 2 — dual write with SAP) → Mostly clear, some fog
├── HR (Tier 1 — connector from Workday)       → Medium clarity, external refs
├── Legal (Tier 0 — scanned contracts only)    → Foggy, hash-only evidence
└── Property (Tier 0 — municipal registry)     → Foggy, hash-only evidence
```

The visual contrast is immediate. Management sees exactly which parts of the organization are operating with full truth and which parts are relying on external claims. No dashboard needed. No adoption metric. The tree shape IS the adoption metric.

### §57.7 — Upgrade Paths

Moving from one tier to the next is always voluntary and reversible:

| Transition | What happens |
|------------|-------------|
| Tier 0 → 1 | Connect API. Existing hashes remain. New filaments get structured fields. Historical hashes can be back-filled if the external system provides records. |
| Tier 1 → 2 | Users start entering some work directly in Relay. External connector continues. Reconciliation gate detects duplicates. |
| Tier 2 → 3 | External system decommissioned or demoted to backup. All new work in Relay. Historical external filaments remain with their original confidence level. |
| Any → 0 | Connector removed. Existing filaments preserved permanently. New filaments from that system stop. Branch goes dormant (no new growth, all history preserved). |

Downgrading never deletes data. A Tier 3 branch that reverts to Tier 0 keeps all its rings — it just stops growing.

**Contract #140 — Relay functions at all four adoption tiers simultaneously. No tier is prerequisite for any other. No feature is gated behind Tier 3. Evidence hashes (Tier 0) are a permanent, first-class integration method. The visual difference between tiers is rendered through existing confidence/fog physics — not through badges, warnings, or degraded UI. The tree makes the case for adoption by being legible. Relay never pushes.**

---

## 58. Education — The Internal Adventure — Frozen Contract #142

> *"Education is not the filling of a pail, but the lighting of a fire."* — attributed to W.B. Yeats (originally Plutarch)
>
> *"Being good at it doesn't mean we should be doing it."* — ChatGPT 5.2

Learning in Relay is not a course catalog. It is a personal adventure documented on your user tree. Every skill you acquire — from filing a spreadsheet row to casting a fire spell — is a module you discovered, demonstrated, and earned. The system never tells you what to learn next. It shows you what you can do, and the things you cannot yet do remain invisible until you are ready to find them. Education is the act of growing your tree outward by adding new capability branches.

When a new user opens Relay for the first time, they choose a starting path. Not a "role" — a direction. A banker learns different first skills than a game developer, who learns different first skills than a farmer. But they all use the same tree, the same physics, the same modules. The difference is which modules they encounter first and which prerequisite chains they traverse naturally.

### 58.1 The Official Demo/Tutorial

Every Relay account begins with a guided tutorial — the only time the system actively teaches. After this, learning is self-directed discovery.

**Path selection at first launch:**

| Path | Who it's for | First skills taught | Initial tree shape |
|------|-------------|--------------------|--------------------|
| **Personal** | Individual managing files, health, calendar | Filament creation, basic commits, personal branches, calendar scheduling | Thin personal tree, 5-6 branches |
| **Business / Finance** | CFO, accountant, procurement | Three-way match, accounting packets, mass balance, reconciliation gates | Finance-heavy tree, invoice/PO/GR branches |
| **Coder / Maker** | Developer, engineer, designer | Code filaments, version commits, AI code governance, project branching | Code-centric tree, repo-like branches |
| **Manager / Executive** | Team lead, department head, CEO | Cross-section inspection, branch health reading, scheduling, projection branches | Overview tree, department branches |
| **Creator / Artist** | Musician, filmmaker, writer | Media filaments, timeline-based bark, production branches, collaboration | Media tree, creative workflow branches |
| **Student** | Learner in any subject | Note-taking, evidence linking, study branches, curriculum following | Learning tree, subject branches |
| **Gamer** | Someone drawn to the game layer | Presence, achievement discovery, basic SCV interaction, detection | Adventure-ready tree, achievement branches |

Each path teaches the same underlying physics through different examples. The banker learns filament lifecycle by processing a sample invoice. The coder learns it by committing a code change. The gamer learns it by capturing a camera event. Same module, different door.

The tutorial is a short guided sequence (10-15 minutes) that results in a real tree with real data — not a sandbox. When the tutorial ends, the user's tree is already alive and growing. Everything they did during the tutorial is permanent.

### 58.2 Skill Paths as Module Prerequisite Chains

After the tutorial, all learning is discovery. But the system maintains **skill paths** — ordered sequences of modules that the community has voted as effective learning progressions. These are not gates. They are suggestions.

A skill path is a projection branch on the user's tree:

- Light blue (human-curated) or lavender (SCV-suggested)
- Each node in the path is a module with prerequisites
- The user's current position in the path is visible (which modules they've demonstrated, which remain)
- The user can skip ahead at any time — if they demonstrate a module's prerequisites, they don't need to follow the suggested order

Skill paths are community-created and community-voted. Anyone can propose a new path. The community votes on effectiveness. The best paths rise to the top of search results. Bad paths wilt.

### 58.3 Teaching as a Ranked Filament Activity

Teachers in Relay are not appointed. They are discovered through the same physics that governs everything else:

**How teaching works:**

1. A user creates an **explanation filament** — a recorded lesson, tutorial, walkthrough, or demonstration attached to a specific module or skill path
2. The explanation becomes a filament on the teacher's user tree (their teaching branch)
3. Students who follow the explanation and successfully demonstrate the module create a **learning filament** that references the teacher's explanation as evidence
4. The teacher's explanation filament accumulates confidence from successful student outcomes
5. Teachers whose explanations produce the most successful demonstrations rise in search rankings

**The Genghis Khan round-robin model:**

This follows the same pattern as psychiatric care, dating, and any other human-matching optimization:

- **Round-robin matching**: Students are matched with available teachers for short sessions. After each session, both parties rate the interaction.
- **Convergence**: Over time, the matching algorithm converges — the best teacher-student pairings surface naturally. A teacher who explains accounting brilliantly but struggles with code will attract accounting students and lose coding students.
- **No monopoly**: No single teacher dominates a topic. The round-robin ensures fresh perspectives and prevents stagnation. If a teacher's branch starts wilting (students stop succeeding), they drop in rankings.
- **Compensation**: Teachers earn magnitude (real value) proportional to student success rates, not just view counts. A teacher with 10 students who all demonstrate the skill earns more than a teacher with 1,000 viewers who never try.

**Search optimization:**

When any user searches for help on a topic:

1. Relay returns the highest-confidence explanation filaments for that module
2. Ranked by: student success rate, recency, teaching style match (SCV recommends based on the learner's prior demonstrated learning patterns)
3. The top result is the branch with the most successful student outcomes — the tallest, firmest teaching branch visible in any Relay search query
4. This optimizes the audience's time: the first thing they see is the most effective explanation available

### 58.4 Education as Internal Adventure

Every learning journey is a personal quest:

- Your user tree's **learning branch** shows every module you've discovered and demonstrated
- Cross-section of the learning branch shows your education history — early skills near the core, recent skills on the outer bark
- Twigs represent modules you started but haven't yet demonstrated competence in
- Scars represent failed attempts (which are permanent and valuable — they show you tried)
- The thickness of your learning branch reflects the volume of skills you've actively engaged with

There is no external degree, no paper diploma, no institution-issued certificate. There is only the tree — the tree IS the credential. An employer looking at your user tree sees: "This person has 47 demonstrated modules across finance, code, and project management. Their accounting branch is thick and firm. Their coding branch has two scars and a twig." That IS the resume. Credentials are the proven record of commits, all held with high confidence at the time of commitment by people who themselves held high confidence. Profile reveal percentages allow employers to request a specific proportion of tree visibility (e.g., "60% tree reveal required") without accessing individual filament content. (See §71.10 for full credential and profile reveal mechanics.)

### 58.5 Community-Curated Curricula

What professions and roles deserve curricula, and what those curricula contain, is governed through §72 layered option governance — the community meta-votes on what should be offered before voting on the content itself. The §73 tutorial master list surfaces these curricula to new users.

Lesson plans are not designed by institutions. They are proposed by anyone and validated by the community:

1. **Proposal**: A user (teacher, institution, or SCV) proposes a curriculum — an ordered set of skill paths covering a domain (e.g., "Financial Accounting Fundamentals," "Full-Stack Development," "Agricultural Operations Management")
2. **Projection branch**: The curriculum appears as a projection branch visible to anyone searching for that domain
3. **Community voting**: Users who have demonstrated the domain's modules vote on curriculum quality. This ensures only competent reviewers judge lesson plans.
4. **Student outcomes**: Curricula are ranked by aggregate student success — the percentage of students who follow the curriculum and successfully demonstrate all its modules
5. **Teacher assignment**: The curriculum references the highest-ranked teachers per module, automatically updated as teacher rankings change
6. **Version evolution**: Curricula evolve through governance commits — modules get added, removed, or reordered. Each version is preserved. Students following an older version can see what changed and why.

The best curricula for any topic float to the top because they produce the most competent graduates. The system self-optimizes.

### 58.6 How This Connects to Module Discovery (§38)

The education system IS the module discovery system. They are the same thing seen from two angles:

- **Module discovery** (§38) says: "demonstrate competence and the module becomes available"
- **Education** (§58) says: "here's how you get competent — through community-ranked teachers, curated skill paths, and round-robin matching"

The tutorial teaches the first few modules explicitly. After that, the user's growth is their own. Some users will discover modules through work (the banker who learns reconciliation gates by doing their job). Some will discover modules through play (the gamer who stumbles into presence detection). Some will follow structured curricula. Some will apprentice with a specific teacher. All paths are valid. All paths produce the same demonstrated competence filaments on the user tree.

There is no graduation. There is only growth. The tree never stops learning.

**Contract #142 — Education is an internal adventure on the user tree, not an external institution. Teaching is a ranked filament activity where teachers are compensated by student success rates, not view counts. Skill paths are community-curated suggestions, never mandatory gates. The round-robin matching model applies to teaching, psychiatric care, dating, and all human-matching optimization uniformly. Curricula evolve through governance commits and are ranked by aggregate student outcomes. The tutorial is the only moment Relay actively teaches — after that, all learning is self-directed discovery.**

### 58.7 Course Template Model — A Course Is a Tree

A course is not a flat list of lessons. A course is a **branch that hosts a sub-tree** (§60). The course branch on a school's education tree contains its own trunk, its own branches, its own filaments — full recursive depth.

**Structure:**

```
School Tree
└── education branch
    └── Biology 01 (course sub-tree)
        ├── curriculum branch (canonical truth)
        │   ├── Unit 1 — Cell Structure
        │   │   ├── Lesson 1.1 (filament)
        │   │   ├── Lesson 1.2 (filament)
        │   │   └── Assessment 1 (filament)
        │   ├── Unit 2 — Genetics
        │   └── ...
        ├── delivery branch (teacher method projections)
        ├── grading branch (assessment results)
        ├── discussion branch (student interactions)
        └── resources branch (textbooks, media, lab data)
```

**Course template schema:**

```
CourseTemplate {
  courseId:              string,
  syllabusFilaments:     FilamentRef[] (canonical curriculum — the truth anchor),
  assessmentBlueprint:   AssessmentRef[] (required evaluations),
  evidenceRules: {
    minSourcesPerLesson:   number (default: 2),
    requiredSourceTypes:   enum[] { TEXTBOOK, PEER_REVIEWED, DATASET, PRIMARY_SOURCE },
    assessmentAlignment:   boolean (each lesson must link to at least one assessment)
  },
  allowedMethodVariations: string[] (what teachers may customize),
  prerequisiteModules:     ModuleRef[] (what students must demonstrate before enrolling)
}
```

The **curriculum branch is the truth anchor.** It defines what must be taught — the canonical syllabus filaments with their evidence requirements. Teachers do not modify the curriculum branch. They create delivery branches (§58.8) that are projections bound to it.

The curriculum branch itself evolves through governance commits (§58.5). New units can be proposed by teachers, reviewed by peers who have demonstrated the domain, and merged after community approval. Each revision is preserved. Students on an older curriculum version see what changed and why.

### 58.8 Teacher Method Marketplace

Teachers compete by publishing **delivery branches** — their unique method of teaching the canonical curriculum. A delivery branch is a projection branch (light blue) bound to the curriculum truth branch.

**What a delivery branch contains:**

```
TeacherDeliveryBranch {
  teacherUserId:       string,
  courseRef:            courseId,
  curriculumVersion:   commitId (which curriculum snapshot this delivery targets),
  methodMetadata: {
    pace:              enum { SLOW, MODERATE, FAST, SELF_PACED },
    style:             enum { VISUAL, PROOF_HEAVY, EXAMPLE_DRIVEN, SOCRATIC, LAB_FOCUSED },
    depth:             enum { INTRODUCTORY, STANDARD, ADVANCED },
    language:          string,
    estimatedHours:    number
  },
  lessonFilaments:     LessonFilamentRef[] (teacher's explanation for each syllabus item),
  assessmentMethods:   AssessmentMethodRef[] (how this teacher evaluates — within blueprint bounds)
}
```

**Each lesson filament on the delivery branch is a media filament (§59)** — a recorded explanation, tutorial, walkthrough, or live session. It carries:

- Claims made (concept list mapping to syllabus items)
- Evidence links (textbook references, peer-reviewed sources, datasets)
- Student outcome data (how many students who followed this explanation successfully demonstrated the module)
- Revision history (scars if the teacher corrected an error)

**The marketplace mechanism:**

Students searching for "Biology 01" see all available delivery branches for that course. They can filter and compare:

| Filter | What It Measures |
|--------|-----------------|
| Best outcomes | Highest percentage of students who demonstrated the module after this teacher's delivery |
| Best clarity | Highest student clarity votes (§58.9) |
| Best evidence | Highest orgConfidence on lesson filaments (evidence completeness) |
| Best fit | SCV recommendation based on the student's prior demonstrated learning patterns |
| Pace / style / depth | Method metadata match |

**Switching teachers is a routing operation, not a curriculum rewrite.** The canonical curriculum stays fixed. The student simply changes their `preferredTeacherRef` to point to a different delivery branch. All prior learning under the old teacher is preserved. Progress through the syllabus is unchanged — only the method of delivery changes.

### 58.9 Student Voting — Clarity vs Truth Separation

Students vote on teachers. But votes on **teaching quality** are structurally separated from **evidence truth**.

**Two independent confidence channels (consistent with §7.4–7.7):**

**A. Organizational Confidence (orgConfidence) — non-votable by students:**

This is the evidence quality of the lesson itself. Computed from:

- Does the lesson reference required source types? (textbook, peer-reviewed, dataset)
- Does the lesson align with the syllabus assessment blueprint?
- Has the lesson been peer-reviewed by other teachers who demonstrated the domain?
- Does the lesson's claim set match the canonical curriculum filament it targets?

If a teacher teaches "conspiracy biology" with no evidence links, their lesson filaments have low orgConfidence. The branch gets fog and wilt. Lessons drop below default visibility thresholds. No amount of student popularity votes can override this.

**B. Teaching Effectiveness Score (community-votable):**

Students vote on specific, measurable dimensions of each lesson filament:

```
StudentVotePacket {
  studentUserId:     string,
  lessonFilamentRef: filamentId,
  teacherRef:        userId,
  votes: {
    clarity:         number (1-5, "Was the explanation clear?"),
    pacing:          number (1-5, "Was the pace appropriate?"),
    engagement:      number (1-5, "Did the method hold your attention?"),
    practiceQuality: number (1-5, "Were the exercises useful?")
  },
  outcomeEvidence:   commitId | null (link to the student's demonstration filament, if they passed)
}
```

Votes are weighted by outcome: a vote from a student who successfully demonstrated the module carries more weight than a vote from a student who dropped out. This prevents "fun but wrong" from dominating rankings — a charismatic teacher whose students consistently fail to demonstrate competence will rank below a dry teacher whose students consistently succeed.

**The invariant (frozen):** Student votes affect teacher **visibility and routing** (which teacher appears first in search results, which teacher gets recommended). Student votes **never override orgConfidence** (evidence quality). A lesson with high popularity and low evidence stays foggy. A lesson with low popularity and high evidence stays firm. Both signals are visible. Neither can suppress the other.

### 58.10 Sortition Grading — Removing the 1:Many Bottleneck

A single teacher grading papers for hundreds of students does not scale. It creates bottlenecks, inconsistency, burnout, and standards drift. Relay replaces this with a **sortition grading pipeline** — the same jury mechanism used throughout the system (§46, contract #85).

**The grading pipeline:**

```
Assignment submitted (filament)
        │
        ▼
[Auto-check layer] ← Objective parts: MCQ, structured responses, code tests
        │                 Deterministic. No human needed.
        │
        ▼
[Sortition peer review] ← Subjective parts: essays, proofs, creative work
        │                    Random student jury (3-5 peers per submission)
        │                    Each juror grades independently using rubric filament
        │                    Consensus = grade confirmed
        │                    Disagreement = escalation
        │
        ▼
[Teacher spot-check] ← Teacher reviews a random sample (e.g., 10%)
        │                 Plus all escalated disagreements
        │                 Teacher grade overrides jury only with evidence commit
        │
        ▼
[Final grade committed] ← Filament on student's learning branch
                           Evidence: rubric scores, jury identities, teacher review (if any)
```

**Rubrics are policy filaments** — fixed, version-controlled, attached to the assessment blueprint. Jurors grade against the rubric, not against personal opinion. The rubric is the truth anchor for grading, the same way the syllabus is the truth anchor for teaching.

**Peer review jury mechanics (consistent with §46):**

- Jury selection is by sortition — random selection from students who have already demonstrated the module being assessed (they must be competent to grade it)
- Jurors grade independently. They see the submission but not each other's grades until all are committed.
- Consensus: if grades cluster within a tolerance band, the median is the final grade
- Disagreement: if grades diverge beyond tolerance, the submission is flagged as a **scar candidate** and escalated to the teacher or a higher-tier jury (students who demonstrated a higher-level module in the same domain)
- Jurors are graded on their grading (§46, contract #85): after the final grade is determined, each juror's grade is compared to the consensus. Consistently outlier graders see their grading weight reduced over time.

**Why this scales:**

- Auto-checks handle 60-80% of grading volume (objective questions)
- Sortition distributes the remaining 20-40% across the student body
- Teacher only reviews ~10% (random sample) plus escalations
- A course with 10,000 students requires the same teacher effort as a course with 100 — the sortition layer absorbs the scale
- Standards remain consistent because the rubric is fixed and jury consensus converges

**Compensation:** Peer graders earn a small magnitude credit for each grading session (teaching others is a form of demonstrated competence). This makes grading a valued activity, not unpaid labor.

### 58.11 Teacher Score, Routing, and Quality Decay

**Teacher score computation:**

```
TeacherScore(course, teacher) = weighted combination of:
  0.35 × studentOutcomeRate     (% of students who demonstrated the module)
  0.25 × evidenceIntegrity      (avg orgConfidence across lesson filaments)
  0.20 × clarityScore           (avg student clarity votes, weighted by outcome)
  0.10 × consistencyScore       (alignment with canonical curriculum filaments)
  0.10 × appealRate_inverse     (1 - proportion of grading appeals/scars)
```

All weights are Category A global parameters (§11.6). Initial values as shown; community governs from day one.

**Routing:**

A student sets `preferredTeacherRef` for each course. Relay routes them to that teacher's delivery branch. If no preference is set, Relay recommends based on SCV analysis of the student's demonstrated learning patterns (§58.3).

**Quality decay:**

If a teacher's score drops below a threshold (Category A global parameter, default: 0.40):

1. The delivery branch begins wilting (slab wilt increases per §3.7)
2. Students on that delivery branch receive a suggestion (advisory only, per §58.6): "Alternative delivery branches with higher student outcomes are available"
3. No automatic re-routing. The student decides. Suggestions never auto-switch (contract #142).

If a teacher's orgConfidence drops below the course template's minimum evidence threshold:

1. The delivery branch gains fog (low opacity per §3.4)
2. The branch drops below default search visibility
3. Students already enrolled are notified: "This teacher's evidence quality no longer meets course requirements"
4. New students cannot be routed to the branch until evidence is restored

**Contract #147 — Student votes on teaching effectiveness affect visibility and routing, never evidence-based organizational confidence. A lesson with high popularity and low evidence stays foggy. A lesson with low popularity and high evidence stays firm. Both signals are independently visible. Neither can suppress the other. Grading is a sortition process: peer review juries grade against fixed rubric filaments, with auto-check handling objective parts and teacher spot-checking a random sample plus escalations. The sortition grading pipeline scales independently of class size. Teaching quality decays visibly through wilt and fog when standards drop, but suggestions never auto-switch students.**

### 58.12 Certification & Credentialing — Relay as Third-Party Verification

Relay does not issue degrees. Relay does not have a registrar. Relay has something stronger: a **verifiable, immutable record of demonstrated competence** graded by community-certified teachers against community-voted curricula, anchored to the user's tree and inspectable by anyone the user permits. The requirement lists for each profession are governed through §72 layered option governance — what should be required is a community meta-vote, not a top-down mandate.

**The certification model:**

In the physical world, becoming a CPA in Arizona requires completing specific coursework, passing specific exams, and being verified by an accredited institution. In Relay, the same structure exists — but the institution is replaced by the tree and the community.

**Step 1 — Regional requirement lists:**

Any professional community (municipal, state, industry, guild) can publish a **certification requirement branch** on their organizational tree. This branch contains:

```
CertificationRequirementSet {
  certificationId:       string (e.g., "cert.arizona.cpa.2026"),
  issuingTreeRef:        treeId (the organizational tree publishing the requirement),
  region:                string | null (geographic scope, if applicable),
  requiredModules:       ModuleRef[] (ordered list of modules the candidate must demonstrate),
  requiredCourses:       CourseRef[] (specific courses or course categories),
  assessmentGates:       AssessmentRef[] (exams, practicals, portfolios required),
  minimumTeacherScore:   number (minimum teacher score for grading to count),
  minimumGradingConfidence: number (minimum sortition grading confidence per course),
  governancePolicy:      GovernanceRef (how the requirement set evolves)
}
```

The requirement list is itself a governed branch. Changes follow the same governance model as all Relay content: proposals are committed, the qualified community votes, and the winning revision becomes the active requirement. If the Arizona accounting community decides that a new ethics module is required for CPA certification, that module is proposed, voted upon by users who have already demonstrated accounting expertise, and merged into the requirement set through a governance commit.

**Step 2 — Curriculum independence:**

Each required course within the certification is a separate sub-tree (§58.7). Courses can be replaced, improved, or forked without disrupting the certification structure:

- If a better "Auditing 301" course appears (higher student outcome rate, better teacher score), it can be proposed as a replacement within the requirement set
- Students who already completed the older "Auditing 301" under a qualified teacher are not affected — their demonstration filament references the specific course version they completed
- The certification checks module completion, not course identity — if two different courses teach the same module and the student demonstrated competence in that module, the requirement is satisfied regardless of which course they took

**Step 3 — Teacher certification for grading:**

Not every teacher can grade for a professional certification. The certifying community sets a `minimumTeacherScore` threshold. Only teachers whose `TeacherScore` (§58.11) for the relevant domain meets or exceeds this threshold at the time of grading may issue grades that count toward certification.

```
CertificationGradeCommit {
  studentUserId:         string,
  certificationRef:      certificationId,
  courseRef:              courseId,
  moduleRef:             moduleId,
  teacherUserId:         string,
  teacherScoreAtGrading: number (snapshot of teacher's score at grading time),
  gradingMethod:         enum { SORTITION_PIPELINE, DIRECT_ASSESSMENT, PRACTICAL_EXAM },
  gradingConfidence:     number (from sortition pipeline or direct assessment),
  gradingTimestamp:       ISO-8601,
  evidenceChain:         EvidenceRef[] (rubric scores, jury identities, assessment artifacts)
}
```

**Step 4 — The snapshot principle (critical invariant):**

When a teacher grades a student for certification, the `teacherScoreAtGrading` is snapshotted and committed as permanent evidence. If the teacher later degrades — their score drops, their branch wilts, they lose community confidence — **this does not retroactively affect the student's certification.** The grade was valid at the time it was issued. The evidence chain is immutable. The student's demonstrated competence is a committed fact on their tree.

This mirrors how physical professional certifications work: if your accounting professor later loses their credentials, your CPA license is not revoked — because you passed the exam under qualified supervision at the time.

The reverse is also enforced: if a teacher is discovered to have fraudulently inflated grades, the evidence chain shows this through scars on the teacher's branch and potential sortition jury review (§46) of individual grade commits. Fraud is detectable because every grade has a full evidence trail.

**Step 5 — Certification completion:**

When a student has demonstrated all required modules, completed all required courses with qualifying grades, and passed all assessment gates — their tree displays the certification:

```
CertificationCommit {
  certificationRef:      certificationId,
  studentUserId:         string,
  completionTimestamp:    ISO-8601,
  requirementVersion:    commitId (which version of the requirement set was active),
  gradeCommitRefs:       CertificationGradeCommit[] (all grades that satisfy requirements),
  status:                ACTIVE | EXPIRED | SUSPENDED
}
```

The certification appears as a **firm, high-confidence filament** on the student's professional branch. It carries the full evidence chain: every course, every grade, every teacher, every rubric score. Anyone the student permits to inspect their tree (employer, client, regulatory body) can verify every component.

**Step 6 — How knowledge, position, and responsibility grow together:**

The certification model closes the loop between education (§58), module discovery (§38), and work zone governance (§19.3):

| Layer | What It Represents | How It Grows |
|-------|-------------------|--------------|
| **Knowledge** | Demonstrated modules on the learning branch | Completing courses, passing assessments, sortition grading |
| **Position** | Certifications that unlock professional scope | Fulfilling community-voted requirement sets |
| **Responsibility** | Work zone permissions derived from certification | Certified users gain access to governed branches (e.g., a certified CPA can operate on a firm's accounting tree) |

A user who demonstrates accounting competence (knowledge) can earn CPA certification (position), which grants them work zone permissions on accounting branches (responsibility). These three layers reference each other but grow independently. A user can have knowledge without certification (self-taught). A user can have certification without responsibility (certified but not yet employed). A user can have responsibility without certification (legacy integration per §57). The tree shows all three — and makes the gaps visible.

**Contract #153 — Relay functions as a third-party verification platform through community-governed certification requirement sets.** Regional or professional communities publish requirement branches specifying modules, courses, assessment gates, and minimum teacher qualifications. Teachers must meet a minimum score threshold at the time of grading for their grades to count toward certification. The `teacherScoreAtGrading` is snapshotted and committed as immutable evidence — subsequent teacher degradation does not retroactively affect student certifications. Course replacement within requirement sets does not invalidate prior completions. Certification commits carry the full evidence chain (every course, grade, teacher, rubric score, jury identity). Knowledge (demonstrated modules), position (certifications), and responsibility (work zone permissions) reference each other and grow together on the user tree.

---

## 59. Media & Content Circulation — Frozen Contracts #143–146

> *"Art is not what you see, but what you make others see."* — Edgar Degas

**Prerequisites:** §3.2 (content-type bark rendering), §3.2.1 (individual filament depth), §3.4 (cross-section triple encoding), §3.21–3.22 (content-type temporal mapping), §21.2.9 (media production template), §31 (accounting packets), §33.5 (LOD thresholds), §57 (adoption tiers), §11.6 (global parameter registry).

This section formalizes how video, audio, and all temporal media work in Relay. It covers: the internal structure of a media project as a branch, the physics of watching (viewer traversal), single-instance circulation (how a purchased copy is shared without duplication), the creative license system, derivative fork economics, and media-specific LOD rendering.

The governing principle: **a media object in Relay behaves like a physical object.** It can be lent, viewed, checked out, and returned — but never silently duplicated beyond a controlled cap set by the rights holder. Watching is not "pressing play." It is traversing a branch along the L-axis. Your position is real, spatial, and visible. Your engagement becomes wood.

### 59.1 Media Object as a Governed Branch

A film, album, podcast, or any temporal media work is not a single filament. It is a **project branch** on a media tree.

**Structural decomposition:**

```
Media Branch (project level)
└── F-PROJECT (the work as a whole)
    ├── F-SCENE-1 (scene / track / chapter)
    │   ├── F-SEG-1.1 (segment, Δt = 1s or 2s, template param)
    │   │   ├── F-FRAME-CLUSTER-1 (atomic rendering unit)
    │   │   ├── F-FRAME-CLUSTER-2
    │   │   └── ...
    │   └── F-SEG-1.2
    ├── F-SCENE-2
    └── ...
```

Each segment is a filament with its own:

- **Identity** — `F-MEDIASEG-<projectId>-<segIndex>` where `segIndex = floor(timeSec / Δt)`
- **Commit history** — radial depth per §3.2.1. A segment edited 50 times has 50 inward layers. A segment recorded once and never touched has one layer.
- **Lifecycle state** — SCHEDULED (pre-production), OPEN (in editing), ACTIVE (in review), HOLD (on hold), CLOSED (approved/released), ABSORBED (archived master)
- **Engagement weight** — accumulated from viewer dwell, replay, pause, and derivative fork activity
- **Evidence** — production QA gates, approval commits, master certification

This is identical to how spreadsheet cells work on a financial branch. Each segment is a cell. Each cell has its own tracked filament history going inward. The branch is the project. The bark surface is the current state. The rings are production epochs.

**The media object itself** (the actual file — video, audio, image sequence) is stored as a single content-addressed blob:

```
MediaObject {
  objectId:              string,
  contentHash:           SHA-256 of encrypted master file,
  ownerTreeRef:          treeId of the rights holder,
  branchRef:             branchId of the media project branch,
  licenseType:           enum (see §59.5),
  maxConcurrentCopies:   number (Global Parameter, Category A),
  totalCopiesSold:       number (append-only counter),
  circulationMode:       enum { PRIVATE_ONLY, LIMITED_STREAM, OPEN_STREAM, THEATRICAL_ONLY },
  derivativePolicy:      enum (see §59.5),
  royaltyModel:          RoyaltyModelRef,
  encryptionKeyRef:      keyId,
  segmentCount:          number,
  segmentDuration:       seconds (Δt),
  totalDuration:         seconds,
  contentType:           enum { VIDEO, AUDIO, MIXED, IMAGE_SEQUENCE }
}
```

### 59.2 Dual-Axis Equation Set — History Inward, Engagement Outward

Two forces act on every media segment. They are **orthogonal and independent**. This is the same dual-axis model that governs all Relay branches, applied specifically to media content.

**Axis 1 — Radial Position (r): History + Lifecycle + Stability**

Radial position is governed by edit activity, lifecycle state, and production stability. Engagement does not move `r`.

**Stability function** (per segment filament F at time t):

```
editCountWindow(F, t, W) = number of MEDIA_EDIT commits in window W (default 30 days)
approvalPresent(F)       = 1 if APPROVAL evidence commit exists, else 0
qualityConfidence(F)     = orgConfidence for this segment (production QA evidence completeness)

stability(F, t) = clamp(
    0.5 * approvalPresent(F)
  + 0.3 * qualityConfidence(F)
  + 0.2 * (1 - min(editCountWindow(F, t, W) / editCap, 1)),
  0, 1
)
```

Where `editCap` is a template parameter (default: 20 edits per window).

**Lifecycle-to-base-radius mapping** (consistent with §4.3):

| State | r_base |
|-------|--------|
| SCHEDULED | 1.0 |
| OPEN | 1.0 |
| ACTIVE | 0.75 |
| HOLD | 0.6 |
| CLOSED | 0.3 |
| ABSORBED | 0.0 |

**Radial position equation:**

```
r(F, t) = r_base(state(F)) × (1 - k_stab × stability(F, t))
```

Where `k_stab ∈ [0,1]` is a template constant (default: 0.5). Stable, approved segments migrate inward within their lifecycle zone faster. Unstable segments remain nearer the bark even if older.

**Invariant: `r(F, t)` never increases due to engagement. Only commits can change it.**

**Axis 2 — Magnitude / Engagement (m): Heat and Thickness**

Engagement is a field over the L-axis (the content timeline). For each segment filament F:

```
E(F, t) = w1 × uniqueViewers
         + w2 × watchTimeSec
         + w3 × replays
         + w4 × pauseCount
         - w5 × skipCount
```

All terms computed per timebox and rolled into TimeboxAggregate for the media branch. Default weights: `w1=1.0, w2=0.1, w3=2.0, w4=0.5, w5=0.3` (all Category A global parameters).

**Engagement affects only these rendering outputs:**

- **Thickness / glow intensity** at the segment's L position
- **Heat color overlay** at the segment's L position (per §3.16)
- **Presence markers** (viewer dots) anchored at L during active playback sessions

**Engagement does not affect:** lifecycle state, radial position, archival compression, or timebox membership.

**The invariant (frozen):**

```
Radial axis (r) = history + lifecycle + commits → inward only
Magnitude axis (m) = engagement + attention → thickness and heat only
These axes are orthogonal. They never cross-contaminate.
```

History always goes inward. Engagement makes sections thicken and glow — not float.

### 59.3 Single-Instance Circulation — The Governed Copy

A digital media object in Relay behaves like a physical object. It can be purchased, lent to friends, watched together, and returned — but it cannot be silently duplicated beyond the rights holder's copy cap.

**This system only operates on media where the rights holder has opted in by publishing through Relay with explicit governance parameters.** Relay does not impose this model on external content. It does not override external IP law. It provides a superior voluntary alternative.

**Two layers:**

**A. Storage Layer**

Only one encrypted master copy exists in content-addressed storage. All viewers stream from the same `contentHash`. No per-viewer duplication occurs. Storage incentives naturally reward shared viewing over redundant copies.

**B. Access Token Layer**

Each playback session requires an `AccessLeasePacket`:

```
AccessLeasePacket {
  objectId:            string,
  leaseHolderUserId:   string,
  leaseStart:          ISO-8601,
  leaseEnd:            ISO-8601,
  maxConcurrentViewers: number (for shared viewing / "couch mode"),
  transmissionMode:    enum { PRIVATE_VIEW, SHARED_STREAM },
  commitId:            string (this packet IS a filament commit),
  sourceLeaseId:       string | null (if borrowed from another user's copy)
}
```

The lease packet is a committed, auditable filament on the media object's access branch. It is counted against `maxConcurrentCopies`.

**Circulation rules:**

| Scenario | Lease Behavior |
|----------|---------------|
| Owner watches alone | 1 lease consumed. `transmissionMode = PRIVATE_VIEW` |
| Owner invites 3 friends (same location) | 1 lease consumed. `maxConcurrentViewers = 4`. Same proximity channel. |
| Owner shares with remote friend | 2 leases consumed (1 owner + 1 remote). `transmissionMode = SHARED_STREAM` for remote viewer. |
| Remote friend shares further | Blocked if `totalLeases >= maxConcurrentCopies`. Queued if cap reached. |
| Lease expires | Lease filament migrates inward. Slot freed. |

**Global copy cap:**

`maxConcurrentCopies` is a governance parameter set by the rights holder on the MediaObject. The rights holder can adjust it at any time (raise to sell more, lower to create scarcity). This is a Category A parameter (§11.6) — the rights holder sets the initial value; community governance does not override it (this is a per-object owner parameter, not a global community parameter).

**Economic incentive:**

- Each active copy consumes storage budget and circulation budget
- Fewer copies = lower storage cost = leaner media branch
- Shared viewing (couch mode) is cheaper than individual copies
- The tree visually shows thick trunk for owned copies, thin trunk for efficient shared circulation
- The system naturally rewards lending over hoarding

### 59.4 Viewer Presence — Watching Is Traversal

When someone watches a video in Relay, they do not "press play." They **traverse the branch along the L-axis.**

**L-axis = playback timeline:**

```
l_content(s) = segIndex / (N_segments - 1)    normalized 0..1 along the branch
l(F)         = L_max × l_content(segOf(F))     mapped to actual branch length
```

The base of the branch (trunk side) is the opening. The tip is the end. When playback starts, the viewer is placed at `l = 0` and moves outward as the content progresses.

**Each viewer generates a session filament:**

```
ViewSessionFilament {
  sessionId:           string,
  userId:              string,
  objectId:            string,
  currentLPosition:    number (0..1, updated in real time),
  playbackSpeed:       number (0.5x to 3.0x),
  pauseState:          boolean,
  startTime:           ISO-8601,
  endTime:             ISO-8601 | null (null while active),
  segmentDwellMap:     Map<segIndex, { watchSec, replays, pauses, skips }>
}
```

**Visibility (privacy tiers):**

| Privacy Setting | What Others See |
|----------------|----------------|
| PRIVATE | Nothing. Session filament exists but is invisible to all others. |
| FRIENDS_VISIBLE | A small glowing marker at the viewer's L position, visible only to connections. |
| PUBLIC_VISIBLE | Marker visible to anyone inspecting the media branch. |

**Social watching (co-location):**

If a viewer's presence is visible, other users can:

- See where they are on the timeline (which scene they're watching)
- Jump to their L position to synchronize playback
- Join their playback session (if the viewer permits — creates a shared session with synced L)

Watch parties are not a special feature. They are co-location on the same branch at the same L coordinate. The infrastructure is the same as any shared branch inspection.

**Heat distribution along timeline:**

Engagement is not global — it is **spatial along L.** If many viewers cluster at `L = 0.75` repeatedly, that segment thickens and heats. Without analytics dashboards, the branch itself shows:

- Which scenes are rewatched (thick, hot segments)
- Which scenes are skipped (thin, cool segments)
- Which scenes cause abandonment (viewer markers disappearing)
- Where commentary forks cluster (derivative branches sprouting at specific L coordinates)

### 59.5 Relay Creative License System

Every media filament carries explicit license metadata. Relay does not assume ownership, override external IP law, or force openness. It provides a transparent, deterministic license framework that rights holders opt into.

**License types:**

| License | Derivatives | Commercial Use | Attribution | Description |
|---------|------------|---------------|------------|-------------|
| `RELAY-OPEN` | Unlimited | Yes | Required | Fully remixable. Derivatives auto-link to source. |
| `RELAY-NONCOMM` | Unlimited | No | Required | Remix allowed, no commercial exploitation. |
| `RELAY-ORIGIN` | Must link original | Yes | Required | Derivative must reference source segments. Revenue split applies. |
| `RELAY-CIRCULATION` | None within Relay | N/A | N/A | View-only. No derivatives permitted. Standard commercial circulation. |
| `LEGACY-COPYRIGHT` | None without external license | Per external terms | Per external terms | Relay stores provenance and hash. All rights governed externally. |

**Derivative policy per object:**

```
DerivativePolicy {
  licenseType:           enum (above),
  derivativesAllowed:    boolean,
  commercialUseAllowed:  boolean,
  attributionRequired:   boolean (always true for RELAY-* licenses),
  maxDerivativeDepth:    number | null (null = unlimited),
  royaltySplitModel:     RoyaltyModelRef | null
}
```

**What Relay enforces:**

- If someone creates a derivative without the required license, the derivative filament exists but is marked `UNLICENSED_DERIVATIVE`
- Unlicensed derivatives are not deleted (append-only)
- They are not eligible for monetization modules
- They may be filtered from public LOD at the viewer's discretion
- Their lineage is permanently visible

Relay does not censor. Relay does not police. Relay labels. The market decides.

### 59.6 Derivative Fork Economics — Segment-Level Provenance

Derivatives are not linked vaguely. They must declare **segment-level provenance** — which specific segments of the source they incorporate.

**Fork types:**

```
forkType ∈ { REMIX, FAN_EDIT, TRANSLATION, DUB, CUTDOWN,
              PARODY, SEQUEL, SPINOFF, SCORE_REPLACEMENT, COMMENTARY }
```

**Per-segment upstream reference (mandatory for RELAY-ORIGIN and RELAY-OPEN derivatives):**

```
UpstreamRef {
  sourceProjectId:   string,
  sourceSegIndex:    number,
  overlapPct:        number (0..1),
  overlapMethod:     enum { HASH_EXACT, PERCEPTUAL_HASH, MANUAL_DECLARED },
  evidenceCommitId:  string
}
```

**Credit share per view session:**

When a viewer watches derivative project P1, the system computes how much of that viewing is attributable to upstream sources:

```
For each watched segment seg_i with watch time wt_i:
    u_i = Σ over upstreamRefs(seg_i) [ overlapPct × sourceWeight(forkType) ]

share_to_source = ( Σ (wt_i × u_i) ) / ( Σ wt_i )
Bounded to [0, 1].
```

**Source weight table (Category A global parameters, initial values):**

| Fork Type | sourceWeight |
|-----------|-------------|
| TRANSLATION / DUB | 0.80 |
| FAN_EDIT | 0.50 |
| REMIX | 0.40 |
| CUTDOWN | 0.60 |
| COMMENTARY | 0.20 |
| PARODY | 0.15 |
| SEQUEL / SPINOFF | 0.10 |
| SCORE_REPLACEMENT | 0.30 |

**Economic flow:**

Each view session emits a `TransferPacket` (§31.1) + `ResponsibilityPacket` (§31.2):

- Viewer's engagement credit wallet debits
- Derivative creator wallet credits `(1 - share_to_source)` of the session value
- Source creator wallet(s) credit `share_to_source`, split proportionally across upstream segment owners by their `overlapPct` density

This is not copyright enforcement. It is native attribution revenue splitting based on explicit, auditable segment mapping. The mapping is evidence. The evidence is committed. The split is deterministic.

**Anti-gaming constraint:** A derivative cannot claim upstream linkage without evidence. `ForkEdge` requires: upstream segment refs + `overlapMethod` + hash proofs or attestations. If mapping is absent or vague (no segments linked), `share_to_source = 0`. No free-riding on upstream attribution.

### 59.7 Media LOD Thresholds

Media branches use four sub-levels within the existing LOD framework (§33.5). These prevent primitive explosion while allowing full granularity on inspection.

| Media LOD | Altitude Threshold | What Renders | Max Primitives |
|-----------|-------------------|-------------|---------------|
| MEDIA-TREE | > 50 km | Branch as normal cylinder. Overall project heat band. Twig/wilt/scar indicators. No segment detail. | 1 branch primitive + 1 heat band |
| MEDIA-BRANCH | 5 km – 50 km | Scene bands (30–120s chunks). Hot strips along L. Viewer presence as single dot per active session. | ≤ 500 scene strips |
| MEDIA-SEGMENT | 200 m – 5 km | Segments at Δt resolution (1s or 2s). Segment ribbons, scars (edits), confidence/fog. Viewer presence marker moving along L. | ≤ 2,000 visible segments (within sight radius window) |
| MEDIA-FRAME | < 200 m (or explicit "Inspect Frames" action) | Frames in a narrow window around focus. Rendered as flat texture panel / canvas layer — NOT as Cesium primitives. | 0 Cesium primitives for frames |

**Sight radius window for segments:**

At MEDIA-SEGMENT LOD, only segments within a sliding window around the viewer's focus are rendered:

```
windowSeconds = 120 (±60 seconds from focus point)
maxRenderedSegments = windowSeconds / Δt
```

With `Δt = 1s` → 120 visible segments. With `Δt = 2s` → 60. Everything outside the window collapses into scene-level heat strips.

**Frame rendering rule (frozen):** Frames never instantiate as Cesium primitives. Ever. They are a UI / texture-atlas problem, not a world-primitive problem. At MEDIA-FRAME LOD, the branch bark unrolls into a 2D inspection panel (consistent with §3.3 zoom-to-flat transition) and frames render as a canvas texture strip within that panel.

### 59.8 Audio, Music, and Temporal Content

Audio follows identical physics. The content type determines only the bark rendering at CELL LOD (per §3.2 table: `Music / audio → Waveform or notation → Milestone sinking`).

**Audio-specific mappings:**

| Concept | Audio Equivalent |
|---------|-----------------|
| Scene | Track / movement / act |
| Segment | Verse, chorus, bridge, outro (or fixed Δt windows) |
| Frame cluster | Beat / measure (inspection-only, never Cesium primitives) |
| Hot segment | High-replay section (chorus that gets replayed → thickens and heats) |
| Derivative fork at L | Remix branching off at a specific timestamp (e.g., "remix of the bridge at 2:34") |
| Cross-section ring | Production session / mix version / remaster epoch |

**Music composition workflow:**

A producer working on an album has a media branch where:

- Each track is a scene-level filament
- Each segment records takes, mixes, and overdubs as commit depth (radial layers)
- Approval commits (producer sign-off, mastering certification) drive stability and inward migration
- The cross-section shows production density: thick rings = intense recording periods, thin rings = quiet periods
- Scars = rejected takes or recalled mixes

Listener engagement after release follows the same dual-axis model: engagement thickens and heats segments but does not move their radial position. The producer's original recording session (the "sticky note posted in Hollywood") sinks inward over time as heartwood. Engagement illuminates history — it does not rewrite it.

### 59.9 Engagement Geography — Wind, Heat, Lightning on Media

Media branches respond to the same force equations (§3.19) as all other branches. Engagement creates directional pressure.

**Wind (lean):**

If viewers of a film cluster geographically — e.g., a movie becomes popular in South America — the branch leans toward that region. This is computed from the angular distribution of viewer session origins mapped to counterparty θ (§3.15). The lean is small (capped per contract #114), observable during replay, and explainable to one click: "This branch leans southwest because 68% of its viewers are in Brazil and Argentina."

**Heat:**

Segment-level heat (`dE/dt` over timebox windows) renders as heat color overlay along the branch. A newly released film with explosive viewership shows a uniformly hot branch. Over time, heat concentrates at rewatched segments while skipped segments cool.

**Lightning cascades (§3.16):**

If a clip goes viral — sudden engagement spike at a specific L position — lightning appears. The trigger: that segment spawns derivative clips, reaction videos branch off, commentary forks appear, cross-language translations spike. The lightning radiates from that L coordinate across multiple trees. This is visible propagation of cultural impact, not decoration.

**Fog:**

Fog on media branches represents **production evidence deficit**, not unpopularity. A segment with no QA approval, no mastering certification, and no production evidence is foggy regardless of how many people watched it. High engagement does not reduce fog. Only evidence commits reduce fog. This preserves the separation: fog = confidence, heat = engagement.

### 59.10 Storage Discipline and Archival Compression

**Single-master principle:**

The encrypted master file is stored once. `contentHash` is the canonical reference. Viewers stream from this single source. No per-viewer copies are created. Session filaments (ViewSessionFilament) are lightweight commit records, not content duplicates.

**Archival compression:**

Media follows the same five-layer replay compression strategy (§48.4.3):

1. Per-segment engagement aggregates compress to timebox summaries
2. Old session filaments migrate inward and compress (warm → cold → heartwood)
3. The master file itself undergoes codec-level archival compression after a configurable age threshold
4. Merkle checkpoints seal engagement history at epoch boundaries
5. Regional federation sharding distributes storage geographically by viewer concentration

**Economic incentive structure:**

- Each copy stored against `maxConcurrentCopies` consumes measurable storage budget
- The media branch visually shows storage efficiency: thick branch = many redundant copies, thin branch = lean shared circulation
- Rights holders who set lower copy caps reduce their storage footprint and increase scarcity value
- Rights holders who raise copy caps increase accessibility and earn from broader circulation
- The balance between copies sold and copies demanded is a visible market signal on the branch: if `maxConcurrentCopies` is consistently saturated (all leases active), the owner sees a hot, fully-utilized branch and knows demand exceeds supply

### 59.11 Cross-Section of a Media Branch

Cut the media branch perpendicular to its axis. The cross-section (§3.4) reveals:

**Radial rings = production epochs:**

- Outermost ring = current release version (CLOSED, post-release)
- Middle rings = production sessions (ACTIVE → CLOSED during production)
- Inner rings = early drafts, pre-production concepts (ABSORBED)
- Core = original concept / first commit (heartwood)

**Angular sectors = viewer/contributor geography:**

- Viewer origins map to counterparty θ
- A film watched mostly from Europe shows dense angular sectors in the European bearing range
- Production contributors (actors, crew, editors) appear as separate angular signatures during production phases

**Color/opacity = engagement magnitude and production confidence:**

- Hot (red) segments = high engagement
- Cool (blue) segments = low engagement
- Solid = high production confidence (well-evidenced, QA-approved)
- Transparent = low confidence (unverified, missing approvals)

A remaster is a schema ridge — a discontinuity in ring structure where a new production epoch begins on top of old rings. A censorship event is a scar. A director's cut is a fork. All are permanent, readable in cross-section.

### 59.12 How This Connects to Existing Modules

**§3.2 content-type table:** This section formalizes what "Music / audio" and "Images / CAD / visual media" mean at every LOD level, not just CELL LOD bark rendering.

**§21.2.9 Media Production template:** The existing template (`creative`, `production`, `talent`, `distribution`, `marketing`, `legal`, `finance` branches) now has a formal circulation and viewing model. The `barkRenderMode: media` with `lAxisMapping: timelinePosition` specified in §21.2.9 maps directly to §59.2's longitudinal position equation.

**§31 Accounting Packets:** View sessions emit the same TransferPacket + ResponsibilityPacket as financial transactions. The royalty split in §59.6 uses the same zero-sum posting rules. The derivative credit share is a deterministic posting — not a separate payment system.

**§57 Adoption Tiers:** Media objects at Tier 0 = hash of external content (foggy but tamper-evident). Tier 1 = mirrored metadata from external distribution platform. Tier 2 = dual tracking in Relay and external platform. Tier 3 = fully Relay-native with circulation, leasing, and derivative economics. All tiers coexist on the same media branch.

**§58 Education:** Educational content (lectures, tutorials, demonstrations) IS media governed by §59. Teacher explanation filaments (§58.3) are media filaments with the same dual-axis physics, the same viewer presence model, and the same engagement-to-magnitude mapping. The difference is only in the template (education template vs. entertainment template) — not in the underlying physics.

**§38 Module Discovery:** The media circulation system is itself a module. Users discover it by demonstrating competence with filament lifecycle, branch governance, and accounting packets. There is no "media tier" or "entertainment stage."

**Contract #143 — Single-instance circulation is the only media distribution model in Relay.** A media object has exactly one encrypted master file identified by `contentHash`. All playback sessions stream from this single source. `AccessLeasePacket` commits track every active lease. `maxConcurrentCopies` is a per-object governance parameter set by the rights holder. When the cap is reached, additional access requests queue. No per-viewer file duplication occurs. Lease expiry frees slots. The system incentivizes shared viewing (fewer leases consumed) over individual copies. Relay does not impose this model on external content — it operates only on media published through Relay with explicit governance parameters.

**Contract #144 — Radial position and engagement are orthogonal on media branches.** The radial axis (`r`) is governed exclusively by lifecycle state, production stability, and commit depth. The engagement axis (`m`) is governed exclusively by viewer activity (dwell time, replays, pauses, skips) and derivative fork count. Engagement never moves a segment's radial position. Commits never change engagement weight. `r` controls where a segment sits in the cross-section rings. `m` controls thickness, heat, and glow. These two axes never cross-contaminate. This is the same invariant as all other Relay branches, explicitly frozen for media to prevent any future system where popularity overrides history.

**Contract #145 — Derivative forks must declare segment-level provenance.** A derivative media project that claims upstream linkage must map specific derivative segments to specific source segments with `overlapPct` and `overlapMethod` (hash exact, perceptual hash, or manual declaration with evidence). Credit share per view session is computed deterministically from these mappings using the `sourceWeight` table by fork type. If no segment-level mapping is provided, `share_to_source = 0` — no upstream credit flows. The mapping is a committed evidence chain, auditable by any party. This prevents both free-riding (claiming credit without evidence) and ghost attribution (vague links without substance).

**Contract #146 — Frames never instantiate as Cesium primitives.** At MEDIA-FRAME LOD (< 200m altitude or explicit inspect action), individual frames render in a 2D inspection panel (flat canvas / texture atlas) using the §3.3 zoom-to-flat transition. Zero Cesium Entity or Primitive objects are created per frame. The world-primitive budget at MEDIA-SEGMENT LOD is capped at 2,000 visible segments within the sight radius window. Scene-level LOD (MEDIA-BRANCH) is capped at 500 strips. MEDIA-TREE uses 2 primitives total (branch + heat band). These caps are Category A global parameters.

---

## 60. Fractal Branching — Any Branch Can Host a Full Tree — Frozen Contracts #148–149

> *"In every walk with nature, one receives far more than he seeks."* — John Muir

**Prerequisites:** §22 (fractal scaling), §3.18 (branch layout), §33.5 (LOD thresholds), §3.19 (universal force equations).

§22 established that a trunk at one level is a branch at the next level up (neighborhood → city → country). That describes fractal scaling **between** trees. This section formalizes the complementary rule: fractal branching **within** a tree. Any branch can host child branches and child trees, recursively, to arbitrary depth. A department branch can contain a course tree. A course branch can contain a unit tree. A unit branch can contain a lab tree. The recursion is unlimited. The physics are identical at every layer.

### 60.1 The Fractal Branching Invariant

**A branch is not a leaf.** A branch is a scope container that can contain:

- **Filaments** — work items, lessons, transactions, media segments
- **Timeboxes** — slab aggregates for the branch's time periods
- **Projections** — analysis branches (light blue)
- **Child branches** — sub-categories within the same scope
- **Child trees** — full sub-worlds with their own trunks, branches, filaments, and physics

A "department branch" can contain a "course tree." A "course branch" can contain a "unit tree." A "product branch" can contain a "factory tree." A "lesson branch" can contain a "quiz tree." There is no maximum depth. The recursion terminates only when there is no further sub-structure to represent.

**Schema:**

```
BranchContents {
  branchId:        string,
  nodeKind:        enum { TRUNK, BRANCH, TREE_PORTAL },
  filaments:       FilamentRef[],
  timeboxes:       TimeboxRef[],
  projections:     ProjectionRef[],
  childBranches:   BranchRef[],
  childTrees:      TreePortalRef[]
}

TreePortalRef {
  portalId:        string,
  parentBranchId:  string,
  childTreeId:     string,
  childTemplate:   TemplateRef,
  spawnEvent:      FractalSpawnEventRef,
  aggregateCache:  TimeboxAggregate (parent sees only this)
}
```

**NodeKind:**

| Kind | Meaning |
|------|---------|
| `TRUNK` | The central spine of a tree. Feeds into the parent scope (a branch on a higher-level tree, or the globe surface). |
| `BRANCH` | A standard branch extending from a trunk or parent branch. Contains filaments, timeboxes, and optionally child branches/trees. |
| `TREE_PORTAL` | A branch that hosts a full child tree. At the parent's LOD, it renders as a branch with aggregate metrics. On entry (zoom/focus), it expands into a complete tree with its own trunk, branches, and full physics. |

### 60.2 Fractal Spawn Events

Sub-trees are not created implicitly. They are spawned by explicit, auditable events:

```
FractalSpawnEvent {
  eventId:         string,
  parentBranchId:  string,
  childTreeId:     string,
  spawnType:       enum { BRANCH_SPLIT, SUBTREE_SPAWN, TEMPLATE_INSTANTIATION },
  trigger:         enum { VOLUME_THRESHOLD, COMPLEXITY_THRESHOLD, GOVERNANCE_DECISION, MANUAL },
  triggerEvidence:  commitId,
  timestamp:       ISO-8601,
  childTemplate:   TemplateRef,
  inheritedParams: ParamOverride[] (which parent parameters the child inherits)
}
```

**Spawn types:**

| Type | When Used | Example |
|------|-----------|---------|
| `BRANCH_SPLIT` | A category becomes too broad and splits into sub-branches within the same parent | `finance` splits into `finance.ap`, `finance.ar`, `finance.treasury` |
| `SUBTREE_SPAWN` | A branch needs its own internal world with independent structure | Inside `factory.operations`, spawn a `Machine-12` tree with its own maintenance, quality, and output branches |
| `TEMPLATE_INSTANTIATION` | A new scope is created from a template | Inside `education.biology01`, instantiate a `Unit 3: Cellular Respiration Lab` tree from the lab template |

**Triggers:**

- `VOLUME_THRESHOLD` — the branch exceeds a configurable filament count (Category A parameter, default: 500). The system suggests splitting. A governance commit approves or rejects.
- `COMPLEXITY_THRESHOLD` — the branch's sub-category diversity exceeds a threshold. SCV may recommend splitting.
- `GOVERNANCE_DECISION` — a human or governance vote explicitly creates the sub-tree.
- `MANUAL` — a user with branch authority creates the sub-tree directly.

All spawns are commits. All spawns are auditable. The spawn event is a permanent filament on the parent branch, marking when and why the sub-tree was created.

### 60.3 Physics Inheritance

Child trees inherit the parent's physics engine (§3.19) without modification. The ten force equations are identical at every recursion layer:

- **Radial position** — lifecycle maturity within the child tree's own coordinate frame
- **Gravity sink** — calendar time drives sinking in the child tree exactly as in the parent
- **Lean vector** — computed from the child tree's own filament θ distribution
- **Wilt** — computed from the child tree's own integrity metrics
- **Heat, fog, storm, lightning** — all computed locally within the child tree
- **Trunk mass** — the child tree's trunk mass feeds upward as the `aggregateCache` on the `TreePortalRef`

**What the parent sees:**

The parent branch does not see the child tree's internal structure. It sees only the `TimeboxAggregate` from the child tree's trunk — a single set of aggregate metrics (commit count, magnitude, confidence, heat, fog, wilt) that represent the child tree's health. This is identical to how a city tree sees a company tree: aggregate only, drill-down on focus.

**What changes inside the child:**

The child tree has its own:

- Template (may differ from parent — a lab tree inside a course tree uses a lab template)
- Branch layout (computed from the child's own `layoutKey` hashes)
- Timebox cadence (may differ — the parent course uses semester timeboxes, the child lab uses weekly timeboxes)
- Governance scope (may have its own voting population — students enrolled in that lab)

**What does NOT change:**

- The ten force equations (§3.19) — identical
- The lifecycle states (§4.3) — identical
- The append-only invariant — identical
- The cross-section encoding (§3.4) — identical
- The LOD rendering rules (§33.5) — identical

### 60.4 LOD Gating for Portals — One Layer at Full Fidelity

The critical rendering rule: **never render more than one recursion layer at full fidelity simultaneously.**

When the camera is at the parent tree's LOD:

- The `TREE_PORTAL` branch renders as a normal branch with aggregate metrics (thickness = child tree's total magnitude, color = child tree's average heat, opacity = child tree's average confidence, lean = child tree's aggregate lean)
- No internal structure of the child tree is visible
- A portal indicator (subtle visual marker) shows that this branch contains a sub-world

When the user enters the portal (zoom into the TREE_PORTAL branch past a threshold):

- The parent tree fades to context (reduced opacity, simplified rendering)
- The child tree expands to full fidelity — its own trunk, branches, filaments become visible
- The child tree's own LOD rules (§33.5) now govern what renders within it
- Navigation within the child tree works identically to any other tree

When the user exits the portal (zoom out past the threshold, or press backtick for position stack):

- The child tree collapses back to aggregate
- The parent tree returns to full fidelity

**Entry threshold:** The portal entry distance is the same as BRANCH LOD (5–50 km equivalent in the child tree's local coordinate frame). This is a Category A global parameter.

**Breadcrumb trail:** When inside a child tree, the HUD shows the full path: `Company > HR > Training > Biology 01 > Unit 3 > Lab`. Each segment is clickable to exit to that level. This uses the existing position stack mechanism (camera controller §50).

### 60.5 The Fan-Out Pattern in Time

The fractal branching rule explains a temporal pattern visible in replay:

1. **Growth phase** — a branch accumulates filaments, thickens, heats
2. **Specialization phase** — volume or complexity triggers splits. New child branches or sub-trees spawn. The parent branch fans out into multiple specialized scopes.
3. **Maturation phase** — each child scope grows independently. Some thrive (thick, firm). Some wilt (thin, foggy). Some get absorbed (collapse back into the parent as the specialization proved unnecessary).
4. **Consolidation phase** — old child scopes sink inward. The rings record the organizational structure that existed at each epoch. New child scopes spawn at the bark. The cycle repeats.

Over many years, the cross-section of a branch shows this pattern: concentric rings where each ring contains the ghost of child scopes that existed during that epoch. Some scopes are continuous threads running through many rings (stable departments). Some appear in a few rings and disappear (temporary projects). Some start small and grow to dominate (successful initiatives).

This is **organizational evolution made visible as wood grain.** You do not need an org chart history document. You look at the cross-section.

### 60.6 Examples

**Company tree:**

```
Relay Corp Tree
├── Finance (branch)
│   ├── AP (child branch)
│   ├── AR (child branch)
│   └── Treasury (child branch)
├── HR (branch)
│   └── Training (TREE_PORTAL → Training sub-tree)
│       ├── Biology 01 (TREE_PORTAL → Course sub-tree)
│       │   ├── curriculum branch
│       │   ├── delivery branches (teacher methods)
│       │   ├── Unit 3 (TREE_PORTAL → Lab sub-tree)
│       │   │   ├── data branch
│       │   │   ├── analysis branch
│       │   │   ├── grading branch
│       │   │   └── equipment branch
│       │   └── ...
│       ├── Accounting 101 (TREE_PORTAL → Course sub-tree)
│       └── ...
├── Operations (branch)
│   └── Machine-12 (TREE_PORTAL → Machine sub-tree)
│       ├── maintenance branch
│       ├── quality branch
│       ├── output branch
│       └── sensor-data branch
└── ...
```

At Company LOD: you see Finance, HR, Operations as branches. Training is a normal-looking branch on HR.

At HR LOD: you see Training as a branch. Its thickness and health reflect the aggregate of all courses inside it.

Enter Training portal: you see course sub-trees as branches. Biology 01 is thick and firm. Accounting 101 is thinner.

Enter Biology 01 portal: you see curriculum, delivery, units as branches on the course tree.

Enter Unit 3 portal: you see data, analysis, grading, equipment branches on the lab tree.

Same physics at every layer. Same rendering rules. Same equations. Only the template and governance scope change.

### 60.7 Relationship to §22 (Fractal Scaling)

§22 describes fractal scaling **between independent trees**: neighborhood → city → country. Each tree exists independently on the globe. A trunk at one level is a branch on the next level up.

§60 describes fractal branching **within a single tree**: any branch can host child trees internally. The child tree exists inside the parent branch, not as an independent globe-level entity.

Both rules use identical physics. The difference is scope:

| Rule | Scope | Navigation |
|------|-------|-----------|
| §22 Fractal Scaling | Between trees on the globe | Zoom out to see city tree, zoom in to see company tree |
| §60 Fractal Branching | Within a single tree | Enter a branch portal to see the sub-tree inside it |

They compose: a city tree (§22) contains company trees as branches. A company tree (§60) contains department sub-trees as portals within branches. A department sub-tree contains course sub-trees. The recursion is seamless.

**Contract #148 — Grading is a sortition process with fixed rubric filaments, auto-check for objective parts, peer review juries for subjective parts, and teacher spot-check for random samples plus escalations (§58.10). Jurors are selected by sortition from students who have demonstrated the module being assessed. Consensus determines the final grade; disagreement triggers escalation. Peer graders earn magnitude credit. The sortition grading pipeline scales independently of class size — a course with 10,000 students requires the same teacher effort as a course with 100.**

**Contract #149 — Any branch can contain child branches and child trees (§60). Child trees inherit identical physics and force equations (§3.19). The parent sees only aggregate metrics from the child tree's trunk. Rendering never shows more than one recursion layer at full fidelity simultaneously — portal entry is explicit (zoom/focus), portal exit collapses the child tree back to aggregate. FractalSpawnEvent commits are the only mechanism for creating child trees; all spawns are auditable. The ten force equations, lifecycle states, append-only invariant, cross-section encoding, and LOD rendering rules are identical at every recursion depth.**

---

## 61. Privacy Sovereignty & Civic Enforcement — Frozen Contracts #150–152

> *"Those who would give up essential liberty, to purchase a little temporary safety, deserve neither liberty nor safety."* — Benjamin Franklin

**Prerequisites:** §8.5 (disclosure tiers), §29 (proximity channels), §46 (sortition case resolution), §10 (pressure physics), §42 (duels), frozen contracts #40 (bystander privacy), #49 (detection mesh local-first), #52 (presence quantization), #62 (presence anti-correlation).

This section formalizes two related principles. First: the absolute boundary between private and public data in Relay — what is private is uninspectable, what is public is fully inspectable, and nothing else exists. Second: how civic enforcement works when society itself is the enforcement mechanism — citizens document violations, the system routes investigations, and enforcement workers are compensated by society through governed parameters.

### 61.1 The Privacy Boundary — Absolute and Binary

A user's tree has exactly two states of visibility for any filament, branch, or sub-tree:

**Private** — exists only on the user's tree at `disclosureTier = 0`. No other user, no SCV, no governance mechanism, no legal process within Relay can inspect it. The filament is cryptographically sealed. It contributes to the user's aggregate tree shape (the branch still has thickness from the filament's magnitude, because the aggregate is truthful per §33.4), but the filament's contents, identity, counterparty, and evidence are invisible to all external observers. Private data cannot be subpoenaed through Relay. It cannot be discovered through duel proceedings. It cannot be revealed by jury sortition. It does not exist to anyone except the user.

**Public** — exists at `disclosureTier >= 1` on the user's tree, or on any public tree (company, municipal, institutional). Fully inspectable by anyone with appropriate access per the disclosure tier rules (§8.5). Can be referenced as evidence in duel proceedings, jury cases, governance votes, and civic enforcement workflows. Public data is append-only, Merkle-sealed, and permanent. Once published, it cannot be un-published — only its disclosure tier can be raised (more visible), never lowered below the level at which it was first committed, except through cryptographic erasure (§65.1) when legally mandated under GDPR Art. 17, COPPA, or court order. Erasure destroys the CEK, rendering content permanently unreadable while preserving the Merkle hash as a tombstone.

**There is no middle state.** There is no "semi-private" or "discoverable under court order within Relay." Relay does not have a backdoor. Relay does not have an admin panel that reveals private data. The cryptographic seal is the privacy boundary, and it is absolute.

**What this means practically:**

- Your personal files, notes, drafts, and private branches are yours. They exist on your tree. Nobody can see them.
- The moment you commit something to a public branch — a company tree, a municipal tree, a published media branch — it becomes part of the shared record. It is inspectable.
- Most professional activity will be public by design: invoices, contracts, municipal filings, corporate reports, governance votes. These are public acts on public trees.
- Most personal activity can remain private by choice: personal finances, health data, private notes, draft documents. The user controls disclosure tier.

**External legal systems operate outside Relay.** A court in any jurisdiction can subpoena a user's personal devices, compel testimony, or seize hardware. Relay cannot prevent that — Relay is software, not a sovereign state. But Relay itself will never provide a mechanism to bypass the cryptographic privacy boundary. There is no API call, no admin function, no governance vote that reveals `disclosureTier = 0` data to any third party. If a court needs data, it subpoenas the user, not Relay.

### 61.2 The Public Exposure Principle — Evidence Admissibility

If you expose something publicly — by committing it to a public tree, by performing an action in a proximity channel, by broadcasting your presence, or by being filmed in a public space — that exposure is permanent evidence.

**The rule:** Only what you have publicly exposed can be used against you within Relay. Private data is inadmissible. Public data is fully admissible.

This applies to:

| Context | What Constitutes Public Exposure |
|---------|--------------------------------|
| **Duel proceedings** | Only publicly committed filaments and their evidence chains. Private tree data is inadmissible. |
| **Jury sortition cases** | Only public filaments, public governance commits, and public evidence. Jurors cannot request private data discovery. |
| **Civic enforcement** | Only evidence captured in public spaces (camera footage, proximity detection, broadcast signals). Private device data is inadmissible. |
| **Governance votes** | Only public participation history. Private branch activity does not affect vote weight or eligibility. |
| **Employment/reputation** | Only the public portion of the user tree. Employers see what the user's disclosure tier permits — nothing more. |

**The deterrent effect is structural, not punitive.** In a world where Relay proximity channels, public cameras connected to the detection mesh, and civic observers exist pervasively, most violations of social norms and laws in public spaces will be captured. Not because Relay surveils — but because the public environment is instrumented by its participants. The rational response is not to hide violations better, but to stop committing them. The privacy boundary protects your inner life. It does not protect public misconduct.

### 61.3 Civic Enforcement — Society as the Enforcement Layer

Relay does not have police. Relay does not have enforcement officers. Relay does not adjudicate crimes. External legal systems handle criminal law, courts, and incarceration.

What Relay provides is a **civic observation and routing substrate** — the infrastructure for citizens to document public violations, link evidence, tag responsible parties, and route enforcement tasks to designated civic workers.

**The workflow:**

```
1. OBSERVATION — A citizen witnesses a violation in a public space
   (e.g., driver runs a red light while on their phone at a crosswalk)

2. EVIDENCE CAPTURE — The citizen films the event using their device
   Camera footage → processed on-device (contract #49)
   → classified signal metadata: vehicle type, license plate OCR,
     timestamp, GPS coordinates, violation type

3. EVIDENCE CORRELATION — Relay correlates available public signals:
   - License plate OCR from camera footage
   - Proximity broadcast from the violator's device
     (phone WiFi, car WiFi hotspot — if broadcasting publicly)
   - Proximity channel detection (BLE/WiFi multi-signal, §29)
   - Timestamp alignment between camera footage and proximity data

4. TAGGING — The citizen creates an EVIDENCE FILAMENT on a public
   civic branch (e.g., the municipal traffic enforcement branch):
   CivicObservationFilament {
     observerUserId:     string,
     observationTime:    ISO-8601,
     location:           GPS coordinates,
     violationType:      enum (from civic violation taxonomy),
     evidenceRefs: [
       { type: VIDEO_CLIP, hash: SHA-256, captureDevice: observerDeviceId },
       { type: LICENSE_PLATE_OCR, value: "XX-123-YY", confidence: 0.94 },
       { type: PROXIMITY_CORRELATION, matchedPresenceId: string | null }
     ],
     taggedUserId:       string | null (linked only if proximity
                         correlation confirms identity publicly),
     status:             OPEN
   }

5. ROUTING — The filament appears on the civic enforcement branch.
   Designated enforcement workers (traffic control, code enforcement,
   etc.) monitor this branch as part of their work scope.

6. INVESTIGATION — An enforcement worker picks up the filament:
   - Reviews evidence (video, OCR, proximity data)
   - Confirms or disputes the violation
   - Adds investigation evidence (additional footage, witness
     statements, official records cross-reference)
   - Updates filament status: OPEN → ACTIVE → CLOSED (confirmed)
     or OPEN → ACTIVE → HOLD (disputed, escalated to sortition jury)

7. RESOLUTION — If confirmed, the filament becomes a permanent
   record on the civic branch. The tagged user's public tree
   (if identified) shows the violation as a filament. Enforcement
   consequences follow external legal systems — Relay records
   the evidence, it does not sentence.
```

**Critical constraints:**

- **Tagging requires evidence, not accusation.** A `CivicObservationFilament` with no evidence refs (no video, no OCR, no proximity correlation) has `orgConfidence = 0`. It is foggy. It sinks. It is functionally invisible. You cannot tag someone without evidence.
- **Proximity correlation is not surveillance.** Relay only correlates publicly broadcast signals. If your phone's WiFi or your car's hotspot is broadcasting its identifier publicly (as all devices do by default), that broadcast is a public signal. If you disable broadcasting, no correlation is possible from Relay's side. Contract #40 (bystander privacy) applies: non-Relay users and disabled presence are never processed.
- **The observer is also on record.** The `observerUserId` is part of the filament. False accusations are traceable. A pattern of unsubstantiated civic observation filaments (high volume, low confirmation rate) creates wilt on the observer's civic participation branch. The system self-corrects against frivolous tagging.

### 61.4 Enforcement Workers — Paid by Society

Civic enforcement in Relay is not volunteer vigilantism. It is **structured work compensated through governed economic parameters.**

**The model:**

- A municipal tree (or any organizational tree with a civic scope) has an **enforcement branch**
- The enforcement branch contains task filaments routed from civic observation filaments (§61.3)
- Designated enforcement workers monitor and process these task filaments as their job
- Compensation follows the same TransferPacket + ResponsibilityPacket model (§31) as any other Relay work

**Task types and routing:**

| Task Type | Who Handles It | Source |
|-----------|---------------|--------|
| Traffic violations | Traffic enforcement workers | Citizen observation filaments on traffic branch |
| Building code violations | Code enforcement workers | Citizen observation filaments on zoning branch |
| Environmental violations | Environmental enforcement workers | Sensor data + citizen observation filaments |
| Noise complaints | Community mediation workers | Proximity channel complaints |
| Public safety concerns | Safety enforcement workers | Citizen observation + SCV hazard detection |

**Compensation parameters:**

Each enforcement task type has a **minimum wage parameter** — a Category A global parameter (§11.6) governed by the municipal community. This sets the floor compensation for processing one enforcement task filament to completion.

```
EnforcementTaskParams {
  taskType:              enum (traffic, code, environmental, safety, ...),
  minimumWagePerTask:    number (Engagement Credits, Category A),
  maxTasksPerWorker:     number (per timebox, prevents burnout/gaming),
  requiredEvidence:      EvidenceRuleSet (what the worker must provide to close),
  escalationThreshold:   number (disputed tasks escalate to sortition jury)
}
```

Workers earn by completing tasks — reviewing evidence, confirming or disputing violations, adding investigation evidence, and closing filaments. The compensation is proportional to the quality and thoroughness of their investigation (measured by evidence completeness and subsequent appeal rate). A worker who rubber-stamps every observation without investigation will accumulate low-confidence closures, which wilt their enforcement branch and reduce their task routing priority.

**Who qualifies as an enforcement worker:**

Any user who demonstrates competence with the relevant civic module (§38 module discovery). Traffic enforcement requires demonstrated understanding of traffic law and evidence evaluation. Building code enforcement requires demonstrated understanding of zoning regulations. The education system (§58) provides the skill paths; the sortition grading pipeline (§58.10) validates competence. There is no centralized hiring — the system discovers qualified workers the same way it discovers qualified teachers.

### 61.5 The Deterrent Geometry

In a world with pervasive Relay presence, the geometry of deterrence changes:

**Before Relay:** Violations succeed when unobserved. Enforcement requires dedicated officers who cannot be everywhere. The ratio of violations to observations is high. Enforcement is expensive and inconsistent.

**With Relay:** Every citizen is a potential observer. Every phone is a potential camera. Every proximity channel is a potential evidence source. The ratio of violations to observations approaches zero in instrumented public spaces. Enforcement workers process documented evidence instead of patrolling for undocumented events. The cost per enforcement action drops because evidence arrives pre-correlated.

**The tree shows this geometrically:**

- A municipal traffic enforcement branch with many OPEN observation filaments and few CLOSED ones = overwhelmed enforcement (thick bark, many twigs)
- A branch with observation filaments that close quickly = effective enforcement (firm, healthy branch)
- A branch that thins over time = declining violations (the deterrent is working — fewer observations needed because fewer violations occur)

The deterrent effect is visible in the branch shape. Society can see whether enforcement is working by looking at the tree. No report needed. No statistics department. The tree IS the report.

### 61.6 Privacy in Duels and Legal Proceedings

Duels (§42) and sortition jury cases (§46) follow the exposure principle:

**In a duel:**

- Both participants may present evidence from public trees and public filaments
- Neither participant can compel the other to reveal private data
- SCV may analyze publicly available evidence chains but cannot access private branches
- The audience votes on publicly presented evidence only
- If one party claims evidence exists but refuses to reveal it, the branch they point to is private (invisible to the audience), and the audience draws their own conclusions from what IS visible

**In a sortition jury case:**

- The jury sees only publicly committed evidence
- No discovery mechanism exists within Relay to force private data disclosure
- If a party to the case wishes to reveal private data as evidence, they explicitly change its disclosure tier (a governance commit on their own tree, permanent and append-only)
- The act of disclosure is itself a committed event — visible, timestamped, irreversible

**The structural consequence:** In Relay, the strongest legal position is one supported by publicly committed, high-confidence evidence. A party with thick, firm, well-evidenced public branches is stronger than a party who kept everything private and has nothing to show. The system rewards transparency for those who want influence, and protects privacy for those who want solitude. Both are valid. The tree reflects the choice.

### 61.7 How This Connects to Existing Architecture

**§8.5 (Disclosure Tiers):** §61.1 elevates the existing three-tier disclosure model from a feature to a first principle. The binary private/public boundary is the absolute foundation. The tiers within the public range (Tier 1 role badge, Tier 2 named identity) are gradations of visibility detail — Tier 1 shows shapes, Tier 2 shows content. At whatever tier data is committed, it is fully inspectable to the extent of that tier. (See §71.9 for canonical tier definition and privacy granularity: per filament, per branch, per tree.)

**§29 (Proximity Channels):** §61.3 uses proximity detection as one evidence correlation signal among several. The BLE/WiFi multi-signal confirmation from §29.2 feeds into the civic observation evidence chain. Approach angle (§29.3) provides directional evidence. Anti-spoof (§29.4) prevents fabricated proximity data.

**§46 (Sortition Case Resolution):** §61.6 defines evidence admissibility rules for sortition cases — public only, no forced discovery. This is consistent with contract #68 (sortition as sole dispute resolution) and adds the privacy constraint.

**§42 (Duels):** §61.6 applies the same admissibility rule to duels. Contract #32 (duels are public filaments) already establishes that duel events are public. §61.6 extends this: the evidence presented in duels must also be public.

**Contract #40 (Bystander Privacy):** §61.3 is fully compatible. Non-Relay users are never processed. Civic observation only correlates publicly broadcast signals from Relay-present devices.

**Contract #49 (Detection Mesh Local-First):** §61.3 camera processing runs on-device. Raw video never leaves hardware. Only classified metadata (license plate OCR, vehicle type, timestamp) is transmitted. The civic observation filament contains metadata references, not raw footage.

**§11.6 (Global Parameter Registry):** Enforcement task minimum wages (§61.4) are Category A global parameters. Each municipality governs its own enforcement compensation rates.

**Contract #150 — Private data is absolutely uninspectable within Relay.** Filaments at `disclosureTier = 0` are cryptographically sealed. No user, SCV, governance mechanism, duel proceeding, jury sortition case, or civic enforcement workflow can access, inspect, reference, or reveal private data. Relay provides no backdoor, no admin function, no discovery mechanism for private data. External legal systems may subpoena the user directly — Relay itself will never provide a pathway to bypass the cryptographic privacy boundary. The aggregate tree shape remains truthful (branch thickness from private filaments is computed per §33.4), but individual filament contents at Tier 0 are invisible to all external observers.

**Contract #151 — Only publicly exposed data is admissible as evidence within Relay.** In duel proceedings, sortition jury cases, civic enforcement workflows, governance votes, and any other Relay process that evaluates evidence, only filaments committed at `disclosureTier >= 1` are admissible. Private data cannot be compelled, discovered, or referenced. A party may voluntarily raise their disclosure tier to present evidence — this act is itself a permanent, append-only commit. The system rewards transparency for those who seek influence and protects privacy for those who choose solitude. Both positions are structurally valid.

**Contract #152 — Civic enforcement is structured work compensated through governed parameters.** Civic observation filaments (§61.3) require evidence references to achieve non-zero confidence — accusations without evidence are structurally invisible. Enforcement workers process observation filaments as compensated tasks with minimum wage set by municipal community governance (Category A parameter). Observer identity is always recorded on civic observation filaments — false accusations are traceable and create wilt on the observer's participation branch. Proximity correlation uses only publicly broadcast signals; non-Relay users and disabled presence are never processed (consistent with contract #40).

---

## 62. Universal Accessibility — The Tree for Every Body — Frozen Contract #154

> *"The power of the Web is in its universality. Access by everyone regardless of disability is an essential aspect."* — Tim Berners-Lee

**Prerequisites:** §33.5 (LOD rendering), §25 (2D/headless parity), §47 (voice input pipeline), §16 (SCV).

Relay is a 3D spatial system. A 3D spatial system that excludes blind, deaf, motor-impaired, or color-blind users is a broken tree. Accessibility is not a bolt-on compliance layer — it is a structural invariant. Every interaction in Relay must have a non-visual, non-auditory, and non-motor-intensive alternative path. The tree is the same for everyone. The rendering adapts to the body.

### 62.1 Accessibility Layers

Relay provides four parallel interaction layers. Every feature must function through at least two of them:

| Layer | Who It Serves | How It Works |
|-------|--------------|--------------|
| **Visual** (default) | Sighted users | 3D globe, branches, bark, filaments, cross-sections — the full spatial rendering |
| **Auditory** | Blind / low-vision users | Sonification of tree structure, spatial audio positioning, screen reader integration |
| **Tactile** | Motor-impaired / deafblind users | Keyboard navigation, switch access, braille display output, haptic device integration |
| **Simplified Visual** | Color-blind / cognitive accessibility | High-contrast modes, pattern-based encoding (replacing color), reduced-motion rendering |

### 62.2 Screen Reader & Semantic Tree

The 3D tree has a parallel **semantic tree** — a structured accessibility DOM that mirrors the spatial layout:

```
SemanticTreeNode {
  nodeId:           string (matches spatial node),
  label:            string (human-readable: "Company trunk, 47 branches, 12,000 filaments"),
  role:             enum { TREE, BRANCH, BARK_SURFACE, FILAMENT, CROSS_SECTION, TIMEBOX },
  depth:            number (nesting level from trunk),
  childCount:       number,
  stateDescription: string ("branch is healthy, leaning 12° toward supplier sector,
                             3 twigs, no scars, moderate heat"),
  confidence:       number (orgConfidence + globalConfidence summary),
  navigationHints:  string[] ("press Enter to zoom into branch", "press Tab to next sibling")
}
```

Screen readers traverse this semantic tree the same way they traverse HTML. The spatial position, health state, lean direction, and physics of every node are expressed as descriptive text. A blind user navigating a company tree hears: "Finance branch. Thick. Firm. Leaning slightly toward European suppliers. Two scars — one from Q2, one from last month. Three active twigs. Press Enter to inspect cross-section."

### 62.3 Sonification — Hearing the Tree

For users who opt into auditory mode, the tree produces sound:

| Tree Property | Sound Mapping |
|---------------|--------------|
| Branch thickness | Volume (thick = louder, thin = quieter) |
| Branch health | Tone (firm = clear tone, wilting = dampened/muffled) |
| Heat | Tempo (high heat = rapid pulse, cold = slow pulse) |
| Fog | Static/noise overlay (more fog = more static) |
| Storm | Low rumble, increasing intensity |
| Lightning | Sharp click/crack |
| Lean direction | Stereo panning (lean left = sound shifts left) |
| Depth in tree | Pitch (deeper = lower pitch, surface = higher pitch) |
| Filament lifecycle | Musical note sequence (OPEN = ascending, ABSORBED = descending, HOLD = sustained drone) |

**Spatial audio** places sounds at their 3D position relative to the user's navigation point. Moving through a tree is an auditory experience: healthy branches ring clearly, wilting branches muffle, storms rumble in the distance, and scars produce brief dissonant tones when passed.

Sonification parameters are Category A global parameters (§11.6). The community governs the sound design — which pitches, which timbres, which mappings — through the same voting model as all other system constants.

### 62.4 Motor-Impaired Access

All interactions that require mouse movement, click precision, or rapid input have keyboard and switch-access alternatives:

- **Full keyboard navigation**: Tab/Shift-Tab moves between branches and filaments. Arrow keys navigate within a branch (up/down = L-axis, left/right = θ rotation). Enter = zoom in. Backspace = zoom out. All camera controller keybinds (§50) have keyboard alternatives.
- **Switch scanning**: A single-switch or dual-switch scanning interface that cycles through navigation options at a configurable pace. The user activates when the desired option is highlighted.
- **Dwell control**: For users who can move a pointer but cannot click — hovering on an element for a configurable duration (default: 1.5s) triggers activation.
- **Voice control**: The full voice pipeline (§47) is the primary input for users who cannot use keyboard or mouse. Every interaction in Relay is voice-accessible through the Whisper → Architect → Canon pipeline.

### 62.5 Color-Blind and Reduced-Vision Modes

Relay's visual encoding relies heavily on color (heat = red/orange, fog = blue-gray, confidence = green/amber, wilt = brown, scar = red, projection = light blue/lavender). For color-blind users:

- **Pattern overlay mode**: Instead of color alone, each state adds a distinct pattern (heat = diagonal stripes, fog = dots, wilt = wavy lines, scar = crosshatch, projection = dashed outline). Patterns are perceivable regardless of color vision.
- **High-contrast mode**: Black background, white branches, with state encoded by brightness and pattern. No color information required.
- **Adjustable color palette**: Users can remap any color assignment. Protanopia, deuteranopia, and tritanopia presets are provided. Custom palettes are stored on the user tree as preference filaments.
- **Text label mode**: Every visual state can optionally display a text label instead of relying on visual encoding alone. "FIRM" / "WILTING" / "HOT" / "FOGGY" labels appear next to branches when enabled.
- **Reduced motion**: All animations (globe rotation, branch sway, sinking, helix twist) can be paused or reduced to stepped transitions. Motion-sensitive users see the same data as static snapshots with explicit state labels.

### 62.6 Accessibility as Template Configuration

Templates (§21) include an `accessibilityProfile` field:

```
AccessibilityProfile {
  requiredLayers:     enum[] { VISUAL, AUDITORY, TACTILE, SIMPLIFIED_VISUAL } (minimum: 2),
  sonificationMap:    SonificationConfig (overrides for domain-specific sound mappings),
  keyboardShortcuts:  KeybindMap (domain-specific keyboard shortcuts),
  screenReaderLabels: LabelOverrideMap (domain-specific terminology for semantic tree nodes),
  minimumContrastRatio: number (default: 4.5:1, WCAG AA),
  reducedMotionDefault: boolean (default: false, true for medical/accessibility templates)
}
```

A medical template might require auditory + visual layers and use medical terminology in screen reader labels. A gaming template might use spatial audio mappings tuned for combat feedback. The template system (§21) governs domain-specific accessibility the same way it governs domain-specific evidence rules.

### 62.7 Compliance Standards

Relay targets:

- **WCAG 2.2 AA** as the minimum for all public-facing interfaces (2D fallback, web client, headless mode per §25)
- **WCAG 2.2 AAA** for text alternatives, audio descriptions, and keyboard navigation
- **Section 508** compliance for government/institutional deployments
- **EN 301 549** for European accessibility requirements
- **Sonification follows ISO 7731** (auditory danger signals) for storm/lightning alerts

Accessibility compliance is tested through automated audits (Lighthouse, axe-core) run as part of the CI pipeline (§48.8). Accessibility regressions are treated as severity-1 bugs — they block deployment.

**Contract #154 — Every interaction in Relay must function through at least two of four accessibility layers (visual, auditory, tactile, simplified visual). The 3D tree has a parallel semantic tree for screen reader traversal. Sonification maps tree physics to sound. Motor-impaired access provides keyboard, switch, dwell, and voice alternatives for all interactions. Color-blind modes use pattern overlays and remappable palettes. Accessibility profiles are template-configurable. WCAG 2.2 AA is the minimum compliance target. Accessibility regressions block deployment.**

### 62.8 UI Internationalization — The Interface Speaks Every Language

§56 defines Language Trees — how languages themselves are tracked as data within Relay. But language-as-data is different from language-as-interface. A planetary system requires that the UI itself — labels, menus, error messages, HUD elements, onboarding text, SCV prompts, and governance interfaces — renders correctly in every writing system and locale.

**Structural requirements:**

- **Bidirectional text (BiDi):** Arabic, Hebrew, and other RTL scripts must render correctly in all UI elements — HUD panels, search bars, governance interfaces, filament labels, branch names. Layout must mirror for RTL locales (navigation, reading order, progress direction).
- **CJK rendering:** Chinese, Japanese, and Korean scripts require proper glyph rendering, line-breaking rules (no breaks mid-character), and vertical text support where culturally expected.
- **Locale-specific formatting:** Numbers (1,000 vs 1.000), dates (MM/DD vs DD/MM vs YYYY-MM-DD), currencies, calendar systems (Gregorian, Hijri, Hebrew, Buddhist), and measurement units adapt to user locale.
- **String externalization:** All user-facing text is externalized into locale files. No hardcoded strings in rendering code. The SCV's T0 deterministic messages and T1/T2 natural language outputs respect the user's locale setting.
- **Pluralization and gender:** Locale-aware plural rules (English: 1 item / 2 items; Arabic: singular / dual / plural; Polish: complex plural categories) and grammatical gender where required by the language.

**Governance:** UI locale files are community-maintained. Translation quality is tracked as a branch on the language governance tree — translations have confidence (verified by native speakers), can wilt (if source text changes and translation is not updated), and can be voted on via standard parametric governance. Machine translations start at low confidence; human-verified translations at high confidence.

**Integration with Language Trees (§56) and SphereCore (§103):**

UI translation is not a separate system from Relay's language architecture — it is wired directly into it:

- **Every UI string maps to a SphereCore semantic anchor (§103.2).** The concept behind "Save," "Cancel," "Submit Motion," or "View Cross-Section" exists as a language-independent anchor point. Each locale's translation is a radial connection (§103.3) from that anchor to the user's language. Translation is navigation: follow the thread inward to the concept, then outward to the target language.
- **Language Trees (§56) track translation lifecycle.** A UI string translation is a filament on the language tree for that locale. New translations start as OPEN. Community verification moves them to ACTIVE. Outdated translations (source string changed, translation not updated) begin to wilt. This means the UI translation quality is visible on the language governance tree — you can see which locales are well-maintained and which are falling behind.
- **Visual elements use voted templates.** Icons, diagrams, instructional images, and any graphical text within the Relay interface use community-governed visual templates. Each template variant (per locale or per cultural context) is a filament voted on through standard parametric governance (§11). The community decides which visual representation best communicates the concept in their region. No single cultural aesthetic is imposed globally.
- **SCV prompts are locale-native.** The SCV's natural language output (T1/T2) generates responses in the user's locale. T0 deterministic messages use the externalized locale string table. When the SCV presents branch data, filament labels, or governance options, all text renders through the same language pipeline — meaning a Hebrew-speaking user sees RTL governance interfaces with Hebrew branch labels and SCV prompts, all drawing from the same SphereCore anchors that an English-speaking user's interface draws from.

The result: every piece of text on screen — UI chrome, filament labels, branch names, SCV dialogue, governance motions, treasure chest contents, arena announcements — flows through the Language Tree and SphereCore translation pipeline. The interface does not have a "language setting" that swaps static string files. It has a living, community-governed, confidence-tracked translation system where the quality of every translation is visible on the tree and improvable by anyone.

**Contract #310 — UI Internationalization. All user-facing text is externalized and locale-adaptable. The UI renders correctly in RTL scripts (Arabic, Hebrew), CJK scripts (Chinese, Japanese, Korean), and all Unicode-supported writing systems. Locale-specific formatting for numbers, dates, currencies, calendars, and measurement units adapts to user preference. Translation quality is community-governed with confidence tracking via Language Trees (§56). Every UI string maps to a SphereCore semantic anchor (§103); translation is radial navigation from concept to language. Visual elements (icons, diagrams, instructional graphics) use community-voted templates per locale. SCV prompts, branch labels, governance interfaces, and all on-screen text render through the same language pipeline. The 3D globe, tree labels, HUD, governance interfaces, and SCV prompts all respect locale settings. No hardcoded strings in rendering code. Internationalization regressions block deployment alongside accessibility regressions (§62.7).**

---

## 63. Child Safety & Parental Governance — Frozen Contract #155

> *"It is easier to build strong children than to repair broken men."* — Frederick Douglass

**Prerequisites:** §8.5 (disclosure tiers), §11.6 (global parameter registry), §38 (module discovery), §58 (education), §61 (privacy sovereignty).

Relay is designed for all ages. A system designed for all ages that does not structurally protect children is a system that will be shut down by regulators and abandoned by parents. Child safety is not a feature — it is a constitutional constraint.

### 63.1 Age Verification & Account Types

Relay has three account classes determined at registration:

| Account Class | Age | Governance |
|---------------|-----|------------|
| **Minor (Child)** | Under 13 | Requires parental consent. Parent/guardian account linked. Parent controls all privacy, interaction, and content settings. |
| **Minor (Teen)** | 13–17 | Parental consent at account creation. Graduated autonomy — parent retains override on privacy and interaction settings but teen manages their own tree. |
| **Adult** | 18+ | Full autonomy. No parental governance link required. |

Age verification uses external identity services (§49b real-world integration). Relay does not collect or store date of birth on-chain. The verification service returns an age bracket (`CHILD`, `TEEN`, `ADULT`) and Relay records only the bracket. The user's actual birthdate is never stored in Relay's systems.

### 63.2 Parental Governance Model

A parent/guardian account has a **governance branch** linked to the child's account:

```
ParentalGovernanceLink {
  parentUserId:     string,
  childUserId:      string,
  accountClass:     CHILD | TEEN,
  permissions: {
    interactionScope:     enum { NONE, FRIENDS_ONLY, COMMUNITY, OPEN },
    contentVisibility:    enum { RESTRICTED, MODERATE, FULL },
    proximityChannels:    boolean (can the child participate in proximity channels?),
    duelParticipation:    boolean (can the child enter duels?),
    voiceChat:            boolean (can the child use voice presence?),
    mediaAccess:          enum { NONE, EDUCATIONAL_ONLY, COMMUNITY_RATED, FULL },
    purchaseLimit:        number (max engagement credits per timebox),
    moduleDiscovery:      enum { GUIDED_ONLY, RESTRICTED, FULL },
    privacyFloor:         number (minimum disclosure tier — parent can prevent child
                                  from making data public below this tier)
  },
  auditLog:              boolean (parent can see activity summary — never filament contents),
  escalationContact:     string (who receives safety alerts)
}
```

**Parental visibility is structural, not content-level.** A parent can see: which branches the child visited, how much time was spent, interaction volume, safety flag count. A parent **cannot** see: filament contents, private notes, message text, voice transcripts. This preserves the child's developing privacy while giving the parent structural oversight. The parent sees the tree shape — not the words on the leaves.

### 63.3 Grooming Prevention

Relay's proximity and presence systems (§17, §29) create structural anti-grooming defenses:

- **Interaction pattern detection**: SCV monitors interaction patterns between adult and minor accounts. Asymmetric engagement (adult initiating repeated private contact with a minor) triggers automated safety flags on the child's governance branch.
- **No private channels between adults and unrelated minors**: Direct message branches between an adult account and a CHILD account require parental approval. TEEN accounts can receive direct messages from adults but the parent is notified of new adult contacts.
- **Session duration alerts**: Extended interaction sessions between an adult and a minor outside of designated educational or community contexts trigger escalation to the parental governance contact.
- **Community moderation**: Safety observation filaments (similar to civic enforcement, §61.3) can be raised by any community member who observes concerning interaction patterns. These route to child safety enforcement workers (§61.4 model).
- **Evidence chain**: All safety flags, pattern detections, and escalations are committed as filaments with full evidence chains. False flags are detectable and traceable (observer identity is always recorded).
- **Immune detection integration (§83.5):** The immune detection trigger — which fires on heat/fog spikes, leaf promotion rate anomalies, new-account commit share exceeding 30%, and confidence drops — also applies to child safety. A sudden spike in adult-to-minor interaction volume on a branch, an anomalous new-account share in a child-oriented community, or rapid confidence drops on a minor's governance branch all trip the same immune response. The immune system does not treat child safety as a separate detection path — it is the same tripwire that protects all branches, operating identically on branches where minors participate.

### 63.4 Content Gating for Minors

Content on Relay carries **content classification metadata** (set by the publisher, verified by community):

```
ContentClassification {
  ageRating:          enum { ALL_AGES, TEEN_13, ADULT_18 },
  contentFlags:       enum[] { VIOLENCE, LANGUAGE, SEXUAL, GAMBLING, SUBSTANCE,
                               HORROR, COMMERCIAL },
  communityOverride:  boolean (community vote can reclassify if publisher misclassifies),
  verificationStatus: enum { SELF_DECLARED, COMMUNITY_VERIFIED, SCV_CLASSIFIED }
}
```

Minor accounts only see content matching their account class and parental permission settings. Content that has not been classified defaults to `ADULT_18` visibility — unclassified content is invisible to minors until classification is completed.

### 63.5 Legal Compliance Framework

| Regulation | Requirement | Relay Implementation |
|-----------|-------------|---------------------|
| **COPPA** (US, children under 13) | Verifiable parental consent, data minimization, deletion rights | Age bracket verification, parental governance link, no PII storage on-chain, cryptographic erasure (§65.1) |
| **KOSA** (US, minors under 17) | Duty of care, opt-out of algorithmic recommendations, parental tools | SCV recommendations are advisory only (never auto-switch, §58), parental governance branch, activity summary without content access |
| **EU DSA** (minors) | No profiling of minors for advertising, no dark patterns | Relay has no advertising system. No profiling. No dark patterns. Minor accounts have no engagement optimization applied. |
| **UK Age Appropriate Design Code** | Default high privacy for children, data minimization, geolocation restrictions | Minor accounts default to maximum privacy. No geolocation tracking beyond what the user explicitly shares via presence (§17). |

### 63.6 Graduated Autonomy

As a TEEN account holder approaches 18, parental governance controls progressively relax (configurable by the parent):

- **Age 13**: Parent controls all interaction and content settings
- **Age 14-15**: Parent retains override but teen manages their own tree structure, branch creation, and learning paths
- **Age 16-17**: Parent retains safety alerts and purchase limits; teen controls interaction scope and content visibility
- **Age 18**: Parental governance link is severed automatically. The teen's tree continues with all accumulated history, modules, certifications, and demonstrated competence. Nothing is lost.

The graduated timeline is configurable by the parent — a parent may grant full autonomy earlier or maintain tighter controls longer. The default timeline above is a Category A global parameter.

**Contract #155 — Minor accounts (CHILD under 13, TEEN 13-17) require age bracket verification and parental governance links. Parents see tree shape and activity structure but never filament contents. No private channels between adults and unrelated CHILD accounts without parental approval. Grooming prevention uses SCV pattern detection, session duration alerts, and community safety observation filaments. Content classification defaults to ADULT_18 for unclassified material — minors see only age-appropriate classified content. COPPA, KOSA, EU DSA, and UK Age Appropriate Design Code requirements are structurally satisfied. Graduated autonomy transfers control to the teen progressively, completing at age 18 with full tree continuity.**

### 63.7 Protected Participation Profiles — Beyond Age

Child safety (§63.1-63.6) is the most critical protected participation case, but it is not the only one. Any participant who faces elevated risk from unrestricted system interaction may activate or be assigned a **Protected Participation Profile**:

```
ProtectedParticipationProfile {
  userId:              userRef,
  profileType:         enum { MINOR, VULNERABLE_ADULT, HIGH_RISK_ONBOARDING,
                              MEDICAL_RECOVERY, SELF_REQUESTED },
  activatedBy:         enum { AGE_VERIFICATION, GUARDIAN, MEDICAL_AUTHORITY,
                              SELF_OPT_IN, GOVERNANCE_ORDER },
  constraints: {
    visibilityScope:   enum { TEAM_ONLY, ORG_ONLY, PUBLIC_RESTRICTED },
    forbiddenRoles:    string[] (e.g., ["governance.arbiter", "governance.chair",
                        "civic.enforcement"]),
    cognitiveLoadCap:  number (0-100, default 50 vs standard 80),
    sessionTimeout:    number (minutes),
    mandatoryOversight: userRef | null (guardian, therapist, case worker)
  },
  expirationPolicy:    enum { AGE_BASED, TIME_BOUNDED, SELF_REVOKE, GOVERNANCE_REVIEW },
  evidence:            filamentRef (activation justification)
}
```

**Who this protects:**

- **Minors** (automatic via §63.1 age brackets) — the existing child safety constraints map directly to this profile
- **Vulnerable adults** — individuals under guardianship, in crisis situations, or with court-ordered digital participation limits
- **High-risk onboarding** — new users in conflict zones, whistleblowers, or individuals whose tree participation carries personal safety risk. Reduced visibility prevents exposure during the critical early period.
- **Medical recovery** — users returning from crisis who opt in to reduced cognitive load and session limits
- **Self-requested** — any user can activate a self-protection profile at any time. No justification required for self-opt-in. Revocation is immediate.

The profile is a filament on the user's governance branch. It is visible to the user's SCV and any designated oversight contact. It does not appear on the user's public tree unless the user explicitly sets it to a visible disclosure tier. Protection is structural — the system enforces the constraints regardless of user behavior.

**Cross-module integration:** PPP constraints propagate to every subsystem, not just child safety:
- **Council roles (§72.11):** The `forbiddenRoles` field in PPP is enforced by the council role assignment system. A user with `governance.chair` in their forbidden list cannot be elected Chair. The engine refuses the `ROLE_ASSIGNMENT` filament.
- **Sybil defense (§84):** PPP users are treated as a protected class during fraud investigations. Down-ranking a PPP user requires elevated sortition review (double jury, higher evidence threshold) to prevent false positives from harming vulnerable participants.
- **Jury service (§85.5):** PPP `cognitiveLoadCap` and `sessionTimeout` are enforced during jury sessions. A PPP user serving on a jury has shorter session limits and mandatory breaks. Annual jury load caps are reduced proportionally to the cognitive load cap ratio (e.g., PPP cap 50 vs standard 80 → max annual hours reduced by 37.5%).
- **UI Internationalization (§62.8):** PPP users with reduced cognitive load caps receive simplified UI variants — fewer simultaneous options, larger touch targets, shorter text labels, progressive disclosure of complex features. The locale system respects PPP constraints as rendering parameters alongside language and directionality.

**Contract #308 — Protected Participation Profiles. Any user facing elevated risk from unrestricted system interaction may operate under a Protected Participation Profile with configurable constraints: visibility scope, forbidden roles, cognitive load cap, session timeout, and mandatory oversight. Profile types include MINOR (automatic per §63), VULNERABLE_ADULT, HIGH_RISK_ONBOARDING, MEDICAL_RECOVERY, and SELF_REQUESTED. Self-opt-in requires no justification and is immediately revocable. Constraints are engine-enforced — not advisory. This is the structural implementation of Edge 6 (vulnerable participants are safe) from the Eight Edges of Livability (§0.5).**

---

## 64. Voice-Driven Development — Every User Is a Developer — Frozen Contract #156

> *"Everybody is a genius. But if you judge a fish by its ability to climb a tree, it will live its whole life believing that it is stupid."* — attributed to Albert Einstein

**Prerequisites:** §16 (SCV), §47 (voice input pipeline), §19 (governance), §38 (module discovery), §58 (education).

There is no developer class in Relay. There is no separate SDK, no API portal, no third-party developer program. Every user, at every level of technical ability, is a developer within the scope of their responsibility. A banker who says "make this column sort by date" is developing. A gamer who says "change my spell animation to blue fire" is developing. A city manager who says "add a recycling tracking field to the waste management template" is developing. The voice is the IDE. The SCV is the compiler. The tree is the codebase.

### 64.1 The Voice-to-Ticket-to-Filament Pipeline

When a user speaks a change request, the following pipeline executes:

```
USER VOICE COMMAND
  "I want to add a due date field to my invoice template"
        |
        v
[Whisper] -> raw transcript (§47.2)
        |
        v
[Architect] -> structured intent (§47.3)
  IntentPacket {
    action: "template.modify",
    target: "template.invoice.personal",
    modification: { addField: "dueDate", type: "date", position: "after.amount" },
    scope: "user.personal" (within user's own tree — no governance required)
  }
        |
        v
[Canon] -> proposed tree operations (§47.4)
  ChangeTicket {
    ticketId:           "ticket.<uuid>",
    initiator:          userId,
    intentRef:          intentId,
    voiceTranscript:    "I want to add a due date field to my invoice template",
    scope:              PERSONAL | TEAM | ORGANIZATION | GLOBAL,
    proposedChanges: [
      { type: TEMPLATE_FIELD_ADD, target: templateRef, field: fieldSpec },
    ],
    status:             DRAFT,
    governanceRequired: boolean (true if scope > PERSONAL),
    estimatedComplexity: enum { TRIVIAL, MODERATE, COMPLEX, ARCHITECTURAL }
  }
        |
        v
[VISUAL PREVIEW] — Canon renders the proposed change as a lavender projection
  The user sees their invoice template with the new "due date" field
  appearing in the preview position. The change is visible but not committed.
        |
        v
[USER APPROVAL] — "Yes, do that" / "No, move it to the left" / "Cancel"
        |
        v
[COMMIT] — The change becomes a committed filament on the user's tree
  with full evidence chain: voice transcript, intent packet, change spec
```

### 64.2 Scope and Governance

The scope of a voice-driven change determines the governance path:

| Scope | Example | Governance |
|-------|---------|-----------|
| **Personal** | "Add a due date to MY invoice template" | No governance. User commits directly to their own tree. Instant. |
| **Team** | "Add a due date to our TEAM invoice template" | Team governance. The change is proposed to the team branch. Team members vote or delegate. (§19.1) |
| **Organization** | "Add a recycling field to the COMPANY waste template" | Organizational governance. Change proposal routes through the org's governance workflow. |
| **Global** | "The invoice template should require a currency field" | Community governance. Change becomes a proposal on the template's global branch. Community votes. (§19, §38) |

The user never needs to know which governance path applies. They speak. Architect parses scope from context ("my" = personal, "our" = team, "the company's" = org). Canon routes to the correct governance pipeline. If the scope is ambiguous, the SCV asks: "Did you mean for your personal template or for the team?"

### 64.3 Working with Architect and Canon — Iterative Development

For changes beyond TRIVIAL complexity, the user enters an **iterative development session** — a back-and-forth dialogue with the SCV where each refinement produces a new preview:

```
User:    "I want to redesign our department's project tracking."
SCV:     [Architect parses: COMPLEX scope=TEAM target=project_tracking]
         [Canon generates preview: current tree shape vs. proposed restructure]

         "Here's what I understand. You want to restructure the project
          tracking branch. I see three sub-branches: active, completed, archived.
          Currently they're flat. Would you like them as nested sub-trees
          with status-based routing?"

User:    "Yes, but add a fourth branch for blocked items."

SCV:     [Canon updates preview: four sub-branches now visible in lavender]
         "Added. Blocked items branch — should blocked filaments automatically
          route here when status changes to HOLD, or should it be manual?"

User:    "Automatic. And add a notification when something's been blocked
          for more than a week."

SCV:     [Canon updates: routing rule + scheduled notification trigger visible]
         "Done. Here's the complete change. Four branches, automatic HOLD routing,
          7-day block notification. This affects 23 existing project filaments
          that would be reclassified. Want me to show the migration preview?"

User:    "Show me."
SCV:     [Canon renders migration: each affected filament shown moving to its
          new branch position, with before/after comparison]

User:    "Looks good. Submit it."
SCV:     [Change ticket submitted to team governance with full evidence chain:
          voice transcripts of entire session, all intermediate previews,
          migration analysis, affected filament list]
```

The entire development session is a committed evidence chain on the user's tree. Every voice command, every SCV response, every preview iteration is preserved. Anyone reviewing the change proposal can replay the entire design conversation.

### 64.4 Filament-Level Modification

For users who want deeper control, the SCV supports **filament-level development** — modifying individual fields, evidence chains, routing rules, and template logic through voice or direct manipulation:

- **Field-level edits**: "Change the amount on invoice #4521 from 500 to 550" — Canon proposes a filament amendment with evidence (voice command + original value + new value + reason)
- **Rule creation**: "Whenever a filament on this branch exceeds $10,000, flag it for review" — Canon creates a policy filament (§19.1) with the threshold rule
- **Template modification**: "Add a dropdown field called 'priority' with values high, medium, low to this branch template" — Canon modifies the template schema and shows the preview
- **Batch operations**: "Move all filaments older than 6 months from the active branch to the archive branch" — Canon previews the batch migration with affected filament count
- **Projection creation**: "Show me a projection of revenue for Q3 based on current growth" — Canon builds a projection branch (§6) using historical data

Every modification follows the same pipeline: voice -> Architect -> Canon -> preview -> human approval -> commit. No modification bypasses human approval. No modification is invisible. The tree records everything.

### 64.5 No Developer Class

This is the critical point: **there is no boundary between "users" and "developers" in Relay.**

A grandmother who says "make the text bigger on my health branch" is using the same pipeline as an engineer who says "refactor the accounting template's evidence chain validation to include SHA-256 hash verification." The difference is complexity and scope — not access level.

Module discovery (§38) governs what a user can modify: you must demonstrate competence before modifying a complex template. But the voice pipeline is always available. A user who hasn't demonstrated template engineering competence can still request changes — the SCV will explain what's possible within their current skill level and suggest learning paths (§58) for capabilities they haven't unlocked yet.

The education system (§58) is the growth path. Certification (§58.12) unlocks professional-scope modifications. But the development tool — the voice — is universal from day one.

### 64.6 How This Connects to Existing Architecture

**§16 (SCV):** The voice-driven development session is an extended SCV interaction. The SCV's Architect parses, Canon plans, and the human approves. Contract #12 (SCVs do not execute) holds absolutely — every change requires human approval.

**§47 (Voice Pipeline):** §64 extends the voice pipeline from single commands to iterative design sessions. The pipeline is the same (Whisper -> Architect -> Canon -> Human), but the interaction may span multiple exchanges before a commit is produced.

**§19 (Governance):** All scope-based routing follows existing governance. Personal changes are instant. Team/org/global changes follow the governance pipeline. Voice-driven development does not bypass any governance constraint.

**§38 (Module Discovery):** The user's demonstrated modules determine what they can modify. Voice commands that target capabilities beyond the user's demonstrated competence are flagged by Canon as OUT_OF_SCOPE with a learning suggestion.

**§16.6 (AI Code Governance):** If the voice-driven change involves code (template logic, routing rules, validation functions), the AICodeContributionPacket (§16.6) is generated for the Canon-produced code. The same quality gates apply.

**Contract #156 — Every user is a developer within the scope of their demonstrated competence. Voice commands initiate change tickets through the Whisper -> Architect -> Canon -> Human pipeline. Change scope (personal, team, organization, global) determines governance routing — the user never needs to know which path applies. Iterative development sessions allow multi-exchange design conversations between user and SCV, with each iteration producing a visible preview. The entire development session is committed as an evidence chain. Filament-level modification is available for all field types, rules, templates, batch operations, and projections. There is no developer class, no SDK, no API portal — the voice is the IDE, the SCV is the compiler, the tree is the codebase. Module discovery (§38) governs modification scope. AI code governance (§16.6) applies to all code-generating changes.**

---

## 65. Platform Compliance & Content Safety — Frozen Contract #157

> *"With great power comes great responsibility."* — Spider-Man (concept from the French Revolution, 1793)

**Prerequisites:** §20 (cryptographic architecture), §48.4.3 (replay compression), §61 (privacy sovereignty), §63 (child safety).

Relay operates within the legal reality of multiple jurisdictions simultaneously. This section addresses the three hardest compliance challenges for a platform with an append-only Merkle chain architecture: the right to erasure (GDPR Article 17), mandatory content removal (EU DSA, CSAM laws), and intermediary liability (Section 230, EU DSA).

### 65.1 Cryptographic Erasure — GDPR Right to Erasure

Relay's append-only Merkle chain (§20) means data is never physically deleted. Every commit is permanent. This appears to conflict with GDPR Article 17 ("right to be forgotten"). The resolution is **cryptographic erasure** — making data permanently unreadable without physically removing the Merkle chain entry.

**The mechanism:**

```
CryptographicErasureEvent {
  targetFilamentId:    string,
  requesterId:         userId (the data subject, or authorized legal representative),
  legalBasis:          enum { GDPR_ART17, COPPA_DELETION, COURT_ORDER, USER_REQUEST },
  erasureMethod:       CONTENT_KEY_DESTRUCTION,
  merkleEntryStatus:   TOMBSTONE (hash preserved, content permanently unreadable),
  evidenceChain: {
    requestTimestamp:   ISO-8601,
    verificationMethod: enum { IDENTITY_VERIFIED, LEGAL_ORDER_VERIFIED },
    processingTime:     ISO-8601 (must be < 30 days per GDPR)
  }
}
```

**How it works:**

1. Every filament's content is encrypted with a unique **content encryption key (CEK)** at creation time
2. The CEK is stored separately from the filament content (Key Management System, §71.6)
3. When cryptographic erasure is invoked, the CEK is permanently destroyed
4. The Merkle chain entry remains (hash preserved for chain integrity) but the content is now permanently unreadable — it is a **tombstone**
5. The tombstone is visible in cross-section as a special state: a gray, inert mark showing that something existed here but has been erased. The tree shape accounts for the tombstone's mass (it occupied space) but the content is gone.

**What cannot be erased:**

- Aggregate metrics that do not contain personal data (branch thickness, timebox summaries)
- Hashes of the erased content (the Merkle chain needs them for integrity)
- The fact that an erasure occurred (the tombstone itself is a committed event)
- Data that other users independently committed (if Alice and Bob both committed the same fact, erasing Alice's filament does not erase Bob's — they are independent commits)

**Processing requirements:**

- Erasure requests must be processed within 30 days (GDPR) or 48 hours (COPPA for children's data)
- The system maintains an erasure audit log (itself append-only) recording every erasure event, its legal basis, and processing timestamp
- Multi-jurisdiction conflicts (e.g., a legal hold preventing erasure in one jurisdiction while another requires it) are resolved through the sortition case resolution system (§46) with legal counsel evidence

### 65.2 Mandatory Content Removal — CSAM, Terrorism, Illegal Content

Certain categories of content are illegal to host, transmit, or display under virtually all jurisdictions:

- **CSAM (Child Sexual Abuse Material)**: Mandatory detection and removal under US law (18 USC §2258A), EU DSA, UK Online Safety Act
- **Terrorism content**: EU Terrorism Content Regulation requires removal within 1 hour of notification
- **Court-ordered removal**: Specific content identified by court order for removal

**Relay's approach:**

1. **On-device classification**: Content uploaded to Relay is classified on-device before reaching the network (consistent with contract #49 — detection mesh local-first). Known CSAM hashes (PhotoDNA, NCMEC database) are checked locally. Content matching known hashes is blocked from upload with mandatory reporting to NCMEC.

2. **Network-level scanning**: Content that reaches the network is scanned against hash databases and ML classifiers as a second layer. Matched content triggers immediate cryptographic erasure (§65.1) plus mandatory reporting to the relevant authority.

3. **Community flagging**: Any user can raise a content safety observation filament (similar to civic enforcement, §61.3) flagging content as potentially illegal. Flagged content enters a review queue processed by designated content safety workers (§61.4 model). Confirmed illegal content is cryptographically erased.

4. **Terrorism content**: Content flagged as terrorism-related enters an expedited pipeline with a 1-hour processing target. Relay maintains a designated point of contact for each jurisdiction's competent authority (EU DSA Article 12).

5. **Mandatory reporting**: All CSAM detections are reported to NCMEC (US), IWF (UK), or the relevant national authority. Reporting is automated and cannot be disabled.

### 65.3 Intermediary Liability

Relay's position under intermediary liability frameworks:

| Framework | Relay's Status | Implications |
|-----------|---------------|--------------|
| **US Section 230** | Interactive computer service; good faith moderation | Protected from liability for user-generated content; must act on CSAM reporting obligations |
| **EU DSA** | Very Large Online Platform (if >45M EU users) | Transparency reports, designated compliance officer, systemic risk assessment, crisis response protocols |
| **UK Online Safety Act** | Category 1 service (if large scale) | Safety duties for illegal content and content harmful to children |

Relay's structural advantages for compliance:

- **Append-only audit trail**: Every piece of content has a verifiable creation timestamp, author attribution, and evidence chain. Takedown compliance is provable.
- **Cryptographic erasure**: Content removal is permanent and verifiable while preserving Merkle chain integrity.
- **Automated detection**: On-device + network-level scanning provides dual-layer protection before content reaches other users.
- **Community enforcement**: The civic enforcement model (§61) provides a scalable human review layer for content that automated systems cannot classify.

### 65.4 Transparency & Reporting

Relay publishes, as a governed branch on the platform tree:

- **Transparency report** (quarterly): content removal volumes, erasure requests processed, legal orders received, CSAM reports filed, false positive rates
- **Systemic risk assessment** (annual, EU DSA Article 34): identified risks to fundamental rights, public safety, and democratic processes, with mitigation measures
- **Algorithmic transparency**: Relay has no recommendation algorithm to disclose — search results are ranked by tree physics (confidence, lifecycle, engagement). The ranking formula is public and deterministic (§24).

All transparency data is a public branch on the platform tree. Anyone can inspect it. The tree IS the transparency report.

**Contract #157 — Cryptographic erasure is the mechanism for GDPR right to erasure, COPPA deletion, and court-ordered removal. Content encryption keys are destroyed; Merkle chain entries become tombstones (hash preserved, content permanently unreadable). Processing completes within 30 days (GDPR) or 48 hours (COPPA). CSAM detection uses dual-layer scanning (on-device hash matching + network ML classifier) with mandatory automated reporting to NCMEC/IWF. Terrorism content enters a 1-hour expedited pipeline. All removals are append-only auditable events. Transparency reports are published as public branches on the platform tree.**

---

## 66. Microsharding & Decentralized Storage Economy — Frozen Contracts #158–159

> *"Knowledge is of two kinds. We know a subject ourselves, or we know where we can find information upon it."* — Samuel Johnson

**Prerequisites:** §20 (cryptographic architecture), §48 (engineering infrastructure), §31 (accounting packets), §11.6 (global parameter registry), §61 (privacy sovereignty).

Relay does not store all data on central servers. Relay distributes data across the network using **microsharding** — splitting encrypted data into small redundant fragments spread across multiple nodes. Users can sell their spare storage capacity and earn from it. The storage economy is decentralized, governed by community pricing, and structurally aligned with Relay's physics: every shard is a traceable, accountable unit.

### 66.1 Microsharding Architecture

Every piece of data in Relay — filament content, media files, evidence attachments, template definitions — can be microsharded for distributed storage:

**The sharding pipeline:**

```
Original Data (e.g., a video file, a document, an evidence attachment)
        |
        v
[Client-Side Encryption]
  AES-256-GCM encryption (military-grade encryption standard) with HKDF key derivation
  The content encryption key (CEK — the secret key that locks/unlocks your data) is managed by the Key Management System (§71.6)
  Raw data NEVER leaves the device unencrypted (consistent with §61, contract #150)
        |
        v
[Reed-Solomon Erasure Coding]
  Encrypted data is split into N data shards + M parity shards
  Default: 4 data shards + 2 parity shards (tolerates loss of any 2 shards)
  Shard size: 4KB (configurable per template)
        |
        v
[Shamir's Secret Sharing for CEK]
  The content encryption key itself is split into K-of-N threshold shares
  Reconstructing the key requires K shares (e.g., 3-of-5)
  Key shares are distributed to different nodes than data shards
        |
        v
[Distributed Placement]
  Shards are placed across multiple nodes using three strategies:
  - Proximity-based (40%): shards near the user for fast retrieval
  - Regional-based (30%): shards in the user's geographic region for redundancy
  - Hash-based (30%): deterministic placement by content hash for deduplication
        |
        v
[Shard Metadata Committed as Filament]
  ShardManifest {
    contentHash:        SHA-256 of original encrypted data,
    shardCount:         number (data + parity),
    threshold:          number (minimum shards for reconstruction),
    shardLocations:     ShardLocationRef[] (node IDs, NOT content),
    keyShareLocations:  KeyShareRef[] (separate from data shards),
    replicationFactor:  number (copies per shard, default: 3),
    placementStrategy:  { proximity: 0.4, regional: 0.3, hash: 0.3 }
  }
```

### 66.2 The Storage Marketplace

Any Relay user can become a **storage provider** — selling spare disk space to the network. Any user can be a **storage consumer** — purchasing distributed storage for their data.

**Provider registration:**

```
StorageProviderProfile {
  providerId:        userId,
  availableCapacity: number (GB),
  pricing:           number (engagement credits per GB per timebox),
  uptimeHistory:     number (rolling 30-day uptime percentage),
  reputationScore:   number (computed from proof-of-storage challenges),
  geographicRegion:  string (for placement strategy matching),
  hardwareClass:     enum { CONSUMER, PROSUMER, DATACENTER },
  maxShardsPerItem:  number (maximum shards stored per unique content item)
}
```

**Three storage tiers (community-governed pricing):**

| Tier | Data Shards | Parity Shards | Key Threshold | Price Multiplier | Use Case |
|------|-------------|---------------|---------------|-----------------|----------|
| **Basic** | 3 | 1 | 2-of-3 | 1.0x | Personal files, non-critical data |
| **Secure** | 5 | 2 | 3-of-5 | 1.6x | Business documents, financial records |
| **Vault** | 8 | 3 | 5-of-8 | 2.5x | Legal evidence, medical records, archival |

Tier pricing multipliers are Category A global parameters (§11.6). The community governs storage pricing through the same democratic model as all other system constants.

### 66.3 Proof of Storage — Trust Verification

Storage providers must prove they actually hold the shards they claim to hold. Relay uses a **challenge-response proof-of-storage protocol:**

```
ProofOfStorageChallenge {
  challengeId:       string,
  targetShardId:     string,
  challengeType:     enum { RANDOM_BYTE_RANGE, MERKLE_SUBTREE, FULL_HASH },
  challengeData:     bytes (random seed for the challenge),
  responseDeadline:  ISO-8601 (default: 30 seconds),
  challengeInterval: number (default: every 5 minutes for hot shards,
                              every 1 hour for warm, every 24 hours for cold)
}
```

- Providers that consistently pass challenges maintain or improve their reputation score
- Failed challenges trigger automatic shard re-replication to healthy nodes
- Providers with uptime below 95% are flagged; below 85% triggers automatic shard migration away
- A pattern of failed challenges creates wilt on the provider's storage branch — visible to anyone evaluating storage providers

### 66.4 Sentinel Vault Storage

For vault-tier data, Relay supports **sentinel nodes** — high-reputation storage providers who hold emergency backup shards. (Note: "sentinel nodes" are storage machines. "Guardian contacts" (§48.2.2, §71.6) are trusted humans who hold Shamir key shares for account recovery. These are different systems.)

- Sentinel selection requires: reputation score > 0.8, uptime > 95%, latency < 200ms, geographic distribution (no two sentinels in the same data center)
- Minimum 3 sentinels per vault item with 2x replication
- Sentinels earn a premium compensation rate (Category A parameter)
- Sentinel failure triggers immediate replacement from the sentinel pool with zero-downtime failover

### 66.5 Storage Economy — Users Earn by Hosting

**The economic model:**

1. **Storage providers earn engagement credits** for hosting shards. Payment is per-timebox (consistent with §31 accounting packets). TransferPackets flow from the content owner's tree to the provider's tree for each timebox the shard is stored and verified.

2. **Pricing is governed democratically**. Storage pricing proposals follow the same governance model as all other Category A parameters. The community proposes price tiers; the highest-ranked proposal becomes active pricing. Constraints: max 50% price change per proposal, 24-hour cooldown between proposals, 7-day proposal lifetime.

3. **Relay fallback**: When P2P storage availability drops below a governed threshold (default: 70%), Relay infrastructure absorbs the overflow. Relay-hosted shards cost 1.5x the P2P rate (Category A parameter). This ensures data availability while incentivizing P2P participation.

4. **Passive income**: A user with spare disk space can register as a provider, configure their capacity and pricing, and earn credits while their device participates in the storage network. No technical knowledge required — the provider onboarding is a module (§38) taught in the tutorial (§58.1).

5. **Data gravity incentive**: The system structurally incentivizes efficient storage. Because every shard costs credits, users and organizations are motivated to archive, compress, and manage data lifecycle (§14, §1.3 heartwood). The storage economy makes data obesity expensive and data discipline profitable.

### 66.6 Hybrid P2P + Relay Infrastructure

The storage network is not purely P2P. It is a hybrid:

- **P2P layer**: User devices contribute storage capacity. Shards are distributed across the network. Most data lives here.
- **Relay infrastructure layer**: Relay-operated nodes serve as fallback when P2P capacity is insufficient, when data requires guaranteed SLA (medical, legal, government), or when a user's device is offline.
- **Transition**: As the P2P network grows, the Relay infrastructure layer shrinks. The system is designed to be increasingly decentralized over time. The ratio is a visible metric on the platform tree.

### 66.7 Offline-First & Low-Bandwidth Architecture

Microsharding enables a robust offline-first model. Users in low-bandwidth or intermittent-connectivity environments can operate Relay with full functionality for their local working set (network-dependent features degrade proportionally to bandwidth — see table below):

**Local shard cache:**

Every user device maintains a local shard cache containing the shards needed for their active working set. The cache operates independently of network connectivity:

```
LocalShardCache {
  cacheCapacity:       number (GB, configurable by user),
  priorityPolicy:      enum { RECENCY, FREQUENCY, MANUAL },
  offlineCommitQueue:  CommitRef[] (commits made while offline, synced when connected),
  syncStrategy:        enum { IMMEDIATE, BATCHED, SCHEDULED },
  conflictResolution:  enum { LATEST_DISPLAY, MERGE, MANUAL_REVIEW }
}
```

- **Offline commits**: Users can create, modify, and commit filaments while offline. Commits enter the `offlineCommitQueue` with local timestamps. Offline commits have local-device-only durability until sync — if the device is destroyed before connectivity is restored, those commits are lost.
- **Background sync**: When connectivity is restored, the queue syncs in chronological order. Merkle chain integrity is verified during sync. Both commits are ALWAYS preserved (append-only, Contract #1). The configured strategy determines display preference: `LATEST_DISPLAY` shows the most recent as default view, `MERGE` presents both inline, `MANUAL_REVIEW` flags for human decision. No commit is ever overwritten or discarded. (See §71.4.)
- **Progressive shard retrieval**: When navigating a tree that is not fully cached, the system retrieves shards progressively — starting with aggregate data (branch thickness, timebox summaries) and fetching detail on demand. Low-bandwidth users see the tree shape first, then content loads as shards arrive.
- **Compression**: All shard transfers use the compression pipeline (§48.4.3). Delta sync transfers only changed shards, not entire files.

**Low-bandwidth operation modes:**

| Mode | Bandwidth | What Works | What Degrades |
|------|-----------|-----------|---------------|
| **Full** | > 10 Mbps | Everything | Nothing |
| **Standard** | 1-10 Mbps | All features, media streams at reduced quality | Video presence delayed, large media downloads queued |
| **Low** | 100 Kbps - 1 Mbps | All text, commits, governance, voice (compressed) | Media cached not streamed, 3D rendering simplified |
| **Minimal** | < 100 Kbps | Text commits, offline queue sync, essential governance | No media, no 3D, 2D headless mode (§25) only |
| **Offline** | 0 | Local cache, offline commits, queued sync | No network features until connectivity restored |

### 66.8 How This Connects to Existing Architecture

**§20 (Cryptographic Architecture):** Microsharding extends the cryptographic layer. Client-side encryption uses the same Key Management System (§71.6). Merkle chain integrity is preserved — shard manifests are committed as filaments with full evidence chains.

**§48.4.3 (Replay Compression):** Sharded data participates in the same compression lifecycle. Hot shards (frequently accessed) have more replicas and faster proof-of-storage intervals. Cold shards (archived) compress to fewer replicas with longer intervals. Heartwood data (§1.3) may reduce to minimum viable shard count.

**§31 (Accounting Packets):** Storage payments use TransferPackets. Every credit flow from consumer to provider is a committed, traceable accounting event. The storage economy is fully auditable through the same accounting infrastructure as all other Relay transactions.

**§61 (Privacy Sovereignty):** Client-side encryption ensures storage providers never see content. They hold encrypted shards. Even if a provider is compromised, the data is unreadable without the CEK (which is itself Shamir-shared across different nodes). Contract #150 (private data uninspectable) holds at the storage layer.

**§59 (Media Circulation):** Large media files (video, audio) are the primary consumers of distributed storage. Single-instance circulation (contract #143) means fewer copies need storage. The storage economy and the media economy are structurally aligned: fewer copies = less storage cost = incentive for efficient circulation.

**§65 (Cryptographic Erasure):** When a filament is cryptographically erased (§65.1), the CEK is destroyed. The encrypted shards across the network become permanently unreadable tombstone fragments. No individual shard provider needs to take action — the data is already encrypted, and without the key it is noise.

**Contract #158 — All user data is client-side encrypted (AES-256-GCM) before leaving the device. Encrypted data is split into microshards using Reed-Solomon erasure coding and distributed across multiple nodes. Content encryption keys are split using Shamir's Secret Sharing with K-of-N threshold reconstruction. Key shares are stored on different nodes than data shards. Shard manifests are committed as filaments with full evidence chains. Storage providers never see unencrypted content. Proof-of-storage challenges verify shard integrity at configurable intervals. Failed challenges trigger automatic re-replication. Provider reputation is computed from challenge pass rates and uptime history.**

**Contract #159 — The storage marketplace is a decentralized economy where users sell spare capacity and purchase distributed storage. Three tiers (basic, secure, vault) with community-governed pricing (Category A parameters). Relay infrastructure provides fallback when P2P availability drops below threshold. Storage payments use TransferPackets — fully auditable through existing accounting infrastructure. The offline-first architecture enables full functionality without network connectivity through local shard caches, offline commit queues, and progressive shard retrieval. Low-bandwidth operation degrades gracefully across five modes from full to offline.**

---

## 67. Automated Business Continuity & Disaster Recovery — Frozen Contract #160

> *"By failing to prepare, you are preparing to fail."* — Benjamin Franklin

**Prerequisites:** §19 (governance), §11.6 (global parameter registry), §48 (engineering infrastructure), §66 (microsharding), §52 (business artifact mapping), §13 (stigmergic coordination).

Business Continuity Planning (BCP) and Disaster Recovery Planning (DRP) are not documents that sit in a binder. In Relay, they are **automated actions that trigger when the tree itself shows distress.** A company's tree visibly deteriorates under failure conditions — branches wilt, heat spikes, fog accumulates, storms form. BCP/DRP in Relay means configuring automated responses that fire when these tree signals cross thresholds. The tree does not just show the disaster. The tree responds to it.

### 67.1 Flag-Based Trigger Model

Companies configure **continuity triggers** — threshold conditions on their organizational tree that, when met, automatically initiate predefined response actions:

```
ContinuityTrigger {
  triggerId:          string,
  name:               string (e.g., "Supply Chain Disruption Response"),
  monitoredBranch:    branchRef (which branch to watch),
  conditions: [
    {
      metric:         enum { WILT_PERCENTAGE, HEAT_INDEX, FOG_DENSITY,
                             STORM_INTENSITY, SCAR_COUNT, TWIG_COUNT,
                             CONFIDENCE_FLOOR, FILAMENT_VELOCITY,
                             OFFLINE_NODE_COUNT, SHARD_AVAILABILITY },
      operator:       enum { GT, LT, GTE, LTE, EQ, DELTA_GT, DELTA_LT },
      threshold:      number,
      timeWindow:     duration (evaluate over this period),
      consecutiveTimeboxes: number (must persist for N timeboxes to trigger)
    }
  ],
  conditionLogic:     enum { ALL, ANY, WEIGHTED_SCORE },
  weightedThreshold:  number | null (for WEIGHTED_SCORE: trigger when combined score exceeds),
  severity:           enum { ADVISORY, WARNING, CRITICAL, EMERGENCY },
  cooldownPeriod:     duration (minimum time between re-triggers),
  responseActions:    ResponseAction[] (what happens when triggered)
}
```

**The key insight:** These triggers use the same tree physics that already exist. Wilt, heat, fog, storm, scars, twigs — these are not abstract metrics. They are the visible state of the branch. A supply chain branch that is wilting heavily, accumulating scars, and showing high fog is a supply chain in distress. The trigger simply formalizes: "when distress reaches this level, do these things automatically."

### 67.2 Automated Response Actions

When a trigger fires, it initiates one or more **response actions** — predefined operations that execute through existing Relay mechanisms:

```
ResponseAction {
  actionId:           string,
  type:               enum {
    NOTIFY,                    -- Send alerts to designated contacts
    ESCALATE,                  -- Route to governance for emergency review
    ACTIVATE_BACKUP_BRANCH,    -- Bring standby branch online
    REROUTE_FILAMENTS,         -- Redirect incoming filaments to backup branch
    FREEZE_BRANCH,             -- Prevent new commits (read-only until resolved)
    SNAPSHOT_STATE,            -- Create emergency checkpoint of current state
    INCREASE_REPLICATION,      -- Boost shard replication factor for critical data
    ACTIVATE_GUARDIAN_VAULTS,  -- Promote critical shards to vault-tier storage
    PUBLISH_STATUS,            -- Commit status filament to public/stakeholder branch
    TRIGGER_CHILD_PLANS        -- Cascade to sub-tree continuity plans
  },
  parameters:         object (type-specific configuration),
  executionOrder:     number (sequential execution within the response),
  requiresApproval:   boolean (if true, action queues for human approval before executing),
  approvalDelegate:   userId | roleRef (who can approve)
}
```

**Examples of configured BCP/DRP plans:**

| Scenario | Trigger Conditions | Automated Response |
|----------|-------------------|-------------------|
| **Supplier failure** | Supply chain branch: wilt > 40%, scars > 3 in 7 days, fog > 60% | NOTIFY procurement team, ACTIVATE_BACKUP_BRANCH (alternate supplier branch), REROUTE_FILAMENTS from failed supplier to backup, PUBLISH_STATUS to stakeholder branch |
| **Data center outage** | Infrastructure branch: offline_node_count > 30%, shard_availability < 85% | INCREASE_REPLICATION to 5x, ACTIVATE_GUARDIAN_VAULTS for all vault-tier data, SNAPSHOT_STATE for recovery point, NOTIFY IT operations |
| **Financial irregularity** | Accounting branch: scar_count delta > 5 in 24h, confidence_floor < 0.3 | FREEZE_BRANCH (prevent further commits), ESCALATE to finance governance, SNAPSHOT_STATE for audit, NOTIFY compliance officer |
| **Production line halt** | Manufacturing branch: filament_velocity drops to 0 for > 2 timeboxes, heat drops to 0 | NOTIFY plant manager, ACTIVATE_BACKUP_BRANCH (secondary production line), PUBLISH_STATUS to customer-facing branch, TRIGGER_CHILD_PLANS for dependent processes |
| **Pandemic / remote work** | Office presence branch: proximity channel activity drops > 80% within 7 days | ACTIVATE_BACKUP_BRANCH (remote operations branch), REROUTE_FILAMENTS from office workflows to remote workflows, PUBLISH_STATUS company-wide |

### 67.3 Cascading Plans — Sub-Tree Continuity

Large organizations have interconnected continuity requirements. A supply chain failure cascades to production, which cascades to delivery, which cascades to customer service. The `TRIGGER_CHILD_PLANS` action enables **cascading continuity responses**:

```
CascadePlan {
  parentTriggerId:   string,
  childTriggers:     ContinuityTrigger[] (sub-tree plans activated by parent),
  cascadeDelay:      duration (wait before cascading — allows parent resolution first),
  cascadeCondition:  enum { ALWAYS, IF_UNRESOLVED, IF_ESCALATED }
}
```

The cascade follows the tree structure. A trigger on the supply chain branch can cascade to production sub-branches, which can cascade to delivery sub-branches. Each level has its own configured response. The tree shape shows the cascade in real time: wilt propagating down branches, backup branches activating (visible as new green growth), rerouted filaments changing direction.

### 67.4 Recovery and Stand-Down

When the triggering condition resolves (the metrics return below threshold), the system enters **recovery mode**:

1. **Automated stand-down**: If configured, backup branches deactivate and filament routing returns to primary. This is reversible — the backup remains warm (not deleted) for a configurable retention period.
2. **Recovery verification**: The SCV analyzes the recovery and generates a **post-incident report** — a projection branch showing: timeline of the incident, trigger conditions met, actions taken, duration, data integrity verification, and lessons learned.
3. **Post-incident review**: The report is routed to the governance body for review. Improvements to the continuity plan are proposed as governance commits.

### 67.5 Relay Platform Disaster Recovery

Beyond organizational BCP/DRP, Relay itself has platform-level disaster recovery built on the microsharding architecture (§66):

**Recovery Point Objective (RPO):** Zero data loss for network-committed data (see §71.19). Once a filament is committed and synced to the distributed network, it exists on multiple nodes. No single point of failure can destroy committed data. Offline commits that have not yet synced have local-device-only durability.

**Recovery Time Objective (RTO):**

| Component | RTO Target | Mechanism |
|-----------|-----------|-----------|
| User data access | < 30 seconds | Shard re-routing to healthy nodes, local cache fallback |
| Governance operations | < 5 minutes | Governance state replicated across federation nodes |
| Full platform restore | < 1 hour | Merkle chain replay from distributed checkpoints |
| Media streaming | < 2 minutes | CDN fallback + shard re-routing |

**Automated failover:**

- Node failure: Proof-of-storage challenges detect within 5 minutes. Automatic shard re-replication begins immediately.
- Regional outage: Geographic distribution (§66.1 placement strategy) ensures shards survive regional failures. Cross-region shard retrieval activates automatically.
- Merkle chain corruption: Checkpoint compaction (§48.4.3 layer 4) provides recovery points. Chain replay from the last valid checkpoint restores integrity.

### 67.6 How This Connects to Existing Architecture

**§3.19 (Universal Physics):** BCP/DRP triggers use the same ten force equations that govern all tree physics. Wilt, heat, fog, storm — these are computed values, not separate monitoring metrics. The trigger system reads what the tree already knows.

**§13 (Stigmergic Coordination):** Backup branch activation and filament rerouting follow the same stigmergic principles — the tree shape changes, and workers see the change and respond. The automated response modifies the tree; humans respond to the modified tree.

**§19 (Governance):** Response actions that require approval follow existing governance. Emergency actions can be configured to require human approval or to execute immediately with post-hoc review. The governance commit records which actions fired and why.

**§52 (Business Artifact Mapping):** The continuity triggers map to existing business artifact measurements. A supply chain branch's wilt percentage IS the supply chain health metric. No separate monitoring system is needed — the dashboard IS the tree.

**§66 (Microsharding):** Platform-level DR uses the distributed shard architecture. Data survives because it is distributed. Recovery is shard re-routing, not backup restoration.

**Contract #160 — Business Continuity and Disaster Recovery in Relay are automated actions triggered by tree physics thresholds. Companies configure continuity triggers on their branches using existing metrics (wilt, heat, fog, storm, scars, twigs, confidence, filament velocity, shard availability). When thresholds are met, predefined response actions execute automatically: notifications, branch activation, filament rerouting, branch freezing, state snapshots, replication increases, sentinel vault activation, status publishing, and cascading to sub-tree plans. Recovery is automated with post-incident reporting. Platform-level DR achieves zero RPO through distributed microsharding and sub-hour RTO through Merkle chain checkpoint replay. The tree does not just show the disaster — the tree responds to it.**

---

## 68. Arena Branches — Bounded Volatility & Crowd-Driven Randomness — Frozen Contracts #161–162

> *"Well yeah, and I'm sad, but at the same time I'm really happy that something could make me feel that sad. It's like, it makes me feel alive, you know? It makes me feel human. And the only way I could feel this sad now is if I felt somethin' really good before. So I have to take the sad with the happy."* — Butters Stotch, South Park

**Prerequisites:** §40 (game layer), §41 (multi-resource economy), §42 (duels), §43 (spell taxonomy), §46 (sortition), §16 (SCV), §47 (voice pipeline), §58.12 (certification).

In StarCraft, the most compelling experience was never the strategy alone. It was the social tension produced by information asymmetry, hidden knowledge, alliance ambiguity, and the sudden revelation that reality was not what other players thought it was. That energy — the meta-game of playing the players, not just the game — is what Arena Branches capture inside Relay's physics. But the critical difference is this: in StarCraft, that tension came from secretly breaking rules. In Relay, it comes from mastering them so deeply that your opponents cannot keep up. And the crowd makes every match unrepeatable.

### 68.1 What an Arena Branch Is

An Arena Branch is a **scoped branch with temporary parameter overrides** applied only inside that branch namespace. It is a self-contained tournament environment that sits on top of the truth layer without ever modifying it.

```
ArenaBranch {
  arenaId:            string,
  parentBranchRef:    branchRef (the tree hosting this arena),
  startBlock:         commitId,
  endBlock:           commitId | null (null = still active),
  rulesetHash:        SHA-256 (immutable once match starts),
  coeffSetId:         string (volatility configuration),
  resourceBudget:     ArenaResourceBudget,
  volatilityTier:     enum { CALM, STANDARD, CHAOTIC, EXTREME },
  sortitionConfig:    SortitionConfig (jury mechanics if applicable),
  crowdTerrainConfig: CrowdTerrainConfig (what the crowd can vote on),
  matchType:          enum { DUEL, COURT_CASE, TRAINING, FREE_ARENA, TOURNAMENT },
  scope:              enum { LOCAL, REGIONAL, GLOBAL, PLANETARY }
}
```

When an arena ends:

- All results are archived as permanent filaments on the parent branch
- No physics leak outward — arena coefficient overrides die at `endBlock`
- Only reputation filaments and achievement tokens persist on participants' user trees
- Arena Points (the internal currency) expire

### 68.2 ArenaContributionPacket Schema

One atomic record of what a player did inside an arena timebox. No hidden inputs. Everything needed to replay and verify the outcome must be inside the commit graph or referenced by hash.

```
ArenaContributionPacket {
  packetId:           "arenaPkt.<uuid>",
  arenaId:            string,
  matchId:            string,
  roundIndex:         number,
  turnIndex:          number,

  actor: {
    userId:           string,
    teamId:           string | null,
    role:             enum { PLAYER, JUDGE_SCV, SPECTATOR, CROWD_VOTER }
  },

  action: {
    type:             enum {
      PLAY_CARD, CAST_INSTANT, OPEN_PROJECTION, CHALLENGE_NODE,
      SUBMIT_EVIDENCE, COUNTER_EVIDENCE, PASS_PRIORITY, CONCEDE,
      CROWD_TERRAIN_VOTE, CROWD_ATTRIBUTE_VOTE
    },
    targetRef:        string | null (filament, projection, or node reference),
    payloadHash:      SHA-256 (content-addressed payload),
    inputs: {
      declaredAt:     ISO-8601,
      priorityWindowId: string,
      requiresApproval: boolean
    }
  },

  costs: {
    powerSpent:              number,
    engagementCreditsSpent:  number,
    arenaPointsStaked:       number
  },

  evidence: {
    evidenceRefs:     string[] (filament, attachment, or external references),
    challengeRefs:    string[],
    disclosureTier:   number
  },

  ruleContext: {
    rulesetId:              string (immutable per match),
    coeffSetId:             string (immutable per match window),
    projectionConstraintsId: string,
    activeCrowdTerrainHash: SHA-256 (current crowd-voted terrain snapshot)
  },

  computed: {
    confidenceDelta:  number,
    stabilityDelta:   number,
    fogDelta:         number,
    heatDelta:        number
  },

  integrity: {
    prevPacketHash:   SHA-256 | null,
    packetHash:       SHA-256,
    signature:        string (actor's key),
    protocolVersion:  string
  }
}
```

**Invariants:**

- `payloadHash` points to content-addressed payload (card text, projection spec, proof bundle)
- `rulesetId` and `coeffSetId` are immutable once a match starts
- `computed.*` is derived and must be reproducible from `action` + `evidence` + coefficients
- `activeCrowdTerrainHash` captures the crowd terrain state at the moment of the action

### 68.3 Stack Resolution Protocol — MTG-Style LIFO for Logic Combat

The stack resolves arguments and evidence the same way Magic: The Gathering resolves spells — last-in, first-out. But instead of creature damage, the stack resolves confidence, stability, fog, and heat deltas.

**State machine:**

```
A) DECLARE
   Active player submits ArenaContributionPacket with type =
   PLAY_CARD | CAST_INSTANT | OPEN_PROJECTION | SUBMIT_EVIDENCE | CHALLENGE_NODE
   Engine validates: costs covered, action permitted by constraints, evidence refs resolvable
   If valid: push StackItem (with packetHash) onto stack

B) PRIORITY PASS LOOP
   Priority rotates: P1 -> P2 -> ... -> PN -> back to P1
   Each priority holder must commit exactly one:
     PASS_PRIORITY (yield)
     OR a new action that pushes a new stack item (respond)

C) RESOLVE
   When all players pass consecutively with no new stack additions,
   resolve the top item. Emit ResolutionEvent:

   ResolutionEvent {
     matchId:              string,
     resolvedPacketHash:   SHA-256,
     result:               enum { PASS, REFUSED, COUNTERED, PARTIAL },
     reasonCode:           enum { OK, INSUFFICIENT_EVIDENCE, OUT_OF_SCOPE,
                                  BUDGET_EXCEEDED, CONSTRAINT_VIOLATION },
     deltas: {
       confidenceDelta:    number,
       stabilityDelta:     number,
       heatDelta:          number,
       fogDelta:           number
     },
     timestamp:            ISO-8601
   }

D) DETERMINISM RULES
   No time-based randomness. Time only selects the timebox/window.
   Timing mechanics use committed timestamps and resolve in commit order
   with deterministic tie-break (packetHash lexicographic).
```

**The stack creates the StarCraft tension legally.** When your opponent plays an evidence card, you have a priority window to counter. They can counter your counter. Each layer of response builds pressure. The crowd watches the stack grow. When it resolves, the cascade of confidence/stability deltas produces dramatic swings — all deterministic, all replayable, all traceable.

### 68.4 Volatility Coefficient Structure

Volatility is a ruleset overlay that modifies costs, reveal rules, projection complexity, confidence impacts, and timebox cadence — but never the underlying equations.

```
ArenaCoeffSet {
  coeffSetId:         string,
  volatilityTier:     enum { CALM, STANDARD, CHAOTIC, EXTREME },

  time: {
    priorityWindowMs:      number (default: 8000),
    turnTimeboxSeconds:    number (default: 60),
    matchMaxMinutes:       number (default: 25)
  },

  economy: {
    powerCostMult:         number (default: 1.0),
    arenaStakeMult:        number (default: 1.0),
    lossPenaltyMult:       number (default: 1.0),
    winRewardMult:         number (default: 1.0)
  },

  visibility: {
    handRevealRule:        enum { FULL, PARTIAL, HIDDEN },
    stackRevealRule:       enum { FULL, PARTIAL },
    projectionRevealRule:  enum { FULL, MASKED_NODES, HASH_ONLY_NODES }
  },

  constraints: {
    maxStackDepth:         number (default: 20),
    maxProjectionDepth:    number (default: 3),
    projectionBudgetMs:    number (default: 50),
    maxEvidenceRefsPerAction: number (default: 12)
  },

  scoring: {
    confidenceWeight:      number (default: 0.50),
    stabilityWeight:       number (default: 0.25),
    evidenceWeight:        number (default: 0.25),
    fogPenaltyWeight:      number (default: 0.30)
  }
}
```

**Hard rules:**

- `coeffSetId` is fixed for a match once it starts
- Volatility cannot change mid-match (but crowd terrain CAN — see §68.5)
- Volatility affects arena scoring only, never core governance
- Same equation, different coefficient, scoped to branch

### 68.5 Crowd-Driven Terrain Voting — The Human Random Engine

This is the mechanism that makes every arena match genuinely unrepeatable. No AI can predict it. No preparation fully accounts for it. The crowd IS the random number generator — but a meaningful one driven by human attention, curiosity, and desire.

**The principle:** Before and during a match, the crowd votes on which attributes to emphasize. These votes shift the scoring weights, constraint parameters, and visibility rules within governed bounds. The participants must adapt in real time to terrain they did not choose and could not predict.

**How it works:**

```
CrowdTerrainConfig {
  votingPhases: [
    {
      phase:          PRE_MATCH,
      duration:       number (seconds, default: 120),
      votableMetrics: MetricRef[] (which attributes the crowd can adjust),
      voteType:       enum { RANKED_CHOICE, WEIGHTED_SLIDER, BINARY_TOGGLE },
      resolution:     MEDIAN (crowd median becomes the active value)
    },
    {
      phase:          MID_MATCH,
      duration:       CONTINUOUS,
      votableMetrics: MetricRef[] (subset — fewer adjustable mid-match),
      voteType:       WEIGHTED_SLIDER,
      resolution:     ROLLING_MEDIAN (recalculated every N seconds),
      updateInterval: number (seconds, default: 30),
      maxShiftPerUpdate: number (% — how much a metric can change per interval)
    }
  ],
  minimumCrowdSize:   number (default: 20 — below this, terrain defaults are used),
  crowdEligibility:   enum { ANY_VIEWER, TIER_1_PLUS, DOMAIN_QUALIFIED }
}
```

**Pre-match terrain voting (the "map selection"):**

Before the match begins, the crowd sees a dashboard of adjustable attributes. They vote on what kind of match they want to see. This is the equivalent of random map selection in StarCraft — except it is driven by human collective preference, not a random seed.

The crowd votes. The median of all votes becomes the active terrain. Neither participant knows the exact result until the match starts. They see the terrain revealed and must adapt instantly.

**Mid-match attention voting (the "weather shift"):**

During the match, the crowd can continue to shift a subset of metrics. This is slower (capped shift per interval) and affects fewer dimensions. But it means the terrain is alive — the crowd's attention IS the weather. If the crowd gets bored with evidence and wants more spectacle, the spectacle weight rises. If the crowd wants deeper analysis, the evidence threshold tightens.

Participants feel this shift. A skilled player reads the crowd and pivots strategy. A rigid player gets caught in terrain they cannot navigate.

**Why no machine can predict this:**

1. **Irreducible human complexity**: Each crowd member's vote is influenced by their mood, attention span, what happened in the last 30 seconds, their personal aesthetic preferences, their domain knowledge, and their social dynamics with other crowd members. No model captures this.

2. **Crowd composition is random**: Who watches any given match is itself unpredictable. A match at 2am attracts a different crowd than a match at noon. A match about accounting attracts domain experts. A match about monster combat attracts gamers. The crowd composition changes the terrain.

3. **Non-stationary preferences**: The crowd's preferences shift during the match in response to what they just saw. A stunning evidence reveal makes the crowd want more evidence. A spectacular spell makes the crowd want more spectacle. The terrain co-evolves with the match.

4. **Emergent meta-gaming**: Crowds develop preferences. "This arena favors evidence-heavy builds." Word spreads. Competitors prepare for evidence-heavy terrain. But the next crowd is different. The meta never stabilizes because the randomness source (human attention) never stabilizes.

5. **Scale amplifies unpredictability**: With 20 crowd members, some statistical patterns emerge. With 20,000, the law of large numbers smooths individual noise but crowd-level dynamics (waves of excitement, collective boredom, reaction to surprise) create higher-order unpredictability that no simple statistical model captures.

### 68.6 Votable Metrics — Duels & Arena Combat

The following attributes can be placed in the crowd terrain vote for arena duels. Template designers choose which subset is votable per arena type. The full taxonomy:

**A. Scoring Weights (how victory is measured):**

| Metric | What It Controls | Range | Default |
|--------|-----------------|-------|---------|
| `evidenceQualityWeight` | How much evidence quality matters to the final score | 0.0–0.8 | 0.35 |
| `argumentClarityWeight` | How much argument structure and clarity matter | 0.0–0.5 | 0.20 |
| `spectacleWeight` | How much physical performance and visual drama matter | 0.0–0.5 | 0.15 |
| `counterplayWeight` | How much successful countering of opponent's moves matters | 0.0–0.4 | 0.15 |
| `consistencyWeight` | How much consistency across rounds matters vs single brilliant plays | 0.0–0.3 | 0.15 |

**B. Tempo & Time Pressure:**

| Metric | What It Controls | Range | Default |
|--------|-----------------|-------|---------|
| `priorityWindowMs` | Time allowed to respond before priority passes | 2000–30000 | 8000 |
| `turnTimeboxSeconds` | Maximum time per turn | 15–300 | 60 |
| `matchMaxMinutes` | Total match duration | 5–120 | 25 |
| `stackResolutionPace` | Speed of stack resolution animation/reveal | INSTANT / STANDARD / DRAMATIC | STANDARD |

**C. Complexity & Depth:**

| Metric | What It Controls | Range | Default |
|--------|-----------------|-------|---------|
| `maxStackDepth` | How many responses can chain before forced resolution | 3–50 | 20 |
| `maxProjectionDepth` | How complex projections can be | 1–10 | 3 |
| `maxEvidenceRefsPerAction` | How many evidence references per single move | 1–50 | 12 |
| `crossBranchRefAllowed` | Can players reference data from outside the arena scope? | boolean | true |
| `historicalDepth` | How far back in time evidence can be drawn from | 7d–UNLIMITED | UNLIMITED |

**D. Visibility & Information:**

| Metric | What It Controls | Range | Default |
|--------|-----------------|-------|---------|
| `handRevealRule` | How much of each player's prepared moves are visible | FULL / PARTIAL / HIDDEN | HIDDEN |
| `stackRevealRule` | Can the crowd see pending stack items before resolution? | FULL / PARTIAL | FULL |
| `projectionRevealRule` | How much of projection internals are visible | FULL / MASKED / HASH_ONLY | FULL |
| `opponentTreeVisibility` | Can players inspect each other's user trees during the match? | FULL / SUMMARY_ONLY / NONE | SUMMARY_ONLY |
| `crowdSeesBothHands` | Does the crowd see what both players hold? (players don't see each other's) | boolean | true |

**E. Volatility & Risk:**

| Metric | What It Controls | Range | Default |
|--------|-----------------|-------|---------|
| `confidenceDeltaMult` | How much each action swings confidence | 0.5–3.0 | 1.0 |
| `fogAccumulationRate` | How quickly fog builds from weak evidence | 0.5–3.0 | 1.0 |
| `heatSensitivity` | How quickly heat builds from rapid exchanges | 0.5–3.0 | 1.0 |
| `stormThreshold` | How much accumulated fog+heat before storm triggers | 0.3–1.0 | 0.7 |
| `scarPermanence` | Do arena scars persist on user tree or expire with arena? | PERMANENT / ARENA_ONLY | ARENA_ONLY |

**F. Combat & Spectacle (game layer duels):**

| Metric | What It Controls | Range | Default |
|--------|-----------------|-------|---------|
| `spellComplexityFloor` | Minimum spell component count allowed | 1–5 | 1 |
| `elementRestrictions` | Which element types are allowed | ALL / SUBSET / SINGLE | ALL |
| `creatureSummonLimit` | Maximum active summons per player | 0–10 | 3 |
| `physicalPerformanceWeight` | How much physical gesture precision matters | 0.0–0.5 | 0.15 |
| `powerRegenerationRate` | How fast Power (mana) regenerates during match | 0.5–2.0 | 1.0 |

### 68.7 Votable Metrics — Court Cases & Sortition Proceedings

When a sortition case (§46) or formal legal proceeding enters an arena branch, the crowd (qualified spectators — not the jury) votes on procedural parameters. The jury decides the verdict. The crowd shapes the terrain on which the case is argued.

**A. Evidence Standards:**

| Metric | What It Controls | Range | Default |
|--------|-----------------|-------|---------|
| `evidenceStandard` | The burden of proof threshold | PREPONDERANCE (>50%) / CLEAR_AND_CONVINCING (>75%) / BEYOND_REASONABLE_DOUBT (>90%) | CLEAR_AND_CONVINCING |
| `evidenceTypeWeighting` | Relative weight of evidence categories | Slider per type | Equal |
| `requiredSourceTypes` | Minimum source diversity required | 1–5 distinct types | 2 |
| `hearsayAdmissibility` | Can second-hand evidence be presented? | ALLOWED / DISCOUNTED / EXCLUDED | DISCOUNTED |

**Evidence type breakdown for weighting:**

| Evidence Type | Description |
|--------------|-------------|
| `DOCUMENTARY` | Committed filaments, contracts, records, financial data |
| `TESTIMONIAL` | Voice transcripts, presence recordings, witness statements |
| `EXPERT` | Analysis by users with certified domain competence (§58.12) |
| `PHYSICAL` | Camera footage, proximity data, device signals, sensor data |
| `STATISTICAL` | Aggregate patterns, cross-section analysis, trend projections |
| `PRECEDENT` | Prior sortition verdicts, archived arena outcomes, governance commits |

**B. Temporal & Scope:**

| Metric | What It Controls | Range | Default |
|--------|-----------------|-------|---------|
| `temporalScope` | How far back evidence may reach | 30d–UNLIMITED | UNLIMITED |
| `branchScope` | How many branches evidence can be drawn from | SINGLE / RELATED / ANY_PUBLIC | RELATED |
| `counterpartyDiscovery` | Can parties compel public data from third-party branches? | YES / ONLY_NAMED / NO | ONLY_NAMED |
| `precedentWeight` | How much prior similar case outcomes influence scoring | 0.0–0.5 | 0.20 |

**C. Procedural Parameters:**

Note: `deliberationTimeHours`, `verdictThreshold`, `jurySize`, and `blindJury` are governance-level sortition parameters (§46) set through §11 weighted-median governance. They are NOT crowd-votable — they have governance-enforced floors that crowd terrain voting cannot breach. Only presentation parameters (`argumentRounds`, `crossExaminationIntensity`) are adjustable by crowd. (See §71.5.)

| Metric | What It Controls | Range | Default | Crowd-Votable? |
|--------|-----------------|-------|---------|----------------|
| `argumentRounds` | Number of alternating argument rounds | 1–10 | 3 | YES |
| `crossExaminationIntensity` | How many follow-up questions per round | 0–10 | 3 | YES |
| `deliberationTimeHours` | How long the jury has to deliberate | 1–168 | 72 | NO — §46 governance |
| `verdictThreshold` | Simple majority vs supermajority required | SIMPLE (>50%) / SUPER (>66%) / UNANIMOUS | SIMPLE | NO — §46 governance |
| `jurySize` | Number of jurors for this case | 5–15 | 9 | NO — §46 governance |
| `blindJury` | Can jurors see participant identities? | FULL_IDENTITY / ROLE_BADGE_ONLY / ANONYMOUS | ROLE_BADGE_ONLY | NO — §46 governance |

**D. Consequence Parameters:**

| Metric | What It Controls | Range | Default |
|--------|-----------------|-------|---------|
| `scarScope` | Does the verdict scar persist on user tree? | PERMANENT / TIME_LIMITED / ARENA_ONLY | PERMANENT |
| `precedentCreation` | Does this verdict create a referenceable precedent filament? | YES / NO | YES |
| `compensationRange` | Range of engagement credits that can transfer | 0–governed_max | governed_max |
| `confidenceImpact` | How much the verdict affects participants' branch confidence | 0.0–1.0 | 0.5 |
| `publicRecordDetail` | How much of the proceeding is archived publicly | FULL_TRANSCRIPT / SUMMARY / VERDICT_ONLY | FULL_TRANSCRIPT |

**E. Credibility & Witness:**

| Metric | What It Controls | Range | Default |
|--------|-----------------|-------|---------|
| `witnessCredibilityMethod` | How witness reliability is assessed | TREE_CONFIDENCE / DOMAIN_CERTIFICATION / CROWD_VOTE | TREE_CONFIDENCE |
| `expertRequirements` | Minimum certification level (§58.12) for expert witness status | NONE / MODULE_DEMONSTRATED / CERTIFIED | MODULE_DEMONSTRATED |
| `characterEvidenceAdmissibility` | Can parties present evidence about opponent's general character? | ALLOWED / LIMITED / EXCLUDED | LIMITED |
| `mitigatingCircumstanceWeight` | How much mitigating factors reduce consequence | 0.0–0.5 | 0.20 |
| `aggravatingCircumstanceWeight` | How much aggravating factors increase consequence | 0.0–0.5 | 0.20 |

### 68.8 Why This Creates True Randomness

The arena terrain is not generated by `Math.random()`. It is generated by human collective attention — which is computationally irreducible.

**The randomness chain:**

```
WHO shows up to watch (unpredictable)
        |
        v
WHAT mood they're in (unpredictable)
        |
        v
HOW they vote on terrain metrics (unpredictable composite)
        |
        v
MEDIAN of thousands of independent human preferences
        |
        v
TERRAIN emerges — unique to this match, this crowd, this moment
        |
        v
PARTICIPANTS must adapt to terrain they could not predict
        |
        v
MID-MATCH crowd shifts terrain in response to what they see
        |
        v
PARTICIPANTS must re-adapt to shifting conditions
        |
        v
OUTCOME is a function of: skill × adaptation × crowd terrain
```

**No two matches are ever the same** because:

1. The crowd composition is different
2. The pre-match terrain vote is different
3. The mid-match attention shifts are different
4. The participants' responses to terrain create new crowd reactions
5. The crowd's reactions shift the terrain further

This is a **feedback loop between human performers and human audience** that no simulation can replicate. It is the same phenomenon that makes live theater different from recorded theater, live sports different from replays, and live music different from albums. The crowd is not passive. The crowd is part of the system.

**What this means for skill:**

- **Adaptability** is rewarded over rote optimization. A player who prepared a perfect evidence-heavy strategy fails if the crowd votes for fast tempo and spectacle weight. The best players read the terrain and pivot.
- **Crowd reading** becomes a skill. Experienced arena players develop intuition for what crowds want. They adjust their presentation style, evidence selection, and timing based on crowd energy — the same way a trial lawyer reads the jury.
- **Preparation breadth** matters more than preparation depth. You cannot predict which metrics will be emphasized, so you must be competent across all of them. Specialists are vulnerable to unfavorable terrain. Generalists thrive.

### 68.9 Camera-Skill Metric Taxonomy — Edge of Tomorrow Training

Arena includes camera-based physical skill training — reaction drills, focus tracking, gesture precision, and pattern recognition. This is not violence simulation. It is motor control and attention training, measured and recorded as filaments on the user tree.

**Signal classes:**

| Category | Metric | Measurement |
|----------|--------|-------------|
| **Reaction** | `reactionLatencyMs` | Time from prompt to correct response |
| **Reaction** | `reactionConsistency` | Standard deviation over N trials |
| **Precision** | `gesturePathError` | Distance between expected vs observed motion path |
| **Precision** | `holdStability` | Micro-jitter during required hold (lower = better) |
| **Rhythm** | `tempoAdherence` | Match accuracy against beat windows |
| **Rhythm** | `windowHitRate` | % of prompts hit inside allowed timing window |
| **Attention** | `gazeStability` | Focus consistency (optional eye tracking, or pointer proxy) |
| **Attention** | `taskSwitchCostMs` | Delay when prompt type changes |
| **Endurance** | `fatigueSlope` | Performance degradation rate over session |
| **Endurance** | `sessionCompletionRate` | % of drills completed per session |

**ArenaSkillPacket schema:**

```
ArenaSkillPacket {
  skillPktId:     string,
  userId:         string,
  arenaId:        string,
  sessionId:      string,
  timeboxId:      string,

  raw: {
    trials:                  number,
    reactionLatencyMs_p50:   number,
    reactionLatencyMs_p95:   number,
    gesturePathErrorAvg:     number,
    holdStabilityScore:      number (0..1),
    windowHitRate:           number (0..1),
    fatigueSlope:            number (negative = degradation)
  },

  derived: {
    skillScore:              number (0..1, deterministic from raw + ruleset thresholds),
    confidence:              number (0..1)
  },

  evidence: {
    signalHashes:            SHA-256[] (local signal data hashes),
    onDeviceOnly:            boolean (true — raw signal never leaves device)
  },

  integrity: {
    packetHash:              SHA-256,
    signature:               string (user key)
  }
}
```

**Deterministic skill score:**

```
skillScore = wR × R + wP × P + wT × T + wA × A + wE × E
```

Where each component is a `0..1` clamp from explicit `min/max` ranges published in the arena ruleset. All weights are Category A global parameters (§11.6).

**The training loop:**

Each repetition is a filament. Each session is a slab. Each improvement is a radial migration inward (competence solidifies). This creates the "Edge of Tomorrow" loop: wake up, train, see your tree change, see your scores improve, see your reactions sharpen. The tree IS the progress bar. Cross-section shows your training history — early attempts near the bark, mastery near the core.

### 68.10 Arena-to-Reputation Conversion Math

Arena results must matter enough to be motivating but never enough to corrupt governance. Arena yields **ArenaRep** — domain-specific reputation that unlocks arena variants, advanced training, matchmaking tier increases, and limited teaching visibility in education trees. ArenaRep cannot convert to vote weight, orgConfidence, permissions, fiat, or Power.

**Core quantities per match:**

| Symbol | Meaning | Range |
|--------|---------|-------|
| W | Win (1) or loss (0) | binary |
| S | Stability score (aggregate from resolved stack) | 0..1 |
| C | Confidence score (from evidence quality) | 0..1 |
| A | Attention factor (eligible viewer count, normalized) | 0..1 |
| V | Volatility tier multiplier (from coeffSet) | 1.0–2.5 |
| P | Participation integrity (no refusals, no spam, no unsafe calls) | 0..1 |

**ArenaRepGain formula:**

```
ArenaRepGain = Base × V × P × (0.45×W + 0.25×S + 0.20×C + 0.10×A)
```

**Loss still yields learning credit:**

```
If W = 0:
  ArenaRepGain *= 0.40
```

Losing is not zero. Losing produces a thinner, cooler filament — but a filament nonetheless. The tree records participation. Scars from losses are visible in cross-section. They show effort, not failure.

**Anti-farm caps (deterministic):**

```
Daily cap per arena:
  capDaily = k × sqrt(uniqueOpponentsToday + 1)

Repeated opponent decay:
  oppDecay = 1 / (1 + repeatsWithSameOpponentToday)
  ArenaRepGain *= oppDecay
```

You cannot farm reputation by fighting the same person repeatedly. You must face new opponents. The cap scales with opponent diversity, not volume.

**Where it lives on the tree:**

ArenaRepGain is a filament on the user tree under `branch.arena.<arenaId>`. Cross-section shows:

- Thick rings = many matches
- Fog = low evidence quality
- Scars = rejected actions / rule violations
- Heat = high stability/confidence changes
- Lean = directional strength (toward certain domains)

### 68.11 Singleplayer & Multiplayer

**Singleplayer training:**

The opponent is historical precedent, stored high-skill replay, simulation branches, or AI-driven logic models. The goal: improve reasoning, argument structure, timing, reaction speed. No real stakes. Pure skill development. The training arena is always available, always free, always private.

Training sessions produce ArenaSkillPackets but not ArenaContributionPackets — training does not earn reputation. Only live matches against real opponents earn ArenaRep.

**Multiplayer modes:**

| Mode | Players | Format | Crowd Terrain? |
|------|---------|--------|---------------|
| **1v1 Duel** | 2 | Alternating turns, full stack, evidence + spectacle | Yes |
| **Team Duel** | 2v2 to 5v5 | Shared priority queue, team stack coordination | Yes |
| **Free Arena** | 3+ | Free-for-all, alliance allowed (visible!), betrayal legal | Yes |
| **Tournament** | 8–256 | Bracket elimination, escalating volatility per round | Yes, resets each round |
| **Court Case** | 2 parties + jury | Formal proceeding, crowd sets terrain, jury decides verdict | Yes (crowd ≠ jury) |

**Free Arena — the StarCraft social tension:**

In free arenas, alliances are **visible commitments** — you commit an alliance filament that is inspectable. But alliances can be broken. Breaking an alliance produces a scar on your arena branch. The crowd sees alliances form and break. Other players see them. The social tension of "who is actually allied with whom" is real — but transparent. You can betray, but your betrayal is on the record. The crowd reacts. The terrain shifts.

This captures the StarCraft energy: social paranoia, hidden motives, alliance ambiguity. But in Relay, the betrayal is visible after the fact. It becomes part of your arena reputation. Serial betrayers earn fog and wilt on their arena branches. Reliable allies earn firm, confident branches. The tree shows your social strategy across all arenas.

### 68.12 The Engagement Feedback Loop

Why this never ends:

1. **Short feedback loops**: Each match is 5-25 minutes. You see results immediately.
2. **Visible progress**: Your arena branch grows. Cross-section shows improvement. Rings thicken. Fog clears.
3. **Escalating challenge**: Matchmaking uses ArenaRep for pairing. As you improve, opponents improve. The plateau is always just ahead.
4. **Crowd variability**: No two matches feel the same because no two crowds vote the same terrain.
5. **Social stakes**: Your reputation is public. Your wins are visible. Your losses are visible. Your arena branch IS your competitive identity.
6. **Discovery depth**: Advanced strategies emerge over time — projection tricks, evidence chain manipulation, timing exploits, crowd-reading skills. There is always more to learn.
7. **Training integration**: Camera-based skill drills feed into duel performance. Physical improvement translates to arena advantage. The body and the mind both grow.
8. **Free entry, reward only**: No cost to enter. No pay-to-win. All rewards are earned. The economy is purely meritocratic within the arena scope.

**The progression curve:**

| Tier | What Opens | How You Get There |
|------|-----------|------------------|
| **Novice** | Training arenas, low-volatility 1v1s | Complete tutorial |
| **Apprentice** | Standard volatility, team duels, basic tournaments | 20+ matches, ArenaRep > threshold |
| **Journeyman** | High volatility, free arenas, court case participation as advocate | 100+ matches, demonstrated evidence quality |
| **Champion** | Extreme volatility, planetary-scale tournaments, court case expert witness | 500+ matches, high ArenaRep, certified domain competence (§58.12) |
| **Architect** | Arena design (propose new arena types, new terrain metrics, new rulesets) | Champion tier + community approval via module discovery (§38) |

### 68.13 What Arena Must Never Grant

This is the constitutional boundary. Arena is entertainment, training, and reputation — never governance leverage.

| Arena CAN grant | Arena CANNOT grant |
|----------------|-------------------|
| Arena Points (branch-scoped, expire) | Governance vote weight |
| ArenaRep (domain-specific reputation) | OrgConfidence override |
| Achievement Tokens | Access to private data |
| Skill filaments | External settlement privileges |
| Teaching visibility (lens only) | Physical resource influence |
| Matchmaking tier advancement | Global vote leverage |
| Narrative influence (temporary attention) | Fiat currency |
| Precedent filaments (for court arenas) | Permission scope expansion |

If any of these boundaries is violated, the arena corrupts the system. ArenaRep is a lens — it shows what you can do. It is never a lever — it cannot change what others must do.

### 68.14 How This Connects to Existing Architecture

**§40 (Game Layer):** Arena is the competitive expression of the game layer. Quests are PvE. Arena is PvP. Both use the same tree physics, the same resource economy, the same discovery model. Arena adds the crowd-driven terrain mechanic and the formal stack resolution protocol.

**§41 (Multi-Resource Economy):** Arena introduces Arena Points as a scoped, expiring resource. All other resources (Engagement Credits, Achievement Tokens, Power, Active Capacity) interact with arena through existing rules. No new resource conversions are created.

**§42 (Duels):** Arena formalizes duels with the ArenaContributionPacket, stack protocol, and crowd terrain system. Existing duel mechanics (§42.1-42.6) remain valid. Arena adds the structured resolution layer and the crowd-driven parameter adjustment.

**§43 (Spell Taxonomy):** Spells work identically inside arenas. Element detection, gesture validation, and card mechanics are unchanged. Arena only adjusts which elements are allowed (crowd terrain metric `elementRestrictions`) and the Power regeneration rate.

**§46 (Sortition):** Court case arenas use sortition for jury selection (unchanged). The crowd is not the jury — the crowd sets the terrain, the jury decides the verdict. Crowd terrain voting is a separate mechanism from jury deliberation. Jurors are not influenced by crowd terrain — they see the evidence and arguments, not the crowd's metric votes.

**§58 (Education):** Arena is a training ground. Skill development in arenas feeds into the education system (§58) through demonstrated competence. A user who develops strong evidence presentation skills in arena can leverage those as teaching material. Camera-skill training (§68.9) is a form of education that produces learning filaments.

**§58.12 (Certification):** Champion-tier arena participation and certified domain competence are connected. A certified accountant who demonstrates arena competence in financial dispute resolution earns both professional and competitive reputation — the tree shows both.

**§61 (Privacy):** Arena is public by definition. All arena actions are committed at `disclosureTier >= 1`. There is no private arena. The crowd sees everything. The participants accept visibility as a condition of entry. Contract #150 (private data uninspectable) applies to data outside the arena — participants cannot be compelled to reveal private branch data during arena proceedings.

### 68.15 Community-Governed Monster Difficulty — PvE Crowd Scaling

As users explore distant gaming world branches (§40.4 fractal quest scaling), the community inhabiting that branch governs the challenge environment. Veterans who have conquered the local monsters do not simply leave — they make the world harder for everyone, including themselves.

**Branch-level difficulty governance:**

Each game layer branch (a quest zone, a planet, a dungeon) has **local difficulty parameters** that are Category A global parameters scoped to that branch:

```
BranchDifficultyParams {
  branchRef:                 branchRef,
  monsterHealthMult:         number (0.5–5.0, default: 1.0),
  monsterBehaviorComplexity: enum { SIMPLE, STANDARD, TACTICAL, ADAPTIVE },
  monsterSpawnRate:          number (0.5–3.0, default: 1.0),
  monsterRewardMult:         number (0.5–3.0, default: 1.0),
  environmentalHazardRate:   number (0.0–2.0, default: 0.5),
  resourceScarcity:          number (0.5–2.0, default: 1.0),
  bossFrequency:             number (0.5–3.0, default: 1.0),
  cooperativeBonus:          number (1.0–2.0, default: 1.2),
  globalFloor:               DifficultyFloor (minimum values — prevents trivializing),
  globalCeiling:             DifficultyCeiling (maximum values — prevents impossibility)
}
```

**Who votes:** Only users who have active presence on the branch (have fought at least one monster, have a filament in the zone). Tourists and spectators do not vote on difficulty — only inhabitants. This prevents distant communities from griefing a zone they have never visited.

**The scaling dynamic:**

1. New zone opens with default difficulty
2. Early explorers arrive, fight monsters, earn rewards
3. As explorers level up, they vote difficulty higher — harder monsters, better rewards
4. The zone's reputation spreads — "Mars Sector 7 is running ADAPTIVE monsters at 3.0x health"
5. Ambitious players travel there for the challenge
6. The community self-selects: casual players leave for easier zones, elite players concentrate
7. The zone's cross-section shows the difficulty history — easy core, hardening bark

**Monster behavior voting:**

Beyond difficulty numbers, communities vote on monster **behavior modes** within governed limits:

| Behavior Mode | What Changes | Global Limit |
|---------------|-------------|-------------|
| **SIMPLE** | Monsters follow basic patterns, predictable | Always available |
| **STANDARD** | Monsters adapt to player count and composition | Always available |
| **TACTICAL** | Monsters coordinate, flank, retreat, set traps | Requires 60% community vote |
| **ADAPTIVE** | Monsters learn from player strategies across sessions | Requires 75% community vote, Champion-tier zone |

The global floor prevents a community from voting difficulty to zero (trivializing the content). The global ceiling prevents a community from making a zone literally impossible (griefing newcomers). Within those bounds, the community shapes their world.

### 68.16 Resource Marketplace — Skill-Based Barter Economy

Arena branches and game layer zones include a **resource marketplace** — a barter system where players trade resources, loot, crafting materials, and arena consumables. The marketplace rewards knowledge and negotiation skill.

**The barter model (Secret of Mana/Evermore inspired):**

Resources in Relay's game layer are not priced in a single currency. They have **contextual value** that shifts based on branch conditions:

```
MarketplaceItem {
  itemId:               string,
  itemType:             enum { RESOURCE, LOOT, CRAFTING_MATERIAL, SPELL_COMPONENT,
                               ARENA_CONSUMABLE, TRAINING_TOKEN },
  baseValue:            number (in Engagement Credits),
  contextModifiers: {
    branchScarcity:     number (how rare this item is on this branch — computed from supply),
    branchDemand:       number (how many active requests exist — computed from demand filaments),
    seasonalModifier:   number (time-based value shift — some resources are worth more at dawn),
    skillPremium:       number (crafted items from high-skill players carry a premium)
  },
  effectiveValue:       number (baseValue × product of contextModifiers)
}
```

**Skill-based trading advantages:**

Players who understand the marketplace physics gain advantages — not through exploitation, but through knowledge:

- **Arbitrage awareness**: A resource that is scarce on Mars Sector 7 (high `branchScarcity`) might be abundant on Earth Sector 3. A player who knows both markets can trade profitably by transporting resources between zones. The transport takes time (the player must physically travel through the tree), creating a natural friction that prevents instant exploitation.
- **Timing skill**: Some resources peak in value during specific timeboxes (seasonal modifier). A player who understands the timing cycle buys low and sells high — visible, legal, and rewarded.
- **Crafting premium**: Items crafted by high-skill players (thick, firm arena branch, many demonstrated modules) carry a `skillPremium`. A sword forged by a Champion-tier crafter is objectively the same item, but the crafter's reputation makes it more desirable — the market prices reputation because the buyer trusts the source.
- **Negotiation filaments**: Direct trades between players are committed as trade filaments with full evidence chains. A player with a history of fair trades (high trade confidence) gets better offers. A player with scars from bad trades (disputes, failed deliveries) gets worse offers. The marketplace self-regulates through reputation physics.

**Resource quotas with flexible balancing:**

Organizations and guilds can set **resource targets** — quotas that must be met collectively but can be balanced differently among members:

```
ResourceQuota {
  quotaId:              string,
  scope:                branchRef (the guild/team/zone branch),
  targetResources: [
    { resourceType: string, targetAmount: number, timeboxWindow: number }
  ],
  balancingRule:        enum { EQUAL_SPLIT, PROPORTIONAL_TO_SKILL,
                               SELF_ASSIGNED, AUCTION },
  completionReward:     RewardSpec (what the group earns for meeting quota),
  overachievementBonus: number (multiplier for exceeding target)
}
```

The key: the quota defines WHAT must be collected, but not WHO collects each part. A guild with a quota of 1000 minerals and 500 crystals can let specialists focus on what they are best at. The miner focuses on minerals; the crystal hunter focuses on crystals. Or they can auction assignments to the highest bidder. Or they can self-assign. The balancing mechanism is itself a votable parameter within the guild.

### 68.17 Crowd Faction System — Pick a Side, Change Your Mind

The crowd is not passive spectators voting on abstract terrain metrics. Crowd members **register their faction** — which side they support. This registration is visible, changeable, and directly influences the match through collective energy.

**Faction registration:**

```
CrowdFactionCommit {
  userId:               string,
  matchId:              string,
  factionRef:           enum { SIDE_A, SIDE_B, NEUTRAL, UNDECIDED },
  commitTimestamp:       ISO-8601,
  switchCount:          number (how many times this user has changed faction in this match),
  switchPenalty:         number (diminishing influence weight with each switch)
}
```

**Rules:**

- Crowd members can register for either side, remain neutral, or start undecided
- Faction choice is **visible** — both participants see the crowd split in real time
- Crowd members can **change sides** at any time during the match — but each switch reduces their influence weight (switchPenalty = `1 / (1 + switchCount)`). A fan who switches 5 times has almost no influence. A fan who commits early and stays has maximum influence.
- Switching faction is itself a committed event — your loyalty pattern is on the record

**How factions influence the match:**

Crowd faction energy flows into the match through **collective resonance** — the aggregate energy of a faction amplifies specific attributes for their supported side:

| Crowd Metric | Effect on Supported Side | Scaling |
|-------------|------------------------|---------|
| **Faction size** (raw count of supporters) | Confidence boost on next action | `sqrt(factionSize) / sqrt(totalCrowd)` |
| **Faction loyalty** (avg commitment duration) | Stability bonus during stack resolution | `avgLoyaltyDuration / matchDuration` |
| **Faction engagement** (how actively the faction is participating — voting, reacting) | Heat amplification on successful plays | `engagementRate × factionWeight` |
| **Faction expertise** (avg domain qualification of faction members) | Evidence weight bonus when presenting to jury/audience | `avgDomainScore / maxDomainScore` |

**Critical constraint:** Faction influence is a **modifier**, not a determinant. The maximum faction bonus on any metric is capped (Category A global parameter, default: +15%). A player with zero skill cannot win through crowd support alone. A player with high skill benefits from crowd support but does not depend on it. The crowd amplifies performance — it does not replace it.

**The social dynamics:**

- Before a high-profile match, faction registration creates anticipation. "Team A has 60% of the crowd." The underdog effect kicks in — some crowd members switch to Side B for the narrative.
- During the match, a dramatic reversal causes faction shifts. Crowd members who switched to the winning side early get credit. Those who switched late get penalized. Loyal supporters who stayed through the low point get maximum influence.
- After the match, your faction history is a filament on your arena branch. Serial front-runners (always switching to the winner mid-match) develop a reputation. Loyal supporters develop a different reputation. The tree shows who you backed and when.

**Multiplayer and group events:**

Faction registration extends beyond 1v1 to any group event:

| Event Type | Factions | How Crowd Helps |
|-----------|----------|----------------|
| **Team duel** | Team A vs Team B | Faction energy pools across all team members |
| **Tournament** | Support any competitor | Faction energy follows your chosen competitor through brackets |
| **Free arena** | Support any player or alliance | Faction shifts as alliances form and break |
| **Dance party / performance** | Support any performer | Faction energy = applause → attention → micro-rewards (§68.18) |
| **Court case** | Prosecution vs Defense | Crowd faction visible but jury is NOT influenced by crowd (§46 sortition independence preserved) |

### 68.18 Attention-Based Micro-Rewards — The Micro-Reward Feedback System

Not all arena events are combat or court proceedings. Relay hosts **social performance events** — dance parties, comedy shows, live music, spoken word, talent showcases, cooking demonstrations, fitness challenges — any activity where a user performs for an audience. These events use the same arena branch infrastructure with a different reward mechanic: **attention converts to micro-rewards.**

**The attention-to-reward pipeline:**

```
USER PERFORMS (dance, joke, song, demonstration, trick)
        |
        v
CROWD REACTS — real-time reaction filaments:
  CrowdReactionPacket {
    reactorUserId:    string,
    performerUserId:  string,
    reactionType:     enum { APPLAUSE, LAUGH, CHEER, SURPRISE,
                             ENCORE, STANDING_OVATION, EMOJI_BURST },
    intensity:        number (0..1, from camera-detected reaction or manual input),
    timestamp:        ISO-8601
  }
        |
        v
ATTENTION SCORE computed per timebox:
  AttentionScore = Σ (reactionIntensity × reactorWeight)
  where reactorWeight = f(reactorPresenceDuration, reactorFactionLoyalty)
        |
        v
MICRO-REWARD issued to performer:
  MicroRewardPacket {
    performerUserId:  string,
    eventRef:         arenaId,
    rewardType:       enum { ENGAGEMENT_CREDITS, ARENA_POINTS,
                             VISUAL_BURST, CROWD_EFFECT, POWER_TRICKLE },
    amount:           number (small — designed for volume, not magnitude),
    triggerCondition: string (what the performer did that earned this)
  }
```

**Reward types and their feedback mechanisms:**

| Reward | What Happens | Why It Engages |
|--------|-------------|-------------------|
| **Engagement Credits** (small) | Tiny EC deposit per sustained attention threshold | Real value, accumulates over time |
| **Arena Points** | Branch-scoped points for event-specific leaderboards | Competition within the event |
| **Visual Burst** | Emoji graphics, particle effects, glow around performer's sphere — visible to all | Immediate social feedback, public recognition |
| **Crowd Effect** | Performer's side of the arena changes atmosphere (colors, sounds, energy) based on crowd reaction | Environmental feedback — the space responds to you |
| **Power Trickle** | Small Power regeneration from sustained audience attention | Enables spell casting fueled by audience energy |

**Visual Bursts — the emoji reward:**

When a performer hits an attention threshold (e.g., 70% of the crowd reacts with LAUGH within 3 seconds of a joke), a **Visual Burst** fires:

- Emoji graphics pop up around the performer's user sphere — laughing faces, fire emojis, hearts, stars
- The burst is visible to everyone in the arena branch
- The burst is brief (2-5 seconds), non-blocking, and purely cosmetic
- Different reaction types produce different visual signatures (APPLAUSE = clapping hands cascade, LAUGH = laughing emojis, STANDING_OVATION = golden glow + confetti)
- Visual Bursts are the Relay equivalent of a laugh track, an applause sign, a standing ovation — but driven by real crowd reaction, not programmed

**The small reward principle:**

Micro-rewards are deliberately small. A single Visual Burst earns nothing material. A single EC deposit is fractional. But over a 30-minute performance with sustained crowd engagement, the accumulation is meaningful:

- A street performer who keeps a crowd entertained for an hour earns more EC than someone farming low-level monsters
- A comedian who consistently gets LAUGH reactions builds a thick, warm performance branch on their tree
- A dancer who generates STANDING_OVATION regularly develops a highly visible arena presence

The engagement comes from the **frequency and visibility** of rewards, not their individual magnitude. Every reaction from the crowd produces a micro-feedback. Every threshold crossed produces a visible burst. The performer sees the crowd's energy in real time and adjusts their performance. The crowd sees their reactions reflected in the arena environment and participates more enthusiastically.

**Social performance categories:**

| Category | What's Measured | Crowd Reaction Types |
|----------|----------------|---------------------|
| **Dance** | Rhythm, movement quality, creativity, crowd sync | CHEER, ENCORE, STANDING_OVATION |
| **Comedy** | Timing, crowd laughter rate, surprise factor | LAUGH, SURPRISE, APPLAUSE |
| **Music** | Performance quality, crowd energy, tempo adherence | CHEER, ENCORE, STANDING_OVATION |
| **Spoken Word** | Clarity, emotional impact, argument quality | APPLAUSE, SURPRISE, STANDING_OVATION |
| **Fitness / Sports** | Physical performance metrics, crowd excitement | CHEER, SURPRISE, STANDING_OVATION |
| **Cooking / Craft** | Technique, creativity, audience engagement | APPLAUSE, SURPRISE, CHEER |
| **Teaching / Demo** | Clarity, audience comprehension, question quality | APPLAUSE, SURPRISE, CHEER |

All categories use the same reward pipeline. The template system (§21) configures which reaction types are available and what thresholds trigger Visual Bursts.

### 68.19 Terrain Rules — Contestant Agreement, Presets & Combat Loadouts

Not all arena terrain is crowd-driven random. The Architect conversation identified three terrain modes:

**Mode 1: Agreed Terrain (contestants negotiate)**

Before the match, both contestants (or all parties) negotiate and agree on terrain parameters. This is the equivalent of chess players agreeing on time controls, or martial artists agreeing on weight class rules.

```
AgreedTerrainConfig {
  negotiationType:     enum { FULL_AGREEMENT, PARTIAL_AGREEMENT_CROWD_FILLS },
  agreedMetrics:       MetricOverride[] (specific values both parties accepted),
  disputeResolution:   enum { CROWD_DECIDES, DEFAULT_VALUES, COIN_FLIP_HASH },
  lockTimestamp:       ISO-8601 (terrain locks when both commit agreement)
}
```

- Both contestants propose terrain values. Where they agree, the value is locked.
- Where they disagree, the resolution mechanism activates: crowd decides the disputed metrics (default), system defaults apply, or a deterministic hash-based coin flip resolves the dispute.
- `PARTIAL_AGREEMENT_CROWD_FILLS` is the hybrid: contestants lock the metrics they care about, the crowd votes on the rest. This creates strategic pre-match negotiation — what you fight to lock reveals what you are preparing for.

**Mode 2: Crowd Random (§68.5 — the human random engine)**

The crowd votes on all terrain metrics. This is the default for public arenas, tournaments, and any event designed for spectacle.

**Mode 3: Preset Terrain (template-based)**

Arena designers create **terrain presets** — named configurations that package a complete set of terrain values for a specific experience. Players select a preset instead of negotiating or crowd-voting.

**Terrain presets (inspired by the best of all games):**

| Preset Name | Inspired By | Key Settings |
|------------|-------------|-------------|
| **Blitz** | Speed chess, FPS deathmatches | 5-second priority windows, 3-minute matches, EXTREME volatility, HIDDEN hands |
| **Grand Strategy** | Civilization, 4X strategy | 5-minute turns, 60-minute matches, CALM volatility, FULL visibility, deep projection depth |
| **Evidence Trial** | Court drama, Phoenix Wright | High evidence weight, strict source requirements, 3 argument rounds, blind jury |
| **Spectacle Arena** | Gladiator, wrestling, martial arts | High spectacle weight, element restrictions lifted, creature summons encouraged, crowd faction bonus +25% |
| **Debate Hall** | Formal debate, Oxford Union | Equal time, structured rounds, no spells, evidence-only, clarity scoring dominant |
| **Survival** | Battle royale, roguelike | Free arena, shrinking resource pool, increasing difficulty per round, last player standing |
| **Puzzle Chamber** | Puzzle games, escape rooms | Cooperative, time-limited, logic-heavy, no combat, projection-based problem solving |
| **Gauntlet** | Endless runners, Lifeforce, Gradius | Single-player, escalating difficulty, no pause, endurance-based scoring |
| **Trading Floor** | Resource management, Catan, Secret of Mana marketplace | Barter-focused, resource quotas, negotiation scoring, no combat |
| **Performance Stage** | Dance Dance Revolution, Guitar Hero, talent shows | Attention-based scoring, crowd reaction dominant, Visual Bursts amplified |

Presets are community-created through module discovery (§38). Anyone can propose a new preset. The community votes on it. Popular presets rise in search. Bad presets wilt.

**Combat loadouts (Final Fantasy / RPG inspired):**

Within arena matches, players can select a **combat loadout** — a configuration that emphasizes certain capabilities at the cost of others. Loadouts are not permanent. They are per-match selections. (Note: "class" in §40.6 refers to permanent element affinity from geography. "Loadout" is the per-match tactical selection.)

```
CombatLoadout {
  loadoutId:            string,
  loadoutName:          string,
  description:          string,
  modifiers: {
    evidenceCapacity:   number (multiplier on max evidence refs per action),
    projectionDepth:    number (multiplier on max projection depth),
    stackResponseTime:  number (multiplier on priority window duration),
    spellPowerMult:     number (multiplier on Power cost/effectiveness),
    stabilityMult:      number (multiplier on stability score),
    crowdInfluenceMult: number (multiplier on how much crowd faction helps you)
  },
  restrictions:         string[] (what this loadout cannot do)
}
```

**Standard classes:**

| Class | Strengths | Weaknesses | Playstyle |
|-------|-----------|-----------|-----------|
| **Advocate** | 2x evidence capacity, 1.5x projection depth | 0.5x spell power, no creature summons | Evidence-heavy, methodical, wins through proof |
| **Battlemage** | 2x spell power, 1.5x creature summons | 0.5x evidence capacity, reduced projection depth | Spectacle-heavy, aggressive, wins through combat drama |
| **Strategist** | 2x projection depth, 1.5x stability | 0.5x stack response time (slower reactions) | Long-game player, wins through complex projections and patience |
| **Duelist** | 2x stack response time (faster), 1.5x counter bonus | 0.5x projection depth, reduced evidence capacity | Reactive player, wins through timing and counterplay |
| **Diplomat** | 2x crowd influence, 1.5x negotiation bonuses | 0.5x spell power, 0.5x combat bonuses | Crowd-reader, wins by leveraging faction support and social dynamics |
| **Wildcard** | 1.0x everything (no bonus, no penalty) | None | Balanced, unpredictable, adapts to any terrain |

Loadouts are selected before the match and visible to the opponent. Knowing your opponent's loadout informs your strategy — but the crowd terrain adds unpredictability. An Advocate in a crowd-voted spectacle-heavy terrain is at a disadvantage. A Battlemage in an evidence-heavy terrain struggles. The interaction between loadout choice and terrain creates deep strategic complexity.

**Loadout discovery follows module discovery (§38).** The six standard loadouts are available from Novice tier. Advanced loadouts (community-designed through Arena Architect tier) unlock through demonstrated competence and community approval.

**Contract #161** and **Contract #162** apply to all sub-sections above. Additionally:

**Contract #163 — Crowd faction registration is visible, changeable, and directly influences match dynamics through collective resonance. Faction influence is capped (Category A parameter, default: +15% maximum bonus) and functions as a modifier, never a determinant. Switching factions reduces influence weight proportionally to switch count. Faction history is a permanent filament on the user's arena branch. Attention-based micro-rewards (Visual Bursts, small EC deposits, crowd effects, Power trickle) are deliberately small per instance and accumulate through sustained performance. Monster difficulty on game layer branches is governed by branch inhabitants through local difficulty parameters within global floor and ceiling bounds. Resource marketplaces use contextual barter pricing with skill-based trading advantages. Arena terrain can be contestant-agreed, crowd-random, or preset-based. Combat loadouts are per-match selections that emphasize different capabilities at the cost of others.**

**Contract #161 — Arena Branches are scoped environments with temporary parameter overrides that never modify core physics equations, custody, or canonical filaments outside the arena scope. The crowd votes on terrain metrics (scoring weights, tempo, complexity, visibility, volatility, evidence standards, procedural parameters) before and during matches. Pre-match terrain is determined by crowd median vote and revealed at match start. Mid-match terrain shifts are rate-limited and continuous. No machine can predict crowd terrain because it is generated by the irreducible collective preferences of the live audience. Stack resolution follows LIFO priority protocol: declare, priority pass, resolve. All arena actions are committed as ArenaContributionPackets with full deterministic replay capability. ArenaCoeffSets are immutable per match window. Arena Points expire when the arena ends. Arena scars, reputation filaments, and achievement tokens persist on the user tree.**

**Contract #162 — Arena reputation (ArenaRep) cannot convert to governance vote weight, organizational confidence, permissions, fiat currency, Power, or any resource that influences the truth or governance layers. ArenaRepGain is computed deterministically from win/loss, stability, confidence, attention, and participation integrity, multiplied by volatility tier and capped daily by opponent diversity. Losing produces reduced but non-zero reputation gain. Anti-farming caps prevent reputation inflation through repeated opponents. Camera-skill training produces ArenaSkillPackets with deterministic scoring from published thresholds. Singleplayer training does not earn reputation — only live matches against real opponents count. Free arenas allow visible alliance formation and betrayal — all social dynamics are on the record and become part of the participant's arena reputation. Arena is entertainment, training, and reputation. It is a lens, never a lever.**

### 68.20 Physical Sport Arenas — Paintball as Battle Training — Contract #320

> *"The battlefield is a scene of constant chaos."* — Napoleon Bonaparte

Relay's arena system is not limited to virtual duels or gesture-based combat. Any real-world physical sport played in a camera-equipped space becomes a Relay arena with live detection, real-time scoring, AR destruction graphics, and full SCV tracking. Paintball is the reference implementation — but the model applies to any physical competition sport.

#### 68.20.1 Paintball — The Reference Physical Arena

A paintball field with Relay-authorized cameras (§39.6) becomes a live battle training arena:

**What the cameras detect:**

| Detection Target | Method | Data Produced |
|-----------------|--------|--------------|
| **Paint splatter on players** | Color detection + splatter pattern analysis | Hit location (body zone), paint color (team identification), splatter radius (shot proximity), impact angle |
| **Paint splatter on walls/obstacles** | Surface change detection (before/after delta) | Territory control map, suppressive fire coverage, fortification marking |
| **Projectile tracking** | Motion detection between frames | Shot speed, trajectory arc, range estimation, rate of fire |
| **Player movement** | Skeletal tracking + position mapping | KIR (§43.10.13), cover usage, flanking patterns, team coordination, sprint/crouch/prone posture |
| **Player aim** | Barrel/marker direction tracking | Target selection, aim stability, lead correction, scope time |

**Real-time AR destruction overlay:**

When a paintball hits a surface or player, the AR overlay renders the impact as visible destruction:

- **Player hit**: The hit zone renders damage graphics — cracks, scorching, energy dissipation — scaled to hit severity (direct center-mass hit = heavy, grazing shoulder = light). The player's AR avatar shows progressive damage accumulation. A heavily-hit player looks "destroyed" in the AR overlay — their avatar cracking, flickering, trailing particles.
- **Wall/obstacle hit**: Paint splatters render as environmental destruction — blast marks, structural damage, melting surfaces. Over the course of a match, the battlefield visually transforms from pristine to war-torn. The AR overlay turns a simple paintball field into a cinematic battlefield.
- **Accumulation**: Every surface in the field accumulates an AR damage layer. By match end, the AR view shows the complete history of the battle — where fire was concentrated, which areas were contested, which were untouched.

**SCV Tracking — The Combat Intelligence Layer:**

Each player's SCV tracks real-time combat metrics:

```
PaintballCombatProfile {
  userId:             userRef,
  matchId:            arenaRef,
  teamColor:          string,

  // Accuracy metrics
  shotsFirered:       int,
  shotsHit:           int,
  accuracy:           float,       // hits / fired
  precisionScore:     float,       // weighted by body zone (headshot > torso > limb)
  
  // Target zone scoring
  headHits:           int,         // highest precision points
  torsoHits:          int,         // standard scoring
  limbHits:           int,         // reduced scoring
  equipmentHits:      int,         // marker/hopper hits (tactical disruption)
  
  // Movement metrics
  distanceCovered:    float,       // meters moved during match
  kineticInputRate:   float,       // KIR from §43.10.13 — movement generates AP
  coverTransitions:   int,         // how often player moved between cover positions
  flankingMoves:      int,         // lateral repositioning attempts
  
  // Tactical metrics  
  suppressiveFireScore: float,     // shots that forced opponents into cover (detected via reaction)
  territoryControlled:  float,     // percentage of field covered by team's paint
  revivesAssisted:      int,       // (if revival rules active) teammates helped
  
  // Paint detection
  paintColorsDetected:  string[],  // all paint colors camera identified
  hitsTaken:            int,       // times this player was hit
  eliminationTime:      float      // seconds survived before elimination
}
```

**Spells and magic guns:**

Paintball markers become spell weapons through the same input protocol (§43.10):

- **Marker = weapon**: The paintball gun registers as an input device. Zone detection on the marker body (grip, barrel, hopper, stock) enables gesture commands while holding the weapon.
- **Paint color = element**: Red paint = fire spells, blue paint = ice spells, green paint = earth spells, yellow paint = lightning. Team color determines which element your shots carry in the AR overlay.
- **Firing = spell casting**: Each shot expends Power (§41.5). Rapid fire drains Power faster. Precision shots cost less per hit (CPI efficiency). The real paintball shot AND its AR spell effect render simultaneously.
- **Special ammo as spell tiers**: Standard paint = standard spell. Glow-in-dark paint = charged spell (higher Power cost, bigger AR effect). Splatter rounds = area spells. The physical ammunition type maps to spell tier.
- **Grenades as area spells**: Paint grenades render as area-of-effect magic — explosion radius detected by camera, all surfaces within radius receive AR destruction.

**Live data feed:**

Spectators (both on-field and remote) see a live data overlay:

- Kill feed with AR destruction replays
- Player health bars (based on hits taken vs elimination threshold)
- Team territory control heatmap
- Individual accuracy and KIR leaderboards
- Spell effect highlights (biggest shots, longest-range hits, multi-eliminations)

#### 68.20.2 Generalization — Any Physical Sport

The paintball model generalizes to any camera-detectable physical sport:

| Sport | Detection | AR Overlay | Spell Mapping |
|-------|-----------|-----------|--------------|
| **Paintball** | Paint color, splatter, trajectory, body zone | Destruction graphics, territory control | Marker = wand, paint color = element |
| **Laser tag** | IR beam detection, sensor hits | Energy weapon effects, shield graphics | Tag gun = spell staff, beam color = element |
| **Archery** | Arrow trajectory, target impact, grouping | Magical arrow trails, target destruction | Bow = ranged weapon (§43.10.10) |
| **Fencing** | Blade contact, touch detection, footwork | Blade enchantment, touch = spell hit | Foil/épée/sabre = sword class weapon |
| **Martial arts sparring** | Strike detection, body zone contact, technique classification | Combat spell effects per technique | Body = empty hand (§43.10.2), KIR from movement |
| **Dodgeball** | Ball trajectory, catch/hit detection | Projectile spell effects, shield on catch | Ball = thrown weapon, catch = counter-spell |

Every physical sport arena follows the same architecture: cameras detect the physical action, the SCV classifies it against the sport's rule schema, AR overlays render the magical/combat interpretation, and all data commits as arena filaments with full deterministic replay.

**Contract #320 — Physical Sport Arenas. Any real-world physical sport played in a camera-equipped Relay space becomes a live battle training arena. Cameras detect physical actions (projectile tracking, body-zone hit detection, paint/impact analysis, player movement and posture). AR overlays render real-time destruction graphics on hit surfaces and players, accumulating over the match to show battle history. SCV tracks precision metrics (shot accuracy, body-zone scoring, movement KIR, tactical positioning, territory control). Physical projectiles and equipment map to the spell/weapon system: paintball markers are spell weapons, paint colors are elements, firing is spell casting with Power cost. Spectators see live data feeds with kill cams, territory heatmaps, and leaderboards. The model generalizes to any camera-detectable sport (laser tag, archery, fencing, martial arts, dodgeball). All match data commits as arena filaments with deterministic replay. Physical sport arena configuration (body zone point values, elimination thresholds, element mappings, AR effect intensity) follows standard arena governance with pre-match ArenaCoeffSet. The generalization model and the principle that physical action IS the combat input are frozen.**

---

## 69. Boundary Editing & Geographic Border Governance — Frozen Contract #164

> *"Good fences make good neighbors."* — Robert Frost

**Prerequisites:** §1 (the globe), §11.6 (global parameter registry), §19 (governance), §29 (proximity channels), §46 (sortition), §33.5 (LOD rendering).

The 375 GeoJSON files in `data/boundaries/` are not static decorations. Geographic boundaries in Relay are **governed objects** — proposable, editable, votable, and committable through the same governance physics that governs everything else. Country borders, state lines, city limits, district boundaries, and custom zones are all mutable through democratic process. The globe's political geography evolves as the world evolves.

### 69.1 Why Boundaries Are Governed

Physical territory shapes governance. Who votes on what is partially determined by where they are (§29 proximity channels, §11.6 geographic scoping). If the boundary of a city changes — a district is annexed, a new municipality is incorporated, a disputed border shifts — the voting population for that scope changes. Boundary changes are governance changes. They must follow governance rules.

### 69.2 Boundary Data Model

Every boundary in Relay is a GeoJSON polygon (or MultiPolygon) with governance metadata:

```
RelayBoundary {
  boundaryId:          string,
  regionType:          enum { COUNTRY, PROVINCE, CITY, DISTRICT, CUSTOM_ZONE },
  name:                string,
  parentBoundaryId:    string | null (hierarchical nesting),
  geometry:            GeoJSON (Polygon | MultiPolygon, with holes supported),
  geometryHash:        SHA-256 (deterministic canonical hash of geometry),
  resolution:          enum { LOW_110m, MEDIUM_50m, HIGH_10m },
  status:              enum { ACTIVE, PROPOSED, HISTORICAL, DISPUTED },
  governanceRef:       branchRef (the governance branch managing this boundary),
  lastCommitId:        commitId,
  lastModified:        ISO-8601
}
```

Boundaries nest hierarchically: cities inside provinces, provinces inside countries, countries inside continents. Every point on the globe belongs to exactly one boundary at each level. Overlap is a governance error that triggers sortition resolution (§46).

### 69.3 The Boundary Edit Pipeline

Modifying a boundary follows a strict state machine — the same DRAFT → PROPOSE → COMMIT pattern used throughout Relay, with additional gates specific to geographic changes:

```
IDLE
  |
  v
DRAFTING — User draws or modifies boundary geometry on the globe
  |        Visual: dashed yellow outline (proposed) vs solid green (current)
  |        Operations: add vertex, remove vertex, drag vertex, undo
  |        Validation: minimum 3 vertices, ring closure, coordinate range,
  |                    NaN guard, geometry hash computed
  |
  v
HOLD — Draft is saved but not yet public
  |     The proposer reviews, refines, prepares evidence
  |
  v
PROPOSED — Draft is published to the boundary governance branch
  |         Visual: proposed boundary appears as dashed yellow overlay
  |         for all users in the affected region
  |         Diff preview: red = territory added, blue = territory removed
  |
  v
VOTING — Hierarchical vote (see §69.4)
  |
  v
COMMITTED — Boundary change takes effect
  |          Geometry hash re-verified (REFUSAL if mismatch)
  |          Custody signature required
  |          Evidence references required
  |          Old boundary becomes HISTORICAL (preserved, never deleted)
  |
  (or)
  v
REVERTED — Proposal rejected, boundary unchanged
           Revert is itself a committed event with evidence
```

**Draft geometry editing:**

Users edit boundaries directly on the 3D Cesium globe through two interfaces:

- **Globe editor**: Click to add draggable pinpoint vertices on the 3D globe. Right-click to delete vertices. Drag to reshape. Selection tools: Single (click), Box (rectangular selection), Lasso (freeform selection), View (inspect without edit).
- **Map editor**: Alternative 2D flat-map interface for users who prefer traditional cartographic editing.

Both editors produce the same GeoJSON output. The geometry hash is computed through deterministic JSON canonicalization (sorted keys, normalized coordinates) so the same vertices always produce the same hash regardless of which editor was used.

### 69.4 Hierarchical Voting — One Level Up

Boundary changes are voted on by the **next level up** in the geographic hierarchy. This prevents self-serving boundary manipulation:

| Boundary Level | Who Votes | Rationale |
|----------------|----------|-----------|
| **District** boundaries | City residents | The city governs its internal districts |
| **City** boundaries | Province residents | The province governs its cities |
| **Province** boundaries | Country residents | The country governs its provinces |
| **Country** boundaries | Region/continent residents | The region governs its countries |
| **Continent/Region** boundaries | All world users | The world governs its regions |
| **Custom zones** | Parent boundary residents | The containing boundary governs custom zones within it |

Each boundary level has one unified **boundary channel** where competing proposals are ranked by vote count. The highest-voted proposal becomes the active boundary when it crosses the approval threshold (Category A parameter, default: 60% of eligible voters who participated).

**Voting display:**

The boundary channel panel shows all active proposals sorted by vote count, with breakdowns:

- Local votes (from residents of the affected boundary)
- External votes (from residents of the parent boundary but outside the affected area)
- Vote trajectory (trending up, stable, declining)
- Visual diff preview: territory gained (red overlay) vs territory lost (blue overlay)

### 69.5 Boundary Modification Types

The system supports both manual editing and algorithmic modifications:

| Modification Type | Description | Use Case |
|------------------|-------------|----------|
| **Manual draw** | User draws new boundary from scratch | New district creation, custom zone |
| **Vertex edit** | User moves, adds, or removes individual vertices | Fine-tuning existing boundary |
| **Expand** | Algorithmic expansion by configurable percentage | Annexation, growth |
| **Contract** | Algorithmic contraction by configurable percentage | Territory cession |
| **Shift** | Algorithmic translation in a compass direction | Border adjustment |
| **Segment adjust** | Modify a specific segment of the boundary while preserving the rest | Localized border dispute resolution |
| **Split** | Divide one boundary into two or more | Municipal incorporation, state division |
| **Merge** | Combine two or more boundaries into one | Consolidation, unification |

All modification types produce a complete proposed GeoJSON geometry with a deterministic hash. The voting process is identical regardless of how the geometry was produced.

### 69.6 Multi-Resolution Streaming

Boundary rendering adapts to zoom level through a streaming service:

| Zoom Level | Resolution | Detail | Use Case |
|-----------|-----------|--------|----------|
| 0–2 (globe view) | 110m | Continent outlines, major country shapes | Global overview |
| 3–7 (region view) | 50m | Country and province boundaries with moderate detail | Regional navigation |
| 8–11 (local view) | 10m | City boundaries, district lines, precise vertex positions | Local governance, boundary editing |

Higher resolutions are loaded on demand as the user zooms in. Pre-chunked boundary tiles enable fast delivery without loading the entire world's geometry at once.

### 69.7 Boundary Containment & Scope Enforcement

Every boundary provides a `containsLL(lat, lon)` function — point-in-polygon query that determines which boundary a given coordinate falls within. This function is used throughout Relay for:

- **Vote scoping**: Determining which users are eligible to vote on which governance parameters (§11.6)
- **Proximity channel assignment**: Linking proximity channels to geographic jurisdictions (§29)
- **Civic enforcement routing**: Routing civic observation filaments to the correct municipal branch (§61.3)
- **Certification region**: Determining which regional certification requirements apply (§58.12)
- **Content classification**: Applying region-specific content rules (§63.4)

Scope enforcement prevents unauthorized boundary changes: if a user's demonstrated scope does not include the affected boundary, the change is refused with `[REFUSAL] reason=SCOPE_VIOLATION`.

### 69.8 Disputed Boundaries

When two or more proposals for the same boundary are active simultaneously and neither reaches the approval threshold, or when the proposals directly conflict (overlapping territory claims), the boundary enters `DISPUTED` status:

- Both proposed boundaries are rendered (dashed yellow and dashed orange)
- The active boundary remains the pre-existing ACTIVE geometry until the dispute is resolved
- Dispute resolution follows sortition (§46) — a jury is drawn from the next level up
- The jury reviews evidence: historical boundaries, population data, infrastructure maps, community testimony
- The verdict becomes a committed boundary change with full evidence chain
- The losing proposal becomes a HISTORICAL record with a scar

### 69.9 How This Connects to Existing Architecture

**§1 (The Globe):** Boundaries are the political layer on the globe. They partition the surface into governed zones. Every trunk that rises from the globe exists within a boundary hierarchy.

**§11.6 (Global Parameter Registry):** Many parameters are scoped to boundaries. A municipal parameter (e.g., enforcement task minimum wage, §61.4) applies within the city boundary. Changing the boundary changes the parameter scope.

**§19 (Governance):** Boundary changes ARE governance commits. They follow the same DRAFT → PROPOSE → COMMIT lifecycle with evidence requirements and custody signatures.

**§29 (Proximity Channels):** Proximity channels are anchored to physical locations. Boundary containment determines which proximity channels fall within which governance scope.

**§46 (Sortition):** Disputed boundaries escalate to sortition resolution. The jury pool is drawn from the next-level-up boundary, consistent with the hierarchical voting model.

**§20 (Cryptographic Architecture):** Geometry hashes provide Merkle-anchored integrity for boundary data. The same vertices always produce the same hash. Any tampering between PROPOSED and COMMITTED states is detected and refused.

**Contract #164 — Geographic boundaries are governed objects that follow the DRAFT → HOLD → PROPOSE → VOTE → COMMIT state machine. Boundary changes are voted on by residents of the next level up in the geographic hierarchy (district changes by city, city by province, province by country, country by region, region by world). Boundary geometry is deterministically hashed; hash mismatch between proposal and commit triggers refusal. All boundary modifications (manual draw, vertex edit, expand, contract, shift, segment adjust, split, merge) produce complete GeoJSON with verifiable hashes. Multi-resolution streaming (110m/50m/10m) adapts to zoom level. Disputed boundaries remain at the pre-existing active geometry until sortition resolution. Old boundaries become HISTORICAL records, never deleted. Boundary containment determines vote scoping, proximity channel jurisdiction, civic enforcement routing, and certification region applicability.**

---

## 70. V93 Retained Systems — Architectural Integration Index — Frozen Contract #165

> *"What is past is prologue."* — William Shakespeare, The Tempest

The V93 codebase (preserved under tag `RELAY-PRE-CLEAN-ARCHIVE-V93`) contained dozens of implemented subsystems. This section ensures every significant v93 system is architecturally accounted for — either as a dedicated section, as a component of an existing section, or as an engineering implementation detail under §48. Nothing is lost. Everything is mapped.

### 70.1 Democratic Messaging & Channels

Relay's communication is not a separate chat app bolted onto the tree. Messaging IS filament creation on shared branches. Every message is a filament. Every conversation is a branch. Every channel is a sub-tree.

**What v93 implemented:** A WhatsApp-like messaging engine with emoji reactions, threading, file sharing, read receipts, forwarding, and democratic moderation (percentile-based filtering where the community's vote distribution determines message visibility).

**Where it lives in the Master Plan:**

- Messages are filaments on proximity channel branches (§29) or organizational branches (§19)
- Threading = branch nesting (§3)
- Reactions = lightweight vote filaments (§7)
- Read receipts = presence markers (§17)
- File sharing = evidence attachments on filaments (§9)
- Democratic moderation = filter tolerances (§12) applied to message branches — the community's vote distribution determines which messages are visible at default filter settings. Messages with low confidence sink. Messages with high confidence rise. No centralized moderator.
- Forwarding = filament reference (evidence twig pointing to the source message filament on another branch)

No separate messaging section is needed because messaging is a direct application of existing tree physics. The v93 implementation details (WebSocket transport, message bubble rendering, typing indicators) are engineering infrastructure (§48).

### 70.2 Notification Pipeline

**What v93 implemented:** Smart notifications with per-user preferences, keyword subscriptions, mention detection, unread tracking, and real-time WebSocket delivery.

**Where it lives:** Notifications in Relay are not a separate system. A notification is a **scheduled filament** (§5b) on the user's personal attention branch that fires when a relevant event occurs on a watched branch. Keyword subscriptions are filter configurations (§12). Mention detection is a specific filament reference pattern. Real-time delivery is engineering infrastructure (§48, WebSocket layer).

### 70.3 Wallet, Payments & Commission

**What v93 implemented:** Unified wallet handling storage payments, channel funding, contract-based job payments, tax documentation, donations, and global commission collection/distribution with founder account transparency.

**Where it lives:**

- Wallets are the economic branch of the user tree (§8), containing TransferPacket filaments (§31)
- Payments follow the double-entry TransferPacket model (§31) — every credit has a debit
- Donations are TransferPackets with `transferType = DONATION` — same accounting, different classification
- Global commission is a Category A parameter (§11.6) — a governed percentage applied to certain transaction types, collected into the platform's operational tree
- Tax documentation is generated from the TransferPacket evidence chain — the Merkle-anchored audit trail IS the tax record
- Founder account transparency is a specific disclosure tier (§8.5) applied to the founder's economic branch

### 70.4 Sybil Enforcement Orchestrator

**What v93 implemented:** End-to-end pipeline: detect anomaly → select jury → conduct review → render verdict → apply trust burn to inviter chain → manage account status → handle appeals.

**Where it lives:** §49 (Adversarial Edge-Case Model) covers the detection and classification. §46 (Sortition) covers jury selection and verdict. The orchestrator is the coordination layer that routes between them. The **trust burn to inviter chain** is architecturally significant and is captured here:

```
TrustBurnCascade {
  violatorUserId:    string,
  violationType:     enum { SYBIL, BOT, FRAUD },
  verdictRef:        commitId (sortition verdict),
  burnChain: [
    { userId: string, relationship: DIRECT_INVITER, burnAmount: number },
    { userId: string, relationship: INVITER_OF_INVITER, burnAmount: number (decaying) },
    ...
  ],
  burnDecayRate:     number (each hop reduces burn by this factor, default: 0.5),
  appealWindow:      duration (default: 14 days)
}
```

When a Sybil account is confirmed, trust burns cascade up the invite chain with decaying severity. The person who directly invited the Sybil account takes the largest trust hit. Their inviter takes half. And so on. This creates a structural incentive to invite only real humans — your reputation is at stake.

### 70.5 Biometric Password Dance

**What v93 implemented:** Multi-modal biometric authentication combining voice + facial gestures ("password dance") with ML-based matching, template storage, and adaptive reverification.

**Where it lives:** §30 (Verification Physics) covers the principle. The concrete mechanism is:

- The user's **password dance** is a unique sequence of facial expressions, head movements, and spoken words that serves as their biometric key
- The dance is captured by the device camera and processed locally (contract #49 — detection mesh local-first)
- ML models (voice recognition + face gesture recognition) compare the live dance against the stored template
- Reverification is triggered by risk assessment: low-risk actions need no re-dance, high-risk actions (large transfers, governance votes, boundary proposals) require fresh verification
- The template is stored encrypted on the user's device and Shamir-shared (§66.1) for recovery — never on central servers

### 70.6 Vote Token Economy & Decay

**What v93 implemented:** Two-phase token system (new users earn tokens through engagement, trusted users get unlimited), multiple decay algorithms, and vote reconciliation across geographic levels.

**Where it lives:** §11 (Parametric Governance) covers the voting mechanism. §41 (Multi-Resource Economy) covers the resource channels. The token economy is a specific implementation of Engagement Credits (§41.1) with these additional mechanics:

- **New user phase**: Fresh accounts receive a limited initial token pool (governed parameter). Tokens are earned through participation (commits, votes, evidence contributions). This prevents Sybil accounts from immediately flooding governance with votes.
- **Trusted user phase**: After demonstrating sustained legitimate participation (trust tier threshold, §46.3), users transition to unlimited voting within their eligible scope. The limit disappears because the user has proven they are real.
- **Vote decay**: Votes cast on governance parameters decay over time (consistent with §14 gravitational time). Recent votes carry more weight than old votes. Decay rate is a Category A parameter. Multiple algorithms are available: linear, exponential, step, custom — selected per parameter type.
- **Geographic reconciliation**: Votes on geographically scoped parameters are reconciled hierarchically using the boundary containment system (§69.7). A vote cast in a city aggregates to province, which aggregates to country, which aggregates to region.

### 70.7 Onboarding, Invite Tree & Temporal Mixing

**What v93 implemented:** Full onboarding flow (invite validation → biometric uniqueness → behavioral baseline → user creation), decaying invite tree, group onboarding, proximity onboarding, and temporal mixing for privacy.

**Where it lives:** §57 (Adoption Tiers) covers integration depth. §58 (Education) covers the tutorial. The onboarding-specific mechanics:

- **Invite tree**: Every user was invited by someone (except the founder). The invite relationship is a committed filament. Invite chains create a tree-within-the-tree — the social trust graph. Trust burns (§70.4) cascade along this graph.
- **Behavioral baseline**: During onboarding, the system collects a behavioral baseline (typing cadence, interaction patterns, device fingerprint) used for continuous verification and anomaly detection. This is stored locally (privacy-first) and used only for self-verification.
- **Temporal mixing**: Invite creation times are batched and shuffled (Fisher-Yates) with timestamp obfuscation to prevent network analysis from correlating who invited whom based on timing patterns. This protects the invite graph from external surveillance.
- **Proximity onboarding**: A new user can be onboarded by physically meeting an existing user (proximity channel verification, §29). This provides the strongest identity assurance — the inviter physically saw the invitee.

### 70.8 Regional Elections & Multi-Sig Treasury

**What v93 implemented:** Democratic elections for 5 regional positions (Governor, Technical Lead, Financial Steward, Community Liaison, Security Officer), multi-signature treasury with 3-of-5 approval threshold.

**Where it lives:** §46.8 (Relay Sortition Council) covers the top-level elected governance. Regional elections extend this model downward:

- Each boundary region (§69) can elect governance officers through continuous confidence voting (same mechanism as the Council, §46.8)
- Regional officers manage the regional treasury — a multi-signature account requiring M-of-N approval for spending (default: 3-of-5)
- Treasury spending proposals are governance commits with evidence requirements
- Weekly transparency reports are published as filaments on the regional governance branch
- The regional governance model is a fractal application of the Council model (§60 fractal branching) — the same governance physics at a smaller scale

### 70.9 P2P Networking & DHT

**What v93 implemented:** Complete P2P networking stack with peer discovery, distributed hash table, connection management, and protocol handling.

**Where it lives:** §48 (Engineering Infrastructure) and §66 (Microsharding). The P2P layer is the transport mechanism for the distributed storage economy:

- **Peer discovery**: Nodes find each other through a combination of bootstrap nodes, DHT announcements, and proximity channel detection (§29)
- **Distributed Hash Table**: Content-addressed storage lookup. Shard manifests (§66.1) reference DHT keys for shard location resolution.
- **Connection management**: Persistent connections to nearby peers (proximity-weighted), ephemeral connections to distant peers (on-demand for shard retrieval)
- **Protocol**: Relay's P2P protocol handles shard transfer, proof-of-storage challenges (§66.3), presence broadcasts (§17), and governance commit propagation

### 70.10 Signal Protocol & End-to-End Encryption

**What v93 implemented:** Full Double Ratchet protocol with forward secrecy, X25519 key exchange, ChaCha20-Poly1305 encryption, and group message encryption.

**Where it lives:** §20 (Cryptographic Architecture). The Signal Protocol is the specific E2E encryption mechanism for private communication:

- All private messages (filaments at `disclosureTier = 0`) are encrypted using the Double Ratchet protocol
- Forward secrecy ensures that compromising a current key does not decrypt past messages
- Group encryption extends the protocol for multi-party branches with shared ratchet states
- Key exchange uses X25519 (Curve25519 Diffie-Hellman) — the same curve used by Signal, WhatsApp, and Matrix
- This is consistent with Contract #150 (private data absolutely uninspectable) — the encryption mechanism that enforces the constitutional boundary

### 70.11 Additional Retained Systems

| V93 System | Master Plan Location | Notes |
|-----------|---------------------|-------|
| Anonymous vote relay (Fisher-Yates shuffle, timestamp obfuscation) | §20 (Crypto), §11 (Governance) | Vote anonymity mechanism — votes are shuffled and batched before recording |
| Censorship resistance (tunneling, proxy chains, domain fronting) | §48 (Engineering) | Network-level mechanisms for operation in censored jurisdictions |
| Risk assessment engine (4-tier scoring) | §30 (Verification), §49 (Adversarial) | Continuous risk scoring triggers appropriate verification levels |
| Guardian recovery (Shamir key share reconstruction with approval timeout) | §48.2.2 (Guardian Contacts), §71.6 (KMS) | Account recovery through trusted human guardians holding Shamir key shares |
| Spatial voter index (H3 hexagonal grid) | §69.7 (Boundary Containment) | Efficient spatial indexing for millions of voters using H3 hexagonal hierarchy |
| Hardware scanning service (Bluetooth/WiFi detection) | §29 (Proximity Channels) | The physical device layer that feeds proximity detection |
| Dictionary/semantic system | §56 (Language Trees) | Word-level semantic linking and multi-language support |
| Developer proposal/bounty system | §46.8 (Council module approval) | Module proposals with bounties follow the sandbox → proposal → vote → council pipeline |
| Content voting/newsfeed | §7 (Social Layer), §12 (Filters) | Content ranking through tree physics replaces algorithmic newsfeeds |
| Trust level tiering (Probationary → Trusted → Verified → Anchor) | §46.3 (Eligibility), §8 (User Tree) | Four trust tiers with accrual mechanics and reverification intervals |
| Bot detection (behavioral scoring) | §49 (Adversarial) | Automated detection feeding into Sybil enforcement pipeline |
| Blockchain sync | §20 (Crypto), §48 (Engineering) | Merkle chain synchronization across distributed nodes |
| Storage pricing governance | §66.5 (Storage Economy) | Community-governed pricing captured in microsharding section |
| Phantom visibility / anonymous mode | §8.5 (Disclosure Tiers) | Tier 0 operation — fully private, no public presence |
| Founder mode / reports | §44 (Founder Key) | Founder-specific transparency and activation mechanics |
| No-dialogue state change rule | §19 (Governance) | Governance constraint requiring prior discussion before state changes |
| Device recovery / management | §70.5 (Biometric), §48.2.2 (Guardian Contacts), §66.4 (Sentinel Vault) | Device loss recovery through biometric re-verification, Shamir key reconstruction via human guardians, and data shard re-replication via sentinel nodes |
| File import / coordination | §37 (Knowledge Migration) | Multi-format file import (Excel, text, binary) converting to filaments |

**Contract #165 — All significant V93 subsystems are architecturally accounted for in the Master Plan. Democratic messaging is filament creation on shared branches with democratic moderation through filter tolerances. Notifications are scheduled filaments on the user's attention branch. Wallets are the economic branch of the user tree using TransferPackets. Sybil enforcement cascades trust burns up the invite chain with decaying severity. Biometric password dance is a multi-modal local-first authentication mechanism using ML voice + facial gesture matching. Vote tokens follow a two-phase model (limited for new users, unlimited for trusted users) with temporal decay and geographic reconciliation. Onboarding uses invite trees with temporal mixing for privacy. Regional elections extend the Council model fractally with multi-signature treasury governance. P2P networking provides the transport layer for distributed storage and presence. Signal Protocol (Double Ratchet with X25519) enforces the cryptographic privacy boundary for private filaments.**

---

## 71. Architectural Clarifications — Frozen Contracts #167–175

> *"God is in the details."* — Ludwig Mies van der Rohe

**Prerequisites:** All prior sections. Each subsection is a binding architectural decision that governs how cross-cutting concerns interact across the system.

### 71.1 Privacy Operates on Available Data Only

§61.1 is absolute. There is no SCV exception for Tier 0 data. The system operates only on what is available at the current disclosure tier.

Child safety mechanisms (§63.3) work with whatever metadata exists at Tier 1+ — interaction frequency on shared branches, public presence patterns, proximity channel events. If an adult-to-minor interaction happens entirely at Tier 0, the system is structurally blind to it. This is by design.

The mitigation is structural, not surveillance:
- All shared branches (community spaces, classrooms, group activities) operate at Tier 1+ by default — so interaction patterns on shared spaces are visible
- Minor accounts under CHILD bracket cannot receive direct private channels from adults (§63.3 already mandates this)
- TEEN accounts can receive DMs, but DM channels between an adult and a teen are visible as branch existence at Tier 1 (the branch exists and its shape is visible; the content inside is Tier 0)
- Pattern detection operates on branch existence and shape metadata, not content

The privacy boundary stands. The child safety system works within it.

### 71.2 All Resources Flow Everywhere

Achievement Tokens, Engagement Credits, and Power can all be earned in any context — truth layer, game layer, arena, education, civic participation. The separation between resource types is about WHAT they unlock, not WHERE they are earned.

- **AT** (Achievement Tokens) = proof of demonstrated skill, regardless of where demonstrated. An arena competitor who demonstrates mastery earns AT. A student who passes certification earns AT. A civic volunteer who completes community work earns AT.
- **EC** (Engagement Credits) = proof of participation and contribution
- **Power** = game layer casting resource

Achievement tokens can be earned through SCV-validated achievements in any context — truth layer real-world actions, arena performance, education certification, civic contribution. The validation requirement (SCV-verified evidence) remains non-negotiable. Virtual-only engagement without demonstrated skill or validated evidence yields only engagement credits. The gradient is: skill-validated effort → AT, participation → EC, game casting → Power.

All resources can be traded within Relay's economy. The "no resource conversion" rule (Contract #47) applies specifically to resource TYPE conversion (EC→AT, AT→Power, etc.) — you cannot convert one resource type into another. Trading game layer items, objects, and marketplace goods (§68.16) denominated in EC is permitted. The marketplace trades items, not resource types.

### 71.3 Audience Resolution — Unified Duel & Arena Model

Duels (§42) and arena matches (§68) are the same system, not two systems. The audience IS the resolution mechanism.

In duels and court cases, rules are determined and agreed upon up front. The audience then influences the outcome through votes and environmental metrics. The stack resolution protocol (§68.3) computes deterministic scoring from evidence quality, spectacle, and crowd metrics — the crowd metrics ARE the audience vote, flowing continuously into the resolution calculation.

**How it works:**
- Contestants agree on rules before the match: duration, stakes, topic scope, terrain mode (agreed/crowd-random/preset), and whether audience influence is toggled ON or OFF
- When audience influence is ON: the crowd's aggregate voting on terrain metrics directly weights the scoring calculation. If you are in an area where people don't like you, you will probably lose based on the crowd vote alone regardless of your performance
- When audience influence is OFF: scoring is computed from evidence quality, stability, and heat only — no crowd component
- **This is fair.** A local area is governed by the locals. They have priority in their area. You are a tourist. If you want a neutral fight — go to a Global Arena where crowd composition is diverse and no faction has home advantage

**The audience toggle is the key rule attribute.** It must be explicitly set when defining match terms. Duels with the toggle ON are social accountability mechanisms — being disrespectful in real life has consequences. You can be challenged. You will lose resources or public opinion. You will be shamed. This incentivizes manners in the videotaped real world.

§42 describes the audience model in narrative terms. §68 formalizes the scoring calculation. The "audience votes on who convinced them" IS the crowd terrain metrics feeding into the `ArenaContributionPacket` scoring weights. §42 is the user-facing explanation; §68 is the implementation specification.

**Pre-activation vs post-activation:** Before game layer activation (§44), duels use the evidence-debate format only (no spells, no creatures, no element casting). After activation, the full arena system engages. All duels occur within arena branches.

### 71.4 Latest-Write Display Within Append-Only

Both commits are always preserved (append-only is absolute). The `LATEST_DISPLAY` conflict resolution mode is a display policy, not a data policy.

When two offline users commit to the same filament and sync later:
1. Both commits are accepted into the Merkle chain (append-only, Contract #1 holds)
2. Both carry their local timestamps and are hash-linked to their predecessors
3. The `conflictResolution` strategy determines **which commit is displayed as the default view**: `LATEST_DISPLAY` shows the most recent timestamp as the primary view, `MERGE` presents both inline, `MANUAL_REVIEW` flags for human decision
4. The non-displayed commit is always accessible through the filament's full commit history

No data is ever overwritten or discarded. `LATEST_DISPLAY` clarifies that it is a rendering preference, not a data operation.

### 71.5 Audience Impact as a Toggled Rule Attribute

In all arenas, duels, and court cases, the degree of audience influence on the outcome is a toggleable attribute that must be explicitly agreed upon when defining the rules.

**For duels:** Audience influence is either ON or OFF. When ON, crowd terrain metrics feed into scoring. When OFF, resolution is evidence-only.

**For court cases:** Jury operating parameters (size, deliberation time, verdict threshold, blind jury mode) are NOT crowd-votable. They are governance-level sortition parameters (§46) set by §11 weighted-median governance. The crowd can influence ATMOSPHERE (tempo, complexity, presentation style) but NOT procedural justice parameters. Jury size, verdict threshold, deliberation time, and evidence standards remain §46 governance defaults.

**Governance floor rule:** Governance-level parameters (§11) cannot be overridden by crowd voting. Minimum deliberation time, minimum jury size, and evidence standards all have governance-enforced floors that crowd terrain voting cannot breach. Crowd voting adjusts the experience within bounds; it never overrides the constitutional framework.

### 71.6 Key Management System

The Key Management System (KMS) is the subsystem responsible for creating, storing, distributing, rotating, and destroying content encryption keys (CEKs) and their Shamir shares (a method of splitting a secret key into multiple pieces so that a minimum number of pieces are needed to reconstruct the original).

```
KeyManagementSystem {
  scope:                  enum { USER_LOCAL, BRANCH_SHARED, TREE_GLOBAL },
  cekGeneration:          AES-256-GCM (per-filament or per-shard-group),
  cekStorage:             LOCAL_KEYCHAIN (never transmitted unencrypted),
  shamirSplitting: {
    threshold:            number (K-of-N reconstruction minimum),
    totalShares:          number (N total shares distributed),
    shareDistribution:    enum { GUARDIAN_CONTACTS, SENTINEL_NODES, HYBRID }
  },
  keyRotation: {
    trigger:              enum { TIME_INTERVAL, SECURITY_EVENT, MANUAL },
    rotationInterval:     number (days, configurable per tree policy),
    forwardSecrecy:       boolean (true — old keys cannot decrypt new content)
  },
  keyDestruction: {
    trigger:              enum { USER_REQUEST, LEGAL_ORDER, COPPA_ERASURE, GDPR_ART17 },
    mechanism:            CEK destruction → all encrypted shards become tombstones,
    auditTrail:           CryptographicErasureEvent committed to Merkle chain (§65.1)
  },
  recoveryPath: {
    shamirReconstruction: K-of-N guardian/contact shares → reconstruct CEK,
    biometricFallback:    Password Dance (§70.5) → re-derive device-local keys,
    timeoutPolicy:        Guardian shares must respond within configurable window (default: 72h)
  }
}
```

**Guardian vs sentinel disambiguation:**
- **Guardian contacts** (§48.2.2): Trusted HUMANS who hold Shamir key shares for account recovery
- **Sentinel nodes** (formerly "guardian nodes" in §66.4): High-reputation STORAGE PROVIDER machines that hold emergency backup data shards

These are different systems. Guardian contacts hold KEY shares. Sentinel nodes hold DATA shards.

### 71.7 Final Commit for Closures and Broken Items

When anything in Relay stops being used — an account closes, a device fails, a storage provider goes offline, a shard manifest becomes stale — the final action is a **closure commit** on the chain the item belongs to.

**Closure commit mechanics:**
- A closure commit is a standard filament commit with `lifecycleState: CLOSED` and a `closureReason` field
- For stale `ShardManifest`: when shards are re-replicated to new nodes, a new `ShardManifestUpdate` commit is appended referencing the original manifest's hash and recording the new shard locations. The original manifest remains (append-only), the update commit carries the current routing
- For account closures: a `AccountClosureCommit` is appended to the user tree root, marking the tree as closed. All associated CEKs follow the key destruction path (§71.6). Merkle chain entries become tombstones — hash preserved, content unreadable
- For device loss: a `DeviceLossCommit` triggers guardian recovery (Shamir reconstruction) and shard re-replication for any shards that were unique to that device
- For storage provider failure: a `ProviderFailureCommit` triggers automatic re-replication (§66.3) and a manifest update commit

**The principle:** Nothing disappears silently. Every ending is a commit.

### 71.8 Entity Privacy, Materiality & Tree Anchors

On the globe LOD (level of detail — how much visual information is shown at different zoom levels), the world has privacy-appropriate materiality objects. Companies classified as certain types have standardized tree anchor types so viewers can quickly identify what they are:

**Anchor classification:**
- Banks, financial institutions → financial anchor type
- Supermarkets, retailers → commercial anchor type
- Hospitals, clinics → medical anchor type
- Schools, universities → educational anchor type
- Government offices → civic anchor type
- Residential → personal anchor type

Anchor types are assigned through template selection when creating the tree. The anchor type determines the tree's visual silhouette on the globe — recognizable category shape without revealing internal details.

**Inside vs outside:**
- **Owners and employees** (users with branch-level access) see inside their own tree — branches, filaments, twigs, internal health metrics. This is the operational view.
- **Clients and customers** (external users) see only the outside anchor tree — the public-facing exposed filaments that the company has chosen to publish. Like a personal presence profile (§8.6), companies control what the world sees.
- **Discovery of unfinished work** (twigs, open filaments, internal issues) happens at the ownership level only. External users do not see internal twigs.

**Tree anchor appearance on the globe scale** is determined by average attention rates — how much interest the entity attracts. Higher attention = more prominent rendering at globe LOD.

**Exposure rules:**
- Exposed filaments from other people (counterparties, employees) on a company tree only show their shapes if those people have agreed to be visible on that branch. Otherwise, counterparty identity is anonymous.
- Nothing exposes without justification and need
- What you expose on your public-facing tree is exactly like your personal presence profile — you choose what to show, at what tier, for what context

### 71.9 Privacy Granularity — Per Filament, Per Branch, Per Tree

Privacy disclosure operates at three granularity levels:

| Level | What It Controls | Who Sets It |
|-------|-----------------|-------------|
| **Per filament** | Individual filament disclosure tier (0, 1, or 2) | The user who committed the filament, at commit time |
| **Per branch** | Default disclosure tier for all filaments on a branch | Branch owner/template policy |
| **Per tree** | Default disclosure tier for the entire tree | Tree owner |

**Inheritance:** Filament tier overrides branch tier. Branch tier overrides tree tier. The most specific setting wins.

**Direction rule:** Disclosure can only be RAISED (made more visible) from the default, never LOWERED below the level at which data was committed. A PresenceProfile (§8.6) can SUPPRESS visibility (hide branches from your broadcast), but it cannot EXPOSE data beyond its committed tier. Profiles are one-way filters: they reduce what others see, they never increase it.

**Canonical tier definitions:**
- **Tier 0:** Private. Invisible to all external observers. Contributes to aggregate tree shape but content/identity/counterparty hidden.
- **Tier 1:** Semi-public. Branch shapes visible, individual filaments visible as shapes without content detail. Role badge identity.
- **Tier 2:** Fully public. Named identity, individual filament content inspectable by authorized parties.

§17.2 describes the consent mechanism for tier transitions. §48.2 describes registration requirements per tier. Tier 1 IS a gradation of visibility — viewers at Tier 1 see shapes but not content. "Fully inspectable" means: at whatever tier data is committed, it is inspectable to the FULL extent of that tier. Tier 1 data is fully inspectable at the Tier 1 level (shapes, metadata). Tier 2 data is fully inspectable at the Tier 2 level (content, identity).

### 71.10 Credentials Are Your Commit Record

Credentials are simply your proven record of commits, all held with high confidence at the time committed by people who themselves held high confidence at the time. Relay's certification model is not a "certificate" in the traditional sense — it is a confidence-verified commit chain on your tree that proves demonstrated competence.

There is no external degree, no paper diploma, no institution-issued certificate. There is only the tree. The tree IS the credential. An employer looking at your user tree sees demonstrated modules, grading commits from high-confidence teachers at the time of grading, and the structural shape of your learning branch. That is the resume.

**Profile reveal for employment:**

Settings within Relay enable you to view your own full tree or any of your presence profiles. You control what you show, when, and where.

An employer might require you to reveal your tree at a specific disclosure level. Even without seeing individual filament content, an employer can observe:
- The structural difference between your full tree and a filtered profile. If you flip between modes, they see that only 3-6% of the tree differs between baseline and Profile 1.
- An employer could request a threshold: "Show me 85% of your tree." A job description could state: "60% tree reveal required."
- The percentage represents how much of your tree's branch structure and shapes are visible — not filament content. It gives employers enough to assess breadth, depth, and consistency without exposing private details.
- It is up to you to classify your life properly and organize your profiles to impress. Infinite organization levels — how you arrange your branches, what you emphasize, what you suppress — all visible through tree shape, all under your control.

### 71.11 Storage Is Natural + Marketplace Is Additional Service

Data moves naturally in Relay using the best available method. The storage architecture has two layers:

1. **Natural layer (core Relay):** Data flows through the Merkle chain (§48) with federation handling chain metadata/ordering and microsharding (§66) handling encrypted content payloads. This is Relay's native data movement.

2. **Marketplace layer (additional service):** People with many storage devices can sell their storage space to others at cheaper rates than commercial data centers. This is the §66.5 storage economy — an optional marketplace running on top of the natural storage layer. Users who want more redundancy or cheaper storage can participate. Users who don't care can rely on the natural layer.

**Federation vs microsharding boundary:** The Merkle chain (a tamper-proof linked list of data hashes — ordering, hashes, sequence numbers) is maintained by federation nodes (§48.4.3 Layer 5). Encrypted content payloads are microsharded (split into small encrypted pieces spread across many machines) across P2P nodes and marketplace providers (§66.1). The chain tells you WHAT exists and in what order. The shards contain the actual data.

### 71.12 Arena Votes Are Continuous Sliders

Arena crowd votes are NOT one-time tokens. They are continuous slider bars of attributes.

Each user in the proximity channel + viewing area has a personal panel with attribute sliders. A user lowers cloud coverage, another raises wind intensity, another shifts scoring weight toward evidence. Each slider position is aggregated with everyone else's in real-time using the median calculation (§68.5). The aggregate then manifests as the arena's terrain state.

Example: The crowd collectively shifts weather conditions. A water wizard gets assistance because the crowd likes water magic. A fire mage gets hindered because the crowd shifted rain coverage up. It flows based on what is happening.

Arena crowd voting does NOT consume vote tokens (§70.6). Vote tokens apply only to §11 parametric governance voting. Arena sliders are free, continuous, real-time interaction. They are closer to a dimmer switch than a ballot.

### 71.13 Voting Is Always Live

There are no elections in Relay unless a duration has been explicitly set. Even when duration is set, voting is a LIVE process. You can change or modify your vote whenever you want. The weighted-median settlement (where all votes are ranked and the middle value becomes the result) is continuous — it recalculates as votes change, enter, or decay.

**Boundary voting (§69.4):** Boundary proposals are live. The 60% threshold is continuously computed. A proposal that was at 55% approval yesterday might be at 62% today as more people vote. There is no "election day." The threshold is crossed when it is crossed. Proposals that never reach threshold eventually decay.

**Duration locks:** Once durations and other match parameters are locked up front (having survived the buffer time and solidified into committed rules), you cannot change them unless you perform the same buffer process to change the original parameter. If the crowd votes to shorten a duration mid-process, whoever is working within that time is influenced to work faster or cut the job short — because that is what is being voted on. If the crowd sees the solution before the participants, they don't wait.

### 71.14 External Systems Coexistence

Trading objects that have powers, attributes, and game-layer properties is real and can happen, but it is all denominated in the same resource economy. Cash (fiat currency) remains external to Relay. Other things remain external entities, even if processed through Relay (payment gateways, bank transfers, etc.).

There will be separated Relay systems running independently — like hidden branches of government or classified corporate operations in the real world that still benefit from the system's organizational structure. This is fine and does not contradict Relay. Relay enables the existing 2D world to live as-is, with better tree organization for business practices. Over time, society will determine how much of that should change.

"No mechanism may convert one resource TYPE to another" (Contract #47) stands. EC cannot become AT. AT cannot become Power. But trading game-layer items (weapons, spells, marketplace goods) denominated in EC is trading items, not converting resource types. The marketplace (§68.16) trades objects, not resources.

### 71.15 Decay Rules Are Context-Dependent

Authorization tokens, initial invite trust, governance votes, and other time-sensitive values decay (lose strength) over time. The decay model varies by context:

| Context | Decay Model | Rationale |
|---------|-------------|-----------|
| **Governance parameter votes (§11)** | Exponential, 30-day half-life | Ensures active participation; old votes naturally lose weight |
| **Invite trust cascade (§70.3)** | Exponential with distance | Trust degrades down the invite chain |
| **Certification teacher score (§58.11)** | Linear quality decay without fresh evidence | Teachers must continuously prove competence |
| **Arena matches** | No decay — matches last the duration | A match is a bounded event; its outcome is permanent |
| **Arena crowd slider positions** | Session-only — reset when match ends | Crowd influence is ephemeral |
| **Branch boundary proposals (§69)** | Slow decay if threshold not reached | Prevents zombie proposals from lingering indefinitely |
| **Filament confidence** | No decay — evidence-based, permanent unless contradicted | Confidence comes from evidence, not time |

Votes lose weight over time. The default decay model for governance parameter votes is exponential with a 30-day half-life (after 30 days, a vote has half its original weight). Other contexts may use different decay models (linear, step, bounded) as specified per context.

### 71.16 Arena Metrics Are Fixed Before Battle

All arena metrics — scoring weights, terrain mode, audience influence toggle, duration, stakes, scar permanence, combat loadout restrictions — are fixed before the battle begins. The pre-match configuration phase (§68.5) produces a committed `ArenaCoeffSet` that is immutable for the duration of the match.

Mid-match crowd sliders (§71.12) adjust atmospheric parameters (weather, visibility, tempo) within the bounds set by the pre-match configuration. They cannot change the structural match rules (scoring formula, duration, stakes).

**Scar permanence:** Default is ARENA_ONLY (scars exist within the arena branch and don't persist on user trees). If pre-match rules explicitly set `scarPermanence: PERMANENT`, then scars persist on the user tree. This must be agreed to by all contestants before the match begins.

### 71.17 Terminology Reference

| Old Term | New Term | Reason |
|----------|----------|--------|
| `ArenaClass` (§68.19) | `CombatLoadout` | "Class" already means element affinity (§40.6). Loadout is per-match, class is permanent. |
| Guardian nodes (§66.4) | Sentinel Nodes | "Guardian" already means trusted human contacts (§48.2.2). Sentinel = storage provider nodes. |
| `LAST_WRITE_WINS` (§66.7) | `LATEST_DISPLAY` | Append-only means nothing "wins" — both preserved. This is a display preference. |
| `proximityZoneRef` (§8.6) | Defined as: `{ zoneType: enum { PROXIMITY_CHANNEL, GEOFENCE, BRANCH_CONTEXT }, zoneId: string }` | Was undefined. Now references §29 proximity channels or geographic boundaries (§69). |
| `branchRef` (used 11+ times) | Defined as: `string` — the branch's stable `layoutKey` (§3.18 identity hash) | Was never formally typed. |
| "attention branch" (§8.6) | The user tree's implicit system branch that logs profile switches, notification events, and attention metrics | Was missing from §8.1's branch list. It is not a manually created branch — it is a system-generated branch on every user tree, like the economic branch. |
| "preference filaments" (§8.6) | Standard filaments with `filamentType: PREFERENCE` — lifecycle is COMMITTED immediately, never OPEN/ACTIVE. Subject to same physics. | Was undefined sub-type. |
| `Base` in ArenaRepGain (§68.10) | Defined as: a global parameter (Category A, default: 10.0) — the base reputation points available per match before multipliers | Was unimplementable without this. |
| `TRAINING_TOKEN` (§68.16) | A marketplace item that grants access to one training session in a specific arena discipline | Was undefined. |
| `minimum viable shard count` (§66.8) | The minimum number of data shards required to reconstruct the original content via Reed-Solomon. For a 5+2 tier: 5 data shards minimum. | Was undefined. |
| Voter eligibility tier → weight (§11.4) | Weight = `1.0` for all eligible voters. Eligibility gates (§7.4, §11.5) determine WHO can vote. Once eligible, all votes carry equal weight. Differential influence comes from decay (recent votes matter more) and branch participation depth (§56), not from an opaque tier-to-weight mapping. | Was a black box. |

### 71.18 Engagement Feedback Design Principles

The engagement feedback system is legitimate game design — skill → mastery → challenge → reward — not a dark pattern. The distinction:
- No pay-to-win (resources come from participation, not purchase)
- No artificial scarcity (no limited-time-only items, no FOMO mechanics)
- No gambling (no loot boxes, no random reward magnitudes)
- No hidden manipulation (all scoring weights are visible, all terrain is transparent)

The mechanism — frequent, small, visible rewards for sustained performance — is transparent and opt-in, not exploitative. §68.12 ("The Engagement Feedback Loop") and §68.18 ("The Micro-Reward Feedback System") detail the implementation.

### 71.19 Zero RPO Qualification & Offline Durability
- **Zero RPO** applies to network-committed data only. Once a filament is committed and synced to the distributed network, it exists on multiple nodes and has zero risk of loss.
- **Offline commits** have local-device-only durability until sync. If the device is destroyed before connectivity is restored, those commits are lost. This is inherent to any offline-first system and is disclosed to users.
- **"Full functionality" offline** is amended to: "Full functionality for the local working set." The bandwidth degradation table (§66.7) accurately describes what degrades at each level. "Full" applies to the cached working set, not to network-dependent features.

### 71.20 LOD Inverse-Scaling — Fisheye Focus Within Basin

When drilling into a branch or filament, the focused element expands in place while the rest of the tree proportionally compresses. The entire tree remains visible within the same basin boundary, never overlapping adjacent trees or basins.

**Mechanics:**
- At TREE LOD: the full tree renders normally — trunk, major branches as silhouettes, timebox cross-sections as ring bands
- As the user drills into a specific branch: that branch expands (higher polygon count, more internal detail, individual filaments become visible), while sibling branches and the trunk proportionally compress toward the tree's central axis
- At BRANCH LOD on the focused branch: the focused branch occupies the majority of the tree's basin area. Other branches are visible as compressed summary forms — still shaped correctly, still showing their aggregate health, but using minimal primitives
- At BARK/SHEET/CELL LOD: the focused filament or cell takes primary visual space. The rest of the branch compresses. The rest of the tree compresses further. But the tree silhouette is always visible as context

**Inverse-scaling rule:**
```
focusScale = baseLODScale × (1 + drillDepth × expansionFactor)
contextScale = baseLODScale × (1 / (1 + drillDepth × compressionFactor))
basinConstraint: focusScale + contextScale ≤ basinRadius (always)
```

**Why this works:**
- You always see where you are relative to the whole tree
- You never lose spatial context when drilling deep
- Adjacent trees and basins are never affected — the inverse scaling is entirely internal to the focused tree's basin
- It mirrors natural vision: when you focus on a leaf, the tree is still in your peripheral vision, just blurry

This is additive to the existing LOD system (§33). It does not replace distance-based LOD — it augments it with attention-based LOD within a single tree's basin.

---

**Contract #167 — Privacy operates only on available data. No SCV, governance mechanism, or system process can inspect Tier 0 data under any circumstance, including child safety. Child safety mechanisms work within the disclosure tier framework using metadata available at Tier 1+ on shared branches. §61.1 is absolute and has no exceptions.**

**Contract #168 — All resource types (Achievement Tokens, Engagement Credits, Power) can be earned in any context — truth layer, game layer, arena, education, civic participation. The validation requirement (SCV-verified evidence for AT) remains. Resource TYPE conversion (EC→AT, AT→Power) remains prohibited. Item trading denominated in EC is permitted. Cash and external financial systems remain external entities.**

**Contract #169 — Audience resolution in duels, arenas, and court cases operates through continuous crowd slider aggregation feeding into deterministic scoring calculations. Audience influence is a toggleable rule attribute agreed upon before each match. Local areas are governed by locals — home advantage is fair. Global arenas provide neutral ground. Arena metrics (scoring weights, terrain, duration, stakes, audience toggle) are fixed before battle and immutable for the match duration. Mid-match crowd sliders adjust atmospheric parameters within pre-match bounds only.**

**Contract #170 — Append-only is absolute. Both commits are always preserved. `LATEST_DISPLAY` is a rendering preference that shows the most recent commit as the default view. No commit is ever overwritten, discarded, or hidden. Every ending (account closure, device loss, provider failure, manifest staleness) produces a closure commit on the relevant chain.**

**Contract #171 — Jury operating parameters (size, deliberation time, verdict threshold, evidence standard) are governance-level sortition parameters (§46) set through §11 weighted-median governance. Crowd terrain voting in arena court cases is restricted to presentation and atmospheric parameters only. Governance floors cannot be breached by crowd voting.**

**Contract #172 — Key Management System: CEKs are generated per-filament or per-shard-group using AES-256-GCM, stored in user-local keychains, split via Shamir's Secret Sharing with K-of-N threshold reconstruction. Key shares are distributed to guardian contacts (humans) or sentinel nodes (storage providers) depending on recovery policy. Key rotation, destruction (for cryptographic erasure), and recovery (via Shamir reconstruction or biometric fallback) follow the KMS specification.**

**Contract #173 — Entity trees on the globe have standardized anchor types for materiality classification. Owners and employees see inside the tree; external users see only the public-facing anchor with exposed filaments chosen by the entity. Counterparty filament shapes are visible only with the counterparty's consent. Tree anchor prominence at globe LOD is determined by average attention rates. Nothing exposes without justification and need.**

**Contract #174 — Privacy disclosure operates at three granularity levels: per filament, per branch, per tree. The most specific setting overrides broader defaults. Disclosure can only be raised (made more visible), never lowered below the committed level. Presence profiles (§8.6) suppress visibility but cannot expose beyond committed tier. Credentials are the proven record of commits with high confidence at the time of commitment. Profile reveal percentages enable employers to request a specific proportion of tree visibility without accessing individual filament content.**

**Contract #175 — LOD inverse-scaling: when drilling into a branch or filament, the focused element expands while the rest of the tree proportionally compresses. The entire tree remains within its basin boundary. Adjacent trees and basins are never affected. The tree silhouette is always visible as context regardless of drill depth. This augments distance-based LOD (§33) with attention-based LOD within a single tree's rendering basin.**

---

## 72. Layered Option Governance — Bottom-Up Ballot Creation — Frozen Contract #176

> *"The ballot is stronger than the bullet."* — Abraham Lincoln
>
> *"Excellence inside a misaligned system only deepens the error."* — ChatGPT 5.2

**Prerequisites:** §11 (parametric governance), §26 (frozen contracts).

Before anyone can vote on a decision, the community first votes on what the options should be. This is the meta-voting layer — the principle that options are never handed down from above, they are built from below.

### 72.1 Why This Exists

In traditional systems, someone at the top decides what appears on a ballot. In Relay, the ballot itself is a community product. What should a region's educational curriculum include? What professions belong on the tutorial master list? Which candidates should be eligible to lead a governance scope? These questions cannot be answered by one person or one committee. The community decides what the choices are before the community decides which choice wins.

### 72.2 Two-Stage Voting

Every governance decision with a list of options follows two stages:

**Stage 1 — Meta-Vote (Option Approval):** Anyone can propose an option. The community votes on whether that option should appear on the ballot. Proposals that fail the meta-vote never reach the substantive vote. This uses the same §11 weighted-median infrastructure — the meta-vote is just a governance parameter with a binary outcome (approved / not approved) and a configurable threshold.

**Stage 2 — Substantive Vote (Decision):** Once the option list is settled, the community votes on which option wins. Standard §11 weighted-median mechanics apply.

### 72.3 Escalating Scrutiny

The scope of impact determines the scrutiny required at the meta-level:

| Impact Scope | Meta-Vote Quorum | Buffer Period | Example |
|-------------|-----------------|---------------|---------|
| Local branch | Branch participants | 24h | Adding a menu item to a restaurant's order flow |
| Organization | Org-scope voters | 72h | Adding a department to a company template |
| Regional | Regional-scope voters | 7 days | Adding a subject to a regional school curriculum |
| Global | Global-scope voters | 30 days | Adding a profession to the universal tutorial master list |

Higher impact = more voters required = longer buffer before the option list solidifies. This prevents capture by small groups on high-impact decisions.

### 72.4 Recursive but Bounded

The meta-vote rules are themselves votable parameters. The threshold required to approve an option onto a ballot? Votable. The buffer period? Votable. The quorum requirement? Votable.

**Recursion floor:** Frozen contracts (§26) cannot be voted away. The recursion stops at the constitutional level. You can vote to change the rules for changing the rules — but you cannot vote to remove the requirement that rules exist.

### 72.5 Bottom-Up Enforcement

Nothing appears on a voting list without passing the meta-vote. A controversial curriculum topic cannot simply be placed on the list — it must survive community approval to even become an option. This applies to:

- Political candidacy within governance scopes
- Educational curriculum contents (§58)
- Tutorial master list categories (§73)
- Arena preset configurations (§68)
- Certification requirements (§58.12)
- Template library additions (§76)
- Any governance decision involving a list of options

### 72.6 The Initial Seed List

For any new domain, Relay creates an initial seed list. Like candidates running for office, the initial options are proposed by the domain creator and immediately subject to meta-vote. The community can add, remove, or reorder options from the moment the list exists. Nothing is permanent without continued community support.

### 72.7 The 4-Layer Model — Minimum Viable Recursion

The two-stage model (§72.2) is the simplified explanation. The full constitutional engine has four layers — enough to prevent both "random crowd hijacks curriculum" and "teachers lock the syllabus forever":

| Layer | What You Vote On | Output |
|-------|-----------------|--------|
| **Layer 0 — Item Vote** | The actual decision: parameter value, teacher ranking, policy choice, arena rule, curriculum item | Governance commit (settled value) |
| **Layer 1 — Ballot Eligibility Vote** | "Should this item be allowed on the ballot at all?" | `ALLOW` / `DENY` / `DEFER` |
| **Layer 2 — Eligibility Rule Vote** | The rules that define who can participate in Layer 1 and Layer 0 | `EligibilityRuleSet` (who qualifies, what quorum, what threshold) |
| **Layer 3 — Audit & Escalation Vote** | Audit triggers, dispute thresholds, and when sortition (§46) is invoked as circuit breaker | Escalation to sortition or rule amendment |

**Layer 0** is the familiar §11 parametric vote. **Layer 1** gates what reaches Layer 0. **Layer 2** governs who gates. **Layer 3** is the circuit breaker — if Layer 1 or 2 deadlocks, sortition decides.

### 72.8 Core Objects

Three schemas implement the 4-layer model:

**1) BallotItem** — A proposed option waiting for eligibility determination:

```
BallotItem {
  ballotItemId:     string ("ballot.<scope>.<slug>"),
  scopeRef:         enum { TREE, BRANCH, TEMPLATE, REGION, GLOBAL },
  itemType:         enum { PARAM, CURRICULUM, TEACHER, ARENA_RULE, POLICY,
                           TEMPLATE_ADDITION, CERTIFICATION_REQ },
  proposedBy:       userRef | scvRef,
  createdAt:        timestamp,
  payloadHash:      string (sha256 of the proposed content),
  status:           enum { PENDING, ELIGIBLE, DENIED, EXPIRED },
  denialReason:     string | null
}
```

**2) MetaVotePacket** — A vote at Layer 1, 2, or 3:

```
MetaVotePacket {
  metaVoteId:       string ("metavote.<uuid>"),
  layer:            number (1, 2, or 3),
  ballotItemId:     ballotItemRef,
  voterId:          userRef,
  choice:           enum { ALLOW, DENY, DEFER },
  weight:           number (0.0..1.0, from §11 decay model),
  eligibilityProof: {
    ruleId:         eligRuleRef (→ EligibilityRuleSet),
    proofRefs:      filamentRef[] (filaments proving qualification)
  },
  timestamp:        timestamp
}
```

**3) EligibilityRuleSet** — Layer 2 output defining who can participate:

```
EligibilityRuleSet {
  eligRuleId:       string ("eligRule.<scope>.<version>"),
  scopeRef:         branchRef | templateRef | regionRef | "global",
  appliesTo:        enum[] { L0_ITEM_VOTE, L1_BALLOT_VOTE },
  requirements: {
    minTier:                number (minimum disclosure tier, default: 1),
    minAgeDays:             number (account age, default: 30),
    minDomainCommits:       number (commits in the relevant domain, default: 10),
    minEvidenceCommits:     number (evidence-backed commits, default: 3),
    recencyHalfLifeDays:    number (participation recency weighting, default: 90),
    conflictOfInterestRules: string[] (e.g., "sameInviteCluster", "directCounterparty")
  },
  ratification: {
    quorum:                 number (0.0..1.0, fraction of eligible voters, default: 0.30),
    approval:               number (0.0..1.0, approval threshold, default: 0.65),
    settlementWindowHours:  number (how long threshold must hold, default: 24)
  }
}
```

### 72.9 Deterministic Settlement Rules

Layer 1 settlement uses the same mechanics as §11 governance with three additions:

1. **Settlement window + hysteresis:** A ballot item becomes ELIGIBLE only when Layer 1 approval holds above the threshold for the full settlement duration. Brief spikes above threshold do not count — the approval must be sustained, preventing flash-mob manipulation.

2. **Hard gate on Layer 0:** Layer 0 votes are ignored if the ballot item's status is not ELIGIBLE. The system enforces this structurally — you cannot cast a vote on an item that has not passed the eligibility gate. Attempting to do so produces a REFUSAL, not a silent drop.

3. **Sortition circuit breaker (Layer 3):** If Layer 1 or Layer 2 is deadlocked (neither approval nor denial reaches threshold within a configurable timeout), Layer 3 triggers sortition (§46). A randomly selected jury of qualified participants makes the decision. This prevents permanent gridlock while maintaining democratic legitimacy.

### 72.10 Visual Encoding on the Tree

Ballot eligibility renders as a ring band on the governance branch:

| Band Color | Meaning |
|-----------|---------|
| **Green band** | Eligible — item has passed Layer 1 and is available for Layer 0 voting |
| **Amber band** | Pending — settlement window is running, threshold has been reached but not yet sustained |
| **Red crack** | Denied — scar-like visual indicating the community rejected this option |
| **Pulsing amber** | Deadlocked — Layer 3 sortition is being assembled |

Meta-vote activity generates heat (rate of governance activity) on the governance branch, but governance heat cannot change truth-layer branch physics. Any "who decided we can decide" action is clickable to a one-sentence explanation (Contract #83 — one-click audit trail).

**Contract #176 — Before any substantive vote with a list of options, the community votes on what the options should be (meta-vote) through a 4-layer constitutional engine: Layer 0 (item vote), Layer 1 (ballot eligibility), Layer 2 (eligibility rules), Layer 3 (audit/escalation via sortition). Core objects: BallotItem, MetaVotePacket, EligibilityRuleSet. Settlement requires sustained threshold approval with hysteresis. Layer 0 votes are hard-gated behind Layer 1 eligibility. Deadlocked layers trigger sortition circuit breaker. Meta-vote rules are themselves votable parameters. Recursion floor = frozen contracts. Escalating scrutiny requires wider participation for wider-impact decisions. Nothing appears on a ballot without community meta-approval. The initial seed list for any new domain is immediately subject to community governance. Visual encoding: green (eligible), amber (pending), red crack (denied), pulsing amber (deadlocked/sortition).**

### 72.11 Procedural Governance Template — Council Meeting as Ritualized Structure

> *"Order is the shape that truth takes when a group of people agree to hold each other accountable."* — Eitan Asulin

Parametric governance (§72.1–72.10) defines WHAT gets decided — the math, the layers, the thresholds. This section defines HOW a governing body convenes, deliberates, and commits decisions. Relay adopts the parliamentary model practiced by organizations like **B'nai B'rith Youth Organization (BBYO)** — not as nostalgia, but because this model is predictable, documented, role-based, motion-driven, transparent, and productive. A meeting that follows this template produces a tree branch that is self-documenting. A chaotic meeting visually looks chaotic. A disciplined meeting looks structured.

The Top Relay Council uses this template first. Every other council (city, organization, branch-level) inherits it.

#### 72.11.1 Structural Roles — The Council Archetype

Each Relay council instantiates a governance tree with formal roles. Roles are not cosmetic — they determine speaking and commit privileges.

| Role | Relay Mapping | BBYO Equivalent | Responsibility |
|------|--------------|-----------------|----------------|
| **Chair** | `role.chair` | Aleph Gadol / S'ganit | Moderates session, enforces procedure, cannot unilaterally pass motions |
| **Treasurer** | `role.treasury` | Gizbar | Reports financial branch state before budget motions |
| **Recorder** | `role.recorder` | Mazkir | Commits motions to tree as filaments, produces minutes |
| **Sergeant-at-Arms** | `role.order` | Shaliach | Enforces speaking rules, manages floor access, mute control in digital sessions |
| **Parliamentarian** | `role.rules` | Moreh | Ensures motion validity under template constraints, rules on procedural challenges |
| **Members** | `role.member` | Alephs / B'nai B'rith members | Introduce motions, propose amendments, debate, vote |

```
ROLE_ASSIGNMENT {
  filamentType:       "ROLE_ASSIGNMENT"
  identity:           roleType          // "chair" | "treasury" | "recorder" | "order" | "rules" | "member"
  counterparty:       userRef           // Who holds the role
  time:               { termStart, termEnd }
  evidence:           electionCommitRef // The election or appointment that created this assignment
  lifecycle:          "ACTIVE"          // ACTIVE during term, CLOSED at term end
}
```

Roles are filaments on the `council.<scope>.roles` branch. Each role has a term. Term lengths are Category A parameters (community-governed). Role assignment requires an election commit as evidence — no role is appointed without a recorded process.

#### 72.11.2 Meeting as a Branch

Every council has a `council.<scope>.meetings` branch. Each meeting is a subtree — not a chat, not a thread, not a log. A structured event with defined anatomy.

```
meeting.<timestamp>
  ├── agenda           // Pre-committed items to discuss, ordered
  ├── reports          // Financial, committee, officer reports as filaments
  ├── motions          // Each motion is a filament with full lifecycle
  │   ├── motion-001
  │   │   ├── amendments
  │   │   └── votes
  │   └── motion-002
  │       ├── amendments
  │       └── votes
  ├── minutes          // Recorder's committed summary
  └── attendance       // Presence filaments for each attendee
```

The meeting opens when the Chair commits an `OPEN_SESSION` filament. It closes when the Chair commits `ADJOURN`. Everything between is structured, timestamped, and permanent.

#### 72.11.3 Motion Lifecycle — Parliamentary Procedure as Filament Lifecycle

BBYO motions map directly to Relay filament states:

| Parliamentary Step | Relay Lifecycle | What Happens |
|-------------------|-----------------|--------------|
| **Proposed** | OPEN | Member introduces motion as a filament. Text is the identity hash. |
| **Seconded** | ACTIVE | A distinct member commits a SECOND filament referencing the motion. Without a second, the motion dies in OPEN. |
| **Under Debate** | ACTIVE (heat increases) | Speaking filaments attach to the motion. Heat rises with engagement. Timebox window enforced. |
| **Amended** | ACTIVE (version bump) | Amendment is a child filament linked to parent motion. Not an edit — a version bump. `F-MOTION-42.v1` → `F-MOTION-42.v2 (amended)`. Cross-section shows amendment history. |
| **Called to Question** | HOLD | Only Chair OR quorum threshold can trigger. Freezes all amendments. Debate ends. |
| **Vote** | HOLD → CLOSED | Each vote is a filament: voterRef, weight, eligibility evidence. When threshold met, motion transitions to CLOSED with result (PASSED or FAILED). |
| **Adopted & Implemented** | ABSORBED | Motion sinks inward only when implementation filaments exist (if required), budget impact is reconciled, and no procedural appeals are open. |

```
CouncilMotionPacket {
  motionId:           "motion.<councilId>.<seq>"
  proposer:           userRef
  text:               string          // The motion text — this IS the identity
  textHash:           sha256          // Immutable content hash
  scope:              "GLOBAL" | "REGIONAL" | "ORG" | "BRANCH"
  scopeWeight:        number          // Magnitude — how significant is this motion?
  
  lifecycle:          "OPEN" | "ACTIVE" | "HOLD" | "CLOSED" | "ABSORBED"
  result:             null | "PASSED" | "FAILED"
  
  secondRef:          filamentRef | null
  amendmentRefs:      [filamentRef]
  voteRefs:           [filamentRef]
  implementationRefs: [filamentRef]   // Required for ABSORBED transition
  
  proceduralFlags: {
    hasSecond:         boolean
    debateTimebox:     duration
    amendmentCount:    number
    quorumMet:         boolean
    thresholdMet:      boolean
  }
}
```

```
AmendmentPacket {
  amendmentId:        "amendment.<motionId>.<version>"
  parentMotion:       motionRef
  proposer:           userRef
  secondRef:          filamentRef     // Amendments also require seconds
  originalText:       string
  amendedText:        string
  diffHash:           sha256          // Hash of the change
  version:            number          // Sequential version number
  result:             null | "ADOPTED" | "DEFEATED"
}
```

#### 72.11.4 Formal Procedure Rules — Preventing Chaos

**Motion Entry Rule:** A motion cannot move from OPEN → ACTIVE unless:
- It has a SECOND filament attached
- The proposer and seconder are distinct users
- EligibilityPacket verifies voting eligibility for both

**Debate Window Rule:** During ACTIVE state:
- Heat increases with each speaking filament
- Timebox window is enforced (duration is a Category A parameter)
- Amendments spawn as child filaments linked to parent motion — amendments are version bumps, not edits
- The Chair controls speaking order; `role.order` enforces it

**Call to Question Rule:** Only the Chair OR a quorum threshold (Category A parameter) can trigger HOLD state. HOLD freezes all amendments. No new amendments during HOLD. Debate ends.

**Vote Resolution Rule:**
```
CouncilVotePacket {
  voteId:             "vote.<motionId>.<voterRef>"
  motionRef:          filamentRef
  voterRef:           userRef
  weight:             number          // Equal, anchor-weighted, or context-weighted (Category A)
  decision:           "AYE" | "NAY" | "ABSTAIN"
  eligibility:        EligibilityPacket
  timestamp:          ISO-8601
}
```

Vote weight scheme is a Category A parameter per council. Options: equal weight (one member one vote), anchor-weighted (participation history), context-weighted (domain expertise). The Top Relay Council uses equal weight.

When the vote threshold is met (majority, supermajority, or unanimous — configurable per motion scope), the motion transitions to CLOSED with result PASSED or FAILED.

**Consolidation Gate — No Symbolic Resolutions:** A passed motion ABSORBS (becomes structural, sinks inward) only when:
- Implementation filaments exist (if the motion requires action)
- Budget impact is reconciled on the treasury branch
- No open procedural appeals remain

This prevents motions that pass but never get executed. A passed motion that sits unimplemented stays at the surface, visible, aging, wilting — a public record of unfulfilled commitment.

**Procedural Violation Scar:**
```
ProceduralViolationPacket {
  violationType:      "SPEAKING_OUT_OF_ORDER" | "MOTION_WITHOUT_SECOND" | "VOTE_WITHOUT_QUORUM" 
                      | "AMENDMENT_DURING_HOLD" | "CHAIR_OVERREACH" | "ELIGIBILITY_FRAUD"
  sessionRef:         meetingRef
  reportedBy:         userRef         // Parliamentarian or any member
  evidence:           filamentRef     // The specific event that violated procedure
  severity:           "MINOR" | "MAJOR" | "CONSTITUTIONAL"
  resolution:         null | "SUSTAINED" | "OVERRULED"
}
```

Procedural violations are scars on the meeting branch. They are permanent. They are visible. They cannot be removed. A council that repeatedly violates its own procedure builds a scarred, wilting governance branch — visible to everyone.

#### 72.11.5 Meeting Geometry on the Tree

What this looks like rendered in 3D:

- The **meeting branch** sprouts off the council trunk at the scheduled timestamp
- **Agenda items** are visible as ordered nodes along the branch
- **Motions** appear as glowing filaments — brighter during active debate (heat)
- **Amendments** attach as child branches to the parent motion, showing version history in cross-section
- **Votes** form radial clusters around the motion — AYE on one side, NAY on the other, proportional to weight
- **Passed motions** sink inward as they absorb, becoming structural mass
- **Failed motions** cool and thin, remaining visible but losing glow
- **Scars** from procedural violations appear as crack textures on the meeting branch

A well-run meeting looks like a clean, structured branch with orderly sub-branches. A chaotic meeting looks chaotic — jagged, scarred, heat-heavy with long debate and short resolution. The tree makes governance quality visible without reading a single word.

#### 72.11.6 Meta-Voting Integration — Procedure Governs Itself

The council procedure is itself meta-votable (§72.7). Members can vote on:

- Debate duration per motion
- Quorum requirements
- Majority thresholds (simple, 2/3, 3/4, unanimous)
- Maximum amendments per motion
- Role term lengths
- Vote weight scheme
- Speaking time limits

But changing procedural rules requires a **Layer 3 vote with elevated threshold** — procedure cannot be casually altered. This prevents a temporary majority from dismantling the meeting structure that protects the minority.

#### 72.11.7 The Top Relay Council as Template

The Top Relay Council (`council.relay.global`) is the first instantiation of this template. It governs Relay-wide decisions: parameter changes that affect all users, frozen contract amendments (constitutional threshold), subsidiary charters, budget allocations, and mission priorities.

The council's governance branch is public. Every meeting, every motion, every vote, every amendment, every procedural violation scar — all visible on Tree Zero. This is the live demonstration of how every branch in civilization should deliberate.

Other councils inherit the template:
- `council.relay.regional.<region>` — regional governance
- `council.<orgId>.board` — organizational governance
- `council.<branchId>.committee` — branch-level committees

Each inherits the role structure, motion lifecycle, and procedural rules. Each can customize Category A parameters (thresholds, timings, weight schemes) through its own meta-vote. None can remove the structural requirements: roles, seconds, debate windows, consolidation gates. The discipline is inherited. The parameters flex.

**Sortition jury application (§46):** Sortition juries — which resolve Sybil flags (§84.6), fraud disputes (§85), governance deadlocks, and duel challenges — also instantiate this template. A jury session is a meeting branch with: a Foreperson (Chair role), a Recorder (commits verdict filaments), defined speaking order (each juror presents analysis in sequence), motion-driven verdict proposal (a juror proposes a verdict, requiring a second), and vote resolution following the same OPEN → ACTIVE → HOLD → CLOSED lifecycle. Procedural violations by jurors produce permanent scars on the jury session branch. This ensures jury proceedings are as structured, transparent, and auditable as council meetings. The template is universal to all Relay deliberation.

**Contract #300 — Procedural Governance Template. Every Relay council (global, regional, organizational, branch-level) instantiates a structured meeting template derived from parliamentary procedure. Six mandatory roles (Chair, Treasurer, Recorder, Sergeant-at-Arms, Parliamentarian, Members) are filaments on the council roles branch with election evidence. Meetings are branch subtrees with defined anatomy (agenda, reports, motions, amendments, votes, minutes, attendance). Motions follow filament lifecycle: OPEN (proposed) → ACTIVE (seconded + debated) → HOLD (called to question) → CLOSED (voted: passed or failed) → ABSORBED (implemented with evidence). Amendments are version bumps, not edits. Seconds are required from distinct members. Debate windows are timeboxed. Procedural violations produce permanent scars. Passed motions absorb only when implementation filaments exist and budget impact is reconciled — no symbolic resolutions. The Top Relay Council on Tree Zero is the first instantiation and the public template for all governance. Council procedural rules are meta-votable but require Layer 3 elevated threshold to change. The role structure, motion lifecycle, second requirement, consolidation gate, and procedural violation scar mechanism are frozen.**

---

### 72.12 Global & Regional Content Classification — The Oblivion Threshold

> *"The only thing necessary for the triumph of evil is for good men to do nothing."* — Edmund Burke
>
> *"But nothing is ever hidden. Burying something and deleting it are not the same act."* — Eitan Asulin

There are things in this universe that humanity may discover are purely destructive. Nuclear weapons. Atom-splitting for annihilation. Attempts to create black holes. Technologies or practices that do not build, do not heal, do not teach — they only destroy. If humanity reaches that conclusion collectively, there must be a mechanism to act on that judgment without betraying the core principle: **nothing is ever deleted, nothing is ever hidden, and the tree never lies.**

The Oblivion Threshold is Relay's answer. It is not censorship. It is civilizational gravity.

#### 72.12.1 The Principle — Gravity, Not Erasure

Relay already uses gravity to manage information relevance. Low-confidence content sinks (§10). Unengaged filaments wilt. Heartwood compresses into stillness (§1.3). The Oblivion Threshold extends this natural physics to a deliberate, voted, civilizational-scale classification:

- Content that humanity classifies as purely destructive receives an **oblivion gravity multiplier** — a force so large that it sinks below the default visibility threshold of every user on the planet
- The content still exists. The filament is still committed. The append-only chain is unbroken. The Merkle hash is intact.
- Anyone who deliberately lowers their filter below the oblivion threshold can still view the content. The act of viewing is itself a committed event — auditable, timestamped, transparent.
- The classification itself is a permanent, public filament on Tree Zero's governance branch — everyone can see what was classified, why, how the vote went, and who proposed it.

This is not a government deciding what you can see. This is humanity deciding what it collectively buries — and doing so in a way where the burial itself is fully visible.

#### 72.12.2 Global Classification — Civilizational Supermajority

**Proposal:** Any Tier 2+ verified user can propose a Global Oblivion Classification. The proposal is a filament on Tree Zero's `governance.classification.global` branch containing:

```
OblivionProposal {
  subjectDefinition:      string,        // precise description of what is being classified
  destructiveEvidence:    evidenceRef[],  // evidence of purely destructive nature
  constructiveAbsence:    evidenceRef[],  // evidence that no constructive application exists
  exampleFilaments:       filamentRef[],  // existing content that demonstrates the category
  patternDefinition:      PatternDef,     // machine-readable detection pattern (see §72.12.5)
  proposer:               userRef,
  timestamp:              ISO-8601
}
```

**Deliberation:** The proposal enters the standard §72 Layered Option Governance pipeline at **Layer 4 — Constitutional MetaVote** because it affects every user globally:

- **Layer 1 (Ballot Eligibility):** Community meta-votes on whether the proposal meets minimum evidence thresholds to even appear on the ballot. Unsubstantiated proposals die here.
- **Layer 2 (Eligibility Rules):** Does the subject meet the definition of "purely destructive"? Does the evidence chain hold? Are there legitimate constructive applications that would make classification inappropriate?
- **Layer 3 (Escalation Review):** Sortition jury (§46) reviews the proposal for procedural integrity — was the evidence valid, was the pattern definition precise, was the deliberation fair?
- **Layer 4 (Constitutional Vote):** Global weighted-median vote. Requires **civilizational supermajority** (initial threshold: 85%, Category A parameter — votable but never below 75% frozen floor).

**Cooling window:** 168 hours (7 days) — the constitutional amendment class from §19.5. No fast-tracking. Humanity does not classify in haste.

**If approved:** The classification creates an **OblivionMarker** — a permanent structural filament on Tree Zero:

```
OblivionMarker {
  classificationId:    hash,
  subjectDefinition:   string,
  patternDefinition:   PatternDef,
  gravityMultiplier:   float,          // applied on top of normal confidence gravity
  voteRecord:          filamentRef,    // the complete vote chain
  evidenceChain:       filamentRef[],  // all supporting evidence
  effectiveDate:       ISO-8601,       // after cooling window expiry
  status:              ACTIVE | REVOKED
}
```

#### 72.12.3 The Oblivion Threshold — Visibility Mechanics

When an OblivionMarker becomes ACTIVE, the following happens to content matching its pattern:

1. **Existing filaments** matching the classification receive the `oblivionGravity` multiplier. Their confidence-weighted visibility drops below the **oblivion floor** — a system-wide threshold far below the default filter tolerance (§12). The filaments are not modified, not deleted, not re-committed. Their rendering weight changes.

2. **New content** matching the classification at commit time is tagged with an `oblivionClassificationRef` pointing to the OblivionMarker. The content is committed normally (append-only is preserved), but enters the world already below the oblivion floor.

3. **Default filter tolerances** (§12) position the oblivion floor below every user's default visibility. To see oblivion-classified content, a user must:
   - Open their filter settings
   - Navigate past a deliberate disclosure gate (not a hidden toggle — an explicit "I understand this content has been classified by civilizational consensus as purely destructive" acknowledgment)
   - Lower their personal filter below the oblivion floor
   - The act of lowering is committed as a filament on the user's tree — visible, auditable, not secret

4. **Physics are honest.** A branch containing oblivion-classified filaments still reflects their mass in its aggregate metrics — droop, weight, ring thickness. The classified content affects branch physics because it exists. You cannot see the individual filaments without lowering your filter, but the branch's shape tells the truth: something heavy is buried here. This is the same principle as disclosure tiers (§8.5) — aggregate truth is universal, individual access is tiered.

5. **Search (§102) respects the threshold.** Oblivion-classified content does not appear in default search results. Explicit oblivion-scope search is available to users who have lowered their filter.

#### 72.12.4 Regional Classification — Local Governance Adds, Never Subtracts

Regional governance (§72, Layers 2-3) can create **regional oblivion classifications** that apply within a region's governance boundary:

- **Proposal and voting** follow the same pipeline but at regional scope with regional thresholds (initial: 75% regional supermajority, Category A parameter)
- **Cooling window:** 72 hours (policy change class)
- **Scope:** The classification applies only to users within that region's governance boundary. Users who travel between regions see the union of all active classifications for their current region plus all global classifications.

**Strict layering rules:**
- A region CAN be **stricter** than global — adding classifications for content that the region's population deems destructive but that did not reach civilizational supermajority
- A region CANNOT be **looser** than global — global OblivionMarkers are the floor. No regional vote can revoke or weaken a global classification. Global gravity is absolute.
- Regional classifications follow identical visibility mechanics — same oblivion floor, same deliberate disclosure gate, same auditable filter-lowering
- A regional classification that later achieves global supermajority can be promoted to global scope through a standard Layer 4 MetaVote

#### 72.12.5 Trained Understanding — The Pattern Library

An OblivionMarker's `patternDefinition` is not a vague label. It is a structured, community-curated pattern specification:

```
PatternDef {
  textPatterns:          string[],      // semantic descriptions for SCV text analysis
  visualPatterns:        visualDef[],   // reference images/videos for camera detection training
  behavioralPatterns:    behaviorDef[], // action sequences (e.g., assembly steps, process flows)
  boundaryExamples: {
    positiveExamples:    filamentRef[], // content that DOES match (clear cases)
    negativeExamples:    filamentRef[], // content that does NOT match (edge cases, legitimate uses)
    ambiguousExamples:   filamentRef[]  // boundary cases requiring human judgment
  },
  confidenceFloor:       float,         // minimum detection confidence required to flag (default 0.85)
  updateHistory:         commitRef[]    // all revisions to the pattern, fully auditable
}
```

**Why boundary examples matter:** A classification for "nuclear weapon construction" must distinguish between:
- Nuclear physics education (NOT classified — knowledge is constructive)
- Medical isotope production documentation (NOT classified — healing application)
- Weapons-grade enrichment process instructions with assembly detail (classified — purely destructive application)

The positive, negative, and ambiguous examples form the **trained understanding** — a community-verified corpus that SCV systems use for pattern matching. The examples are themselves filaments with evidence chains. They evolve through community governance: anyone can propose adding or removing examples, subject to the same meta-vote pipeline. The pattern library is never a black box — every training example is public, auditable, and challengeable.

#### 72.12.6 Camera Detection Integration — Non-Pervasive Flagging

The existing detection mesh (§39) and SCV intelligence pipeline (§92) already classify visual input — fire, smoke, water, light, gestures, objects. The Oblivion Threshold extends this pipeline with a detection category for classified patterns:

**How detection works:**
1. A camera in the detection mesh captures visual input
2. The SCV's T1 local model (§92.2) checks the input against active OblivionMarker pattern definitions
3. If the confidence exceeds the pattern's `confidenceFloor` (default 0.85), a **ClassificationDetectionEvent** is created as a LeafPacket (ephemeral first, standard §82.2 lifecycle)
4. The detection event references the specific OblivionMarker it matched, the confidence score, the visual evidence hash, and the camera's location

**What happens with a detection:**
- A single detection from a single camera is low confidence. It creates a leaf, not a filament. It may decay naturally.
- **Multiple independent detections** from different cameras, different users, or different angles increase confidence through standard convergence (§10). The detection may promote to a filament if evidence reaches threshold.
- The detection creates a **record**, not a punishment. The record has standard physics — confidence, evidence chain, appeal pathway, full auditability.
- If the detection is a false positive: the subject can challenge it through standard dispute resolution (§46 sortition jury). A reversed detection creates a scar on the detection branch (the system made a mistake — that mistake is recorded, not hidden).

**Non-pervasive guarantees:**
- Only cameras whose owners have **opted into the detection mesh** participate. No mandatory surveillance. Opting in is a committed, revocable decision.
- Detection rules are **public, auditable, and votable**. The community sees exactly what patterns are being detected and can challenge or refine them.
- Detection **never triggers automatic action** beyond creating a record. No auto-banning, no auto-deletion, no auto-punishment. The record enters standard confidence physics and governance workflows.
- The SCV's trained understanding is the **community-curated pattern library** (§72.12.5), not a proprietary black-box algorithm. Every decision the system makes can be traced to a specific example in a specific pattern definition approved by a specific vote.

**Violence detection specifically:** Real-world violence captured by opt-in cameras follows the same pipeline. The detection is flagged, not broadcast. The flag is a leaf that may promote to a filament if corroborated. The response is governed by transparent rules — emergency dispatch (§74) if life-threatening, civic flagging if not. The camera is never a spy; it is a witness whose testimony is auditable.

#### 72.12.7 What This Is NOT

To be explicit:

| This IS | This is NOT |
|---------|-------------|
| Civilizational gravity — voted, transparent, auditable | Government censorship — opaque, top-down, unaccountable |
| A visibility threshold — content exists below the floor | Deletion — content removed from existence |
| Democratic consensus — civilizational supermajority | Minority suppression — a small group deciding for everyone |
| Append-only preserved — the Merkle chain is unbroken | Rewriting history — nothing is altered or erased |
| Opt-in detection — cameras participate voluntarily | Surveillance — mandatory monitoring of all activity |
| Pattern-matched flagging with examples and boundaries | Algorithmic black-box classification with hidden rules |
| Record creation with standard evidence physics | Automatic punishment without due process |
| Revocable by the same mechanism that created it | Permanent and irreversible censorship |

#### 72.12.8 Revocation — Humanity Can Change Its Mind

An active OblivionMarker can be revoked:

- **Revocation proposal** follows identical pipeline: Tier 2+ proposer, Layer 4 Constitutional MetaVote, civilizational supermajority, 168-hour cooling window
- **Evidence for revocation** must demonstrate that the original classification was wrong (constructive applications exist) or that circumstances have changed (the technology has been made safe)
- **If revoked:** The OblivionMarker's status transitions to `REVOKED`. The gravity multiplier ceases. Classified content returns to standard confidence physics. The entire classification-and-revocation history remains as permanent filaments — the tree remembers both the burial and the exhumation.
- **Regional revocations** follow the same pattern at regional scope, but cannot revoke global classifications.

#### 72.12.9 Rendering — What Oblivion Looks Like

On the 3D globe:

- **Oblivion-classified branches** at normal zoom are invisible — below the rendering threshold. The branch geometry still contributes to parent branch weight and droop (physics are honest), but the individual branch does not render.
- **At extreme depth zoom** (below the oblivion floor, with filter deliberately lowered): classified content renders in a distinct visual language — **deep grey, heavily compressed, with a visible oblivion glyph** (a downward-pointing gravity symbol derived from the SphereCore anchor vocabulary, §103). The rendering makes it immediately clear that this content carries a civilizational classification.
- **The OblivionMarker itself** — the classification decision — renders normally on Tree Zero's governance branch. The vote record, evidence chain, pattern library, and deliberation history are fully visible at standard filter settings. You can always see THAT something was classified and WHY, even if you cannot see the classified content itself without lowering your filter.
- **Detection events** render as faint pulse markers in the detection mesh visualization — visible to mesh participants, not broadcast to the public. A corroborated detection that promoted to a filament renders with standard confidence physics.

#### 72.12.10 Integration with Existing Systems

| System | Integration |
|--------|-------------|
| **Filter Tolerances (§12)** | Oblivion floor is a new system-level threshold below all user defaults. Personal filter settings respect it but can be deliberately lowered. |
| **Parametric Governance (§11)** | Classification thresholds (85% global, 75% regional), confidence floors (0.85), gravity multipliers — all Category A parameters. |
| **Layered Governance (§72)** | Classification uses the full 4-layer pipeline. Regional classifications use Layers 2-3. |
| **Detection Mesh (§39)** | Camera detection patterns extend the existing classification pipeline. |
| **SCV Intelligence (§92)** | T1 local models handle pattern matching. T2 frontier models handle ambiguous cases. T3 human escalation for edge cases. |
| **Immune Detection (§83.5)** | Oblivion-classified patterns are added to the immune trigger library. Anomalous clusters of classified content trigger the same immune response as Sybil attacks. |
| **Search Architecture (§102)** | Oblivion scope added as a search filter. Default search excludes oblivion-classified results. |
| **Pressure Physics (§10)** | Oblivion gravity multiplier stacks on top of normal confidence gravity. The physics are additive, not a special case. |
| **Cooling Windows (§19.5)** | Constitutional-class cooling (168 hours) for global classification. Policy-class (72 hours) for regional. |
| **Child Safety (§63)** | Protected Participation Profiles (§63.7) cannot lower their filter below the oblivion floor. This is a non-negotiable structural protection. |

**Contract #315 — Global & Regional Content Classification (The Oblivion Threshold). Humanity may vote to classify content as purely destructive through a civilizational supermajority (initial: 85%, Category A, frozen floor: 75%) using the full Layer 4 Constitutional MetaVote pipeline with 168-hour cooling window. Classified content receives an oblivion gravity multiplier that sinks it below a system-wide visibility floor — below every user's default filter tolerance. Nothing is deleted. The append-only chain is unbroken. Anyone can deliberately lower their filter to view classified content; the act of lowering is itself a committed, auditable event. The classification itself — proposal, evidence, vote record, pattern library — is permanently and publicly visible on Tree Zero. Regional governance can create regional classifications (75% supermajority, 72-hour cooling) that are stricter than global but never looser — global classifications are the absolute floor. Camera detection of classified patterns uses the opt-in detection mesh with community-curated pattern libraries containing positive, negative, and ambiguous boundary examples. Detection creates records with standard evidence physics, never automatic punishment. All classification thresholds, detection confidence floors, and gravity multipliers are Category A parameters. Classifications are revocable by the same supermajority mechanism. Protected Participation Profiles cannot lower their filter below the oblivion floor. The tree remembers everything — including what humanity chose to bury and why.**

---

## 73. Universal Onboarding — Three Pillars — Frozen Contract #177

> *"Tell me and I forget. Teach me and I remember. Involve me and I learn."* — Benjamin Franklin
>
> *"You don't know what you don't know until you know."* — Eitan Asulin

**Prerequisites:** §1 (the globe), §8 (user tree), §37 (knowledge migration), §58 (education), §72 (layered option governance).

A new user opens Relay for the first time. What do they see? What can they do? Relay's onboarding rests on three pillars that together ensure any human — regardless of technical skill, profession, or background — can immediately find value.

### 73.1 Pillar One — The Live Globe

You start on the real Earth. Not a tutorial sandbox. Not a guided walkthrough. The actual live globe at whatever its current state is — trees growing, trunks glowing, branches swaying with activity. You can fly anywhere, zoom into any public tree, watch governance votes in real-time, observe weather patterns, and see the shape of civilization.

This is discovery through exploration. The globe IS the tutorial. A user who flies to their city and sees a wilting municipal tree learns more about Relay in ten seconds than any instruction manual could teach. The visceral experience of seeing reality rendered as geometry is the onboarding.

### 73.2 Pillar Two — Drag-to-Tree File Mapping

Drag any file from your computer into Relay. An Excel spreadsheet. A PDF contract. A photo album. A code repository. The §37 Knowledge Migration system reads the file, identifies its structure, and maps it onto your personal user tree.

Your spreadsheet IS a branch. Your rows ARE filaments. Your columns become filament domains (identity, magnitude, counterparty, evidence, time). The migration is immediate and visual — you see your data take shape as a living tree. Every file you own can become part of your Relay identity.

This solves the cold-start problem. Users don't start with an empty tree. They start with their existing life, migrated into 3D.

### 73.3 Pillar Three — Tutorial Master List

A comprehensive, community-governed list of tutorial classes for every trade, profession, and life role known to civilization:

**How the list is built (§72 layered option governance):**
- **Stage 1 meta-vote:** What professions and roles should be on the master list? The community proposes and votes on categories: doctor, lawyer, accountant, mother, student, teacher, farmer, engineer, nurse, plumber, electrician, chef, artist, musician, athlete, soldier, police officer, firefighter, social worker, therapist, architect, pilot, mechanic, librarian, and hundreds more.
- **Stage 2 vote:** How should the list be displayed? Priority ordering, alphabetical, regional relevance, popularity — all global parameters decided by the community.

**Each tutorial class** is a §58.5 community-curated curriculum with §58.12 certification paths. The classes are not static documents — they are living branches with active teachers, evolving content, and continuous quality governance.

**The list is never finished.** As new professions emerge and old ones evolve, the community updates the master list through ongoing meta-votes. A new user searching "how do I become a welder?" finds a living, community-verified curriculum pathway — not a dead PDF.

### 73.4 Coexistence with Game Layer Discovery

§40.6 states: "No tutorial. No onboarding." That applies to the game layer — the fog of war lifts as you explore, monsters appear as you venture outward, spells reveal themselves through experimentation. Game layer discovery is earned through play.

The Universal Onboarding system teaches the PLATFORM — how trees work, how to navigate the globe, how to commit filaments, how to use governance. These are complementary, not contradictory. You learn the world by walking it. You learn the game by playing it.

**Contract #177 — Every new user receives three onboarding pillars: (1) the live globe for exploratory discovery, (2) drag-to-tree file mapping for immediate personal value, and (3) a community-governed tutorial master list for structured learning of any profession or life role. The tutorial master list is governed by §72 layered option governance — what professions appear and how they are prioritized is a community meta-vote. Platform onboarding and game layer discovery coexist as complementary systems.**

---

## 74. Traffic & Civic Response Module (RELAY-CIVIC-1) — Frozen Contracts #178–179

> *"The only thing necessary for the triumph of evil is for good men to do nothing."* — Edmund Burke

**Prerequisites:** §1 (the globe), §9 (confidence), §10 (pressure), §23 (weather/wind), §29 (proximity channels), §33 (LOD rendering), §46 (sortition), §48 (engineering infrastructure), §66 (microsharding), §67 (BCP/DRP).

Public services are branches obeying the same universal equations. A fire truck is a filament. A traffic light is a node computing pressure. An emergency call is a commit. Relay coordinates and makes visible — it does not operate physical infrastructure. This module describes how civic response maps onto the existing physics.

### 74.1 Emergency Call as Filament — CivicAlertPacket

When someone calls for help, that call becomes a filament on the civic alert branch for their region:

```
CivicAlertPacket {
  alertType:              enum { MEDICAL, FIRE, ACCIDENT, TRAFFIC_OBSTRUCTION,
                                 ACTIVE_SHOOTER, NATURAL_DISASTER, ANIMAL_RESCUE,
                                 UTILITY_FAILURE, HAZMAT, OTHER },
  geolocation:            { lat, lon, precision },
  severityEstimate:       enum { LOW, MEDIUM, HIGH, CRITICAL },
  reporterConfidence:     number (from user tree health — a well-maintained tree with history carries more weight),
  timeboxSpawn:           timestamp,
  requiredResponseClass:  enum { NON_CRITICAL, STANDARD, URGENT, LIFE_THREATENING },
  estimatedResourceUnits: number,
  evidenceRefs:           filamentRef[] (camera footage, sensor data, photos)
}
```

The alert spawns a filament on `branch.civic.<region>.alerts`. That filament exerts wind pressure (directional lean toward the incident location), generates heat (engagement spike from responders and bystanders), has fog if evidence is weak, and has magnitude based on severity. If unresolved, it becomes a twig — a visible reminder that something needs attention.

### 74.2 Civic Access Credit (CAC) — Abuse-Resistant Public Service Signaling

Emergency services must not be free to spam, but must never be inaccessible to someone in genuine danger.

- Every user has a monthly **Civic Access Allocation** (regenerates per timebox, weighted by reputation and region)
- Triggering an alert stakes CAC — you put some of your allocation behind the call
- **Validated alert:** CAC returned plus a small bonus for responsible civic participation
- **False or trivial alert:** CAC reduced, reputation penalty, potential civic scar on your tree
- **Repeated abuse:** Temporary suspension from non-life-threatening alert categories
- **Life-threatening alerts can NEVER be blocked by CAC balance** — the system nudges rational usage without preventing genuine emergency access
- **Hospital overuse discipline:** Choosing emergency dispatch for a trivial case costs higher CAC. If the case is later marked non-critical by responders, additional confidence penalty. The system nudges toward self-care guidance or clinic appointments for non-emergencies.

### 74.3 Dispatch Physics — Deterministic and Explainable

Each response unit is a filament with real-time properties:

```
ResponseUnit {
  unitId:           string (e.g., "FIRETRUCK-12", "AMBULANCE-4"),
  currentPosition:  { lat, lon },
  readinessState:   enum { AVAILABLE, EN_ROUTE, ON_SCENE, RETURNING, OFFLINE },
  specialization:   string[] (e.g., ["hazmat", "cardiac"]),
  fuelLevel:        number (0..1),
  fatigueScore:     number (hours since last rest),
  etaEstimation:    number (seconds to any given point, computed from traffic data)
}
```

**Dispatch selection minimizes:**

```
dispatchCost = (responseTime x severityWeight) + (currentUnitLoad x fatigueWeight) + (trafficFriction x routeRisk)
```

No hidden randomness. Fully explainable. Tap any dispatch decision on the civic branch and see exactly why that unit was selected, what alternatives existed, and what each would have cost.

### 74.4 Traffic Flow — Deterministic Pressure, Not Timer-Based

Traditional traffic systems use fixed timers and loop sensors. Relay traffic uses live filament data:

- Each **vehicle** with a Relay-connected device is a filament (destination vector, urgency class, occupancy weight, vehicle type)
- Each **route segment** is a branch segment with aggregate flow magnitude
- Each **intersection** is a node computing aggregate directional pressure using the same lean equation from §10
- **Signal timing** adjusts deterministically: `greenTime_direction = baseTime + (flowMagnitude_direction x scalingCoefficient)`
- **Emergency vehicles** inject directional storm (maximum pressure) that overrides lane priority — traffic clears because the physics demand it, not because a timer says so

### 74.5 Cascading Emergency — Priority Recalculation

When multiple simultaneous events occur (a cat in a tree, a house fire, an active shooter, an earthquake, a solar flare), the system computes:

```
priorityScore = severity x lifeRisk x proximity x capacityFactor
```

Events are sorted deterministically. Higher severity overrides lower. Units can be recalled mid-route if a higher-priority event demands them. All reassignments are visible filaments — you can trace why an ambulance was diverted. The cat rescue alert stays OPEN as a twig — it does not vanish, it just sinks into lower priority and will be addressed when capacity allows.

### 74.6 Degraded Civic Mode

During fire, flood, earthquake, or solar flare:

- Non-critical alerts auto-throttled (reduced visibility, not deleted)
- Emergency-only dispatch — all available units route to highest-severity events
- CAC cost temporarily reduced (don't punish people for calling during a disaster)
- Traffic lanes dynamically reallocated — evacuation routes get maximum pressure priority
- Public live map shows safe corridors, shelter locations, and hazard zones
- If communications drop (solar flare, infrastructure failure): local shards continue operating independently, events queue locally, federation reconnects when possible (§67 BCP/DRP)
- **Triage principle:** Spectacle sheds first. Dispatch remains. Truth never stops.

All mode transitions (NORMAL → DEGRADED → EMERGENCY → RECOVERY) are committed events on the civic branch. The system's crisis response is auditable after the fact.

### 74.7 Resource Registry Integration

Water systems, power grids, telecom networks, road networks — each is a branch with filament-tracked infrastructure:

| Resource Type | Branch Structure | Key Metrics |
|--------------|-----------------|-------------|
| Water | Reservoir → treatment → distribution | capacity, flow rate, contamination events |
| Power | Generation → transmission → distribution | load, outage events, renewable percentage |
| Telecom | Backbone → local exchange → last mile | bandwidth, latency, outage duration |
| Roads | Highway → arterial → local → intersection | traffic volume, accident density, repair backlog |

Each event on these branches modifies magnitude, heat, fog, and lean. The public sees real-time civic health at a glance — a wilting water branch means service issues. A glowing power branch means reliable delivery.

### 74.8 History and Accountability

Every alert, every dispatch, every response time, every outcome — all sink inward with time. A cross-section of the civic branch shows: which months had emergency spikes, which years had fires, which policy changes improved response time, which leadership periods increased fog (uncertainty). No more hiding systemic failure. The tree remembers.

**Contract #178 — Civic alerts are filaments obeying universal equations (heat, fog, lean, magnitude, confidence). Dispatch selection is deterministic and fully explainable — tap any decision and trace it to its inputs. Traffic control uses live pressure aggregation from vehicle filaments, not fixed timers. CivicAccessCredit discourages abuse through staking and reputation consequences without ever blocking genuine life-threatening access. No emergency is suppressed without a recorded commit.**

**Contract #179 — In degraded civic mode, non-critical alerts throttle, dispatch remains operational, local shards run independently during communications loss, and all mode transitions are committed events. Resource infrastructure (water, power, telecom, roads) is branch-tracked with the same physics as all other Relay branches. Relay survives fires, floods, earthquakes, and communication blackouts through federated append-only architecture (§67).**

---

## 74b. Vehicular Proximity Mesh (RELAY-TRAFFIC-SOCIAL-1) — Frozen Contracts #301–304

> *"The car has become the carapace, the protective and aggressive shell, of urban and suburban man."* — Marshall McLuhan

**Prerequisites:** §1 (the globe), §9 (confidence), §17 (presence system), §29 (proximity channels), §33 (LOD rendering), §63 (child safety & parental governance), §66 (microsharding), §74 (traffic & civic response), §82 (three-layer ontology), §105 (device mesh).

A stationary proximity channel (§29) anchors to a place — a store, a park, a factory floor. A vehicle is a place that moves. Relay extends the proximity channel architecture to moving nodes: every car running a Relay device becomes a mobile proximity channel, forming and dissolving ephemeral peer-to-peer links with nearby vehicles as traffic flows. Traffic stops being dead time. It becomes a living, structured, privacy-preserving social layer.

### 74b.1 Vehicle as Mobile Proximity Channel

A car, bus, truck, or motorcycle with a Relay-running device aboard is a **Vehicle Channel Node** — a proximity channel (§29) in motion. Unlike stationary channels that persist for months or years, vehicular channels are ephemeral. They form when cars approach, intensify while cars travel together, and dissolve when they separate.

```
VehicleChannelNode {
  vehicleId:         string (derived from device tree, NOT from license plate),
  occupantCount:     number,
  occupantRoles:     [{ userId, role: enum { DRIVER, FRONT_PASSENGER,
                        REAR_PASSENGER, CHILD_PASSENGER } }],
  broadcastProfile:  BroadcastProfile,
  velocityVector:    { speed, heading },
  laneEstimate:      number | null,
  meshRadius:        number (meters — configurable: 50m urban, 200m highway, 500m rural),
  channelLifecycle:  enum { DISCOVERED, LINKED, ACTIVE, FADING, GONE },
  privacyTier:       enum { SILENT, BROADCAST_ONLY, SOCIAL, OPEN },
  driverMode:        boolean
}
```

**Identity is tree-based, not vehicle-based.** A VehicleChannelNode derives its identity from the device owner's tree — the same identity you carry on foot. No VIN, no plate, no vehicle registration enters the protocol. You are you. The car is just where you happen to be.

**Detection** uses the same BLE/WiFi multi-signal confirmation from §29, extended with a motion-compensated handshake. Devices exchange rolling tokens that account for relative velocity. Two vehicles traveling at 70 mph in the same direction have near-zero relative velocity — their handshake is as stable as two people sitting in a coffee shop. Two vehicles passing in opposite directions have a brief, high-velocity encounter — the handshake completes faster but the link lifecycle is compressed.

**Ephemeral link formation:**

| Event | Threshold | Result |
|-------|-----------|--------|
| Detection | BLE/WiFi signal from nearby device | Lifecycle → DISCOVERED |
| Sustained proximity | Within mesh radius for > 3 seconds | Lifecycle → LINKED |
| Handshake complete | Rolling token exchange + challenge-response | Lifecycle → ACTIVE |
| Separation begins | Signal weakening, predicted exit | Lifecycle → FADING |
| Out of range | Beyond mesh radius for > 5 seconds | Lifecycle → GONE, link dissolved |

The 3-second DISCOVERED→LINKED threshold prevents flicker from vehicles passing at high relative speed. The 5-second FADING→GONE threshold prevents re-link thrash from vehicles at mesh radius boundary (stop-and-go traffic). All links are filaments on the shared `traffic.mesh.<region>` branch and follow standard lifecycle physics.

**Anti-spoof:** The §29 anti-spoof measures apply unchanged — multi-signal confirmation, time-in-range, challenge-response, community flagging. Additionally, velocity consistency checks detect stationary devices falsely broadcasting vehicular presence. A device claiming vehicular mode must demonstrate motion continuity via accelerometer and GPS delta, or the channel degrades to INDETERMINATE.

### 74b.2 Broadcast & Social Layer — Traffic as Conversation

Every vehicle channel can broadcast a presence into the mesh. What you share, how much you share, and who can see it is entirely under your control.

**Privacy tiers** (set by vehicle owner, adjustable at any time):

| Tier | Visible to Others | Interaction |
|------|-------------------|-------------|
| SILENT | Nothing. Invisible in mesh. | No inbound, no outbound. Pure navigation data contribution (anonymous). |
| BROADCAST_ONLY | Broadcast profile visible (tag, genre, decoration). | No inbound interaction. Others see your vibe, cannot contact you. |
| SOCIAL | Broadcast profile + accept inbound requests. | Voice/text/AR channels with nearby cars. Requires mutual consent. |
| OPEN | Full presence + auto-accept within mesh. | CB-radio style open channel. Anyone in mesh radius can hear and speak. |

**Broadcast profiles** are lightweight SapPackets (§82.3) with TTL matching the mesh link duration:

```
BroadcastProfile {
  displayTag:        string (max 32 chars — a handle, a mood, a topic),
  genre:             string | null (music genre currently playing, if shared),
  treeDecoration:    enum { NONE, MINIMAL, FULL } (visual presence on the traffic branch),
  channelTopic:      string | null (conversation topic for SOCIAL/OPEN tiers),
  occupantBroadcast: boolean (whether passengers also appear individually)
}
```

**What this feels like on the globe:** At REGION LOD, traffic flows appear as familiar pressure gradients (§74.4). At TREE LOD, you begin to see individual vehicle filaments — moving dots with broadcast tags. At BRANCH LOD (your own immediate mesh), nearby vehicles render as small companion branches growing temporarily from your traffic participation branch, decorated with their broadcast profiles. Clusters of OPEN-tier vehicles in heavy traffic form visible conversation knots — dense, warm, branching.

**Voice channels** between vehicles use encrypted peer-to-peer audio (no central server, no recording by default). Channel creation requires mutual SOCIAL/OPEN tier. Channels dissolve when the mesh link dissolves. No transcript persists unless both parties explicitly commit a recording as a filament on their respective trees.

**The CB radio reborn.** Long-haul truckers, commuters in traffic jams, families on road trips, ride-share passengers — all can opt into a rolling social layer where the conversation changes as the traffic changes. No accounts to create, no apps to install beyond Relay, no permanent social graph formed. The mesh is the moment.

### 74b.3 Backseat Mode — The Rolling Social Playground

Children in vehicles have a `role: CHILD_PASSENGER` governed by the parental controls defined in §63. Backseat Mode extends this into the vehicular mesh, creating an age-gated social layer where kids in nearby cars can interact while their parents maintain full governance.

```
BackseatGovernancePacket {
  childRef:          userRef (child's tree, age-verified per §63),
  parentRef:         userRef (governing parent),
  maxMeshRadius:     number (meters — may be smaller than vehicle's own meshRadius),
  allowVoice:        boolean,
  allowText:         boolean,
  allowAR:           boolean,
  allowBroadcast:    boolean,
  contentGate:       ageGateRef (§63 age bracket rules),
  friendRequestPolicy: enum { BLOCKED, PARENT_APPROVE, AUTO_DISSOLVE },
  sessionTimeout:    number (minutes — maximum continuous session before mandatory break)
}
```

**Swarming:** When two vehicles with CHILD_PASSENGER occupants enter each other's mesh radius, and both parents have enabled Backseat Mode, a child-to-child channel can form. Kids see other kid-mode passengers in nearby cars — names (or handles), age brackets, shared interests (from their tree). They can play simple mesh games, share drawings (leaf-class content, ephemeral), or voice chat if permitted.

**Auto-dissolve:** When vehicles separate beyond mesh radius, kid-to-kid channels dissolve completely. No contact information persists. No friend request is auto-generated. If a child wants to stay in touch with someone they met on the highway, **both sets of parents** must independently approve a friend request — this is a filament-level commit on both parent trees with full evidence chain. The system makes it easy to connect in the moment and deliberately difficult to form permanent connections without parental consent.

**Content safety:** All Backseat Mode interactions pass through the §63 content gates. SCV monitoring for age-inappropriate content, grooming patterns, and behavioral anomalies applies identically to vehicular mesh channels. A parental alert filament fires if the SCV detects concerning patterns.

**Session limits:** Parents set a `sessionTimeout` — maximum continuous Backseat Mode engagement before the system forces a break. This prevents infinite screen time on long drives. The timeout is a ticking visual element the child can see (a leaf slowly falling), making the boundary transparent rather than surprising.

### 74b.4 Crowd-Sourced Navigation — The Traffic Tree

Every Relay vehicle contributes anonymous navigation data to the traffic tree. This is not surveillance — it is the same aggregate pressure physics from §74.4, fed by real-time filament data from consenting participants.

**What each vehicle contributes (anonymous, aggregate-only):**

- Speed on road segment
- Brake events (sudden deceleration)
- Lane change frequency (congestion indicator)
- Route choice (which segment was selected at each junction)
- Stop duration (at lights, in traffic, at destinations)

No individual vehicle is tracked. Data is aggregated at the road segment level. The segment branch `traffic.flow.<region>.<segment>` accumulates magnitude from all contributing vehicles. High magnitude = heavy flow. High heat = rapid change (accident, sudden stop). High fog = inconsistent data (sensor disagreement, sparse coverage).

**Route recommendations** emerge from the traffic tree the same way any Relay insight emerges — by reading the physics:

```
routeScore = Σ_segments( segmentLength / (flowMagnitude × heatPenalty × fogUncertainty) )
```

Your SCV suggests routes by reading the traffic tree, finding the path of least aggregate resistance. No central routing server. No corporate algorithm deciding which gas station to route you past. The tree is the map, and the map is made by the people driving on it.

**Community-reported events:** Passengers (never the driver during motion) can flag real-time conditions:

```
TrafficEventFilament {
  eventType:         enum { ACCIDENT, POLICE, ROAD_HAZARD, CONSTRUCTION,
                           WEATHER_CONDITION, ROAD_CLOSURE, ANIMAL_ON_ROAD,
                           SPEED_TRAP, FUEL_PRICE, SCENIC_POINT, OTHER },
  geolocation:       { lat, lon, precision },
  reporterConfidence: number (from user tree health),
  evidenceRefs:      filamentRef[] (photos, video — passenger-captured),
  timeboxDecay:      number (hours until auto-fade if unconfirmed),
  confirmationCount: number (independent reports from other vehicles)
}
```

A single report spawns a filament with high fog (unconfirmed). A second independent report from a different vehicle reduces fog. Three or more confirmations crystallize the event — high confidence, visible on the traffic tree for all vehicles in the area. Unconfirmed reports fade according to their timebox decay. False reports accumulate civic confidence penalties on the reporter's tree.

**This is Waze rebuilt on Relay physics.** No central server. No corporate data harvesting. No ads disguised as navigation suggestions. No dark patterns. Just a community of drivers contributing anonymous aggregate data to a shared traffic tree that everyone can read, and anyone can audit.

### 74b.5 Safety Mesh — Opt-In Hashed Plate Protocol

Privacy is the default. The Vehicle Channel Node protocol uses tree-derived identity — no license plates, no VINs, no vehicle registrations. But the world has missing children, stolen cars, and hit-and-run drivers. Relay addresses this with an opt-in safety layer that uses cryptographic hashing to enable civic safety without enabling surveillance.

**The architecture:**

1. **Opt-in only.** Users explicitly choose to join the Safety Mesh. No user is ever enrolled automatically.
2. **Hash, never store.** When a Safety Mesh participant's camera detects a nearby license plate, the plate text is immediately hashed using a one-way cryptographic function. The plaintext plate is never stored, never transmitted, never logged.
3. **Match against active alerts only.** The hash is compared against a curated safety registry of hashed plates from active Amber alerts, stolen vehicle reports, and hit-and-run investigations.
4. **No match = immediate destruction.** If the hash does not match any active alert, the hash object is destroyed. No record of the scan exists anywhere in the system.
5. **Match = safety alert.** If the hash matches an active alert, a SafetyAlertFilament is created with an evidence chain linking the match to the alert, the time, the approximate location, and the reporter's identity (for civic confidence credit).

```
SafetyMeshRegistration {
  userId:            string,
  deviceId:          string,
  optInTimestamp:    timestamp,
  hashAlgorithm:     string (system-wide, rotated periodically per governance),
  activeAlertSources: enum[] { AMBER_ALERT, STOLEN_VEHICLE, HIT_AND_RUN,
                               SILVER_ALERT, ENDANGERED_MISSING },
  matchPolicy:       enum { NOTIFY_ONLY, NOTIFY_AND_REPORT }
}
```

```
PlateHashEvent {
  hash:              string (one-way, irreversible),
  timestamp:         timestamp,
  approximateLocation: { lat, lon, precision: "ROAD_SEGMENT" },
  reporterRef:       userRef,
  matchResult:       enum { CLEAR, ALERT_MATCH }
}
```

- If `matchResult = CLEAR`: The entire PlateHashEvent object is destroyed. No filament is created. No sap is transmitted. The event never existed.
- If `matchResult = ALERT_MATCH`: The event becomes a `SafetyAlertFilament` on the civic alert branch (§74.1), linking to the matched alert, with the reporter receiving a civic confidence boost for responsible participation.

**Evidence sovereignty:** Separate from the Safety Mesh, every vehicle owner has **personal evidence sovereignty**. If you are in an accident, YOUR camera footage is YOUR evidence. It is stored as a private filament on YOUR tree at disclosure tier 0 (§8.5). You choose whether to share it — with insurance, with law enforcement, with the other driver. The system never auto-shares your footage. The system never accesses your camera without your device's active, revocable consent.

**Hash rotation:** The hashing algorithm rotates on a governance-defined schedule. When it rotates, the active alert registry re-hashes all active plates with the new algorithm. Old hashes become useless. This prevents rainbow table attacks and ensures that even a compromised hash database reveals nothing about plates that were scanned and cleared.

**Why this works:** A million drivers with cameras become a distributed safety net for missing children and stolen vehicles — without any of them becoming surveillance cameras. The mathematical properties of one-way hashing guarantee that a CLEAR scan cannot be reversed into a plate number. No government, no corporation, no hacker who intercepts a CLEAR hash can determine what plate was scanned. Privacy is not a policy — it is a mathematical guarantee.

### 74b.6 Driver Safety — The Driver Mode Contract

The driver is sacred. A distracted driver kills. Relay enforces this architecturally:

When a device is registered as `role: DRIVER` in the VehicleChannelNode:

- **No interactive social features.** No text, no AR, no visual channels. The driver cannot swipe, type, tap, or visually engage with social mesh content.
- **Voice-only navigation.** SCV provides turn-by-turn voice guidance from the traffic tree. Route suggestions are spoken, not displayed.
- **Passive broadcast only.** The driver's broadcast profile is set before departure or by voice command. No mid-drive profile editing.
- **Emergency override.** The driver can issue voice-activated emergency alerts (§74.1 CivicAlertPacket). This is the one interactive feature that remains — because emergencies do not wait.
- **Passenger delegation.** All interactive social features — flagging traffic events, managing Backseat Mode, adjusting broadcast profiles, engaging in voice channels — are delegated to passengers. If there are no passengers, these features are unavailable during motion.

The device detects motion state from accelerometer and GPS. If the device is in DRIVER role and the vehicle is moving above 5 mph, interactive features lock automatically. Attempting to circumvent (removing from mount, handing to a child) triggers a role reassignment — the device becomes a PASSENGER device, and Driver Mode features (navigation voice, emergency alerts) transfer to whatever device remains in the driver's mount.

**Contract #301 — Every vehicle running Relay is a mobile proximity channel. Identity is tree-based, never vehicle-based. Ephemeral links form on sustained proximity (>3 seconds) and dissolve on separation (>5 seconds). VehicleChannelNode uses motion-compensated BLE/WiFi handshake with velocity consistency anti-spoof. Privacy tiers (SILENT through OPEN) give vehicle owners complete control over mesh visibility. Broadcast profiles are SapPackets with mesh-link TTL. Voice channels are encrypted peer-to-peer with no default recording. The vehicular mesh extends §29 proximity channels to moving nodes without altering stationary channel physics.**

**Contract #302 — Backseat Mode creates an age-gated child-to-child social layer within the vehicular mesh, governed by BackseatGovernancePacket with parental controls for voice, text, AR, broadcast, mesh radius, friend requests, and session timeout. Channels auto-dissolve on vehicle separation. No persistent contact without dual-parent approval. All content passes through §63 safety gates. SCV monitors for grooming and behavioral anomalies. Session timeout prevents unlimited engagement. The rolling social playground forms and dissolves with the traffic — no child is ever a click away from a stranger without explicit, audited parental consent.**

**Contract #303 — Navigation data is anonymous and aggregate-only. No individual vehicle is tracked. Segment-level pressure, heat, and fog derive from the same equations as §74.4. Route recommendations emerge from reading the traffic tree — no central routing server, no corporate algorithm. Community-reported TrafficEventFilaments require independent confirmation to crystallize. False reports carry civic confidence penalties. The traffic tree is auditable, decentralized, ad-free, and owned by its contributors.**

**Contract #304 — The Safety Mesh is opt-in only. License plates are hashed immediately and irreversibly — never stored in plaintext anywhere in the system. Hashes are checked against active safety registries (Amber alerts, stolen vehicles, hit-and-run). No match = hash destroyed, no trace. Match = SafetyAlertFilament with evidence chain. Hash algorithm rotates on governance schedule. Personal camera footage is private evidence on the owner's tree at tier 0 — never auto-shared. Driver Mode locks all interactive features during motion, delegates social functions to passengers, and preserves voice-only navigation and emergency alerts. Privacy is a cryptographic guarantee, not a policy promise.**

---

## 75. Physical Weather Layer — Frozen Contract #180

> *"Sunshine is delicious, rain is refreshing, wind braces us up, snow is exhilarating; there is really no such thing as bad weather, only different kinds of good weather."* — John Ruskin

**Prerequisites:** §3.16 (branch weather), §9 (confidence), §23 (weather and wind), §33 (LOD rendering), §68 (arena branches).

Relay has two weather systems that stack but never confuse:

1. **Branch Weather** (existing, §3.16 and §23) — social and operational truth fields computed from filament activity. Heat means high engagement. Fog means uncertainty. Storm means heat multiplied by fog. Lightning means cascading failures. This is metaphorical weather that tells you about the health of data.

2. **Physical Weather** (this section) — actual meteorology. Real rain. Real wind. Real temperature. Measured by sensors, rendered in 3D, deterministic from source data. This is the weather you feel when you step outside.

Both layers render simultaneously. They use different color palettes so you always know which is which.

### 75.1 Data Source

Physical weather data comes from Relay-registered sensors — buoys, weather stations, anemometers (wind speed meters), rain gauges, lightning detectors, barometers (air pressure meters) — plus optionally public weather sources (radar, satellite imagery, forecast models) as external evidence feeds, clearly labeled as external.

Every sensor is a tree or branch with its own identity, calibration commits, uptime history, and data stream filaments. Sensors with low confidence (infrequent calibration, spotty uptime) contribute less to the weather computation — the same confidence physics (§9) that governs all other data in Relay.

### 75.2 PhysicalWeatherTileAggregate Schema

The globe is divided into grid cells. Each cell aggregates sensor readings for a time window:

```
PhysicalWeatherTileAggregate {
  tileId:               string,
  windowStart:          timestamp,
  windowEnd:            timestamp,
  precipRate:           number (mm/hr — millimeters of rain per hour),
  precipType:           enum { RAIN, SNOW, HAIL, MIXED },
  windU:                number (m/s — east-west wind component),
  windV:                number (m/s — north-south wind component),
  tempC:                number (temperature in Celsius),
  pressureHpa:          number (atmospheric pressure in hectopascals),
  humidityPct:          number (relative humidity as percentage),
  visibilityM:          number (visibility distance in meters),
  lightningStrikeRate:  number (strikes per minute in the cell),
  sourceCoverage:       number (0..1 — what fraction of the cell has sensor data),
  sourceList:           sensorRef[] (which sensors contributed),
  interpolationMethod:  string (mathematical method used to fill gaps between sensors),
  damageField:          number (aggregated incident reports + verified footage),
  damageConfidence:     number (how well-evidenced the damage assessment is)
}
```

### 75.3 LOD Rendering — Radar to Clouds

Physical weather renders differently at each zoom level:

- **GLOBE / REGION LOD:** Radar-style precipitation overlay — familiar green, yellow, red blobs showing rainfall intensity. Coarse wind streamlines show prevailing wind direction. Pressure contours show high and low pressure systems. Lightning density renders as a heatmap. This is the "weather map" everyone recognizes from television.

- **CITY / TREE LOD:** Precipitation becomes 3D volume columns — you can see rain shafts falling from cloud base to ground. Cloud layers become visible as translucent volumes. Wind becomes layered vectors showing speed and direction at different altitudes. Lightning is localized to specific areas.

- **BRANCH / BARK LOD:** Weather becomes local and tangible. Wind creates visual distortion (a wall of pressure you can see). Rain renders as individual streak density. Fog thickness comes from humidity readings. Lightning flashes where strike probability is highest. Users can fly through a hurricane and experience it in three dimensions.

All rendering is deterministic. Same sensor data = same storm visualization. Tap any weather voxel (3D pixel) and see exactly which sensor readings drove it, at what time, with what interpolation.

### 75.4 Two-Layer Visual Distinction

Both weather systems render simultaneously with clearly different visual languages:

- **Physical weather:** Familiar meteorology palette — radar greens, yellows, reds for precipitation. Cloud greys for overcast. Blue for clear sky.
- **Branch weather:** Existing Relay truth-lens palette — fog (semi-transparent uncertainty clouds), storm (dark red heat-times-fog), lightning (bright cascade flashes).
- **UI legend:** Always visible, always showing which layer is active: PHYSICAL vs RELAY. Users can toggle each layer independently.

### 75.5 Forecasts as Projections

Physical observations from sensors are truth filaments — measured, timestamped, evidence-backed.

Forecasts are projection branches (§6) — light-blue, clearly labeled PROJECTION, showing the model and data source that produced them. Forecasts render as a faint ghost layer ahead in time, visually distinct from current conditions. You can see the predicted storm approaching as a translucent volume while the current sky is clear.

Forecasts are never presented as truth. They are always labeled with their source model and confidence level.

### 75.6 Bridge to Game Layer

The same physical weather data serves multiple purposes across Relay's activation stages:

- **Stage 1–2 (pre-game layer):** Physical weather is a real-world risk lens. Storms are visible hazards. Users can see approaching weather systems and plan accordingly.
- **Stage 3 (game layer active):** Those same storm volumes become the elemental arena substrate. A duel fought inside a real hurricane uses the same weather rendering. The world's weather becomes the world's spell palette — a thunderstorm empowers lightning-element users. A blizzard favors ice specialists. The weather is not random — it is real, measured, and deterministic.

**Contract #180 — Physical weather is a deterministic 3D rendering of measured meteorological fields from Relay-registered sensors. Every rendered pixel traces to source sensor readings, time window, and interpolation method. Physical weather and branch weather are separate layers with distinct visual palettes and independent data sources. Weather graphics are a lens, never a lever — they render risk, they do not enforce behavior. Forecasts render as projections (light-blue), never as truth. Physical weather data bridges into the game layer as elemental arena substrate at Stage 3 activation.**

---

## 76. Civilization Template Library — Frozen Contracts #181–182

> *"Civilization is not inherited; it has to be learned and earned by each generation anew."* — Will Durant

**Prerequisites:** §21 (templates), §38 (module discovery), §72 (layered option governance).

**Companion document:** [RELAY-CIVILIZATION-TEMPLATE-LIBRARY.md](RELAY-CIVILIZATION-TEMPLATE-LIBRARY.md) contains the full specification — 13 civilization pillars (PERSON through FIN-INSTRUMENTS) with index cards, cross-pillar standards (canonical object IDs, universal truth packets, cross-tree linking protocol), and deep-dive specifications for HEALTH-1 and PROPERTY-1. Estate/Death, Marriage/Partnership, Sports, and Utilities are handled as extensions of the core pillars (see §76.3, §76.4). Machine-readable JSON stubs live in `config/templates/`.

Every domain of human civilization can be represented as a tree using the same physics. No new equations are needed. What is needed is a library of standard templates — branch archetypes that cover the domains people actually live in. A farmer needs an agriculture template. A hospital administrator needs a healthcare template. A family needs a family governance template. This section defines the seed library.

### 76.1 The Seed Domains

Each template below uses the six universal filament domains (identity, counterparty, time, magnitude, evidence, lifecycle) and the ten universal equations. What varies is the branch structure, the magnitude type, the evidence rules, and the governance policies. The companion document contains full index cards with schemas, evidence rules, consolidation gates, and meta-vote parameters for each pillar.

| # | Domain | TemplateId | Key Branch Structure | Magnitude Type |
|---|--------|-----------|---------------------|---------------|
| 1 | **Person** | `template.person.v1` | Roles, learning, health, economic, social, arena, attention | Mixed |
| 2 | **Family** | `template.family.v1` | Joint finances, property, children, inheritance, shared decisions | Money, time, responsibility |
| 3 | **Property** | `template.property.v1` | Ownership, encumbrances, zoning, permits, inspections, maintenance | Money (value, tax) |
| 4 | **Healthcare** | `template.health.v1` | Patient timeline, labs, meds, procedures, consent, break-glass | Patient count, cost, outcomes |
| 5 | **Education** | `template.education.v1` | Curriculum, courses, students, teachers, grading, certification | Completion rate, scores |
| 6 | **Emergency** | `template.emergency.v1` | Alert queue, unit dispatch, response tracking, outcomes | Severity, response time |
| 7 | **Infrastructure** | `template.infra.v1` | Maintenance, stress load, accidents, weather, utilities (water/power/telecom) | Cost, capacity units |
| 8 | **Agriculture** | `template.agri.v1` | Soil, crop cycles, water, fertilizer BOM, harvest, mass balance | Weight (kg), cost |
| 9 | **Commerce** | `template.commerce.v1` | Product listings, retail, peer exchange, fulfillment | Transaction value |
| 10 | **Logistics** | `template.logistics.v1` | Shipments, custody chain, incident routing, delivery confirmation | Weight, volume, time |
| 11 | **Law** | `template.law.v1` | Cases, evidence, hearings, judgments, appeals, custody of process | Severity, financial stakes |
| 12 | **Culture** | `template.culture.v1` | Museums, theatres, religious institutions, community centers, festivals | Attendance, funding |
| 13 | **Finance** | `template.finance.v1` | Mortgages, loans, bonds, insurance, derivatives — linked debit/credit pairs | Money (principal, interest) |

**Domains handled as extensions of the above (not separate pillars):**

| Domain | Handled By | How |
|--------|-----------|-----|
| **Estate / Death** | Person template + §76.3 | Closure commit freezes the user tree. Heir designation, memorial mode, digital will. See §76.3. |
| **Marriage / Partnership** | Family template + §76.4 | Bilateral consent commit creates shared governance tree. Dissolution via sortition. See §76.4. |
| **Sports** | Culture template + Arena (§68) | Organized sports use culture template for league/team trees; matches use arena mechanics. |
| **Utilities** | Infrastructure template | Water, power, telecom are branches on infrastructure trees, not separate pillars. |

### 76.2 How Templates Work

Each template specifies:

- **Branch structure:** The default hierarchy of branches that makes sense for the domain. A healthcare template starts with triage, staffing, equipment, procedures, and compliance branches. A user can customize — but the template gives a working starting point.
- **Magnitude type:** What gets measured. Money for commerce. Weight for agriculture. Patient count for healthcare. This maps to the filament's magnitude domain.
- **Evidence rules:** What constitutes proof in this domain. A property transfer needs deed documentation. A medical procedure needs clinical notes. An agricultural harvest needs scale readings.
- **Governance policies:** Who can commit, who can view, what the default disclosure tiers are. A family tree might default to Tier 0 (private). A municipal services tree defaults to Tier 2 (fully public).
- **Integration points:** How this template connects to other templates. A property template links to the finance template (mortgage). A healthcare template links to the insurance template (claims). A person template links to everything.

### 76.3 Estate and Death — The Final Commit

When a user dies, their tree does not disappear. It freezes:

- A **closure commit** (§71.7) is appended to the tree root, marking it as frozen
- An **heir designation** branch (if configured) transfers access to designated heirs through sortition-verified process (§46)
- **Memorial mode** renders the tree as a permanent monument — still navigable, still searchable, but no new filaments can be committed
- A **digital will** (a governance commit) specifies which branches transfer to which heirs, which branches are sealed permanently, and which branches are published to a wider audience posthumously
- The tree's Merkle chain remains intact. The person's contributions to civilization are permanent.

### 76.4 Family Governance

A family tree is a shared governance tree where:

- Both partners have equal commit authority on shared branches (joint finances, property, children's education)
- Children have age-appropriate access tiers (§63 child safety)
- Inheritance chains are pre-configured — if a parent's tree freezes, designated branches automatically transfer
- Dissolution (divorce, separation) follows sortition-based case resolution (§46) with pre-agreed terms where possible
- Extended family can be granted read-only or limited-commit access to specific branches

### 76.5 Template Library Governance

The template library itself is governed by §72 layered option governance:

- **What templates exist** is a community meta-vote. Anyone can propose a new domain template. The community votes on whether it should be part of the standard library.
- **What a template contains** (branch structure, evidence rules) is governed within that domain's community. Healthcare professionals govern the healthcare template. Farmers govern the agriculture template.
- **Templates can be extended** through §38 module discovery. A regional community might create a variant healthcare template for their local regulatory environment.
- **No template is permanent** except through continued community support. If a template is abandoned (no users, no governance activity), it wilts naturally — visible as a dead branch on the template library tree.

**Contract #181 — Every domain of civilization is representable as a tree template using the same universal equations. No new physics is required. Templates define branch structure, magnitude types, evidence rules, governance policies, and integration points with other templates. The template library is governed by §72 layered option governance — what templates exist, what they contain, and how they evolve are all community decisions.**

**Contract #182 — Person, family, property, healthcare, agriculture, infrastructure, commerce, estate/death, emergency, utilities, finance, culture, sports, and marriage/partnership are the fourteen seed template domains. Each can be extended through module discovery (§38). The community governs what templates exist and how they evolve. No template is permanent except through continued community support. Estate/death templates preserve user trees as frozen monuments with sortition-verified heir transfer.**

---

## 77. Product Supply Chain Traceability — Mineral to Shelf — Frozen Contracts #183–184

> *"The care of the Earth is our most ancient and most worthy, and after all our most pleasing responsibility."* — Wendell Berry
>
> *"Skill is not virtue if the branch is wrong."* — ChatGPT 5.2

**Prerequisites:** §4 (filaments), §21 (templates), §30 (verification physics), §31 (accounting packets), §52.5 (mass balance), §53 (atomic traceability), §60 (fractal branching), §76 (civilization template library).

Every retail product sitting on a shelf is a tree. Not a SKU. Not a barcode. A tree — with design branches, supplier branches, batch branches, and a lineage that stretches all the way back to the mineral particles extracted from the earth. Relay makes that lineage visible, traceable, and auditable using the same physics that governs every other branch. No new equations. Just recursive application.

### 77.1 A Product Is a Tree

A manufactured product (a laptop, a medicine bottle, a car, a bag of baby wipes) is represented as a **Product Tree**:

```
Product Tree: Laptop Model X-2026
├── design (versions, specs, approvals)
├── bom (bill of materials — component list per version)
├── suppliers (counterparty trees for each component source)
├── manufacturing (production batches, machine IDs, operator responsibility)
├── distribution (logistics chain from factory to warehouse to retail)
├── retail (shelf placement, sale events, customer linkage)
├── warranty (service events, returns, replacements)
├── recall (defect tracking, propagation, remediation)
└── environmental (carbon intensity, water usage, waste, recycling content)
```

Each branch contains filaments. Each filament has identity, counterparty, time, magnitude, evidence, and lifecycle — the same six universal domains.

### 77.2 Version Control at Product Level

Every change to a product creates a new version filament on the design branch:

- `Laptop X-2026 v1.0` — initial release
- `Laptop X-2026 v1.1` — new battery supplier
- `Laptop X-2026 v1.2` — firmware update
- `Laptop X-2026 v2.0` — new motherboard architecture

Each version filament has evidence (design files, engineering approvals, regulatory certifications) and a lifecycle state. Superseded versions sink inward. In cross-section, each ring represents a release cycle. Thickness shows scope of change. Scars mark recalled versions. Lean indicates supplier or regulatory pressure.

### 77.3 Bill of Materials as Branch Physics

Each product version has a BOM branch. Each component in the BOM is a filament that links to its supplier tree:

```
Product Tree
└── BOM Branch (version-specific)
    ├── F-COMPONENT: Aluminum chassis → Supplier Tree A
    ├── F-COMPONENT: Lithium battery  → Supplier Tree B → Material Lot → Mine Tree
    ├── F-COMPONENT: OLED panel       → Supplier Tree C
    ├── F-COMPONENT: WiFi chip        → Supplier Tree D
    └── F-COMPONENT: Polypropylene casing → Supplier Tree E → Refinery → Extraction Site
```

This is recursive fractal branching (§60). The product tree links to supplier trees, which link to material trees, which link to extraction trees. No new physics — just cross-tree references at each level.

### 77.4 Batch-Level Traceability

Every manufactured batch becomes a filament:

```
ManufacturingBatch {
  batchId:              string ("batch.<productId>.<plantId>.<date>.<seq>"),
  productVersionRef:    filamentRef (→ design branch version),
  componentLotRefs:     filamentRef[] (→ specific material lots used),
  machineId:            string (production line identifier),
  operatorResponsibility: responsibilityPacketRef,
  productionStart:      timestamp,
  productionEnd:        timestamp,
  qualityInspection:    evidenceRef (inspection report hash),
  unitCount:            number (units produced in this batch),
  massBalanceCheck:     { inputKg, outputKg, wasteKg, variance },
  environmentalMetrics: { energyKwh, waterLiters, co2Kg }
}
```

Each individual retail unit (serial number) links to its batch filament. When you scan a product with a Relay-connected device, you trace:

**Retail Unit → Batch → Component Lots → Material Lots → Refinery → Extraction Site**

Every link is a cross-tree filament reference. Every link is clickable.

### 77.5 Mineral-Level Mapping

At the deepest level, material lots link to extraction events:

```
MaterialExtractionEvent {
  extractionId:       string,
  mineTreeRef:        treeRef (the mine is a tree with its own history),
  mineralType:        string (lithium, aluminum ore, crude oil, etc.),
  extractionDate:     timestamp,
  oreGrade:           number,
  massExtractedKg:    number,
  energyConsumedKwh:  number,
  carbonIntensityKg:  number,
  transportEmissions: number,
  evidenceRefs:       filamentRef[] (assay reports, GPS coordinates, operator attestation)
}
```

Relay does not track individual atoms. It tracks **mass-conserved batches** at each stage. The conservation law is enforced by consolidation gates:

```
inputMass = outputMass + wasteMass + emissions
```

This is the same mass balance rule from §52.5 applied recursively at every stage of the supply chain.

### 77.6 The Retail Shelf Experience

A shopper stands in a store, opens Relay, and points their camera at a product. Relay resolves:

1. **Retail SKU filament** — product identity, price, batch reference
2. **Batch filament** — when and where this batch was made
3. **Component filaments** — what went into it, from which suppliers
4. **Material lot filaments** — raw material provenance
5. **Extraction filaments** — where on Earth the minerals came from

An overlay shows at a glance:
- Carbon intensity color band (green = low, red = high)
- Water usage indicator
- Recycled content percentage
- Supplier confidence score (are supply chain links well-evidenced?)
- Labor compliance confidence
- Active recall risk (heat indicator if any upstream lot has a scar)

Tap "show full provenance" and the cross-section opens: rings from extraction through refining, polymerization, manufacturing, packaging, distribution, and retail — each clickable.

### 77.7 Recall Propagation as Lightning Cascade

When a defect is found — say, an impurity in a lithium batch causing battery overheating — the affected material lot filament receives a **scar**. That scar propagates upward through the linked filament chain using Relay's existing lightning cascade mechanics (§3.16):

```
Defective lithium lot (scar)
  → Every battery batch using that lot (lightning flash)
    → Every product batch containing those batteries (lightning flash)
      → Every retail unit from those batches (recall alert)
        → Every customer who purchased those units (notification filament)
```

This is not a database query. It is geometric propagation along linked filaments. The affected products literally glow with heat on the globe. No email chains. No spreadsheet tracking. The recall is visible as geometry.

### 77.8 Environmental Correlation

Because every material filament carries mass, emissions, energy usage, and waste data, Relay can compute **true embedded carbon per retail unit** — not estimated, but summed across all upstream filaments.

A shopper comparing Product A vs Product B sees:
- Product A: thick, firm supply chain branch (well-documented, low fog) with moderate carbon band
- Product B: thin, foggy supply chain branch (gaps in documentation) with high carbon band

The tree shape tells the story before any number is read.

### 77.9 Consolidation Gate — Supply Chain

A product batch cannot be marked ABSORBED (sealed for that epoch) unless:

1. All component lot references are resolved and linked
2. Mass balance closes at every stage (input = output + waste, within tolerance)
3. Quality inspection evidence is attached
4. Supplier certifications are current (not expired, not revoked)
5. No active recall scars on any upstream material lot

Incomplete batches wilt. The branch shape reveals supply chain health at a glance.

**Contract #183 — Every manufactured product is a tree with version-controlled design, BOM, batch, distribution, retail, warranty, recall, and environmental branches. Components link to supplier trees. Material lots link to extraction sites. Mass balance is enforced at every stage via conservation consolidation gates. Recall propagation follows lightning cascade mechanics along linked filament chains. Individual retail units trace to their batch, component lots, material lots, and extraction events through cross-tree filament references. No link in the chain is hidden or unauditable.**

**Contract #184 — The retail shelf experience renders product provenance as a navigable cross-section from extraction to shelf. Environmental metrics (carbon intensity, water usage, recycled content) are computed by summing upstream filament data, not estimated. Supply chain fog indicates documentation gaps. Supply chain heat indicates active issues or recalls. Shoppers see truth, not marketing claims. Every rendered metric traces to source filaments in one click.**

---

## 78. Filament Length Ontology — Structural Weight from Commit Topology — Frozen Contract #185

> *"We are what we repeatedly do. Excellence, then, is not an act, but a habit."* — Will Durant, summarizing Aristotle

**Prerequisites:** §3 (branch model), §4 (filaments), §14 (gravitational time), §21 (templates).

Different things in life have different structural weights. A social media post is a brief moment. A purchase order spans weeks. A book takes months. A balance sheet account never ends. In Relay, filament length is not manually assigned — it emerges from commit topology. The geometry of a filament tells you what kind of thing it is, without reading a label.

### 78.1 The Principle

Filament length along the L-axis (longitudinal position on the branch) represents the **span of active structural relevance across commits**. It is not "how long it took" in calendar time alone. It is a function of:

```
l_extent = f(commitCount, lifecycleSpan, structuralWeight)
```

Where:
- `commitCount` = number of commits on this filament
- `lifecycleSpan` = duration between first commit and lifecycle closure (or ongoing if never closed)
- `structuralWeight` = evidence density, contributor count, and cross-tree reference count

This means filament length emerges from reality, not from declaration.

### 78.2 Five Filament Profile Classes

Different domains naturally produce different filament geometries. These are not hardcoded categories — they are emergent patterns that the system recognizes:

| Profile | Examples | Typical Commits | Lifecycle | Visual Geometry |
|---------|----------|----------------|-----------|-----------------|
| **Micro** | A post, a comment, a single approval, a minor edit | 1–3 | Rapid OPEN → CLOSED | Small ribbon, thin cross-section, quickly sinks inward. Like a twig or leaf. |
| **Transaction** | Purchase order, invoice, goods receipt, payment, change order | 5–20 | Multi-stage evidence accumulation with defined completion | Medium-length ribbon, visible slab interaction, leaves permanent ring thickness. Like a seasonal growth segment. |
| **Project** | Book writing, software module, film production, machine installation, CAPEX project | Dozens to thousands | Multiple timeboxes, multiple contributors, version evolution | Long L-span, strong radial migration over time, thick slab accumulation. Like a large branch segment. |
| **Structural** | Balance sheet accounts, ledger accounts, directory trees, organizational branches, language trees, patient health history | Continuous stream | No terminal lifecycle, always active at surface | Underlying branch structure — these define the trunk and branches themselves. Like the vascular system. |
| **Continuous** | A live data directory, a sensor feed, an ongoing monitoring branch | Steady commit flow | Never closes, grows with time | Solid branch appearance because it is growing live commits continuously. It does not jump to stay alive — it is simply growing as one with time. |

### 78.3 How Length Emerges — No Manual Assignment

Filament length is never declared. It is computed from commit topology:

```
l_span = commitDensity × timeboxSpan × activityFactor
```

Where:
- `commitDensity` = commits per timebox for this filament
- `timeboxSpan` = number of timeboxes this filament spans
- `activityFactor` = normalized contributor count × evidence attachment count

Small activity → short filament. Long sustained activity → long filament. Permanent structural activity → continuous filament that defines branch shape.

### 78.4 Structural Nodes vs Finite Filaments

An important distinction:

- **Finite filaments** have lifecycle states (OPEN → ACTIVE → CLOSED → ABSORBED). They are discrete events with beginnings and endings. Posts, transactions, projects — all finite.
- **Structural nodes** are commit aggregators that never close. Balance sheet accounts, directory trees, organizational branches — these receive continuous commits and produce continuous branch thickening. They look like solid tree trunks because they are.

The visual difference: finite filaments are ribbons on the bark surface that eventually sink inward. Structural nodes ARE the bark surface — they define the branch geometry itself.

### 78.5 Cross-Domain Comparison

The same physics produces visually distinct geometry for different domains:

| Object | Filament Behavior | Visual Effect |
|--------|-------------------|---------------|
| Tweet | 1 commit, instant close | Tiny ribbon, fast inward migration |
| Purchase order | 5–10 commits, weeks to close | Medium ribbon across multiple slabs |
| Laptop product version | Multi-month project, many contributors | Long ribbon spanning many timeboxes |
| Annual budget cycle | Repeating timebox pattern, yearly close | Ringed branch with annual thickness bands |
| Balance sheet account | Continuous aggregator, never closes | Thick trunk segment, always at surface |
| File directory | Continuous commit flow | Stable branch, solid appearance |
| Language tree | Multi-century cultural flow | Massive trunk, deep historical rings |

Everything obeys the same equations. Only commit structure differs.

### 78.6 Anti-Gaming — Length Inflation Detection

If someone tries to inflate filament length by adding meaningless commits:

The system detects:
- Low semantic complexity delta between commits (each commit adds little new information)
- High scaffold percentage (most commits are structural, not substantive)
- Low confidence accumulation (no real evidence attached)
- Excessive commit frequency without corresponding evidence growth

This produces:
- **Fog** (low confidence from evidence deficit)
- **Twig growth** (unresolved open items)
- **Lean instability** (pressure from quality metrics)
- **Scar markers** (if community flags the pattern)

Length inflation without substance becomes visually obvious — a long, foggy, wilting filament is worse than a short, firm one. The system rewards substance, not volume.

### 78.7 Template Configuration

Templates (§21) can configure filament profile expectations:

```
FilamentProfileConfig {
  expectedCommitRange:   { min: number, max: number },
  expectedLifecycleDays: { min: number, max: number },
  structuralNode:        boolean (true for accounts, directories, ongoing branches),
  autoClassification:    boolean (true = system infers profile from commit topology)
}
```

A healthcare template expects clinical encounter filaments to be Transaction-profile (5–15 commits over days). A manufacturing template expects production batch filaments to be Project-profile (dozens of commits over weeks). If actual commit topology deviates significantly from the expected profile, the confidence calculation adjusts — unusually short batches or unusually long posts trigger fog.

### 78.8 Evidence Renewal Cadence — Physical Asset Confidence Decay

> *"The tree does not judge the filament. It renders the filament's truth and lets the humans judge."* — Relay

A building that existed last year probably exists this year. But "probably" is not "certainly." In Relay, all long-lived physical assets — buildings, machines, vehicles, infrastructure, land parcels — fade in confidence over time unless evidence of continued existence is renewed. This is not a penalty. It is the honest rendering of uncertainty: the longer since anyone verified something, the less certain we are.

**Global default renewal cycle**: 1 year. This is a global parameter (§11) on the global options list of parameters voted to be on the list (§72). The community decides what the baseline renewal expectation is for physical assets. Starting value: 12 months. If no renewal evidence is posted within the cycle, the asset filament begins to fog.

**Regional and organizational overrides**: A company can set stricter cycles — quarterly audits, monthly inspections. A company can also set looser cycles — 1.5 years, 2 years. Both are permitted. The deviation from the global model is visible, not blocked:

- A company posting quarterly evidence has crisp, firm asset branches — high confidence, no fog
- A company posting evidence every 3 years has slightly foggy asset branches — lower confidence, visible uncertainty
- Neither is "wrong." Both are modeling choices. The tree shows the consequence, not a judgment.

**How this actually works in practice**:

- Auditors follow the global minimum at least. If the global parameter is 1 year, external audit filaments should appear at least annually on any asset tree operating under global rules.
- If a company decides to post evidence only from year 1 to year 3 and no auditors arrived in between — that is the company's choice. Their asset branches will fog proportionally to the evidence gap. When the year 3 evidence arrives, confidence restores.
- Over time, the global community observes which renewal cadences produce the healthiest trees. If most buildings still exist after 3 years without proof, communities may vote to relax the global parameter. If they don't, stricter stays. The parameter settles organically.

**The foundational rule — no auto-correction**:

Relay never auto-corrects anything. It only notifies humans. When an asset's confidence drops below the fog threshold, Relay does not:
- Delete the asset
- Downgrade the asset's status
- Block transactions involving the asset
- Override the owner's model

Relay does:
- Render the fog (the visual uncertainty signal)
- Emit notification filaments to responsible parties
- Allow other users to see the fog and make their own decisions

Whether the notification is acted upon, or flagged as noise and dropped into the archive as a twig, is entirely up to the humans in that region. Some regions will respond aggressively to fog. Others will tolerate more uncertainty. Both are valid governance outcomes under the fractal majority model: global majority sets the floor, regional majority adjusts within their scope, organizational trees adjust within theirs, all the way down.

**This means**: A factory in Germany with quarterly audits looks different from a factory in a region with annual audits. Neither is penalized. The German factory has clearer branches. The other has slight fog. A buyer comparing suppliers sees the difference in branch clarity. The tree makes the case. Relay never pushes.

**Contract #185 — Filament length along the L-axis emerges from commit topology (commit count, lifecycle span, structural weight), not from manual declaration. Five emergent profile classes (micro, transaction, project, structural, continuous) describe the natural geometry of different event types. Structural nodes (balance sheet accounts, directories, ongoing branches) are commit aggregators that never close and define branch geometry. Finite filaments have discrete lifecycles and migrate inward over time. Length inflation without substantive evidence produces fog, wilt, and scar markers. The system rewards substance over volume. Physical assets decay in confidence without periodic evidence renewal; the global default renewal cycle (starting at 1 year) is a votable global parameter. Organizations may set stricter or looser cycles — deviation is visible as branch clarity, never blocked. Relay never auto-corrects. It renders fog, emits notifications, and lets humans decide. Whether a notification is acted upon or archived as noise is a governance outcome at each fractal level.**

---

## 79. Quote Attribution & Open Annotation — Frozen Contract #186

> *"If I have seen further, it is by standing on the shoulders of giants."* — Isaac Newton

**Prerequisites:** §4 (filaments), §5 (notes), §7 (social layer), §8 (user tree), §8.6 (presence profiles), §11 (parametric governance), §20 (cryptographic architecture), §32 (stable IDs).

Everything in Relay is a filament. A quote is a filament. An annotation is a filament. A vote on a single word in someone else's post is a filament. This section formalizes how open annotation, attribution, and deferred identity linking work — enabling anyone to credit anyone, annotate anything, and claim their contributions retroactively.

### 79.1 Posts Are Open by Default

When a user commits a filament (a post, a comment, a claim, a report), the filament exists on its branch with all standard physics. But the user controls an **annotation permission** setting:

```
AnnotationPermission {
  filamentRef:       filamentRef,
  allowAnnotations:  boolean (default: true),
  allowWordVotes:    boolean (default: true),
  allowSuggestions:  boolean (default: true),
  lockEditing:       boolean (default: false — only the owner can toggle this)
}
```

By default, posts are open. Anyone can annotate, vote on individual words, or suggest changes. The owner can lock editing at any time — this freezes the filament content but does not prevent new annotation filaments from attaching to it.

### 79.2 Word-Level Voting

Any user can vote on any word, sentence, or passage within any open filament. The vote is itself a filament — a micro-filament (§78.2) with 1–3 commits:

```
WordVoteFilament {
  voteId:         string,
  targetFilament: filamentRef,
  targetRange:    { startOffset: number, endOffset: number },
  voteType:       "agree" | "disagree" | "clarify" | "cite" | "flag",
  weight:         number (voter's engagement weight),
  comment:        string (optional — if present, this vote becomes a conversation starter),
  commitId:       string
}
```

When someone votes on a word, they are placing a note on that filament. If they add a comment, they have started a new conversation — a new filament branching from that point. The conversation grows its own branch, linked to the exact character range that spawned it. This is how marginalia, footnotes, and peer review emerge naturally from filament physics.

### 79.3 Suggestions and Version Growth

When another user suggests a change to the original filament, the suggestion is a linked filament:

```
SuggestionFilament {
  suggestionId:     string,
  targetFilament:   filamentRef,
  targetRange:      { startOffset: number, endOffset: number },
  suggestedText:    string,
  rationale:        string,
  suggestorId:      userId,
  status:           "PROPOSED" | "ACCEPTED" | "REJECTED",
  commitId:         string
}
```

If the original author accepts the suggestion, they add a new commit to their filament — the filament grows longer (§78), showing the version changed in response to external input. The suggestion filament's status updates to ACCEPTED and links to the new commit. The original author's filament now has a visible history: the original text, the suggestion, and the revised text — all auditable, all in sequence.

Rejected suggestions remain as filaments — visible as conversation history, never deleted.

### 79.4 Attribution to Unknown Users — Deferred Identity Linking

A critical feature: you can attribute a quote, idea, or contribution to someone whose Relay identity you do not know. The mechanism:

1. **Placeholder attribution**: The author includes `@whoever` or a descriptive tag (`@the-barista-who-said-this`, `@my-grandmother`) in their filament. This creates an `UnresolvedAttribution` record:

```
UnresolvedAttribution {
  attributionId:    string,
  sourceFilament:   filamentRef,
  placeholderTag:   string ("@the-barista-who-said-this"),
  createdBy:        userId,
  resolvedTo:       userId | null,
  resolvedAt:       timestamp | null,
  resolutionProof:  filamentRef | null (link to the confirmation exchange)
}
```

2. **Discovery**: The real person eventually discovers the attribution — through search, through a friend, through browsing the branch where it lives.

3. **Claim process**: The real person contacts the filament owner through standard Relay channels (notes, proximity, shared branch). The owner verifies identity through conversation.

4. **Resolution**: The owner grants access. The `@whoever` placeholder resolves to the real user's ID. The attribution filament updates with a new commit linking the placeholder to the confirmed user tree. All past references to `@whoever` in this context now point to the real user.

5. **Immutability**: The original placeholder commit remains in history. The resolution commit is appended. The full provenance chain — from anonymous attribution to confirmed identity — is auditable.

### 79.5 Owner Control — Lock and Grant

The filament owner maintains sovereign control:

- **Lock editing**: The owner can lock their filament at any time. After locking, the content is frozen — only annotation filaments can attach, no inline changes.
- **Grant attribution access**: The owner explicitly grants linking rights to the claimed user. No one can self-attribute without the owner's consent.
- **Revoke**: If an attribution was granted in error, the owner can scar the resolution (append a correction commit). The scar is visible — revocations are never silent.

### 79.6 How Quotes Work in the Tree

A quote attributed to another person is a filament with:
- The quoted text as content
- An `attribution` field pointing to either a resolved userId or an `UnresolvedAttribution`
- The quoter's own userId as the filament author (they are not claiming to BE the person — they are recording that the person said it)
- Evidence references if available (recording, document, witness)

Over time, the most cited quotes from a user accumulate as inbound annotation filaments on public branches. A user's tree shows, through natural geometry, how many other trees reference their words. Thick inbound connections = widely cited. Thin connections = niche. The tree shape IS the citation index.

### 79.7 Tribute Through Geometry

When this document quotes Butters Stotch, Benjamin Franklin, Rachel Carson, or Bruce Lee, it is doing exactly what Relay formalizes: attributing an idea to its source, making the link visible, and letting anyone follow the chain. In Relay, every quote from every user — famous or anonymous — lives as a filament with a provenance chain. The barista who says something profound at 6 AM deserves the same attribution physics as Einstein. The tree does not care about fame. It cares about links.

**Contract #186 — Every filament supports open annotation by default. Word-level voting creates micro-filaments linked to character ranges. Suggestions are linked filaments that, when accepted, cause the original to grow with a new commit. Attribution to unknown users is handled through placeholder tags (`@whoever`) with a deferred resolution protocol: the real user claims the attribution, the owner confirms, and the placeholder resolves to a verified userId. The original placeholder commit remains in history; resolution is appended. Owners control annotation permissions and attribution grants. Quote provenance chains are auditable. The tree shape is the citation index.**

---

## 80. Genesis Record — Founder Initiation & Development Archive — Frozen Contract #187

> *"In the beginning was the Word, and the Word was with God, and the Word was God."* — John 1:1
>
> *"Every tree was once a seed that decided to reach."* — Relay

**Prerequisites:** §44 (Founder Key), §8 (User Tree), §21 (Templates), §37 (Knowledge Migration), §70 (V93 Retained Systems), §48 (Engineering Infrastructure).

Relay itself is a tree. Before any user signs up, before the globe renders its first frame, before the first SCV awakens — the entire history of how Relay was designed, argued, revised, and built must exist as the first filament tree in the system. This section defines the genesis record: the founder's first commit, the conversion of development artifacts into tree structure, the initial parameter state, and the mechanics of SCV pressure management that will guide the system from birth.

### 80.1 The Relay HQ Tree — Tree Zero

The very first tree in Relay is `tree.org.relay-hq` — the Relay headquarters tree. This tree contains the full development history of the system itself:

| Branch | Service Path | Content |
|--------|-------------|---------|
| **Architecture** | `dev.architecture` | The Master Build Plan, Civilization Template Library, and all architectural documents — each version as a filament commit |
| **Conversations** | `dev.conversations` | Every design conversation (Cursor agent chats, architect reviews, user discussions) — each session as a filament with the full transcript as evidence attachment |
| **Codebase** | `dev.codebase` | The source code — every git commit maps to a filament commit. Branches in git map to branches on the tree. Pull requests map to merge filaments |
| **Media Archive** | `dev.media` | Videos, audio files, screen recordings, extracted conversation transcripts — each as a filament with the media file as evidence attachment |
| **Decisions** | `dev.decisions` | Major architectural decisions extracted as individual filaments, with evidence twigs linking to the conversations where they were made |
| **Governance** | `gov.parameters` | Initial global parameter values, founder lever settings, frozen contract registry |

### 80.2 The Founder's First Commit — Genesis Commit

The founder account (Eitan Asulin) creates the **genesis commit** — the first filament ever committed in Relay. This commit:

1. **Creates `tree.org.relay-hq`** with the branch structure above
2. **Creates `tree.person.eitan-asulin`** — the founder's personal user tree
3. **Cross-links both trees** — the founder is the owner and initial sole contributor of the Relay HQ tree. A filament on the founder's `roles` branch records the relationship.
4. **Commits the Master Build Plan** as the first filament on `dev.architecture` — the hash-anchored, Merkle-sealed architectural specification. Every subsequent version is an additional commit on the same filament (version growth, §78).
5. **Commits the full development archive** — all Cursor conversations, v93 backup artifacts, design videos, audio recordings, extracted transcripts — as filaments on their respective branches. Each artifact's original creation timestamp is preserved as the filament's `occurredAt` field; the commit timestamp reflects the moment it was imported into Relay.
6. **Applies Revelation Tier encryption** — every imported artifact is classified RT-0 through RT-4 (§89.1) using the AI Curation Tool (§89.5) and encrypted per tier. RT-0 content is publicly readable from genesis. RT-1 through RT-4 content lives on sealed branches — branch geometry visible, filament content encrypted. Decryption keys release via achievement milestones (§89.3). The classification itself is a committed filament on the governance branch.
7. **Sets initial disclosure tier** — the genesis development archive starts at Tier 0 (private). The founder controls who sees it. He can raise the tier to Tier 1 (shapes visible) or Tier 2 (fully public) at any time. The decision to make the genesis archive public is the founder's alone.

### 80.3 How 2D Files Convert to 3D Tree Structure

**Companion document:** [RELAY-DEVELOPMENT-TREE-MAP.md](RELAY-DEVELOPMENT-TREE-MAP.md) contains the exhaustive file-by-file mapping, the full 3D tree visualization of Tree Zero, and the evolution pipeline showing how camera detection → pet translation → spell detection are one filament lineage.

Every file that exists in the current Cursor workspace and git repository has a natural mapping to Relay's tree:

| 2D Artifact | 3D Tree Equivalent |
|-------------|-------------------|
| `.md` document | Filament on `dev.architecture` or `dev.decisions` — document content as the filament body, each edit as a commit |
| `.json` config | Filament on `dev.codebase` — schema as left block, data as right block |
| `.ts` / `.js` source | Filament on `dev.codebase` — source as body. Git blame history → commit chain on the filament |
| Git commit | Filament commit — the git hash becomes an evidence reference linked to the Relay commit |
| Git branch | Tree branch — `feature/xyz` in git → a branch on the Relay HQ tree |
| Git tag | Slab boundary marker — tags like `RELAY-PRE-CLEAN-ARCHIVE-V93` become timebox epoch seals |
| Cursor conversation | Filament on `dev.conversations` — the full transcript as evidence attachment, key decisions extracted as separate linked filaments on `dev.decisions` |
| Video / audio file | Filament on `dev.media` — the media as evidence attachment. Frame-level detail available per §59.4 (media as L-axis cells) |
| Screenshot / image | Evidence attachment on the filament it documents |

The import process is deterministic: given the same git repository and conversation archive, the same tree structure is produced. This is the **knowledge migration** (§37) applied to Relay's own history.

### 80.4 The Archive Lives in the Roots

Once imported, the oldest development artifacts sink into the root archive (§1.4) following standard gravitational physics. The earliest design conversations from the v93 era become the deepest roots of the Relay HQ tree. The Master Build Plan's first draft is heartwood. Recent development work is living bark.

Anyone the founder provides access to can drill down into the roots and trace how every decision was made — from the first sticky note idea through every architect review, every user conversation, every code commit, all the way to the living system. The provenance chain is complete. Nothing is invented retroactively. The genesis history is append-only and Merkle-sealed from the moment it is committed.

If made public, any Relay user can explore the full development history of the platform they are using. This is Relay eating its own cooking — the same transparency and traceability the system demands of every organization, applied to itself from birth.

### 80.5 Founder Initial Parameter State — Day-1 Settings

The genesis commit includes the **Initial Parameter Commit** — a signed filament on `gov.parameters` recording every Category A parameter's starting value (§11.6). These values become immediately votable by the community after the first users join.

**Critical initial values set by the founder:**

| Parameter | Initial Value | Rationale |
|-----------|--------------|-----------|
| Global transaction commission rate | 0% | No platform extraction at birth. Community votes it up when infrastructure costs require it. |
| Regional tax allocation rate | 0% | No regional taxation at birth. Regions vote their own rates when civic services are funded through Relay. |
| Per-session service tax rate | 0% | No session-level taxation at birth. Emergent as commerce scales. |
| Civic Allocation Contribution (CAC) | 0% | No civic extraction at birth. Communities vote allocation rates when civic response services (§74) are operational. |
| Storage pricing base rate | Cost-recovery only | Initial storage economy (§66.5) priced at infrastructure cost, not profit. |
| All other Category A parameters | Values per §11.6 table | Sleep cycles, spam thresholds, vote decay, presence time-buckets — all as specified in the existing parameter registry. |

**Why 0% across the board:** Relay does not extract value from users at birth. The founder sets all extraction rates to zero. The community decides, through parametric voting (§11), when and how much value flows to platform operations, civic services, and regional governance. This is the structural guarantee that Relay starts as a public good and only becomes revenue-generating through democratic consent.

### 80.6 2D Traffic Monitoring — Mapping Legacy Network Pressure to Tree Geometry

Before Relay's 3D world is populated, the system can already observe the 2D internet. Existing network traffic — website visits, API calls, social media engagement, financial transactions — represents fragmented pressure flowing through disconnected pipes. Relay maps this pressure to tree geometry:

**How it works:**

1. **Traffic ingestion**: Relay's SCV layer (§16) monitors opted-in network feeds — public APIs, partner data streams, RSS feeds, social platform exports, financial market feeds. No surveillance; only voluntarily shared or publicly available data.
2. **Pressure mapping**: Each data source becomes a branch on a system-level observation tree. Traffic volume → branch thickness. Traffic volatility → branch heat. Traffic direction (source → destination patterns) → branch lean. Traffic reliability → confidence (evidence-backed data is firm; unverified is foggy).
3. **Fragmentation rendering**: The current 2D internet shows up as a fragmented, disconnected set of branches — no cross-tree links, no mass balance, no counterparty verification. The visual result is a forest of isolated, leaning, foggy branches. This IS the honest rendering of the current state of digital infrastructure.
4. **Correction by adoption**: As organizations and users adopt Relay, their branches gain cross-tree links, counterparty attestations, evidence backing, and mass balance. The fragmented branches become connected. The fog clears. The lean balances. The visual transformation from fragmented 2D to interconnected 3D IS the adoption story.

### 80.7 SCV Pressure Management — State Correction at Birth

SCVs (§16) are active from the moment Tree Zero exists. Their first job is managing the pressure state of the genesis tree itself:

**SCV roles at genesis:**

| SCV Instance | Scope | Function |
|-------------|-------|----------|
| `SCV: Architecture Coherence` | `dev.architecture` | Validates that the Master Plan's internal cross-references are consistent, detects contradictions, flags unresolved TODOs |
| `SCV: Code Coherence` | `dev.codebase` | Validates that code implements what the architecture specifies, flags drift between spec and implementation |
| `SCV: Evidence Completeness` | All branches | Checks that every filament claiming evidence actually has the evidence attached and hash-anchored |
| `SCV: Pressure Balance` | All branches | Monitors lean, heat, thickness, and fog across the entire tree — flags structural imbalances to the founder |
| `SCV: Parameter Governance` | `gov.parameters` | Monitors parameter drift, validates that initial values match the founder's intent, flags when community voting begins |

**Pressure correction protocol:**

SCVs do not correct state. They propose corrections (frozen contract — §16.4). The correction workflow:

1. **Detection**: SCV detects pressure anomaly (branch leaning beyond threshold, filament fogging without cause, mass imbalance, evidence gap)
2. **Proposal**: SCV generates a lavender projection branch (§24) showing the proposed correction — what commits would fix the imbalance, what evidence is needed, what parameters should be adjusted
3. **Founder review**: At genesis, only the founder reviews SCV proposals. As the team grows, responsibility distributes fractally (§60)
4. **Commit or dismiss**: The founder commits the correction (which becomes a human commit on the truth branch) or dismisses the proposal (which archives the SCV projection as a twig)
5. **Learning**: SCV proposals that are consistently dismissed in a category cause the SCV to recalibrate its threshold for that anomaly type. Proposals that are consistently accepted reinforce the detection pattern.

### 80.8 The Genesis Sequence — Step by Step

The complete founder initiation sequence:

```
GENESIS SEQUENCE:

1. FOUNDER ACCOUNT CREATION
   → Eitan Asulin creates the founder account
   → Biometric password dance registered (§70.5)
   → Guardian contacts designated (§48.2.2)
   → Account is the ONLY account in the system

2. TREE ZERO CREATION
   → tree.org.relay-hq instantiated with dev.* and gov.* branches
   → tree.person.eitan-asulin instantiated with standard user tree branches (§8)
   → Cross-tree link: founder → Relay HQ owner

3. ARCHIVE IMPORT
   → Git repository history → dev.codebase (every commit becomes a filament commit)
   → Cursor conversations → dev.conversations (each session as a filament)
   → Master Build Plan → dev.architecture (versioned filament)
   → Media files (videos, audio, screenshots) → dev.media
   → V93 backup archive → dev.archive (preserved as root-depth historical filaments)
   → All timestamps preserved. All hashes anchored. Genesis Merkle root computed.

4. PARAMETER INITIALIZATION
   → All Category A parameters set to initial values (§11.6 table)
   → All tax/commission/CAC rates set to 0%
   → All Category B founder levers set to INACTIVE
   → Initial parameter commit signed and Merkle-sealed

5. SCV ACTIVATION
   → Architecture Coherence SCV instantiated on dev.architecture
   → Code Coherence SCV instantiated on dev.codebase
   → Evidence Completeness SCV scans all imported filaments
   → Pressure Balance SCV establishes baseline lean/heat/fog readings
   → Parameter Governance SCV monitors initial parameter state

6. DISCLOSURE CONFIGURATION
   → Relay HQ tree default: Tier 0 (private)
   → Founder sets initial disclosure per branch:
      dev.architecture → Tier 2 (public, the plan is transparent)
      dev.conversations → Tier 0 (private, raised when founder decides)
      dev.codebase → Tier 1 (shapes visible, code visible at founder's discretion)
      dev.media → Tier 0 (private)
      gov.parameters → Tier 2 (public, all parameters are always transparent)

7. GENESIS SEAL
   → All imported data Merkle-sealed
   → Genesis root hash computed and recorded
   → The hash IS the birth certificate of Relay
   → First timebox epoch closes. First slab rendered. Tree Zero exists.

8. FIRST INVITATION
   → Founder invites the first user (the invite tree begins)
   → The invite creates the first cross-tree social link
   → The system is live
```

### 80.9 What the Founder Controls After Genesis

After the genesis sequence, the founder:

- **Can** raise disclosure tiers on any Relay HQ branch (making more history public)
- **Can** invite additional users and contributors
- **Can** commit new architectural decisions, code, media, and conversations
- **Can** turn the game layer founder key when thresholds are met (§44)
- **Can** append new items to the spell/card/treasure registry (§44.3)
- **Cannot** modify frozen contracts (ever)
- **Cannot** override governance votes (ever)
- **Cannot** lower disclosure tiers below the level at which data was first committed
- **Cannot** delete or alter any genesis import (append-only)
- **Cannot** set extraction rates unilaterally (all rates start at 0% and require community votes to change)

The founder runs the Relay HQ tree the way any organizational owner runs their tree — with full internal visibility, responsibility for its health, and the same physics as everyone else. The founder's tree is not special. It is the first tree. Every tree after it follows the same rules.

**Contract #187 — The Relay HQ tree (`tree.org.relay-hq`) is the first tree in the system, created by the founder's genesis commit. All development artifacts (architecture documents, conversations, code, media, decisions) are imported as filaments with original timestamps preserved and Merkle-sealed. The genesis commit sets all extraction rates (transaction commission, regional tax, session tax, CAC) to 0% — the community votes these up through parametric governance. SCVs activate at genesis to monitor architecture coherence, code coherence, evidence completeness, pressure balance, and parameter governance. The archive lives in the roots, accessible to anyone the founder grants access to. The genesis root hash is the birth certificate of Relay. The founder controls the Relay HQ tree under the same physics as every other tree owner — no special privileges beyond the founder key (§44).**

---

## 81. Operational Hardening — Frozen Contracts #188–196

> *"In theory, theory and practice are the same. In practice, they are not."* — attributed to Yogi Berra

**Prerequisites:** All prior sections. This section addresses operational gaps identified through adversarial review: governance friction, offline behavior, rendering safety, adoption ergonomics, and structural enforcement. Each subsection is a binding contract that prevents specific failure modes at scale.

### 81.1 Structural vs Finite Filament Enforcement — Contract #188

Every filament in Relay is one of exactly two kinds:

| Kind | Behavior | Lifecycle | Examples |
|------|----------|-----------|----------|
| **Finite** | Spawns → migrates inward → ABSORBED → heartwood | Terminates. Has a natural end. Sinks when resolved. | Invoice, lab test, legal case, PO, course assignment, duel |
| **Structural** | Persists as underlying branch geometry. Never closes. | Ongoing. Aggregates commits indefinitely. Defines the branch shape. | Balance sheet account, department branch, curriculum branch, directory, language tree |

The base filament schema gains a required field:

```
filamentKind: "finite" | "structural"
```

**Engine-level enforcement:**
- Finite filaments MUST transition through the lifecycle: SCHEDULED → OPEN → ACTIVE → HOLD → CLOSED → ABSORBED. They cannot remain OPEN indefinitely without generating twigs (§5).
- Structural filaments NEVER enter CLOSED or ABSORBED. They accumulate commits that define the branch's geometric properties (thickness, lean, heat). Attempting to close a structural filament emits `[REFUSAL] reason=STRUCTURAL_FILAMENT_CANNOT_CLOSE`.
- Templates (§21) declare each filament type's kind. If a template marks `CLINICAL_EVENT` as finite and `BALANCE_SHEET_ACCOUNT` as structural, the engine enforces the behavioral distinction at commit time.
- `FilamentProfileConfig` (§78) auto-classification must respect the kind field: structural filaments are always `structuralNode: true`.

**Contract #188 — Every filament has a `filamentKind` of "finite" or "structural." Finite filaments lifecycle inward toward heartwood. Structural filaments persist as branch geometry and never close. The engine enforces this distinction at commit time. Templates declare filament kind per object type. Mismatched lifecycle transitions are refused.**

#### 81.1.1 Structural Filament Compression — Heartwood Ring-Summarization — Contract #294

Contract #188 says structural filaments never close. Without compression, "never closes" becomes "never compresses," which becomes unbounded storage growth on every structural branch. A balance sheet account that runs for 40 years with daily commits generates ~14,600 timebox slabs of individual-level commit data. That data must remain auditable but it cannot remain at full fidelity in the active rendering pipeline indefinitely.

**The heartwood compression model:**

Structural filaments compress exactly the way real trees form heartwood — the inner rings become dense, structurally critical, but no longer carry active sap or individual cell detail.

```
HeartwooodRingSummary {
  filamentId:         filamentRef (the structural filament being compressed)
  ringSpan:           { startTimebox: slabRef, endTimebox: slabRef }
  commitCount:        number (total commits in span)
  aggregateMagnitude: number (sum/avg/min/max per template config)
  aggregateConfidence: number (weighted average)
  counterpartySummary: [{ counterpartyRef, commitCount, netMagnitude }] // top N
  merkleRoot:         sha256 (Merkle root of all individual commits in span)
  compressionLevel:   "ANNUAL" | "QUARTERLY" | "MONTHLY"
  individualCommitsArchived: boolean (true = moved to cold storage, hash-addressable)
}
```

**Compression schedule:**

| Age of Timebox Span | Compression Level | What Remains in Active Pipeline | What Moves to Archive |
|---------------------|-------------------|-------------------------------|----------------------|
| < 1 year | NONE | All individual commits, full fidelity | Nothing |
| 1–5 years | MONTHLY | Monthly ring summaries + Merkle roots | Individual commits (hash-retrievable) |
| 5–20 years | QUARTERLY | Quarterly ring summaries + Merkle roots | Monthly summaries + individual commits |
| > 20 years | ANNUAL | Annual ring summaries + Merkle roots | Everything below annual level |

**Invariants:**

1. **No data is deleted.** Compression moves individual commits from the active rendering pipeline to cold archive storage. Every commit remains hash-addressable and retrievable. The Merkle root in the ring summary proves the archive's integrity.

2. **Ring summaries are committed filaments.** Each `HeartwoodRingSummary` is itself a committed filament on the structural branch. It is auditable, immutable, and participates in the branch's geometry (contributes to inner-ring thickness and density).

3. **Drill-through on demand.** When a user zooms to CELL LOD on a compressed ring, the system fetches individual commits from cold archive, decompresses them into the rendering pipeline, and displays them at full fidelity. The ring summary's `merkleRoot` validates integrity upon retrieval.

4. **Compression is deterministic.** Given the same input commits and the same compression schedule, the same `HeartwoodRingSummary` is produced. No hidden inputs, no probabilistic aggregation.

5. **Compression schedule is Category A.** The age thresholds and compression levels are community-governed parameters. The existence of the compression mechanism and its invariants are frozen.

**Visual rendering:** Compressed rings render as denser, darker inner wood — visually indistinguishable from real heartwood. The deeper you go, the more compressed the rings, the darker and denser the texture. This is already correct per §82.8 (Reality as Interface) — heartwood in real trees IS compressed dead cells that form the structural core.

**Contract #294 — Structural Filament Compression. Structural filaments that never close compress their commit history into HeartwoodRingSummary filaments on an age-based schedule: monthly after 1 year, quarterly after 5, annual after 20. No data is deleted — individual commits move to cold archive with Merkle root verification. Ring summaries are committed filaments that contribute to inner-ring geometry. Drill-through retrieves full fidelity on demand. Compression is deterministic. The schedule thresholds are Category A parameters. The compression mechanism is frozen.**

### 81.2 Basin Visibility Normalization — Contract #189

At regional LOD, multiple trees share the same visual basin. Without normalization, a multinational corporation's tree visually dominates a local clinic's tree purely through absolute magnitude — even though both are equally important within their own scope.

**The rule:**

```
visibleScale = log(1 + magnitude) / log(1 + basinMaxMagnitude)
```

This produces **relational geometry, not imperial geometry.** A clinic with $500K annual revenue and a corporation with $50B annual revenue both appear as meaningful trees within the same basin — the corporation is larger, but not 100,000x larger. The logarithmic compression preserves the ratio while keeping small entities visible.

**Basin normalization applies at:**
- REGION LOD: trees within the same geographic basin
- CITY LOD: trees within the same municipal boundary
- COMPANY LOD: branches within the same organizational tree

**Does NOT apply at:**
- BRANCH LOD and below: individual filaments render at actual magnitude within their branch context
- GLOBE LOD: trunk prominence follows the existing attention-weighted aggregation (§33)

**Contract #189 — Basin visibility normalization uses logarithmic compression (`log(1 + magnitude) / log(1 + basinMaxMagnitude)`) at REGION and CITY LOD to prevent large entities from visually dominating small ones. Relational geometry, not imperial. Does not apply below BRANCH LOD where actual magnitude governs rendering.**

### 81.3 The Silence Stability Doctrine — Formalized — Contract #190

> *"The best government is that which governs least."* — Henry David Thoreau

Parameters that nobody is actively voting on should be hard to change. The current system allows a small burst of votes to shift a long-dormant parameter because the weighted-median is continuous and inactive voters express nothing. The Silence Stability Doctrine treats prolonged consensus — including the consensus of inaction — as a structural asset that requires proportional effort to disturb.

#### 81.3.1 The State Machine

Every Category A parameter has a stability state that progresses through four phases:

```
ACTIVE ──(N epochs, no votes)──► QUIET ──(N more epochs)──► STABLE ──(2N more epochs)──► SEALED
   ▲                                 │                          │                           │
   │                                 │                          │                           │
   └──────(any vote cast)────────────┴──────(any vote cast)─────┴───────(any vote cast)─────┘
                                     reactivation               reactivation                reactivation
```

| State | Entry Condition | Change Threshold | Rate-of-Change Cap | Visual |
|-------|----------------|-----------------|-------------------|--------|
| **ACTIVE** | Any vote in last N epochs | Simple weighted median (default) | 20% max shift per epoch | Normal parameter filament |
| **QUIET** | No votes for N consecutive epochs (default: 12) | **65% supermajority** | 15% max shift per epoch | Faint amber stability ring |
| **STABLE** | No votes for 2N consecutive epochs (default: 24) | **80% supermajority** | 10% max shift per epoch | Firm golden stability seal |
| **SEALED** | No votes for 4N consecutive epochs (default: 48) | **90% supermajority** | 5% max shift per epoch | Thick crystalline seal with visible age rings |

#### 81.3.2 The Inertia Equation

The stability weight of a parameter increases with silence duration:

```
stabilityWeight(P, t) = min(1.0, silentEpochs(P, t) / (4 × N))
```

The effective change threshold scales with stability weight:

```
effectiveThreshold(P, t) = baseThreshold + (stabilityWeight(P, t) × (maxThreshold − baseThreshold))

where:
  baseThreshold  = 0.50  (simple majority — the default for active parameters)
  maxThreshold   = 0.90  (the sealed state ceiling — Category A, frozen floor: 0.80)
  N              = 12 epochs (the silence window — Category A)
```

The effective rate-of-change cap:

```
effectiveRateCap(P, t) = baseCap × (1 − 0.75 × stabilityWeight(P, t))

where:
  baseCap = 0.20 (20% max change per epoch for active parameters)
```

At maximum stability (sealed, stabilityWeight = 1.0): threshold = 90%, rate cap = 5% per epoch. This means a sealed parameter requires overwhelming consensus AND can only shift by 5% per epoch even if that consensus exists — preventing shock changes.

#### 81.3.3 Reactivation Protocol

When a vote is cast on a parameter in any stability state:

1. **Notification cascade:** A notification filament fires on all eligible voters' attention branches: "Parameter P is being reconsidered after [silentEpochs] epochs of stability."
2. **Graceful thaw:** The elevated threshold does NOT immediately drop. It decays linearly over a reactivation window:

```
reactivationDecay(P, t) = max(baseThreshold, effectiveThreshold(P, t_vote) × (1 − (t − t_vote) / reactivationWindow))

where:
  t_vote              = epoch when first reactivation vote was cast
  reactivationWindow  = 3 epochs (Category A parameter — default, min 1 epoch frozen floor)
```

This 3-epoch thaw window forces deliberation. A flash-mob vote on a stable parameter faces the elevated threshold for 3 full epochs before thresholds normalize — enough time for the notification to reach all eligible voters and for legitimate opposition to form.

3. **Counter reset:** After the reactivation window expires, the stability counter resets to zero. The parameter returns to ACTIVE state. The next silence period starts fresh.

#### 81.3.4 Interaction with Other Governance Primitives

| Primitive | Interaction with Silence Stability |
|-----------|-----------------------------------|
| **Cooling Windows (§19.5)** | Cooling windows and stability thresholds stack independently. A stable parameter that receives a POLICY_CHANGE vote faces BOTH the elevated stability threshold AND the cooling window delay. |
| **Oblivion Classifications (§72.12)** | OblivionMarker parameters (gravity multiplier, detection confidence) follow the same stability doctrine. A long-standing classification becomes progressively harder to modify — which is correct: civilizational consensus deepens with silence. |
| **Minority Alarm (§81.7)** | A 15% minority alarm on a stable parameter triggers the alarm AND the stability threshold applies. The sortition jury's advisory opinion carries additional weight when the parameter has been sealed. |
| **Frozen Contracts** | Frozen contracts are exempt — they are not parameters and cannot be voted on at all. Silence stability applies only to Category A votable parameters. |
| **Filter Tolerances (§12)** | Personal filter settings are client-side state and do not participate in stability tracking. Only globally-scoped governance parameters have stability states. |

#### 81.3.5 Edge Cases

**Mass reactivation attack:** An adversary coordinates hundreds of accounts to vote simultaneously on a sealed parameter. Defense: the 90% supermajority threshold at sealed state makes this extremely expensive (requires 90% of eligible voters). The 3-epoch reactivation window gives time for organic opposition. The notification cascade alerts all eligible voters. The Sybil defense stack (§84) detects coordinated voting clusters.

**Legitimate urgent change on a sealed parameter:** A sealed parameter genuinely needs urgent adjustment (e.g., spam threshold is sealed at a value that allows a new attack vector). Defense: the change CAN happen — it just requires 90% consensus and takes 3 epochs to normalize. For true emergencies, the emergency dispatch mechanism (§74) bypasses governance entirely but requires post-hoc sortition review. The system is deliberately slow for consequential changes — urgency does not override deliberation (§0.5, Edge #3).

**Oscillation attack:** An adversary casts a single vote to break stability, waits for reactivation to expire, then lets the parameter re-stabilize, repeating to keep it in perpetual ACTIVE state. Defense: each reactivation resets the counter but also produces a visible reactivation filament. A pattern of repeated reactivation-without-change is itself a detectable anomaly — the immune trigger (§83.5) can be configured to fire on governance oscillation patterns.

#### 81.3.6 Rendering

The stability state renders on the parameter's governance filament:

- **ACTIVE**: Normal filament rendering. No special visual.
- **QUIET**: A faint amber ring appears around the parameter filament — like the first layer of bark hardening.
- **STABLE**: A firm golden seal wraps the filament. Cross-section shows a thick, dense ring. The parameter looks "settled."
- **SEALED**: A crystalline encasement with visible age rings — one ring per N-epoch period. The seal is visually unmistakable. Breaking it (voting) produces a visible crack in the crystal — the reactivation event is rendered as a structural disruption.

The visual grammar communicates: "This has been quiet for a long time. Changing it should feel consequential."

**Contract #190 — The Silence Stability Doctrine. Every Category A parameter progresses through four stability states (ACTIVE → QUIET → STABLE → SEALED) based on consecutive epochs without votes. Change thresholds escalate from simple majority (ACTIVE) through 65% (QUIET), 80% (STABLE), to 90% (SEALED). Rate-of-change caps tighten proportionally from 20% to 5% per epoch. Stability weight is continuous: `stabilityWeight = min(1.0, silentEpochs / (4 × N))`. Reactivation on any vote triggers a notification cascade to all eligible voters and a 3-epoch graceful thaw window during which elevated thresholds decay linearly — preventing flash-mob hijacking while allowing legitimate reconsideration. Stability interacts with all governance primitives (cooling windows, oblivion classifications, minority alarm) additively. Rendering progresses from normal through amber ring, golden seal, to crystalline encasement with visible age rings. The silence window (N), maximum threshold (0.90, frozen floor 0.80), and reactivation window (3 epochs, frozen floor 1 epoch) are Category A parameters.**

### 81.4 Offline Conflict Merge Protocol — Contract #191

Append-only does not solve the case where two users edit the same filament offline and reconnect simultaneously. Relay does not use "last write wins" — that destroys evidence.

**The protocol:**

1. **Detection**: When a client reconnects and submits commits, the system checks whether the target filament has received commits from other sources since the client's last sync point. If yes → **fork detected**.

2. **Fork preservation**: Both commit chains survive. The filament splits into two parallel versions, each carrying its own commit chain. Neither is canonical. Both are visible on the bark surface as a **fork marker** — two filament ribbons emerging from a shared base.

3. **SCV notification**: The branch SCV detects the fork and creates a **mandatory resolution branch** — a child branch containing both versions side by side with a diff projection showing what changed.

4. **Human resolution**: The responsible party (filament owner, branch operator, or designated resolver per template) must commit a **resolution filament** that either:
   - Accepts version A (version B becomes an archived twig)
   - Accepts version B (version A becomes an archived twig)
   - Merges both into a new version C (both originals become evidence twigs on C)

5. **Unresolved forks wilt**: If no resolution is committed within the template-defined resolution window (default: 7 days), the fork marker wilts and generates governance heat.

```
OfflineForkEvent {
  forkId:           string,
  filamentRef:      filamentRef,
  branchA:          commitChain[] (client A's commits),
  branchB:          commitChain[] (client B's commits),
  lastCommonCommit: commitId,
  detectedAt:       timestamp,
  resolvedAt:       timestamp | null,
  resolution:       "ACCEPT_A" | "ACCEPT_B" | "MERGE" | null
}
```

**Contract #191 — When offline clients produce conflicting commits on the same filament, both commit chains survive as parallel versions (fork event). Neither is silently discarded. SCV creates a mandatory resolution branch. Human resolves by accepting one version or merging both. Unresolved forks wilt after the template-defined resolution window. No "last write wins."**

### 81.5 Lens Read-Only Invariant — Contract #192

Cross-section mode is explicitly read-only. But the same principle must apply universally to every analytic or visual layer that presents data without modifying it.

**Universal rule:**

Any rendering mode, overlay, or view marked `projectionType: "lens"` is structurally prohibited from:
- Producing TransferPackets
- Modifying filament lifecycle state
- Calling commit() on any branch
- Creating filaments (except annotation micro-filaments if the user explicitly initiates one)
- Modifying governance parameters

**Lens-classified views:**
- Cross-section inspection (§3.13)
- Time scrubbing / replay (§15)
- Weather overlays (§23, §75)
- Arena spectacle overlays (§68)
- Curriculum projections (§58)
- Meta-governance visualizations (§72)
- Live confidence overlay (§55)
- Supply chain provenance viewer (§77)
- 2D/headless parity views (§25)

**Engine enforcement:** The rendering pipeline checks `projectionType` before allowing any write operation. If a lens view attempts a write, it emits `[REFUSAL] reason=LENS_WRITE_PROHIBITED view=<viewId>`.

**Contract #192 — Any view classified as `projectionType: "lens"` is prohibited from producing TransferPackets, modifying lifecycle state, calling commit(), creating filaments (except explicit user-initiated annotations), or modifying governance parameters. Engine-enforced. Lens views are read-only by constitutional rule, not by convention.**

### 81.6 Template Version Fork Reconciliation — Contract #193

Templates evolve through community governance (§72). When a region upgrades from `template.health.v1` to `template.health.v2`, cross-tree links between regions using different versions must remain functional.

**The protocol:**

```
TemplateVersionBridge {
  sourceTemplate:    templateRef (e.g., "template.health.v1"),
  targetTemplate:    templateRef (e.g., "template.health.v2"),
  fieldMappings: [
    { sourceField: string, targetField: string, transform: "identity" | "rename" | "split" | "merge" | "deprecated" }
  ],
  compatibility:     "full" | "partial" | "incompatible",
  bridgeDirection:   "bidirectional" | "forward-only"
}
```

**Rules:**
- **Full compatibility**: All fields map 1:1. Cross-tree links render normally.
- **Partial compatibility**: Some fields map, some are new in v2, some are deprecated from v1. Cross-tree links render with a **fog indicator** on unmapped fields and a one-click explanation: "This field exists in v2 but not v1."
- **Incompatible**: The template structures diverged fundamentally. Cross-tree links render as **broken bridges** — visible but non-functional until a human creates a manual mapping commit.

Template version upgrades are governance acts (§72 Layer 1 ballot). The `TemplateVersionBridge` must be published as part of the upgrade proposal. No template upgrade is valid without a bridge to the previous version.

**Contract #193 — Template version upgrades must include a TemplateVersionBridge defining field mappings to the previous version. Cross-tree links between different template versions render according to compatibility level: full (normal), partial (fog on unmapped fields), or incompatible (broken bridge). No template upgrade without a published bridge.**

#### 81.6.1 TemplateResolvedSpec — Cross-Version Projection & Federation — Contract #296

Contract #193 defines the bridge mechanism. This contract defines the deterministic resolution that every subsystem uses when it encounters data from a different template version than its own.

**The problem:** A projection (§39) references branches built from `template.health.v1`. The projecting tree uses `template.health.v2`. Without a deterministic resolution strategy, the projection engine must guess how to map v1 fields to v2 fields — or fail silently.

**The resolver:**

When any subsystem (renderer, projection engine, cross-tree link resolver, SCV validator, search engine) encounters a filament or branch whose `templateVersion` differs from the consuming context's expected version, it must resolve through a `TemplateResolvedSpec`:

```
TemplateResolvedSpec {
  sourceTemplate:       templateRef (the version the data was committed under)
  targetTemplate:       templateRef (the version the consuming context expects)
  bridgeChain:          [TemplateVersionBridge, ...] (ordered v1→v2→...→vN)
  compatibility:        "full" | "partial" | "incompatible"

  resolvedFieldMap: [
    {
      sourceField:      string,
      targetField:      string | null,
      transform:        "identity" | "rename" | "split" | "merge" | "deprecated" | "new_in_target",
      dataLoss:         boolean,
      defaultValue:     json | null (for new_in_target fields)
    }
  ]

  renderingHints: {
    fogFields:          [string, ...] (fields that exist in one version but not the other)
    brokenFields:       [string, ...] (fields where transform is destructive or incompatible)
    confidencePenalty:   number (0.0-0.3, applied to cross-version confidence display)
  }
}
```

**Resolution rules:**

1. **Bridge chain composition.** If data is from v1 and the consumer expects v3, the resolver composes: `bridge(v1→v2)` then `bridge(v2→v3)`. Each bridge must exist (Contract #193). If any link in the chain is missing, the overall compatibility is "incompatible."

2. **Compatibility degrades through the chain.** `full` + `full` = `full`. `full` + `partial` = `partial`. Any `incompatible` link = whole chain `incompatible`. Compatibility never upgrades through composition.

3. **Projections across versions.** When a projection references a branch built from a different template version:
   - **Full compatibility:** Projection renders normally. No visual indicator.
   - **Partial compatibility:** Projection renders with fog on unmapped fields. A one-click tooltip explains: "This field exists in version X but not in version Y." The confidence display applies a `confidencePenalty` (default: 0.1 per bridge hop) to signal version uncertainty.
   - **Incompatible:** Projection renders as a broken bridge glyph. The data is visible but not mapped. The user can inspect the raw data but cannot perform computed operations across the version boundary.

4. **Federation across regions.** When two regions use different template versions for the same domain, cross-region links resolve through the same `TemplateResolvedSpec`. The bridge chain may pass through intermediate versions. Regional governance (§72) controls which version a region adopts, but the bridge mechanism ensures that cross-region data never silently drops fields.

5. **SCV validation across versions.** When an SCV validates a cross-tree filament from a different template version, it resolves through `TemplateResolvedSpec` first. Validation rules are applied using the source template's schema, not the target's. This prevents false rejections when a v2 SCV encounters v1 data that was valid under v1 rules.

6. **Cache key.** `TemplateResolvedSpec` is cached by `(sourceTemplate, targetTemplate)` pair. Invalidated when any bridge in the chain is updated.

**Contract #296 — TemplateResolvedSpec. All subsystems encountering cross-version template data must resolve through a single TemplateResolvedSpec object produced by composing the TemplateVersionBridge chain. Compatibility degrades monotonically through the chain. Projections across versions render with fog (partial) or broken bridge glyph (incompatible). SCV validates using the source template's rules. Confidence display applies a per-hop penalty for version distance. No subsystem may silently drop fields during cross-version resolution. This contract is frozen.**

### 81.7 Minority Alarm Channel — Contract #194

Standard governance operates by weighted-median majority. But existential changes — deleting a civilization pillar, removing a template, restructuring the meta-voting layers — require a higher bar. Any sufficiently large minority must be able to force deliberation.

**Minority alarm trigger:**

Any group holding **15% or more** of branch-scoped eligibility (as defined by the relevant EligibilityRuleSet, §72.8) can trigger a **minority alarm** on any governance proposal classified as `impactScope: "existential"`.

Existential proposals include:
- Removing or fundamentally restructuring a civilization template (§76)
- Modifying a Layer 2 or Layer 3 meta-voting rule (§72.7)
- Changing the sortition jury composition formula (§46.4)
- Modifying the frozen contract amendment process itself

**What the alarm does:**
1. The proposal is **paused** for one settlement window
2. A **sortition jury** is convened per §46 to review the proposal
3. The jury does not decide the outcome — it deliberates and publishes a **binding advisory opinion** as a filament on the governance branch
4. The proposal then proceeds to normal vote with the advisory visible to all voters
5. If the jury finds the proposal would cause "irreversible structural harm," the vote threshold escalates to 80% supermajority

The alarm does not grant veto power. It forces deliberation and raises the bar for consequential changes.

**Contract #194 — Any group holding 15%+ of branch-scoped eligibility can trigger a minority alarm on existential governance proposals. The alarm pauses the proposal, convenes a sortition jury for binding advisory opinion, and escalates the threshold to 80% supermajority if the jury finds irreversible structural harm. Does not grant veto. Forces deliberation.**

### 81.8 Conceptual LOD — Progressive Disclosure — Contract #195

Relay's physics operate from CELL to LANIAKEA (§33.5). But users should not see that range on day one. Complexity must be proportional to engagement depth.

**Conceptual LOD tiers:**

| Tier | Name | What the User Sees | Unlocked By |
|------|------|-------------------|-------------|
| C0 | **PERSONAL** | Your tree, 3 starter branches, filaments on bark | Account creation |
| C1 | **TEAM** | Your team's tree, cross-tree links to teammates, shared branches | First cross-tree interaction |
| C2 | **ORG** | Organizational tree, department branches, governance parameters for your scope | 30+ commits across 3+ branches |
| C3 | **CIVIC** | Regional trees, boundary governance, civic response, traffic overlay | Demonstrated civic engagement (votes, evidence contributions) |
| C4 | **CIVILIZATION** | Globe LOD, civilization pillars, Laniakea, full meta-governance recursion | Natural discovery through sustained engagement |

**Rules:**
- Conceptual LOD does not hide data. It controls **default view configuration**. A C0 user can manually zoom to globe LOD — but the default camera opens at their personal tree.
- Conceptual LOD advances automatically based on engagement metrics. No gates, no achievements required — just natural use.
- Users can pin their preferred conceptual LOD. A C4 user who prefers the personal view can set C0 as their default.
- Templates can declare a minimum conceptual LOD for their domain: healthcare templates might require C2 (organizational context is necessary to understand the data).

**Contract #195 — Conceptual LOD controls default view complexity in five tiers: PERSONAL, TEAM, ORG, CIVIC, CIVILIZATION. Tiers advance automatically through engagement. Data is never hidden — only the default view scope changes. Users can manually override or pin their preferred tier. Templates may declare minimum conceptual LOD.**

### 81.9 First-Screen Contract — Contract #196

The single most important moment in Relay is the first 60 seconds. If a new user sees a cosmic globe with civilization pillars and Laniakea and meta-voting recursion, they leave.

**What the first screen shows:**

1. **The globe**, slowly rotating in the background — ambient, not interactive yet
2. **Your empty personal tree**, centered in view. Three starter branches visible, chosen from the role path selected during onboarding (§73):
   - **Student path**: `learning`, `social`, `projects`
   - **Worker path**: `tasks`, `communications`, `reports`
   - **Parent path**: `family`, `household`, `health`
   - **Explorer path**: `notes`, `discoveries`, `collections`
3. **One guided action**: "Drag a file onto your tree." The file becomes the user's first filament. The branch grows visibly. The filament appears on the bark. The system has demonstrated its core mechanic in one interaction.
4. **No menus, no settings, no governance**. Those appear as the tree grows.

**Time-to-first-value target:** 60 seconds from account creation to first filament visible on the user's tree.

**What is NOT shown at first screen:**
- Laniakea LOD
- Civilization pillars
- Meta-voting recursion
- Arena/game layer
- Weather overlays
- Supply chain traceability
- Sortition mechanics

All of these exist in the system. None are visible until the user's conceptual LOD (§81.8) naturally reaches them.

**Contract #196 — The first screen shows the user's empty personal tree with 3 role-path starter branches against the ambient globe. One guided action: drag a file to create the first filament. Time-to-first-value: 60 seconds. No governance, no civilization pillars, no meta-recursion visible at first screen. Complexity emerges through engagement, never through exposition.**

#### 81.9.1 Small Tree Mode — Offline Minimum & Genesis Architecture — Contract #297

Contract #196 defines what the first screen shows. This contract defines what the system MUST be able to render with zero network connectivity and zero server-side state — the irreducible offline kernel.

**The problem:** If the first-time experience requires a server round-trip to fetch globe tiles, template definitions, governance parameters, and SphereCore anchors before anything renders, then airplane passengers, rural users, disaster responders, and anyone with intermittent connectivity gets a blank screen. Relay must boot to a functional state locally.

**Small Tree Mode — the offline genesis package:**

Every Relay client ships with or downloads-once a `GenesisBundle` that contains everything needed to render a functional personal tree with zero network:

```
GenesisBundle {
  version:              "genesis.v1"
  sizeBytes:            < 50MB (hard cap — this ships with the app binary)

  // Globe — minimal rendering
  globeTiles:           low-resolution offline tileset (terrain + imagery, ~15MB)
  globeElevation:       coarse DEM for altitude clamping (~5MB)

  // Templates — starter set
  starterTemplates: [
    "template.personal.v1",     // personal tree (notes, files, media)
    "template.social.v1",       // basic social (follow, message, share)
    "template.work.v1"          // basic work (tasks, reports, communications)
  ]

  // SphereCore — seed anchors
  sphereCoreSeed:       ~500 universal anchors (subset of full ~4000)
  anchorGlyphs:         elemental glyph sprites for seed anchors (~2MB)

  // Governance — safe defaults
  defaultGovernanceParams: {
    // All Category A parameters at their global defaults
    // No regional or venue overrides (those require network)
  }

  // Airspace — safe defaults
  defaultAirspaceSpec:  global airspace config at default values

  // Camera — initial state
  defaultCameraState: {
    mode: "ORBIT",
    target: "user.tree.center",
    altitude: 500  // CANOPY layer — personal tree fully visible
  }

  // SCV — offline tier
  offlineSCVRules:      T0 deterministic validation rules only (no AI)
}
```

**What renders on first boot with no network:**

1. The globe, at low resolution, slowly rotating
2. The user's empty personal tree at their last-known or default location
3. Three starter branches from the selected role path (§81.9)
4. The guided action: "Drag a file onto your tree"
5. Full camera controls (FPS, RTS, ORBIT)
6. Basic SCV validation (T0 — schema checks, type checks, lifecycle enforcement)

**What is deferred until network is available:**

- High-resolution globe tiles (streamed progressively)
- Full SphereCore (~4000 anchors, downloaded in background)
- Regional/venue airspace overrides
- Cross-tree links and presence
- T1/T2/T3 SCV intelligence tiers
- Governance updates beyond defaults
- Template updates beyond starter set
- Substrate reference filaments

**The 3-branch genesis rule:**

Every new user's tree starts with exactly 3 branches. Not 0 (empty tree is intimidating). Not 10 (too many choices). Three. The branches are determined by the role path selected during onboarding (§73):

| Role Path | Branch 1 | Branch 2 | Branch 3 |
|-----------|----------|----------|----------|
| Student | `learning` | `social` | `projects` |
| Worker | `tasks` | `communications` | `reports` |
| Parent | `family` | `household` | `health` |
| Explorer | `notes` | `discoveries` | `collections` |
| Builder | `designs` | `materials` | `sites` |
| Healer | `patients` | `records` | `protocols` |

These branches are structural filaments (§81.1). They never close. They define the initial geometry of the tree. New branches grow from engagement — the user never has to "configure" their tree. They use it and it grows.

**Time budget for first render:**

| Phase | Target | What Happens |
|-------|--------|-------------|
| App launch → globe visible | < 2s | GenesisBundle globe tiles loaded from local storage |
| Globe visible → tree visible | < 1s | Three starter branches rendered at user location |
| Tree visible → first interaction possible | < 0.5s | Camera positioned at CANOPY, drag-and-drop listener active |
| First file dropped → filament visible | < 1s | File hashed, filament committed locally, bark ribbon renders |
| **Total: launch to first filament** | **< 5s** | Full offline path, no network required |

**Contract #297 — Small Tree Mode. Every Relay client ships with a GenesisBundle (< 50MB) containing low-resolution globe tiles, three starter templates, 500 seed SphereCore anchors, default governance and airspace parameters, and T0 SCV rules. This bundle enables full offline first-boot: globe renders, personal tree with 3 role-path branches appears, camera works, drag-and-drop creates filaments, all without network connectivity. Launch to first filament must complete in under 5 seconds. Deferred content (high-res tiles, full SphereCore, cross-tree links, T1+ SCV, governance updates) streams progressively when network is available. The 3-branch genesis rule and offline-first boot guarantee are frozen.**

#### 81.9.2 Relay Lite — One System, Fog Reveal — Contract #316

> *"There is no Relay Lite. There is only Relay — with fog."* — Eitan Asulin

**There is no separate binary.** There is no "Relay Lite" executable, no stripped-down app, no demo version. There is ONE system. Every user downloads and installs the same Relay. The difference between a first-day user and a civilization-scale operator is not what they installed — it is how much fog has lifted.

**The Fog Reveal Model:**

Relay ships complete. The entire engine — truth layer, game layer, AR, detection, governance, arena, crafting, everything — is inside every installation from day one. What limits the user's experience is not missing code but **Conceptual LOD fog** (§81.8): features that the user has not yet naturally encountered are rendered in fog, invisible at their current conceptual tier, waiting to be discovered through engagement.

```
What a new user sees:     Personal tree, 3 branches, globe, drag-and-drop
What actually exists:      The complete civilization engine, fogged

What lifts the fog:        Natural engagement — not purchases, not achievement gates
What NEVER lifts fog:      Paying, hacking, skipping — the curve cannot be accelerated (§99)
```

**Device Capability Adaptation (NOT separate tiers):**

The same Relay binary adapts its rendering to the device it runs on. There is no D0/D1/D2 tier system — there is one system that scales:

| Device Reality | How Relay Adapts | What the User Experiences |
|---------------|-----------------|--------------------------|
| Low-end phone (1 GB RAM) | Reduced globe resolution, T0 SCV only, simplified sap rendering | Full truth operations. Tree grows. Filaments commit. Fog lifts at the same rate. Visual fidelity lower. |
| Mid-range phone (4 GB) | Standard rendering, T1 SCV (local model), full leaf/sap | Full experience at standard quality. Game layer renders when fog lifts to reveal it. |
| Desktop / laptop (8+ GB) | Full rendering, T2 SCV (frontier API), high-fidelity weather/arena | Complete immersion. Every particle, every spell, every mesh session at full quality. |
| VR / workstation (16+ GB) | Maximum rendering, device mesh hosting, crafting IDE at full capacity | The ceiling. Venue-scale mesh, multi-intelligence combat, full immersion spectrum. |

The key principle: **a low-end phone user and a VR user at the same engagement level see the same fog boundary.** The VR user sees it at higher visual fidelity, but neither has more features unlocked. Discovery is engagement-driven, never hardware-gated. A user on a feature phone who has been using Relay for a year has more fog lifted than a VR user who installed yesterday.

**Progressive Asset Streaming (NOT stages):**

Assets stream in the background as the fog lifts — not in predefined stages. When a user's engagement naturally reaches a new conceptual tier, the assets for that tier stream on demand:

- First-day assets: GenesisBundle (< 50MB, ships with binary) — globe, personal tree, starter templates, T0 SCV
- As engagement grows: regional tiles, additional templates, SphereCore anchors stream in background
- When game layer fog lifts: combat assets, arena textures, spell effects download on first encounter
- When mesh fog lifts: device mesh protocols, immersion assets download on first multi-device interaction

No pre-download of stages. No "you must download 2 GB before proceeding." Assets arrive when the user's natural discovery path needs them. If they never discover the arena, arena assets never download.

**Offline Guarantee (unchanged from §81.9.1):**

The GenesisBundle enables full offline operation — globe, personal tree, camera, filament creation, T0 SCV. When connectivity returns, queued commits sync and fog-revealed assets stream. The offline guarantee is absolute: Relay never shows a blank screen or an error because of missing network.

**The Fog Reveal Invariant:**
- Relay is ONE system. No separate executables. No demo mode. No lite version.
- Fog = Conceptual LOD (§81.8). Fog lifts through engagement, never through purchase.
- Device capability affects rendering quality, not feature availability.
- Asset streaming follows the user's discovery path, not predefined download stages.
- A first-day user on any device has the complete engine — most of it is simply fogged.

**Contract #316 — Relay Lite (Fog Reveal). There is no separate Relay Lite binary. There is ONE system. Every installation contains the complete civilization engine. Feature availability is governed by Conceptual LOD fog (§81.8), which lifts through natural engagement — never through purchase, hardware tier, or explicit unlock. Device capability affects rendering quality (resolution, particle count, SCV intelligence tier) but never feature access. Assets stream progressively as fog lifts, following the user's discovery path rather than predefined download stages. The GenesisBundle (< 50MB) ships with every binary for full offline operation. A user on a feature phone and a user on a VR headset at the same engagement level see the same fog boundary at different visual fidelity. The fog reveal model, the single-binary invariant, and the prohibition on hardware-gated feature access are frozen.**

---

## 82. Three-Layer Ontology — Wood, Leaf, Sap — Frozen Contracts #197–201

> *"The clearest way into the Universe is through a forest wilderness."* — John Muir
>
> *"The world is a lot more simple than it seems."* — Eitan Asulin

A real tree is not just wood. It has wood (permanent structure), leaves (seasonal surface growth), and sap (live internal flow). Until now, Relay had only two layers — filaments (wood) and Notes (proto-leaves, §5). Everything else was either committed truth or weather graphics. This section formalizes the full biological model: three distinct layers with clear boundaries, clear physics, and clear rules about what crosses from one layer to another.

The instinct behind this section is precise: if every chat comment, micro-reaction, arena crowd cheer, and camera-position broadcast becomes a filament, the tree becomes brittle with noise-as-wood. The tree needs material that can fall, compost, and feed the roots without ever becoming structural. It also needs live state — presence, WIP status, active dispatch — that flows fast and dies fast without bloating the commit chain.

### 82.1 The Three Layers — Structural Definition

| Layer | Biological Analog | Relay Meaning | Persistence | Consolidation | Example |
|-------|-------------------|---------------|-------------|---------------|---------|
| **Wood (Filament)** | Growth fiber / wood grain | Permanent truth record — obligations, evidence, consent, votes, transfers | Append-only, eternal | Participates in gates | Invoice, lab result, vote, title transfer, scar |
| **Leaf (LeafPacket)** | Seasonal leaf | Ephemeral engagement — attention, commentary, reactions, drafts, speculation | TTL-governed, compostable | Never counted in trunk mass or consolidation | Chat comment, emoji reaction, draft note, arena crowd preference |
| **Sap (SapPacket)** | Xylem/phloem flow | Live state propagation — presence, WIP, active viewing position, dispatch status | Overwritable, TTL in milliseconds | No replay requirement, no archive | "User watching minute 37:12", "Unit en route", "Projection recomputing" |

**The boundary rules are non-negotiable:**

1. **Leaves never mutate truth.** No `commit()` path. A leaf cannot create or modify a filament directly.
2. **Sap never becomes archive.** Sap is overwritable; latest-within-TTL wins. Sap is not replayed as truth. Replay can show summarized sap for context, but sap is not required for correctness.
3. **Promotion is explicit.** A leaf can become a filament only through a defined promotion trigger (see §82.4). This is the same mechanism as §5's FilamentBirth — one external response, manual formalization, or threshold crossing.
4. **Sap can checkpoint into filament.** When live state becomes material (incident report, dispatch order, clinical event), a SapPacket triggers a filament commit. The sap itself is not preserved — only the committed filament.
5. **Degradation order: sap first, leaves second, wood last.** Under resource pressure, the system sheds sap (live state goes stale), then drops leaf rendering (comments disappear from view but hash-stubs remain), then — only at extremis — reduces wood rendering (silhouette mode). Truth is the last thing to degrade.

### 82.2 LeafPacket Schema

A LeafPacket is the formal successor to the §5 Note. Every Note is a LeafPacket of type `NOTE`. The LeafPacket extends the Note schema with richer lifecycle, engagement tracking, and promotion rules while preserving all existing Note contracts.

```json
{
  "LeafPacket": {
    "leafId": "leaf.<uuid>",
    "leafType": "NOTE | COMMENT | REACTION | HINT | DRAFT | PROJECTION_PREVIEW | ARENA_VOTE_INTENT | PING",
    "scopeRef": "tree.<id> | branch.<id> | filament.<id> | slab.<id> | arena.<id> | surface.<id>",
    "createdBy": "user.<id> | scv.<id> | system",
    "createdAt": "ISO-8601",
    "expiresAt": "ISO-8601",
    "ttlSec": 900,

    "position": {
      "mode": "BARK | BRANCH | TRUNK | ROOT | FREE",
      "l": 0,
      "r": 1.0,
      "theta": 0.0,
      "ecef": [0, 0, 0]
    },

    "content": {
      "text": "string | null",
      "attachments": [
        { "hash": "sha256:...", "mime": "string", "bytes": 0 }
      ],
      "refs": [
        { "type": "filament | branch | tree | external", "id": "string", "hash": "sha256:... | null" }
      ]
    },

    "engagement": {
      "views": 0,
      "reactions": { "like": 0, "dislike": 0, "flag": 0 },
      "replies": 0,
      "uniqueParticipants": 0
    },

    "evidenceHint": {
      "suggestedEvidenceRefs": ["sha256:..."],
      "qualityHint": 0.0
    },

    "policy": {
      "disclosureTier": 0,
      "countsTowardAttention": true,
      "countsTowardConfidence": false,
      "countsTowardTrunkMass": false,
      "isExportable": false,

      "promotionRule": {
        "mode": "NONE | FIRST_REPLY | THRESHOLD | MANUAL | TEMPLATE",
        "minUniqueParticipants": 2,
        "minReplies": 1,
        "minConfidenceHint": 0.0,
        "targetFilamentType": "string | null"
      }
    },

    "lifecycle": {
      "state": "BUD | ACTIVE | FALLING | COMPOSTED | PROMOTED",
      "fallStartedAt": "ISO-8601 | null",
      "compostedAt": "ISO-8601 | null",
      "promotedToFilamentId": "F-... | null",
      "scarIfPromotedRejected": true
    },

    "determinism": {
      "leafSpecVersion": "1.0",
      "seed": "sha256(scopeRef + createdAt + leafId)",
      "noHiddenInputs": true
    }
  }
}
```

**Leaf lifecycle state machine:**

```
BUD → [ttl active, visible on surface]     → ACTIVE
ACTIVE → [ttl expires, no promotion]       → FALLING
FALLING → [compost timer expires]           → COMPOSTED
ACTIVE → [promotion trigger met]            → PROMOTED → FILAMENT(OPEN)
COMPOSTED → [hash-stub remains in root strata for audit]
```

**Relationship to §5 Notes:** The Note schema (§5.2) is a strict subset of LeafPacket with `leafType: "NOTE"`. All Note contracts remain valid. The FilamentBirth trigger (§5.3) maps to `promotionRule.mode: "FIRST_REPLY"`. Existing Note TTL governance (§5.2) applies unchanged. LeafPacket simply adds new leaf types beyond NOTE and formalizes the lifecycle that §5 described narratively.

### 82.3 SapPacket Schema

SapFlow is the missing middle layer: live state propagation that is fast, reversible, not wood, not leaf, and degrades gracefully. Sap carries current operational state — not history, not commentary. "This invoice is being reviewed right now." "This branch is under inspection." "12 viewers are expanding this slab." "This camera is in FPS mode." "This projection is recomputing."

**Relationship to Contract #138:** Contract #138 states "Filaments are discrete growth fibers, not fluid flows." SapFlow is explicitly *not* a filament. It is a separate layer with separate rules. Contract #138 prevents filaments from becoming streaming state. SapFlow is the correct architectural home for streaming state — separated from truth, subject to TTL, and never replayed as committed history.

```json
{
  "SapPacket": {
    "sapId": "sap.<uuid>",
    "scopeRef": "tree.<id> | branch.<id> | filament.<id> | slab.<id> | arena.<id>",
    "type": "PRESENCE | FOCUS | WIP_STATE | PROJECTION_CACHE | ALERT | DEVICE_STATE | TRAFFIC_FLOW",
    "emittedBy": "user.<id> | scv.<id> | system",
    "emittedAt": "ISO-8601",
    "ttlMs": 5000,

    "payload": {
      "k": "string",
      "v": "json"
    },

    "priority": "LOW | NORMAL | HIGH | EMERGENCY",

    "visibility": {
      "disclosureTier": 0,
      "aggregateOnlyAboveLOD": "COMPANY",
      "quantizeMs": 5000,
      "precisionMeters": 10
    },

    "determinism": {
      "noHiddenInputs": true,
      "derivation": "pure function of current committed state + current live signals",
      "snapshotHash": "sha256 (optional)"
    }
  }
}
```

**Sap laws:**

1. **Overwritable.** Latest emission within TTL wins. No history preserved.
2. **Not replayed as truth.** Replay can show summarized sap for visualization context, but sap is not required for state reconstruction. If you replay a branch's history, you rebuild from committed filaments only. Sap is "what was happening live" — useful for documentary playback, not for audit.
3. **Checkpoint-to-filament.** When sap becomes material (an incident report is filed, a dispatch order is committed, a clinical event is logged), the sap triggers a filament commit. The filament is the truth. The sap that led to it is ephemeral context.
4. **Degradation-first.** Sap is the first layer shed under resource pressure. If bandwidth drops, sap TTL shortens. If compute drops, sap aggregation coarsens. Truth and leaves survive longer than sap.
5. **LOD-governed visibility.** Sap aggregates at higher LOD. At CELL LOD you see individual sap signals (user cursor position, machine state). At BRANCH LOD you see aggregated sap (12 viewers active, 3 machines running). At TREE LOD you see only sap intensity (branch pulse rate). At GLOBE LOD sap is invisible — only committed truth drives trunk appearance.

### 82.4 Promotion & Checkpoint Rules

The boundary between layers is the most important architectural decision in this section. Getting it wrong means noise becomes wood (brittle trees) or truth gets lost as compost (accountability failure).

**Leaf → Filament promotion triggers:**

| Trigger Mode | When It Fires | Use Case |
|-------------|---------------|----------|
| `FIRST_REPLY` | Another user responds to the leaf | §5 FilamentBirth — the original trigger. Chat becomes coordination. |
| `THRESHOLD` | `minUniqueParticipants` AND `minReplies` AND `minConfidenceHint` all met | High-noise environments (arenas, crowd events) where one reply isn't enough signal |
| `MANUAL` | Author explicitly promotes | Formalizing a draft, converting a sketch to a spec |
| `TEMPLATE` | Template-defined rule fires | Domain-specific (e.g., healthcare Note about patient symptom auto-promotes when clinician responds) |
| `NONE` | Never promotes | Pure ephemeral — reactions, emoji, pings. Falls and composts. |

**Sap → Filament checkpoint triggers:**

| Trigger | When It Fires | Use Case |
|---------|---------------|----------|
| Materiality | Live state crosses a domain-defined materiality threshold | Dispatch order committed, incident report filed |
| Duration | Sap has persisted beyond max-sap-duration (configurable) | Long-running WIP that should be recorded |
| External event | Committed filament references the sap state | Audit trail wants to capture "what was live at the time of commit" |
| Emergency | Priority = EMERGENCY and sap contains actionable state | Civic emergency dispatch — sap becomes committed record |

**Anti-gaming:** Inflating leaf engagement to force false promotions produces a scar on the promoted filament. The promotion audit trail (which leaf, which trigger, which participants) is itself a committed record. Coordinated leaf-spam that triggers promotion is detectable by the same pressure physics that detects any coordinated distortion — heat rises, SCV flags, sortition reviews.

#### 82.4.1 Promotion Gate — Non-Self Counterparty Requirement — Contract #295

The promotion triggers above (`FIRST_REPLY`, `THRESHOLD`, `TEMPLATE`) all depend on engagement signals. In adversarial environments, a single actor running multiple devices (or a bot cluster) can manufacture the appearance of engagement entirely within one identity's control sphere. This is the "astroturf promotion" attack — noise disguised as consensus.

**The gate:**

Every promotion trigger, regardless of mode, must satisfy at least ONE of these non-self requirements before the engine permits leaf → filament transition:

| Requirement | How It's Validated | Applies To |
|-------------|-------------------|-----------|
| **Non-self counterparty** | At least one `uniqueParticipant` in the leaf's engagement metrics must be from a different `treeId` than the leaf author | `FIRST_REPLY`, `THRESHOLD` |
| **Non-trivial evidence** | The leaf (or a reply to it) contains at least one `evidenceHint.suggestedEvidenceRefs` entry with a verifiable hash | `MANUAL`, `TEMPLATE` |
| **SCV attestation** | The branch SCV has validated the leaf content against domain schema and attests that the content is structurally valid for the target filament type | All modes as fallback |

**Rules:**

1. `FIRST_REPLY` mode: the reply must come from a different tree. A user replying to their own leaf on their own tree does not trigger promotion. Cross-tree or cross-branch-with-different-user replies do.

2. `THRESHOLD` mode: the `minUniqueParticipants` count excludes the leaf author. Two participants means two OTHER people, not one other plus the author.

3. `MANUAL` mode: when the author explicitly promotes their own draft, the promotion requires either a non-trivial evidence attachment (document hash, image hash, external reference) OR SCV attestation that the content is valid for the target filament type. A bare "promote this" with no evidence and no SCV validation is refused.

4. `TEMPLATE` mode: the template declares which of the above gates apply for its domain. Healthcare templates require SCV attestation (clinical validity). Financial templates require evidence hash. Social templates require non-self counterparty.

5. `NONE` mode is unaffected — these leaves never promote.

**Refusal:**
`[REFUSAL] reason=PROMOTION_GATE_FAILED leafId=<id> trigger=<mode> missing=NON_SELF_COUNTERPARTY|EVIDENCE|SCV_ATTESTATION`

**Contract #295 — Leaf Promotion Anti-Gaming Gate. Every leaf-to-filament promotion must satisfy at least one non-self requirement: non-self counterparty engagement, non-trivial evidence attachment, or SCV content attestation. Self-replies do not count as counterparty engagement. The author is excluded from `minUniqueParticipants` counts. Manual promotions without evidence or SCV attestation are refused. Templates declare which gate applies for their domain. The promotion gate is frozen.**

### 82.5 Demotion Stress Test — What Goes Where

This is the definitive classification guide. If a record type is not listed, apply the criteria in §82.5.1.

**Must remain FILAMENT (wood — never demote):**

- TransferPacket / ResponsibilityPacket / EvidencePacket
- Votes that trigger governance actions
- Consent grants / revocations
- Break-glass events (§76 HEALTH)
- Clinical events, lab results, diagnoses
- Title transfers, permits, inspections
- Dispatch orders, after-action reports
- Any closure / absorb / scar event
- Any record referenced as evidence by another filament
- Financial transactions of any kind
- Legal rulings, contracts, binding agreements

**Demote to LEAF (ephemeral — promotable):**

- Emoji reactions, quick acknowledgements
- Low-stakes comments that don't add evidence
- FYI pings, mentions, nudges
- Draft thoughts (sticky notes) that don't get replies
- Arena crowd micro-preferences ("more aggressive pacing") unless they set a parameter — then the parameter vote is a filament, the chatter is a leaf
- Speculation and "what if" discussions before formalization
- Projection previews before they are committed as projection branches

**Classify as SAP (live state — never persisted unless checkpointed):**

- "User is watching minute 37:12 of this media branch"
- "Camera is in FPS mode, pointer locked"
- "This projection is recomputing / cached / stale"
- "This incident is currently active: units en route"
- "Traffic lane A is blocked right now"
- "WIP machine status: running / down / changeover"
- "Live sensor stream summaries"
- "This user's cursor is at filament F-xyz"
- "12 viewers are currently on this branch"

#### 82.5.1 Classification Criteria

When in doubt, apply these rules in order:

1. **Does it create obligations, rights, consent, grades, legal outcomes, or financial movement?** → FILAMENT. No exceptions.
2. **Is it evidence-bearing and must remain verifiable under audit?** → FILAMENT.
3. **Does it change the lifecycle state of a durable object?** → FILAMENT.
4. **Is it non-binding speech/attention whose value decays quickly?** → LEAF.
5. **Is it safe to lose content while keeping only "it existed" (or lose entirely)?** → LEAF.
6. **Is it live status useful only "right now" that must be fast and reversible?** → SAP.
7. **If still uncertain:** start as LEAF. The moment it triggers action or evidence, promote to FILAMENT.

### 82.5.2 Classification Matrix — Global Defaults — Contract #291

The §82.5.1 criteria are correct for human reasoning. The classification matrix is the machine-enforceable form. Every objectType declared in a template MUST map to exactly one default layer. If a template omits the mapping, the engine refuses the template registration.

**Always FILAMENT (wood — permanent truth, never demote):**

| objectType Pattern | Reason |
|-------------------|--------|
| `TRANSFER_*`, `RESPONSIBILITY_*`, `EVIDENCE_*` | Creates obligations, rights, or audit evidence |
| `CONSENT_*`, `REVOCATION_*` | Consent is irrevocable history |
| `VOTE_*` (that triggers governance action) | Governance acts are permanent |
| `CLINICAL_*`, `LAB_*`, `DIAGNOSIS_*` | Health records are permanent |
| `TITLE_*`, `PERMIT_*`, `INSPECTION_*` | Legal/regulatory outcomes |
| `DISPATCH_*`, `AFTER_ACTION_*` | Civic response records |
| `FINANCIAL_*`, `INVOICE`, `PO`, `CONTRACT` | Financial truth |
| `BREAK_GLASS_*` | Emergency override records |
| `SCAR_*`, `CORRECTION_*` | Error/correction history |
| Any record referenced as evidence by another filament | Dependency chain forces permanence |

**Always LEAF (ephemeral — promotable):**

| objectType Pattern | Reason |
|-------------------|--------|
| `REACTION`, `EMOJI`, `ACK` | Non-binding engagement |
| `PING`, `MENTION`, `NUDGE` | Attention signals, not truth |
| `DRAFT`, `SKETCH`, `WIP_NOTE` | Pre-commitment thinking |
| `ARENA_MICRO_PREF` | Crowd chatter (unless it sets a parameter, which is a VOTE filament) |
| `PROJECTION_PREVIEW` | Speculative view, not committed |
| `COMMENT` (without evidence or binding action) | Speech, not obligation |

**Always SAP (live state — never persisted unless checkpointed):**

| objectType Pattern | Reason |
|-------------------|--------|
| `PRESENCE`, `CURSOR_POSITION`, `VIEW_STATE` | Live user location |
| `CAMERA_MODE`, `POINTER_LOCK_STATE` | Client rendering state |
| `PROJECTION_CACHE`, `RECOMPUTE_STATUS` | Transient computation |
| `INCIDENT_LIVE_STATUS`, `TRAFFIC_LIVE` | Operational telemetry |
| `SENSOR_STREAM_SUMMARY` | Real-time sensor digest |
| `DEVICE_TELEMETRY` | SCV physical extension live state (§101) |
| `WIP_MACHINE_STATUS` | Manufacturing floor state |
| `SUMMON_COMBAT_STATE` | Live creature HP, position, cooldowns during combat (§43.12) |
| `CROWD_AGGREGATE` | Audience engagement aggregate during events (§106) |
| `MESH_FRAME_SYNC` | Device mesh frame synchronization packets (§105) |

**Always LEAF (ephemeral — promotable) — game-layer additions:**

| objectType Pattern | Reason |
|-------------------|--------|
| `CRAFTING_DRAFT`, `CRAFTING_TEST` | Pre-finalization graphic iterations (§43.11) — promotable on finalization |
| `DUEL_SPECTATOR_REACTION` | Crowd chatter during combat — not truth unless it sets a parameter |
| `SPELL_PREVIEW` | Spell graphic preview before finalization |

**Always FILAMENT (wood) — game-layer additions:**

| objectType Pattern | Reason |
|-------------------|--------|
| `CRAFTING_FINALIZED` | Committed graphic with verified content hash (§43.11) — permanent creative record |
| `SUMMON_REGISTRY_ENTRY` | Registry-level creature definition — permanent game infrastructure |
| `DUEL_RESULT`, `ARENA_MATCH_RECORD` | Combat outcomes are permanent — governance consequences flow from them |
| `TREASURE_CHEST_MARKER` | Chest placement, type, location hash — permanent structural game data |
| `MESH_SESSION` | Device mesh session record (§105) — structural event filament |

**May promote (LEAF → FILAMENT):**

| objectType Pattern | Trigger | Target Filament Type |
|-------------------|---------|---------------------|
| `NOTE` | `FIRST_REPLY` or `THRESHOLD` | Filament inheriting note content |
| `COMMENT` (with evidence) | `MANUAL` or `TEMPLATE` | Evidence-bearing filament |
| `DRAFT` | `MANUAL` | Formalized spec/document filament |
| `ARENA_CROWD_VOTE` | `THRESHOLD` (when it sets a governed parameter) | Governance vote filament |

**May checkpoint (SAP → FILAMENT):**

| objectType Pattern | Trigger | Target Filament Type |
|-------------------|---------|---------------------|
| `INCIDENT_LIVE_STATUS` | Materiality (dispatch committed) or `EMERGENCY` | Incident record filament |
| `WIP_MACHINE_STATUS` | Duration (exceeded max-sap-duration) | Machine state snapshot filament |
| `SENSOR_STREAM_SUMMARY` | External event (audit references the state) | Sensor evidence filament |

**Validator rule:** At commit time, the engine checks `objectType` against the template's classification matrix. If a system attempts to commit a SAP-classified objectType as a filament without a valid checkpoint trigger reference, it emits:
`[REFUSAL] reason=CLASSIFICATION_VIOLATION objectType=<type> attemptedLayer=FILAMENT requiredLayer=SAP`

If a system attempts to commit a LEAF-classified objectType as a filament without a valid promotion audit trail (Contract #200), it emits:
`[REFUSAL] reason=CLASSIFICATION_VIOLATION objectType=<type> attemptedLayer=FILAMENT requiredLayer=LEAF missingPromotionAudit=true`

**Contract #291 — Classification Matrix. Every objectType declared in a template must map to exactly one default layer (FILAMENT, LEAF, or SAP). The matrix defines which types are permanently wood, which are ephemeral leaf, which are volatile sap, and which may cross boundaries via promotion or checkpoint. The engine enforces classification at commit time and refuses misclassified writes with CLASSIFICATION_VIOLATION. Templates that omit classification mappings are refused at registration. The classification matrix is frozen per template version; changes require a TemplateVersionBridge (§81.6).**

### 82.6 Visual Rendering — How Each Layer Appears

**Wood (filaments):** Rendered as ribbons, dots, or bark texture depending on LOD. Permanent geometry. Full color from lifecycle state. This is the existing rendering pipeline (§33, filament-renderer, slab-renderer).

**Leaves:** Rendered as small translucent objects on the bark surface. Leaves drift slowly outward from their attachment point during `BUD` and `ACTIVE` states. During `FALLING`, they detach and animate downward toward the root zone — visually identical to a leaf falling from a tree. During `COMPOSTED`, they fade and merge into the root strata texture. At high LOD (CELL, BRANCH), individual leaves are visible. At TREE LOD, leaves aggregate into a "canopy density" metric — more leaves means more engagement surface. At GLOBE LOD, leaves are invisible.

**Sap:** Rendered as subtle pulse animations on branches. A branch with high sap traffic shows gentle luminous pulses moving along its length — like veins glowing briefly. Sap intensity drives "branch pulse rate" visible at BRANCH and TREE LOD. At CELL LOD, individual sap signals may show as small moving indicators (user cursors, status dots). At GLOBE LOD, sap is invisible. Sap rendering is the first layer disabled under performance pressure.

### 82.7 Relationship to §53.1 — No Contradiction

Contract #138 (§53.1) states: "Filaments are discrete growth fibers, not fluid flows. All state changes are commit-driven events. No continuous simulation, no streaming state, no fluid dynamics. Every filament transition is an atomic append-only commit."

This contract remains fully intact. SapFlow is not a filament. It does not participate in the commit chain. It is not append-only. It does not affect replay correctness. Contract #138 prevents *filaments* from becoming streaming state. SapFlow is the architecturally correct home for streaming state — a separate layer with separate rules, separated by an explicit checkpoint boundary.

Leaves are also not filaments until promoted. A leaf's lifecycle (BUD → ACTIVE → FALLING → COMPOSTED) is internal to the leaf system and does not touch the filament commit chain. Only when a leaf is promoted does a new `FILAMENT(OPEN)` birth occur through the standard commit pathway.

**Contract #197 — Three-Layer Ontology. Relay data exists in exactly three layers: Wood (filaments — permanent truth), Leaf (LeafPackets — ephemeral engagement), and Sap (SapPackets — live state). Each layer has distinct persistence rules, distinct rendering, and distinct degradation priority. Promotion from leaf to filament is explicit and auditable. Sap never persists without checkpoint. Degradation order: sap first, leaves second, wood last. No fourth layer may be introduced without constitutional amendment.**

**Contract #198 — Leaf Immutability Boundary. LeafPackets cannot call commit(), cannot create or modify filaments, cannot produce TransferPackets or ResponsibilityPackets, and cannot participate in consolidation gates. A leaf's only path to truth is explicit promotion through a defined trigger, which creates a new filament through the standard commit pathway. The promotion audit trail is itself a committed filament.**

**Contract #199 — Sap Volatility Guarantee. SapPackets are overwritable, TTL-governed, and never required for state reconstruction. Replay correctness depends only on committed filaments. Sap is the first layer shed under resource pressure. No system behavior may depend on sap history — only on sap's current-moment value or on filaments created via checkpoint.**

**Contract #200 — Leaf-Filament Promotion Audit. Every leaf-to-filament promotion creates an auditable record: which leaf, which trigger mode, which participants, and the content hash at promotion time. Coordinated promotion gaming is detectable through standard pressure physics (heat, SCV flags, sortition review). A promoted filament carries a `promotedFromLeafId` reference in its origin metadata.**

### 82.7b Canon Summarization Discipline — Summaries Are Projection, Never Truth

Any aggregation, summary, dashboard, report, or AI-generated synopsis of committed filaments is a **projection** (§0.4, §6). It is never truth. This must be enforced at the commit-type level:

- **Summary documents** (meeting minutes, quarterly reports, AI briefings) may only be committed as projection filaments or LeafPackets. They cannot be committed as truth-layer wood filaments.
- **Every summary must cite its source filaments.** A summary without source references is refused: `REFUSAL: SUMMARY_MISSING_SOURCES`.
- **Summaries cannot be used as evidence** in governance votes (§72), dispute resolution (§46), or confidence calculations (§9). Only the original committed filaments they summarize qualify as evidence.
- **Legibility may be summarized; truth may not.** A well-written summary helps humans navigate complex branches. But the summary is a lens (§81.5), not a record. The record is always the original commits.

This prevents a critical failure mode: derivative documents gradually replacing source data as the authoritative record. In existing organizations, meeting minutes often become "what happened" while the actual events they summarize are forgotten. In Relay, the events are the permanent record. Summaries are helpful views that sit on the surface and fall like leaves.

### 82.8 Reality as Interface — The Isomorphic Learning Principle

By mapping data to the structure of a real tree, Relay does not merely organize information — it teaches reality itself. A user watching sap pulse through a branch in Relay learns what sap does in a real tree. A user watching leaves bud, grow, detach, fall, and compost learns what seasonal cycles are. A user watching wood rings form inward learns what dendrochronology is. A user watching gravity sink filaments downward learns what gravity does to everything. The interface is not a metaphor layered on top of data. The interface IS the data, rendered through a structure that already exists in the physical world and already works.

This is the deepest architectural principle in Relay: **reality already solved the information problem.** Trees already know how to grow, archive, shed, compress, and survive. Orbits already know how to balance forces. Seasons already know how to cycle. Relay does not invent new physics and then explain them to users. Relay maps to physics that users can walk outside and observe. The learning curve collapses because the system behaves the way the world already behaves.

**Where this principle must be enforced throughout the system:**

| Relay Concept | Real-World Analog | What the User Learns by Using Relay |
|---------------|-------------------|-------------------------------------|
| Wood (filaments sinking inward) | Tree rings forming over years | Time deposits permanent structure. Old things become foundation. |
| Leaves (budding, falling, composting) | Seasonal leaf cycles | Engagement is temporary. What doesn't become structure feeds the roots. |
| Sap (pulsing through branches) | Xylem/phloem nutrient flow | Live activity flows through structure but is not structure itself. |
| Gravity (filaments sink with time) | Physical gravity | Everything settles. Nothing floats forever without energy. |
| Wilt (branches drooping) | Dehydrated plants | Neglect is visible. Unwatered things droop. |
| Fog (low confidence haze) | Actual fog | Uncertainty obscures. You cannot see clearly through incomplete evidence. |
| Heat (rapid change glow) | Thermal radiation | Rapid activity generates heat. Too much heat burns. |
| Storm (danger indicators) | Weather storms | Convergent pressure creates danger. Storms are visible before they hit. |
| Bark (active surface) | Tree bark | The living surface is where growth happens. Inside is settled. |
| Heartwood (terminal stillness) | Dense tree core | The oldest, most compressed history becomes the structural foundation. |
| Roots (underground archive) | Root systems | What you don't see supports what you do see. Roots retrieve. |
| Branch lean (pressure direction) | Wind-bent trees | Persistent force in one direction shapes growth permanently. |
| Cross-section rings (timebox slabs) | Dendrochronology | Cut any branch and read its history in the rings. |
| Canopy density (leaf count) | Forest canopy | Healthy engagement creates shade and shelter. Sparse canopy means exposure. |
| Compost (fallen leaves feeding roots) | Forest floor decomposition | Nothing is wasted. Ephemeral attention decomposes into archival nutrients. |

**The design rule:** When adding any new visual, mechanic, or data structure to Relay, the first question is: *what does this already look like in reality?* If there is a natural analog, use it. If there is no natural analog, the feature may be inventing unnecessary complexity. Reality already organized itself. Relay renders reality's organization with data inside it.

This principle also means Relay is self-documenting for children, non-technical users, and anyone who has ever looked at a tree, felt rain, or watched a leaf fall. The interface teaches the system. The system teaches reality. The loop closes.

**Contract #201 — Reality as Interface. Every visual, mechanic, and data structure in Relay must map to an observable real-world analog wherever one exists. The system teaches reality by rendering data through structures that already exist in the physical world. When no natural analog exists, the feature must justify its necessity independently. Reality is the first design document. The interface is not a metaphor — it is the thing itself, filled with data instead of cellulose.**

---

## 83. Energy Budget — Photosynthesis, Dormancy, and Vitality — Frozen Contracts #203–205

> *"People are excellent at what they do. What they do is not always excellent."* — Eitan Asulin

The ten universal equations (§3.19) describe position, decay, danger, and aggregation. They describe six ways things *deteriorate* — gravity sinks, wilt droops, fog obscures, heat warns, storm endangers, lightning cascades — but zero ways things *grow*. Branch thickness increases when filaments are absorbed, but there is no explicit equation for **how attention converts into structure**. That is photosynthesis. It is the missing half of the energy system.

This section closes the loop. The full energy cycle is now:

```
Attention (sap) → Engagement (leaves) → Promotion (wood) → Sinking (gravity) → Compression (heartwood)
     ↑                                                                              ↓
     └──────────────── Compost (fallen leaves feed root retrieval) ─────────────────┘
```

Every stage now has an equation. No stage is implicit.

### 83.1 Equation 11 — Photosynthesis (Attention → Structure Conversion)

Photosynthesis is how a branch grows. Sunlight (attention) + water (evidence) + CO2 (counterparty input) → wood (structural mass). In Relay terms: engagement that is backed by evidence and involves real counterparties becomes permanent structure. Engagement without evidence stays as leaves and eventually composts.

```
branchGrowthRate(B, t) =
    Σ (promotedLeafMagnitude(Fᵢ) × confidence(Fᵢ) × resolutionRate(Fᵢ))
    / Δt

where:
    promotedLeafMagnitude = magnitude of filaments born via leaf promotion (§82.4)
    confidence            = orgConfidence at time of promotion
    resolutionRate        = closedFilaments / totalFilaments over the timebox
```

**Zero-growth guards (non-negotiable):**

```
if resolutionRate == 0   → branchGrowthRate = 0    (activity without closure is noise)
if confidence < C_min    → branchGrowthRate = 0    (unverified bursts don't build structure)
```

Where `C_min` is a Category A global parameter (default: 0.3). This prevents arena-style hype storms from growing structural mass. Pure attention without evidence and resolution produces leaves that compost — never wood.

**What this means in plain language:** A branch grows when people pay attention to it (leaves land on it), that attention produces real evidence-backed commitments (leaves promote to filaments), and those commitments get resolved (filaments close and sink). All three factors must be present. Attention without evidence = leaves that fall and compost. Evidence without resolution = wilt. Resolution without attention = dormancy.

**The growth shows up as:**
- Branch thickness increasing (more absorbed filament mass)
- Bark surface expanding (more active filaments at r=1.0)
- Canopy density rising (more leaves budding on the surface)
- Sap pulse rate increasing (more live activity flowing through)

A branch with high photosynthesis is visually lush — thick, leafy, pulsing with sap, firm bark. A branch with zero photosynthesis is dormant — thin, leafless, still, frosted.

### 83.2 Equation 12 — Energy Budget (The Conservation Principle)

The change in structural mass over time is:

```
Δ(branchMass) = photosynthesis − gravity − wilt

Expanded:
Δ(branchMass) =
    (Σ promotedLeafMagnitude × confidence)      ← structure gained
    − (Σ absorbedFilamentMagnitude × sinkRate)   ← structure moving to trunk/heartwood
    − (Σ wilt(T) × activeMass)                   ← structure lost to integrity deficit
```

**Interpretation:**
- **Positive Δ** = branch is growing. More structure being created than sinking or wilting. Healthy, active branch.
- **Zero Δ** = branch is stable. Growth exactly balances sinking and decay. Mature, steady-state.
- **Negative Δ** = branch is shrinking. More mass sinking or wilting than being created. Declining — either naturally (old branch completing its purpose) or pathologically (neglect).

This is the tree equivalent of metabolic rate. A tree with positive energy budget across all branches is thriving. A tree with negative budget is dying. You can see it in the shape without reading a single number.

### 83.3 Equation 13 — Dormancy Index

Wilt is active neglect (missing evidence, unresolved issues). Heartwood is terminal compression (maximum density, zero activity). Between them is **dormancy** — a branch that is simply quiet. Not broken. Not dead. Sleeping.

```
dormancyIndex(B) = 1 − (engagementRate(B, t) / baselineEngagement(B))

where:
    engagementRate     = current commits + leaf activity + sap traffic per epoch
    baselineEngagement = rollingMean(engagementRate, N epochs)    (default N: 12)
```

**Why rolling mean:** A static baseline would freeze seasonal branches permanently. A rolling mean self-normalizes — a branch that was busy last quarter but quiet this quarter enters dormancy naturally. A startup branch with only 2 epochs of history uses `min(actualEpochs, N)` for the window, preventing new branches from appearing dormant at birth. Explosive short-term spikes don't reset the baseline too quickly because the rolling window smooths them.

**Dormancy thresholds:**

| dormancyIndex | State | Visual | Compute |
|--------------|-------|--------|---------|
| 0.0 – 0.3 | **Active** | Normal rendering | Full per-frame |
| 0.3 – 0.7 | **Quiet** | Slight desaturation, reduced sap pulse | Normal |
| 0.7 – 0.9 | **Dormant** | Frost overlay on bark, no sap visible, leaves gone | Skip per-frame LOD updates; recompute on camera approach or new commit |
| 0.9 – 1.0 | **Deep dormancy** | Pale, still, frosted, minimal geometry | Minimal compute; only wake on direct interaction or new commit |

**Key distinctions:**
- **Dormancy ≠ wilt.** Wilt means something is wrong (missing evidence, integrity deficit). Dormancy means nothing is happening (no engagement, no commits). A dormant branch can be perfectly healthy — just quiet. **Dormancy does NOT reduce mass. Dormancy does NOT imply negative vitality.** Dormancy is winter. Wilt is rot. This distinction is sacred.
- **Dormancy ≠ heartwood.** Heartwood is permanent terminal compression. Dormancy is reversible. One new commit wakes a dormant branch instantly.
- **Dormancy saves compute.** A dormant branch at TREE LOD skips per-frame sap calculations, leaf animations, and presence aggregation. It renders as static geometry until engagement returns. At scale, this is significant — most branches on most trees are dormant most of the time.

**Re-engagement trigger:** Any of these wakes a dormant branch:
- New filament commit
- New leaf landing on the branch surface
- User presence marker entering the branch LOD zone
- SCV proposal targeting the branch
- Cross-tree reference from another active branch

### 83.4 Composite Vitality Score

Rather than introducing a separate entropy metric (which would overlap with wilt, fog, and storm), the existing equations combine into a single vitality score:

```
branchVitality(B) = confidence(B) × firmness(B) × (1 − dormancyIndex(B))

where:
    confidence = average orgConfidence across active filaments
    firmness   = 1 − wilt(B)
```

| Vitality | Meaning | Visual |
|----------|---------|--------|
| 0.8 – 1.0 | Thriving | Lush, firm, leafy, pulsing |
| 0.5 – 0.8 | Healthy | Normal appearance |
| 0.2 – 0.5 | Stressed | Some wilt, thin canopy, slow pulse |
| 0.0 – 0.2 | Critical | Heavy wilt, frost, nearly dormant |

Vitality is NOT a new force. It is a diagnostic composite of existing equations — confidence (Eq 6 inverse), wilt (Eq 4), and dormancy (Eq 13). It is useful for dashboard views and SCV health monitoring but does not drive any physics.

**Game-layer branch application:** The energy equations apply uniformly to ALL branches, including game-layer branches:

- **Crafting branches (§43.11):** Crowd attention on crafted spell effects generates engagement sap → photosynthesis (Eq 11) converts attention into structural growth. A crafting branch with beautiful, popular effects grows thick and firm. A neglected crafting branch with no audience interest wilts. The crafting economy's "attention as metric" (§43.11.3b) IS photosynthesis operating on the crafting branch.
- **Arena branches (§68):** Combat activity generates engagement (high heat), but adversarial context means counterparty relationships are oppositional. Arena branches run hot with rapid engagement but may have lower confidence (less corroborated evidence per commit). A healthy arena branch is hot but firm; a degenerate one is hot and foggy.
- **Legendary branches (§97):** "Cannot wilt" and "confidence permanently 1.0" are explicit overrides to Eq 4 (wilt) and Eq 6 (confidence). Legendary branches are exempt from energy-budget degradation because they are fully formed at spawn — crystallized history, not living growth. They still sink through gravity (Eq 3) like all branches. The energy equations do not need a formal exception; the legendary branch schema sets `wiltResistance = 1.0` and `confidence = 1.0` as immutable properties, which zeros out the wilt and fog terms.
- **Tree Health Pool (§43.12.5):** Combat health is derived from "mass, confidence, engagement history." This is a subset of the vitality formula: `branchVitality = confidence × firmness × (1 − dormancy)`. Tree Health Pool = Σ vitality across contributing branches × a combat scaling factor (Category A parameter). A user with high-vitality branches has a deeper health pool. A user whose tree is wilting has less combat health. Truth-layer stewardship directly affects game-layer combat capability.

### 83.5 Immune Detection Trigger

The immune response mechanisms already exist: scars for reverts (§4), sortition for disputes (§46), civic observation for enforcement (§61), confidence decay for missing evidence (§9). What is missing is the **detection threshold** — the tripwire that activates these responses.

```
immuneTrigger(B, t) = TRUE if any of:
    heat(B) > heatThreshold  AND  fog(B) > fogThreshold       ← storm brewing
    leafPromotionRate > promotionRateThreshold                 ← coordinated leaf spam
    newAccountCommitShare > freshnessThreshold                 ← Sybil pattern
    confidenceDropRate > dropRateThreshold per epoch           ← evidence withdrawal attack
```

When `immuneTrigger = TRUE`:
1. SCV generates an anomaly filament on the branch (lavender projection)
2. Branch enters elevated monitoring state (increased sap sampling, shorter SCV proposal interval)
3. If anomaly persists beyond buffer period, sortition review is triggered (§46)
4. Heat overlay intensifies visually — the branch "runs a fever"

The detection thresholds are Category A global parameters (community-voted). The existence of the trigger mechanism is frozen.

**Oblivion classification integration (§72.12):** The immune trigger library includes all active OblivionMarker pattern definitions. Anomalous clusters of oblivion-classified content — concentrated bursts of destructive material appearing on a branch, coordinated posting of classified patterns across multiple accounts, or rapid creation of near-threshold content designed to evade detection — trip the same immune response as Sybil attacks. The immune system treats oblivion-classified content proliferation as a structural threat to branch health, identical in mechanism to any other coordinated manipulation attempt.

**Contract #203 — Photosynthesis Equation. Branch growth rate is a deterministic function of promoted leaf magnitude, confidence at promotion time, and resolution rate. Attention without evidence produces leaves that compost. Evidence without resolution produces wilt. All three factors must be present for structural growth. No branch grows without real engagement backed by real evidence involving real counterparties.**

**Contract #204 — Dormancy State. Branches with engagement below baseline threshold enter dormancy: visually frosted, computationally reduced, instantly reversible on any new commit, leaf, presence, or cross-tree reference. Dormancy is not wilt (nothing is wrong) and not heartwood (nothing is permanent). Dormancy saves compute at scale. The dormancy threshold is a Category A global parameter.**

**Contract #205 — Energy Budget Conservation. The change in branch structural mass equals photosynthesis minus gravity minus wilt. This is the complete energy cycle: attention flows in as sap, crystallizes as leaves, promotes to wood, sinks under gravity, compresses into heartwood, and compost feeds root retrieval. Every stage is deterministic. No stage is implicit. The energy budget is the unified health metric for any branch at any scale.**

### 83.6 Equation 14 — The Trust Half-Life — Contract #317

> *"Time is the most valuable thing a man can spend."* — Theophrastus

Relay has multiple decay mechanisms — vote decay (§7.6), dormancy (§83.3), gravity sink (§3.3) — but no unified equation for how trust erodes over time. The Trust Half-Life formalizes the universal principle: **every assertion in Relay loses weight unless continuously re-evidenced.** Evidence is not a one-time stamp — it is a pressure that must be maintained.

#### 83.6.1 The Core Equation

```
Equation 14 — Trust Half-Life:

trustWeight(F, t) = initialWeight(F) × 2^(−Δt / τ(F))

where:
  F                = any filament, vote, evidence reference, or confidence assertion
  t                = current epoch
  initialWeight(F) = the weight at the moment of commit (always 1.0 for new commits)
  Δt               = epochs since the last re-evidencing event (new evidence, confirming vote,
                     counterparty attestation, or integrity verification)
  τ(F)             = the half-life parameter for F's context (Category A, varies by domain)
```

After one half-life (`Δt = τ`), the trust weight drops to 50%. After two half-lives, 25%. After three, 12.5%. The decay is exponential — steep at first, asymptotic toward zero but never reaching it. Old assertions never fully disappear (append-only), but their influence on branch physics diminishes continuously.

#### 83.6.2 Context-Dependent Half-Lives

Different domains demand different decay rates. A medical test result should be trusted longer than a social media vote:

| Context | Default Half-Life (τ) | Rationale | Governance |
|---------|----------------------|-----------|------------|
| **Social votes** (§7.6) | 30 days | Opinions shift quickly; relevance is temporal | Category A |
| **Evidence references** | 180 days | Evidence remains valid longer, but should be refreshed | Category A |
| **Financial assertions** | 90 days | Quarterly cycles; assertions need re-verification | Category A, template-overridable |
| **Medical records** | 365 days | Slow-changing; annual verification cycles | Category A, template-overridable |
| **Legal/compliance** | 730 days (2 years) | Regulatory cycles; biennial audits common | Category A, template-overridable |
| **Infrastructure records** | 365 days | Annual inspection cycles | Category A, template-overridable |
| **Scientific data** | 1825 days (5 years) | Slow-changing; replication cycles are long | Category A |
| **Governance decisions** | 365 days | Annual renewal expectation for mandates | Category A |
| **Oblivion classifications** (§72.12) | ∞ (no decay) | Civilizational consensus does not erode by time alone — only by explicit revocation vote | Frozen |
| **Frozen contracts** | ∞ (no decay) | Structural invariants are immune to time | Frozen |

Templates declare the half-life for each domain within their scope. The global parameter sets the floor — no template can specify a half-life shorter than the global minimum (default: 7 days, Category A).

#### 83.6.3 Re-Evidencing Events — Trust Renewal

The decay counter (`Δt`) resets to zero when any of these occur:

1. **New evidence added:** A counterparty commits new supporting evidence referencing the filament. The trust weight resets to the filament's current confidence level (not necessarily 1.0 — a low-confidence filament re-evidenced is still low-confidence, just no longer decaying).
2. **Confirming vote:** A Tier 1+ user votes to confirm the filament's continued validity. Voting requires viewing the filament (§7.4) — rubber-stamp bots caught by the engagement gate.
3. **Counterparty attestation:** An existing counterparty on the filament commits a re-attestation (a lightweight commit indicating "this remains accurate as of epoch t").
4. **Integrity verification:** An automated integrity check (Merkle chain validation, cross-reference consistency) confirms the filament's evidence chain is intact. This is the only non-human re-evidencing event — and it only confirms structural integrity, not semantic truth.

What does NOT reset the counter:
- Viewing the filament (reading is not evidence)
- Searching for the filament (search is not endorsement)
- AI-generated summaries referencing the filament (projections are not truth — §82.7b)

#### 83.6.4 Interaction with Branch Physics

Trust half-life feeds directly into the existing equations:

| Equation | How Trust Half-Life Affects It |
|----------|-------------------------------|
| **Confidence (§9)** | Confidence opacity = f(evidence, votes). When votes and evidence decay via half-life, confidence drops proportionally. Old, unrefreshed filaments become translucent — visually fading. |
| **Wilt (§3.7)** | As trust weight decays, the filament's structural contribution to slab firmness decreases. Branches with many old, un-re-evidenced filaments develop wilt — not because anything is wrong, but because nothing has been reconfirmed. |
| **Photosynthesis (§83.1)** | Growth rate depends on confidence at promotion time. Decayed trust weight means promoted leaves carry less structural contribution. Sustained growth requires sustained evidence. |
| **Dormancy (§83.3)** | A branch where all filaments have decayed past 3 half-lives naturally enters dormancy (engagement rate drops below baseline). Trust half-life is the individual-level mechanic; dormancy is the branch-level consequence. |
| **Silence Stability (§81.3)** | Governance votes decay via trust half-life. A parameter whose votes have all decayed past threshold effectively has zero active votes — triggering silence stability. The doctrines reinforce each other: old votes fade, silence deepens, thresholds escalate. |

#### 83.6.5 The Renewal Incentive

The trust half-life creates a natural maintenance pressure: institutions, organizations, and individuals are incentivized to periodically re-evidence their assertions. An invoice branch where no one has attested to accuracy in 6 months (2 half-lives at financial τ=90d) shows visible decay — trust weight at 25%, filaments translucent, branch developing early wilt. The visual signal is: "These records were last verified months ago. Confidence is declining."

This is Relay's turgor pressure (§10.4) expressed at the temporal level. Just as a plant cell needs continuous water pressure to stay firm, a branch needs continuous evidence pressure to stay trustworthy. The half-life makes this mathematically explicit.

**What this prevents:**
- Stale authority: A government record posted 10 years ago with no re-verification has trust weight near zero. The record still exists (append-only), but it no longer contributes meaningful confidence to its branch. Authority must be maintained.
- Credential coasting: A certification issued 5 years ago (at τ=730d, ~3.4 half-lives) has trust weight ~9%. The certification is still on the user's tree, but the branch is visibly fading. Re-certification refreshes it.
- False permanence: A social media post with 10,000 votes from 3 years ago (at τ=30d, ~36 half-lives) has trust weight effectively zero. The post exists, but its votes carry no current weight. Fresh engagement matters more than historical popularity.

#### 83.6.6 Rendering

Trust decay renders as progressive translucency on the filament's bark ribbon:

| Trust Weight | Visual |
|-------------|--------|
| 1.0 – 0.75 | Full opacity. Vibrant color. Firm rendering. |
| 0.75 – 0.50 | Slight translucency. Colors begin to desaturate. |
| 0.50 – 0.25 | Noticeable translucency. Muted colors. Thin ribbon. |
| 0.25 – 0.10 | Highly translucent. Near-grey. Ribbon barely visible at BRANCH LOD. |
| < 0.10 | Ghost state. Visible only at CELL LOD or with filter override. Branch aggregate still reflects mass. |

A branch full of ghost-state filaments is structurally present (mass, weight, droop) but visually hollow — like a tree with dried, translucent bark. The shape tells the truth: something is here, but nothing has been recently verified.

**Contract #317 — Trust Half-Life (Equation 14). Every assertion in Relay decays exponentially via `trustWeight = initialWeight × 2^(−Δt / τ)` where τ is a context-dependent half-life parameter. Default half-lives range from 30 days (social votes) to 5 years (scientific data); oblivion classifications and frozen contracts are exempt (infinite half-life). Re-evidencing events (new evidence, confirming votes, counterparty attestation, integrity verification) reset the decay counter. Trust decay feeds into confidence opacity, wilt, photosynthesis, dormancy, and silence stability — all existing equations become time-aware. Templates declare domain-specific half-lives with a global minimum floor (7 days, Category A). Trust decay renders as progressive translucency: vibrant at full weight, ghost-state below 10%. The half-life is Relay's temporal turgor pressure: assertions that are not maintained lose structural weight. The equation, the re-evidencing mechanism, and the prohibition on non-evidence-bearing events resetting decay are frozen.**

---

## 84. Anti-Fraud & Sybil Resistance — The Complete Defense Stack — Frozen Contract #207

> *"You can execute perfectly inside a system that's wrong."* — Eitan Asulin

Relay's anti-fraud architecture is not a single mechanism. It is a layered stack where each layer makes the next attack harder, and every attack attempt becomes visible geometry. The principle: **cheap to observe, expensive to influence; influence requires verified humans with domain history; suspicious clusters are rate-limited and routed to sortition; everything is logged and replayable.**

This section consolidates the defense mechanisms distributed across §48, §49, §61, §72, §83.5, and frozen contracts #45, #55, #72, #73, #75, #77, #99 into a single readable narrative. No new physics. No new contracts except #207 (the stack itself). Parents reading this section should understand exactly how Relay stops fraud.

### 84.1 Layer 1 — Separate Reading from Influencing

| Capability | Tier 0 (Anonymous) | Tier 1+ (Verified) |
|-----------|-------------------|-------------------|
| Browse the globe | Yes | Yes |
| View public trees | Yes | Yes |
| Post Notes/Leaves | Yes (local TTL) | Yes |
| Vote on governance | **No** | Yes (with cooldown) |
| Contribute to attention at GLOBE/REGION LOD | **No** (contract #45) | Yes |
| Trigger high-impact actions | **No** | Yes (evidence required) |
| Serve on sortition juries | **No** | Yes (Trusted tier+) |

This alone kills most bot-farm value. Bots can watch. They cannot steer. (§48.2, contract #45)

### 84.2 Layer 2 — Gate Account Creation

Accounts enter through invite chains, not open signup (§48.2.3):

- Each verified user gets a limited number of invites, refilled at a community-governed rate
- Invites expire after 14 days (Category A parameter)
- Invite-chain topology is visible — if one account spawns hundreds of invites, the centrality is detectable (contract #99, threshold: 25% of active users)
- Mass fake accounts require burning real invite capacity from many real people — visible and costly

**Users help by:** not sharing invites casually, reporting suspicious invite clusters, refusing to guardian unknown accounts.

### 84.3 Layer 3 — One Human = One Influence Identity

Verification is not one-and-done. It renews on a schedule tied to trust tier (contract #72):

| Trust Tier | Reverification Interval | Promotion Requirements |
|-----------|------------------------|----------------------|
| Probationary | 7 days | New account |
| Trusted | 90 days | 30 days + 10 commits |
| Verified | 180 days | 180 days + 50 commits + jury service |
| Anchor | 365 days | 365 days + 100 commits + 3 juries + nomination |

Failed reverification triggers tier demotion. Inactivity beyond 180 days triggers demotion (§48.2.4).

**Dual-user simultaneous verification (contract #73):** When two accounts are suspected of being the same person, both must verify at different physical locations within a synchronized time window. This is available to sortition juries and automated Sybil enforcement. It cannot be disabled by governance vote.

**Biometric password dance (§70.5):** A unique physical gesture sequence registered at account creation, used for high-stakes verification. Not stored centrally — only the hash. Re-registration requires guardian approval.

### 84.4 Layer 4 — Context-Weighted Voting

Raw vote counts don't determine outcomes. Effective vote weight depends on (§11, §19, contract #55):

- **Time since verification** — fresh accounts have zero governance weight for 14 days AND 10 domain-relevant commits
- **Branch-specific participation depth** — your vote on a branch weighs more if you've contributed evidence there
- **Recency** — vote decay half-life of 30 days prevents permanent entrenchment
- **Evidence-contributing history** — "likes" don't build weight; evidence-backed commits do

**Result:** 500 fresh Sybil accounts get near-zero effective weight. A single Anchor-tier domain expert outweighs them all.

**Hysteresis + settlement windows (§7.7, §19.2):** Threshold actions require sustained supermajority across a settlement window, not momentary spikes. This prevents flash-mob coordination from flipping reality.

### 84.5 Layer 5 — Cluster Detection (Behavioral Tripwires)

Most Sybil attacks reuse infrastructure. Relay tracks non-identifying clustering signals — not who you are, but whether many accounts behave identically:

| Signal | What It Detects | Privacy Impact |
|--------|----------------|---------------|
| Timing regularity | Bot-like commit patterns (exact intervals, synchronized bursts) | None — pattern only, no content |
| Invite-chain topology centrality | Single source spawning many accounts | None — graph metric only |
| Proximity/Wi-Fi/BLE overlap | Many "different" accounts always near the same device | Aggregated — no individual tracking |
| Behavioral fingerprint | Identical navigation patterns, identical vote sequences | Pattern hash only — no raw data stored |
| Leaf promotion rate anomaly | Coordinated leaf spam forcing false promotions | §83.5 immune trigger |
| Confidence drop rate | Mass evidence withdrawal attack | §83.5 immune trigger |
| New-account commit share | Fresh accounts dominating a branch's commit volume | §83.5 immune trigger (threshold: 30%) |

**When a cluster trips thresholds:**

1. Flagged accounts are down-ranked (not deleted — append-only, contract #1)
2. Their votes are excluded above COMPANY LOD
3. Their content is hidden behind default filters until reverification
4. Cases are escalated to sortition review (§46)
5. The cluster itself becomes visible geometry — heat + storm overlays on the affected branches

**What is NOT done:** No accounts are silently deleted. No content is invisibly suppressed. No shadow bans. The flagging itself is a filament. The down-ranking is visible. The appeal path (sortition) is always open. Transparency is the immune system.

### 84.6 Layer 6 — Community Enforcement

Sortition juries are the circuit breaker (§46, contract #68):

- When someone contests a Sybil flag or fraud claim, a randomly selected jury decides
- 4:3:3 ratio: 40% random selection, 30% volunteer, 30% historic pool
- Verdicts are logged as committed filaments
- Bad-faith jurors lose trust eligibility over time
- No founder decree, admin action, or majority vote can override a jury verdict

**Users help by:** serving on juries honestly, flagging synchronized behavior through civic observation filaments (§61), refusing to guardian unknown accounts, and participating in reverification norms.

### 84.7 Layer 7 — Self-Auditing Geometry

Even if an attacker gets some influence, Relay makes the attack visible:

- Vote graphs, invite-chain graphs, cluster heat, and sudden parameter shifts are all filaments
- Anomalies create weather (storms) that trigger investigation
- The immune detection trigger (§83.5) fires when: heat + fog exceed thresholds, leaf promotion rate spikes, new-account commit share exceeds 30%, or confidence drops rapidly
- The attack attempt becomes geometry — visible to every user at the appropriate LOD
- Replay (§15) lets anyone rewind and watch the attack unfold step by step

**The key principle:** Attacks cannot be hidden. If someone tries to steer the world, the steering effort becomes visible structure. The shape of the tree IS the audit.

### 84.8 Day-0 Legal Compliance

Relay must comply with existing laws from launch (contract #51):

| Requirement | How Relay Meets It |
|------------|-------------------|
| GDPR right to erasure | Cryptographic erasure (§48.7, §65) — encryption key destroyed, data becomes unreadable while Merkle chain stays intact |
| CCPA data access | User tree IS the data — full export through tree traversal |
| COPPA/KOSA child safety | Age bracket verification, parental governance, grooming prevention (§63, contract #155) |
| KYC / identity verification | Trust tier system with progressive verification (§48.2.4) |
| Election law (where applicable) | Relay governance is not a legal election — it is platform governance. Where legal elections are modeled, jurisdiction-specific templates define compliance rules |
| Data residency | Microsharding with jurisdiction-aware shard placement (§66) |
| Accessibility | WCAG 2.2 AA (§62, contract #154) |

**No Relay instance may accept external users without a published legal posture document** (contract #51). This is a deployment blocker, not a suggestion.

**Contract #207 — Anti-Fraud Defense Stack. Relay's Sybil resistance operates as a seven-layer stack: (1) read/influence separation by identity tier, (2) invite-chain gated account creation with topology visibility, (3) periodic reverification with dual-user simultaneous verification for suspected duplicates, (4) context-weighted voting with fresh-account cooldown and vote decay, (5) behavioral cluster detection using non-identifying signals with sortition escalation, (6) community enforcement through sortition juries with logged verdicts, (7) self-auditing geometry where attack attempts become visible structure. No layer depends on a single mechanism. No account is silently deleted. Every flag, down-rank, and verdict is a committed filament. The defense is transparent, auditable, and replayable.**

---

## 85. Adversarial Stress Hardening — Frozen Contracts #208–215

> *"Everyone has a plan until they get punched in the mouth."* — Mike Tyson

This section addresses the structural, governance, and economic stress cases identified during adversarial review. Each subsection identifies a specific failure mode and specifies the defense. No new physics — only hardening of existing mechanics.

### 85.1 Projection Thrash Prevention — Contract #208

**The problem:** On a hot branch with thousands of projections, every new commit invalidates all cached projection results. At 10,000 users × 500 projections on a high-activity branch, even with memoization, recomputation thrashes the system.

**The fix:** Projections recompute at timebox boundaries, not per commit.

```
projectionInputHash = hash(set of filament commitIds within scope at timebox T)
```

A projection's cached result is valid as long as `projectionInputHash` hasn't changed. New commits within a timebox do NOT trigger recomputation — only the timebox close event does. Users see a "stale projection" indicator between timebox closes on hot branches. This converts O(commits) recomputation into O(timeboxes) recomputation.

**Contract #208 — Projection results are cached per timebox boundary. Recomputation triggers only when the projection input hash (set of in-scope filament commit IDs) changes at timebox close. Mid-timebox commits display a staleness indicator on affected projections but do not trigger recomputation. The projection evaluation time budget (50ms) and recursion cap (3) remain frozen.**

### 85.2 Archive Strata Collapse — Contract #209

**The problem:** At 20-year global scale, billions of filaments per branch make replay and cross-section expansion pathological. Merkle compression preserves hashes but doesn't reduce query depth.

**The fix:** Deterministic strata collapse at defined depth thresholds.

| Archive Depth | Stratum | What Happens |
|--------------|---------|-------------|
| 0–2 years | **Living archive** | Full filament detail, full replay |
| 2–5 years | **Warm archive** | Per-timebox summary aggregates + Merkle proofs. Individual filaments available on-demand (rehydration gate). |
| 5–20 years | **Cold archive** | Per-epoch summary only. Timebox detail available through rehydration request (latency budget: 5 seconds). |
| 20+ years | **Heartwood** | Hash-only stubs. Content reconstruction requires full rehydration from shard network. Latency budget: 30 seconds. |

**Strata collapse is deterministic:** given the same commit history, the same collapse is produced. Collapse never destroys data — it compresses representation while preserving Merkle proofs. Any stratum can be rehydrated to full detail on demand.

**Contract #209 — Archive strata collapse at defined depth thresholds: living (0-2y), warm (2-5y), cold (5-20y), heartwood (20y+). Collapse is deterministic and never destroys data. Every stratum retains Merkle proofs. Rehydration to full detail is available on demand with defined latency budgets. Collapse thresholds are Category A global parameters.**

### 85.3 Detection Mesh Legal Safeguard — Contract #210

**The problem:** Even with on-device processing and metadata-only transmission, if camera detection metadata can be combined with location and presence, regulators may classify it as biometric surveillance infrastructure.

**The fix:** Two hard rules.

1. **Detection metadata is sap-class by default.** Camera classification output (element type, confidence, timestamp) is a SapPacket (§82.3) — overwritable, TTL-governed, never persisted without explicit checkpoint. It does not automatically become a filament.

2. **No automatic filament creation from camera detection without human confirmation.** The SCV may propose that a detection event become a committed filament (e.g., "fire detected — create incident report?"), but the human must confirm. This prevents "Relay auto-logs everything happening in the world."

**Contract #210 — Camera detection output is sap-class by default: ephemeral, TTL-governed, never auto-committed. No filament is created from detection metadata without explicit human confirmation. SCV may propose; human decides. This applies to all detection types: object recognition, pet behavior analysis, environmental sensing, and spell gesture detection.**

### 85.4 Governance Quorum Safeguard — Contract #211

**The problem:** If 5% of power users continuously vote on every parameter while 95% never touch them, the weighted median becomes a reflection of a hyper-engaged minority. This is not malicious capture — it is statistical capture.

**The fix:** Participation quorum per parameter class.

```
if activeVoterCount(param) < quorumThreshold × activeUserBase(scope)
    → param enters QUORUM_INSUFFICIENT state
    → current value freezes until participation rises above threshold
    → visual: parameter badge shows amber "low quorum" indicator
```

**Quorum thresholds (Category A, community-governed):**

| Parameter Scope | Default Quorum | Rationale |
|----------------|---------------|-----------|
| Global | 10% of active Tier 1+ users | System-wide parameters need broad input |
| Regional | 15% of active regional users | Regional decisions need regional participation |
| Template | 20% of active template users | Domain experts must weigh in on domain rules |
| Branch | 30% of active branch contributors | Local parameters need local voices |

A parameter in QUORUM_INSUFFICIENT state is not frozen forever — it unfreezes the moment quorum is met. The quorum mechanism incentivizes participation without punishing quiet periods.

**Contract #211 — Every governance parameter requires minimum voter participation (quorum) relative to the active user base at its scope. Parameters below quorum freeze at their current value until participation rises. Quorum thresholds are Category A parameters. The existence of a quorum requirement is frozen.**

### 85.5 Jury Fatigue Prevention — Contract #212

**The problem:** Over 5+ years, high-trust users are pulled into many juries. Even with rotation caps (contract #77: 2 consecutive terms, 6-month cooldown), cumulative annual service can cause fatigue, reduced attention, and poor verdicts.

**The fix:**

```
annualJuryLoad(user) = Σ juryHoursServed in trailing 365 days

if annualJuryLoad > maxAnnualHours → mandatory jury sabbatical (6 months)
```

| Metric | Default Value | Governance |
|--------|-------------|-----------|
| Max annual jury hours | 120 hours | Category A |
| Sabbatical duration | 6 months | Category A |
| Jury training requirement | 1 Flow module per year | Category A |

**Jury training:** Every active jury-eligible user must complete one jury-training Flow module (§18) per year to maintain eligibility. The training covers: evidence evaluation, bias detection, scar history reading, and verdict commitment rules. Training completion is a filament on the user's tree.

**Contract #212 — Jury-eligible users have a maximum annual service load (default: 120 hours). Exceeding it triggers mandatory sabbatical. Annual jury training via Flow module is required to maintain eligibility. Both thresholds are Category A parameters. The existence of fatigue prevention is frozen.**

### 85.6 Monster Economy Grounding — Contract #213

**The problem:** If monster spawn rate and reward magnitude are both median-governed, multi-epoch drift can cause runaway inflation even with a 20% rate-of-change cap.

**The fix:** Tie reward issuance to real-world filament absorption.

```
monsterRewardBudget(epoch) = k × totalAbsorbedRealWorldMagnitude(epoch)

where:
    k = reward-to-productivity ratio (Category A parameter, default: 0.01)
    totalAbsorbedRealWorldMagnitude = Σ magnitude of non-arena ABSORBED filaments
```

If real-world contribution drops (fewer resolved invoices, fewer closed cases, fewer completed courses), monster rewards throttle automatically. The virtual economy cannot outgrow the truth economy.

**Contract #213 — Monster economy reward budget per epoch is bounded by a function of real-world filament absorption magnitude. The reward-to-productivity ratio is a Category A parameter. Virtual economy issuance cannot exceed truth economy productivity. The grounding mechanism is frozen; the ratio is votable.**

### 85.7 Anchor Allowance Anti-Gaming — Contract #214

**The problem:** Organizations could game Anchor Allowance through idle-clicking employees, fake presence loops, or proximity beacons in closets.

**The fix:** Three diversity requirements.

1. **Minimum meaningful activity threshold:** Commits counted toward Anchor Allowance must include evidence-bearing filaments (not just presence or reactions). Leaf-only activity does not count.

2. **Cross-branch contribution diversity:** At least 3 distinct branches must show activity. Single-branch idle farming is excluded.

3. **Presence pattern anomaly detection:** The immune detection trigger (§83.5) applies to Anchor Allowance qualification. Bot-like timing regularity, single-device multi-account patterns, and proximity-without-commits are flagged.

**Contract #214 — Anchor Allowance qualification requires evidence-bearing commits across at least 3 distinct branches. Leaf-only activity and presence-only signals do not count. Immune detection triggers (§83.5) apply to Anchor Allowance computation. Gaming attempts are visible as geometry.**

### 85.8 Cross-Region Feature Negotiation — Contract #215

**The problem:** Regions can disable features (game layer, detection mesh, specific templates). When users cross regional boundaries, asymmetric feature availability creates friction. A duel initiated in Region A (game layer enabled) involving a user from Region B (game layer disabled) has no resolution path.

**The fix:** Automatic capability negotiation at boundary crossing.

```
when user crosses region boundary:
    effectiveFeatures = intersection(userRegion.enabledFeatures, targetRegion.enabledFeatures)
    
    if requiredFeature ∉ effectiveFeatures:
        action is refused with visible explanation
        user sees which region disabled it and the governance path to request change
```

**Rules:**
- Cross-region interactions use the **intersection** of both regions' feature sets — the most restrictive combination applies
- Arena matches between regions require both regions to have game layer enabled
- Cross-region evidence links work regardless of feature settings (truth layer is never gated by feature flags)
- The feature negotiation is visible — users always know why something is unavailable and which governance vote controls it

**Contract #215 — Cross-region interactions use the intersection of both regions' enabled feature sets. Truth-layer operations (evidence links, filament references, Merkle verification) are never gated by regional feature flags. Feature unavailability is always visible with governance attribution. Arena and game-layer interactions require mutual regional enablement.**

### 85.9 Missed Opportunities — Adopted Enhancements

**Civilization Energy Dashboard:**

The energy budget (§83.2) aggregates upward:

```
civilizationEnergyBalance = Σ photosynthesis(all trees) − Σ gravity − Σ wilt
```

Rendered as a global indicator at GLOBE LOD: green glow (growing civilization), amber (stagnant), red (declining). This is not a new metric — it is Equation 12 applied at maximum aggregation. No new physics.

**Structural Entropy Visualization (no new metric):**

High fog + high wilt regions render with fractal edge noise on bark surfaces. High firm + low fog regions render with smooth, clean surfaces. This is aesthetic mapping of existing physics — users intuitively feel order vs. chaos without a new number.

**Scar Density Heatmap:**

Scar density per branch per epoch is already computable from existing data. Render as a heatmap overlay: high scar density = red-hot bark. Scar recurrence clustering (same branch, repeated scars) surfaces organizational instability. This is a lens (read-only, contract #192).

**Intent Layer:**

Every filament may carry an optional `intentStatement` — a short, immutable, append-only text field: "Why this commit exists." Not editable after commit. Not required. When present, it becomes a philosophical stratum — in 200 years, historians see not just what was done but what people believed they were doing. Intent statements are searchable and projectable.

---

## 86. Infrastructure Sustainment & Treasury Model — Frozen Contracts #216–222

> *"Relay coordinates truth. It does not extract rent."* — Relay

Relay cannot be free at launch. Hosting, storage, compute, security, legal defense, and infrastructure redundancy cost money. If Relay becomes civilization infrastructure, it must be economically sustainable. The Pricing Module funds infrastructure only. It must never control governance, truth, or physical supply.

### 86.1 Infrastructure Sustainment Rate (ISR) — Contract #216

The ISR is Relay's global economic sustainment mechanism — analogous to a credit card processing fee, not a tax.

```
ISR(t) ∈ [0.00%, 1.00%]
```

**ISR applies only to:**
- TransferPacket transactions with economic settlement
- Commercial branches
- Marketplace and finance template operations

**ISR does NOT apply to:**
- Votes and governance packets
- Civic emergency branches
- Healthcare clinical events
- Education core branches
- Pure truth commits (non-economic filaments)
- Internal organizational transfers within a single tree

**Fee equation:**

For any eligible TransferPacket:

```
infrastructureFee = transactionAmount × ISR
```

The fee is recorded as an explicit third leg — never a hidden deduction:

```
TransferPacket {
  debit:   { account: payer,                    amount: -X }
  credit:  { account: receiver,                 amount: +X }
  fee:     { account: relay.system.treasury,    amount: X × ISR }
}
```

All fees are visible, immutable, Merkle-anchored, and traceable in cross-section. No silent extraction. Every fee filament is auditable.

**Default ISR at Genesis:** 0.30% (voted upon by community from day one).

**Contract #216 — Infrastructure Sustainment Rate (ISR). Relay levies a transparent, deterministic fee on economic TransferPackets only. ISR is constitutionally capped at 1.00%. ISR never applies to votes, governance, civic emergency, healthcare, education, or non-economic truth commits. Every fee is recorded as an explicit third-leg filament on the treasury tree — visible, immutable, auditable. The constitutional cap is frozen. The rate within the cap is community-governed.**

### 86.2 ISR Governance — Meta-Vote Control

Changes to the ISR require:

| Requirement | Value |
|------------|-------|
| Vote type | Layer 3 MetaVote (§72) |
| Supermajority threshold | ≥ 70% of eligible voters |
| Voting window | 3 epochs |
| Cooling-off period | 1 epoch after vote closes |
| Modification lock | 6 months after any ISR change |
| Quorum | Per §85.4 governance quorum rules |

**The 0% Transition (The Off Switch):**

The community may vote ISR to 0%. This requires:

- ≥ 85% supermajority global vote
- Once triggered, ISR phases down over 24 months (linear decline, not instant cut)
- Phase-down is irreversible once committed — prevents oscillation
- After phase-down completes, ISR re-enablement requires a fresh Layer 3 MetaVote at ≥ 70%

This ensures Relay can become free when the community decides it is self-sustaining, without sudden treasury collapse.

### 86.3 Founder Bootstrap Window — Contract #217

For the first 5 years from Genesis:

The Founder may adjust ISR within **±0.20%** of the current community-voted value.

**Requirements for any Founder adjustment:**
- A `ResponsibilityPacket` must be published explaining the rationale
- Justification must be explicit and evidence-linked
- Every override creates a visible "Executive Adjustment" scar on the treasury branch
- Override is logged as a committed filament — permanent, auditable, never erasable

**After 5 years from Genesis:**
- Founder override authority is **permanently and automatically removed**
- No mechanism exists to re-enable it
- The removal is hardcoded into the bootstrap window — not votable, not extendable

**Emergency Legal Defense Clause (within bootstrap window):**

If `legalExpenseRate > 3× baselineRate` (a defined threshold):
- Temporary ISR increase of ≤ +0.05% is permitted
- Automatically expires within 12 months
- Must be ratified by MetaVote within 2 epochs
- Failure to ratify → automatic rollback to pre-emergency ISR

This is a defense mechanism, not a revenue stream.

**Contract #217 — Founder Bootstrap Window. For the first 5 years from Genesis, the Founder may adjust ISR within ±0.20% of the community-voted value. Every adjustment requires a published ResponsibilityPacket and creates a permanent scar. After 5 years, Founder override authority is permanently removed — not votable, not extendable. Emergency legal defense ISR increases (≤ +0.05%) require MetaVote ratification within 2 epochs and auto-expire within 12 months. The sunset is frozen.**

### 86.4 Branch-Level Operational Rates — Contract #218

Each branch may define its own operational rate, independent of the global ISR:

```
branchOperationalRate ∈ [0.00%, branchRateCap]
```

**Examples:**

| Branch Type | Typical Rate | Governance |
|------------|-------------|-----------|
| Arena tournament | 1.0% | Branch owner or branch MetaVote |
| Commerce marketplace | 0.5% | Template default, branch MetaVote adjustable |
| Educational hosting | 0.2% | Template default, branch MetaVote adjustable |
| Civic emergency | 0.0% | Funded via civic treasury, rate locked at 0% |
| Healthcare clinical | 0.0% | Exempt by constitutional rule |

**Rules:**
- Branch rates do NOT override ISR — they stack independently (`totalFee = ISR + branchRate`)
- Branch rates must be explicitly declared in the tree template
- Branch rates are governed via branch-level MetaVote (or owner decision for private trees)
- Branch rate caps are Category A parameters at the template level
- Fee revenue from branch rates stays within the branch treasury — it does not flow to Relay's global treasury

**Contract #218 — Branch-Level Operational Rates. Each branch may define its own operational rate, stacking independently with the global ISR. Branch rates are governed at the branch level. Branch fee revenue remains in the branch treasury. Healthcare and civic emergency branches are constitutionally exempt. Rate caps are Category A template parameters. The fractal pricing structure is frozen.**

### 86.5 Resource-Based Pricing — Contract #219

Beyond transaction fees, Relay meters actual resource consumption:

```
computeCost  = Σ(cpu_ms × computeRate)
storageCost  = Σ(bytes × retentionPeriod × storageRate)
renderCost   = Σ(gpu_ms × renderRate)
```

**What users see:**
- Branch resource meter (live consumption indicator)
- Storage depth indicators (how much archive exists)
- Projection load indicators (compute cost of running projections)

**Resource rates** are Category A parameters — community-governed, transparent, published.

**Purpose:**
- No one can DDoS economically without proportional cost
- Heavy users pay proportionally to their actual resource consumption
- System self-balances: if storage is cheap, rate drops; if compute is scarce, rate rises
- Projection-heavy branches see real cost feedback — incentivizing efficient projection design

Resource costs are billed per timebox and recorded as filaments on the branch's resource ledger.

**Contract #219 — Resource-Based Pricing. Relay meters compute, storage, and render consumption. Resource rates are Category A parameters. Costs are billed per timebox and recorded as filaments. Heavy usage scales proportionally. Resource pricing is deterministic, transparent, and self-balancing.**

**Game-layer resource flows — closing the economic loops:**

| Flow | Source | Sink | Treasury Impact |
|------|--------|------|-----------------|
| **Crafting token purchase** | User pays real money → TransferPacket with ISR | Tokens credited to user's crafting wallet | ISR fee (0.30%) flows to infrastructure.revenue |
| **Crafting token spend (finalization)** | User spends tokens | 70% flows to `infrastructure.compute` (covers ongoing render costs of the graphic); 30% burned (removed from circulation) | Net deflationary — prevents token inflation |
| **Summon AI compute** | Elite-tier creature decisions during combat | Metered as compute cost per decision cycle at the SCV tier used (§92) | Billed to the summoner's tree per timebox via standard resource pricing |
| **Arena branch operational rate** | Arena tournaments collect entry fees (EC-denominated) | Prize pool distributed to winners; operational surplus funds arena branch maintenance | Entry fee split: 80% prize pool, 20% branch operations (Category A parameters) |
| **Monster reward budget** | Virtual monster kills yield EC/AT | Budget bounded by k × real-world absorbed magnitude (§85.6) | Arena duel outcomes count as "real-world absorbed magnitude" when they trigger governance consequences (§42.1) |

The 70/30 crafting token split (infrastructure allocation vs. burn) is a Category A parameter — the community can adjust the ratio. The burn mechanism prevents unbounded token accumulation. The infrastructure allocation covers the real GPU cost of rendering finalized graphics every time they are displayed to spectators.

### 86.6 Treasury Transparency — Contract #220

Relay maintains a system tree visible to all users:

```
tree.system.relay
```

**Treasury branches:**

| Branch | Purpose |
|--------|---------|
| `infrastructure.revenue` | ISR fee inflows |
| `compute.expense` | Server and processing costs |
| `storage.expense` | Data retention costs |
| `legal.reserve` | Legal defense fund |
| `development.fund` | Development and audit funding |
| `contingency.fund` | Emergency reserve |

Every expense and inflow is a committed filament. Treasury health obeys the same physics as any branch:

- **Heat** = spending spikes
- **Wilt** = reserve depletion (open obligations without resolution)
- **Fog** = unclear or unlinked liabilities
- **Lean** = concentration of revenue source or expense category
- **Dormancy** = unused reserve (healthy quiet)

If the treasury wilts — everyone sees it. If infrastructure overheats — the community knows fees may need adjusting. The treasury is self-monitoring geometry.

**Founder responsibility:** The Founder is responsible for managing contracts and ensuring hosted data requirements are met by verifiable receipts. All hosting contracts, vendor agreements, and infrastructure costs are committed as filaments with evidence attachments. The Founder's stewardship is visible as tree health — not hidden behind reports.

**Contract #220 — Treasury Transparency. Relay's treasury is a public system tree (`tree.system.relay`) with defined branches for revenue, expenses, reserves, and contingency. Every financial event is a committed filament. Treasury health is rendered using the same physics as any branch. All hosting contracts and vendor agreements are evidence-linked filaments. The treasury's structural visibility is frozen.**

### 86.7 Accumulation Ceiling — Contract #221

Relay may not hoard infinite capital.

```
if treasuryBalance > 12 × annualOperatingCost:
    → automatic MetaVote triggered to reduce ISR
    → proposal must be published within 1 epoch

if treasuryBalance > 24 × annualOperatingCost:
    → ISR automatically reduced by 0.05% per epoch
    → until balance falls below 18× threshold
    → no vote required — this is a hard circuit breaker
```

**Purpose:** Relay funds infrastructure. It does not accumulate disproportionate capital. The accumulation ceiling ensures that excess revenue is returned to the community through rate reduction, not retained as a power base.

`annualOperatingCost` is computed as the trailing 12-month sum of all expense-branch filament magnitudes — deterministic, auditable, not estimated.

**Contract #221 — Treasury Accumulation Ceiling. If treasury balance exceeds 12× annual operating cost, an automatic ISR reduction MetaVote is triggered. If balance exceeds 24×, ISR auto-reduces by 0.05% per epoch until balance falls below 18×. Annual operating cost is the trailing 12-month expense sum. The ceiling mechanism is frozen; the multiplier thresholds are Category A parameters.**

### 86.8 Pricing Invariants — Contract #222

These invariants are absolute and frozen:

1. **Pricing never alters governance weight.** Paying more ISR does not increase vote power.
2. **Pricing never alters confidence.** Fee payment does not affect filament confidence scores.
3. **Pricing never alters lifecycle state.** Non-payment does not auto-close or wilt filaments.
4. **Pricing cannot suppress truth commits.** A filament with evidence cannot be blocked by fee status.
5. **ISR applies only to economic transfer events.** Non-economic filaments are structurally exempt.
6. **Fee visibility is absolute.** No fee may be charged without a visible, auditable filament.
7. **Branch rates stay in branch treasuries.** Global ISR flows to `tree.system.relay`. Branch rates flow to branch treasuries. No cross-contamination.
8. **Pricing does not create class hierarchy.** Free-tier access to truth, governance, civic, health, and education is constitutionally guaranteed. Pricing applies only to commercial economic activity.

**Contract #222 — Pricing Invariants. Pricing never alters governance weight, confidence, lifecycle state, or truth commit availability. ISR applies only to economic transfers. All fees are visible filaments. Branch rates stay in branch treasuries. Free-tier access to truth, governance, civic, health, and education is guaranteed. These invariants are frozen.**

### 86.9 Live Download Pricing — Contract #234

Relay has no pricing tiers. No free/basic/premium/enterprise. One app. One price. The price is a live measurement of the treasury tree's health.

**The equation:**

```
downloadPrice = max(0, (annualOperatingCost − annualISRrevenue − annualResourceRevenue) / projectedNewUsersThisYear)
```

The download price is the **unfunded gap per user.** If the system pays for itself, the price is zero.

**How it works:**
- `annualOperatingCost` = trailing 12-month sum of all expense-branch filament magnitudes on `tree.system.relay`
- `annualISRrevenue` = trailing 12-month sum of ISR fee inflows
- `annualResourceRevenue` = trailing 12-month sum of resource pricing inflows (compute, storage, render)
- `projectedNewUsersThisYear` = trailing 12-month new user registration rate, projected forward

Every input is a committed filament on the treasury tree. Every number links to its source. One click. Full audit.

**What users see on relay.world:**

The download page displays the live price alongside its derivation:

```
Operating cost this month:      $4,200
ISR revenue this month:         $1,800
Resource revenue this month:    $400
Active users:                   8,400
Unfunded gap per new user:      $12.37
```

Every number is a link to the treasury tree filament. No "trust us" — trust the tree.

**Price behavior over time:**

| Scale | Typical Price | Why |
|-------|-------------|-----|
| First 1,000 users | $30–$50 | ISR revenue near zero, infrastructure costs real |
| 10,000 users | $5–$10 | ISR beginning to cover costs |
| 50,000+ users | $0 | ISR + resource pricing exceeds operating costs |

Early adopters are investing in the system's birth — and they can see exactly where their money goes. The price dropping is public proof that Relay is working. When it hits $0, that's a milestone the whole community celebrates.

**Contract #234 — Live Download Pricing. Relay has no pricing tiers. The download price is a single live-calculated value: the unfunded operating gap per projected new user, floored at zero. Every input to the formula is a committed filament on the public treasury tree. The price is displayed on relay.world alongside its full derivation with links to source filaments. When ISR and resource revenue exceed operating costs, the download price is $0. No tiers, no SKUs, no "contact sales." The single-price model is frozen.**

### 86.10 Crowdfunded Operations Model — Contract #235

The live download pricing model is not unique to Relay — it is Relay's native model for **any crowdfunded operation or project.**

Every tree in Relay that accepts contributions follows the same pattern:

```
projectPrice = max(0, (operatingCost − revenue − contributions) / projectedParticipants)
```

**How any project uses this:**

1. **Create a project tree** from the appropriate template
2. **Declare operating costs** as committed filaments on an expense branch (rent, materials, labor, licensing — all evidence-linked)
3. **Declare revenue sources** as inflow filaments (ticket sales, grants, ISR from sub-transactions, donations)
4. **The gap is the price.** The template auto-calculates what each new participant needs to contribute for the project to be funded.
5. **The price is live.** As contributions arrive, the price drops. When fully funded, the price hits $0. Overfunding triggers the accumulation ceiling logic — excess returns to contributors or reduces future pricing.

**Examples:**

| Project Type | Operating Cost Source | Revenue Source | Price Meaning |
|-------------|---------------------|---------------|---------------|
| **Open source software** | Hosting, dev salaries | Donations, grants | Cost per user to keep the project alive |
| **Community event** | Venue, equipment, permits | Sponsorships, ticket sales | Ticket price adjusts as sponsors arrive |
| **Neighborhood project** | Materials, labor | Municipal grant, resident contributions | Per-household cost drops as grants are secured |
| **Film production** | Production budget | Distribution deals, crowdfunding | Backer price adjusts as deals close |
| **Research lab** | Equipment, personnel | Grants, institutional funding | Per-supporter gap to reach funding |
| **Cooperative business** | Startup costs | Member buy-ins, early revenue | Membership price adjusts with traction |

**The rules:**
- All costs must be evidence-linked filaments — no "miscellaneous $50K" without receipts
- All revenue must be verifiable inflows — no phantom contributions
- The price formula is visible on the project tree — anyone can audit it
- Overfunding is governed by the same accumulation ceiling principle (§86.7) — projects cannot hoard
- The price updates per timebox, not per second (prevents manipulation through rapid micro-contributions)
- Contributors receive a contribution filament on their own tree — permanent proof of participation

**This is how Relay itself launched.** The download price on relay.world is the first instance of this model. Every project that follows uses the same equation, the same treasury branch structure, the same transparency. Relay's own pricing is the template.

**Contract #235 — Crowdfunded Operations Model. Any project tree in Relay can adopt live gap-based pricing: the unfunded operating gap per projected participant, floored at zero. All costs and revenue must be evidence-linked filaments. The price formula is visible and auditable. Overfunding triggers accumulation ceiling logic. Price updates per timebox. Contributors receive permanent proof-of-participation filaments. This model is the native funding mechanism for all crowdfunded operations in Relay. Relay's own download pricing is the first instance. The crowdfunded operations model is frozen.**

### 86.11 Genesis Contributors — Contract #236

Every person who pays for Relay before the download price reaches $0 is not a customer. They are a **genesis contributor** — a funder of the system's birth.

**Where contributions live:**

Genesis contributors are recorded as **standard filaments** on Tree Zero that follow normal physics:

- **Purchase filaments** land on `tree.system.relay → infrastructure.revenue` as standard financial inflows. They follow gravity. They sink over time. They become roots. They become heartwood. They are findable through root archaeology like any other historical record — because that is where history belongs.
- **Development contributors** (users who help build Relay) are recorded on `tree.org.relay-hq → dev.*` branches as standard commit filaments. Code contributions, architecture reviews, bug fixes, documentation — all standard filaments following standard physics.

Tree Zero is a **working company tree.** It must stay operationally clean. No special flags. No gravity exemptions. No physics violations. Contributors are honored by being part of the tree's real history, not by being pinned to the surface.

**What genesis contributors receive:**

1. **A filament on Tree Zero's treasury branch.** Their purchase is a standard inflow filament. It sinks under gravity like everything else. In 20 years it's in the roots. In 50 years it's heartwood. That's correct — it's history, and history sinks.

2. **Optional public attribution.** The contributor may choose to make parts of their purchase filament public:
   - Name or pseudonym
   - Contribution amount
   - An `intentStatement` (§85.9): why they believed in Relay before it was free. Immutable. Append-only.

3. **Sequential contributor number.** Genesis Contributor #1, #2, #3... A committed filament. The sequence is the order in which people believed.

4. **The genesis ring.** The period during which Relay charged for downloads becomes a distinct timebox ring on Tree Zero's trunk. When the price hits $0, the ring closes. The ring is inspectable — drill into the cross-section and see every contributor. The ring sinks inward over time like every other ring. In 200 years it's deep in the core. Archaeologists drill down and find the people who funded the birth.

**What genesis contributors do NOT receive:**
- No extra governance weight. Contribution does not buy votes.
- No extra confidence. Money does not buy truth.
- No privileged access. The system is the same for everyone.
- No gravity exemptions. The tree's physics are sacred.

**When the price hits $0:**

A `GenesisSealEvent` filament is committed on Tree Zero's governance branch:
- Total number of genesis contributors
- Total amount contributed
- Duration of the genesis period
- The exact moment ISR revenue exceeded operating costs

**Contract #236 — Genesis Contributors. Every user who purchases Relay before the download price reaches $0 is a genesis contributor. Their purchase is a standard filament on Tree Zero's treasury branch following normal gravity. Optional public attribution including name, amount, and intent statement. Sequential contributor number. The genesis period forms a distinct timebox ring that closes with a GenesisSealEvent when the price reaches $0. No governance weight, confidence, feature access, or gravity exemptions are conferred. Contributors are honored by being part of Tree Zero's real history. The genesis contributor model is frozen.**

### 86.12 Self-Hosted Development — Contract #237

Tree Zero (`tree.org.relay-hq`) is not a museum. It is a **working company tree** that runs Relay's development, operations, and governance. The founder continues to commit to it. Contributors continue to commit to it. It grows, wilts, heals, and evolves like any living tree.

**The transition:**

Relay development begins in external tools (Cursor, Git, CLI). But at a defined maturity point, development **must transition to Relay itself:**

```
Phase 0:  Development in Cursor/Git → commits imported to Tree Zero as evidence
Phase 1:  Development in Cursor/Git → commits mirrored live to Tree Zero dev branches
Phase 2:  Development happens ON Tree Zero → external tools become optional
Phase 3:  Tree Zero's dev branches ARE the running system → Relay builds Relay
```

**What "Relay builds Relay" means:**

- The `dev.codebase` branch on Tree Zero contains the actual source code as filaments
- Code changes are commits on those filaments — reviewed, confidence-scored, evidence-linked
- The running system reads its own logic from its own tree
- Bug fixes are filaments. Feature additions are filaments. Architecture decisions are filaments.
- The SCV validates code coherence the same way it validates any other branch

**Who can contribute:**

Development contributions must come from **Relay-approved users** working through Relay's own governance:

- Contributors are recorded on `dev.*` branches as standard filaments
- Code review follows the same confidence mechanics as any evidence evaluation
- Merge decisions follow the same governance as any branch-level vote
- The dev branch has its own template, its own consolidation gates, its own quality metrics
- External pull requests (from GitHub) are imported as evidence-linked filaments — but the authority is the tree, not the external tool

**Why this matters:**

If Relay's own development doesn't run on Relay, the system is not self-consistent. The architecture demands that every organization's truth is visible as tree geometry. Relay the organization is not exempt. Its code, its decisions, its contributors, its expenses — all filaments on a working tree that anyone with access can inspect.

At Phase 3, Cursor and Git become what paper ledgers became after spreadsheets — still available, no longer necessary. The tree IS the development environment.

**Contract #237 — Self-Hosted Development. Tree Zero is a working company tree, not an archive. Relay development transitions from external tools to Relay-internal development in defined phases. At maturity, Tree Zero's dev branches contain the running system logic. Development contributions come from Relay-approved users through Relay's own governance. Code review, merge decisions, and quality metrics follow standard branch physics. The self-hosting transition is frozen as an architectural requirement.**

---

## 87. Scale Invariance Guarantee — Frozen Contracts #223–225

> *"Nature uses only the longest threads to weave her patterns, so that each small piece of her fabric reveals the organization of the entire tapestry."* — Richard Feynman

Relay is designed to serve 10 billion daily active users without changing a single equation. The logic does not scale. The data does. If the equations work for one filament, they work for one trillion filaments. Only storage, bandwidth, and infrastructure fees grow with user count.

### 87.1 Computational Complexity by Operation — Contract #223

Every operation in Relay has a defined complexity class. None scale with total system population.

| Operation | Complexity | Why |
|-----------|-----------|-----|
| Filament commit | O(1) | Append to branch. Hash. Done. |
| Filament read | O(1) | Address lookup by `(treeId, branchId, filamentId)` |
| Confidence computation | O(k) | k = number of evidence links on this filament (bounded by template) |
| Timebox aggregation | O(n) | n = filaments in this timebox on this branch (bounded by cadence) |
| Cross-section render | O(b) | b = branches on this tree (LOD-shed at distance) |
| Gravity sink | O(1) per filament | Age-based position. No neighbor interaction. |
| Lean computation | O(c) | c = counterparties on this branch (bounded by template) |
| Wilt computation | O(1) per timebox | Ratio of open to total. Local. |
| Heat computation | O(1) per timebox | Rate of change. Local. |
| Fog computation | O(1) per filament | 1 − confidence. Local. |
| Storm computation | O(1) per timebox | heat × fog. Local. |
| Projection evaluation | O(scope × depth) | Bounded by 50ms budget + recursion cap 3 + timebox-boundary caching (§85.1) |
| Governance vote | O(1) per vote | Weighted median recomputation is O(v) where v = voters, but settles per epoch, not per vote |
| LeafPacket create/expire | O(1) | TTL-governed. No aggregation. |
| SapPacket emit/overwrite | O(1) | Overwrite in place. No history. |
| Merkle verification | O(log n) | n = commits in chain. Logarithmic by design. |
| Archive strata collapse | O(n/epoch) | Runs once per epoch boundary, not per operation |

**The key invariant:** No operation's complexity depends on `N_total` (total users in the system) or `F_total` (total filaments in the system). Every operation is scoped to its local context: this filament, this branch, this tree, this timebox.

**What scales with user count:**

| Resource | Scales As | Managed By |
|----------|----------|-----------|
| Storage volume | O(N × activity_rate) | Microsharding (§66), archive strata (§85.2), resource pricing (§86.5) |
| Bandwidth | O(N × read_rate) | LOD shedding (§33), CDN federation, regional sharding |
| Treasury ISR revenue | O(N × transaction_rate) | Self-balancing via accumulation ceiling (§86.7) |
| Sap traffic | O(N_concurrent × emit_rate) | TTL expiry, sap-first degradation (§82.5), regional relay nodes |
| Leaf volume | O(N × engagement_rate) | Compost cycle, TTL, promotion gates (§82.2) |

**Contract #223 — Scale Invariance. No Relay equation's computational complexity depends on total system population or total filament count. Every operation is scoped to its local context. Adding users increases data volume and bandwidth, not per-operation compute. The ten universal equations (§3.19) are O(1) per filament. LOD shedding, timebox aggregation, and archive strata collapse bound all aggregation operations. This invariance is frozen.**

### 87.2 Federation Architecture — Contract #224

At planetary scale, Relay operates as a federated system:

```
                    ┌──────────────┐
                    │  Globe Index  │  (lightweight: tree locations + Merkle roots only)
                    └──────┬───────┘
            ┌──────────────┼──────────────┐
     ┌──────┴──────┐ ┌────┴─────┐ ┌──────┴──────┐
     │  Region A   │ │ Region B │ │  Region C   │
     │  Shard Set  │ │ Shard Set│ │  Shard Set  │
     └──────┬──────┘ └────┬─────┘ └──────┬──────┘
        ┌───┴───┐     ┌───┴───┐     ┌───┴───┐
        │Trees  │     │Trees  │     │Trees  │
        └───────┘     └───────┘     └───────┘
```

**Rules:**
- Each tree lives in one primary region (determined by registration geography)
- Cross-region reads use Merkle proofs — the requesting node verifies without trusting the remote shard
- Cross-region writes (evidence links, cross-tree references) use atomic two-phase commit at the filament level
- The Globe Index is a lightweight routing layer: tree location + latest Merkle root per tree. It does NOT store filament data.
- Regional shards are independently scalable — adding capacity to Region A does not affect Region B
- Sap traffic is region-local by default. Cross-region sap requires explicit subscription.

**Degraded mode:** If a region goes offline, all other regions continue operating. Cross-region references to the offline region show "verification pending" status. When the region recovers, Merkle verification catches up automatically. No data loss. (BCP/DRP §67 applies.)

**Contract #224 — Federation Architecture. Relay operates as a federated system with regional shards, cross-region Merkle verification, and a lightweight Globe Index for routing. Each region scales independently. Cross-region operations use cryptographic verification, not trust. Regional failure does not cascade. The federation model is frozen.**

### 87.3 Day-One Load Profile — Contract #225

At 10 billion daily active users with average activity:

| Metric | Estimate | Handling |
|--------|----------|---------|
| Daily filament commits | ~100B (10 per user avg) | Distributed across regional shards. Each shard handles O(millions/sec) append operations. |
| Daily TransferPackets | ~5B (0.5 per user avg) | ISR processing is O(1) per packet. Treasury aggregation is per-timebox. |
| Concurrent SapPackets | ~2B (20% concurrent × 1 per user) | Region-local, TTL-governed, overwrite-in-place. No persistence cost. |
| Active LeafPackets | ~20B (2 per user avg) | TTL-governed, compost cycle. Storage is temporary. |
| Storage growth/day | ~10 PB (100 bytes avg × 100B commits) | Microsharding, strata collapse, resource pricing self-balance |
| Projection recomputes | ~500M/day (at timebox boundaries) | Cached per timebox. 50ms budget per evaluation. Parallelizable across shards. |
| Governance votes | ~50M/day (0.5% of users vote on something) | Weighted median settles per epoch. O(v) per parameter. |

None of these numbers require changes to the equation set. They require infrastructure — servers, storage, bandwidth — which is funded by ISR (§86) and resource pricing (§86.5).

**Contract #225 — Day-One Load Readiness. The architecture supports 10 billion daily active users without modification to equations, contracts, or logic. Scaling is achieved through regional federation, microsharding, LOD shedding, timebox-boundary aggregation, and TTL-governed ephemeral layers. Infrastructure requirements are funded through the ISR and resource pricing. The load profile estimates are planning targets, not hard limits.**

---

## 88. Launch Strategy & Distribution Model — Frozen Contracts #226–228

> *"You do not launch a civilization. You launch a tool people can use on Monday morning."* — Relay

### 88.1 The Ignition Principle

Relay wins if someone uses it once and cannot go back to dashboards.

If that happens, everything else follows.

The architecture is complete. The bottleneck is no longer physics. The bottleneck is distribution, simplicity, first-use experience, and narrative clarity.

### 88.2 Product Packaging — Contract #226

Relay ships as three distribution channels, in order of priority:

**Channel 1 — Relay Desktop (Primary)**

| Attribute | Specification |
|-----------|--------------|
| Platform | Electron-based desktop application (Windows .exe, macOS .dmg, Linux .AppImage) |
| Runtime | Embedded CesiumJS, local SQLite, preloaded templates |
| Installation | Standard OS installer. No CLI. No Git. No Node. No developer tools. |
| First launch | Empty tree + 3 starter branches + guided import wizard (§81.9 first-screen contract) |
| Data import | CSV, Excel, JSON. Drag-and-drop file mapping to Relay templates. |
| Auto-update | Built-in update channel. Silent background updates. |
| Offline | Fully functional offline. Sync when connected. |

If a CFO needs a terminal, you already lost.

**Channel 2 — Relay Web (Phase 2)**

| Attribute | Specification |
|-----------|--------------|
| URL | `relay.world` |
| Access | Invite-gated (§84 anti-Sybil) |
| Storage | Cloud-hosted, regionally sharded |
| Sync | Desktop ↔ Web bidirectional sync |
| Purpose | Collaboration, cross-org tree viewing, public tree browsing |

Web comes after desktop because desktop = perceived control + trust. Enterprise adoption requires "my data is on my machine" before "my data is in the cloud."

**Channel 3 — Developer Build (Parallel)**

| Attribute | Specification |
|-----------|--------------|
| Repository | Public GitHub |
| Purpose | Transparency, auditing, contribution, academic validation |
| Audience | Developers, auditors, researchers |
| NOT for | End-user onboarding |

The developer build is the transparency layer, not the adoption path.

**Contract #226 — Product Packaging. Relay ships as a desktop application first (standard OS installer, no developer tools required), web application second (invite-gated, cloud-synced), and open-source developer build third (transparency and contribution). The desktop-first strategy is the primary adoption path. The packaging order is frozen for initial launch.**

### 88.3 Website Architecture

**`relay.world` — The Narrative**

The website is not documentation. It is a story.

**Landing Page:**

Headline: *The shape is the audit.*

Subtext: *See your company as it really is.*

Three scroll sections showing:
1. A healthy branch (smooth cylinder, balanced confidence)
2. A branch with twigs (unmatched invoices, unresolved items)
3. A wilting branch (missing evidence, integrity deficit)

No technical jargon. No "filament ontology." No "Merkle-anchored append-only commit chain."

**Product Page:**
- How it works (30-second animation)
- Who it's for (CFO, auditor, operations manager, educator)
- Live interactive demo (preloaded sample company tree — fly, click, inspect)
- Download button

**Build History Page — "How Relay Was Built":**

The full development archive revealed as a timeline — not dumped, but narrated:

| Year | Reveal |
|------|--------|
| Year 1 | Geometry — "We started with a cylinder" |
| Year 2 | Filaments — "Every row became a fiber" |
| Year 3 | Confidence — "We taught it to doubt" |
| Year 4 | Governance — "We gave it to the community" |
| Year 5 | Civilization — "We mapped everything" |

This builds trust. People see that this was built methodically, not announced overnight.

### 88.4 Video & Narrative Strategy

You do not start with a 2-hour cinematic. You start with 90-second films.

**Film 1 — "The AP Meeting"**
CFO opens tree. Sees three twigs. Walks into meeting. Doesn't open a spreadsheet. Says: "Why are these three still open?" Cut to black: *The shape is the audit.*

**Film 2 — "The Board"**
Board sees trunk. One branch wilting. No 40-slide deck. The tree IS the deck.

**Film 3 — "The Parent"**
Parent sees Education branch. Teacher's branch leans. Evidence is thin. Changes teacher.

**Film 4 — "The Factory Floor"**
Shift manager sees maintenance branch heat up. Three work orders unresolved. Catches the failure before the line stops.

**Film 5 — "The City"**
Emergency coordinator sees civic branch. Traffic pressure. Hospital branch overloaded. Dispatches resources. The tree IS the dashboard.

Only after traction: long-form cinematic reveal. The story of how one tree became a civilization.

### 88.5 Adoption Sequence — Contract #227

Adoption is phased. Complexity is aggressively hidden.

| Phase | What Ships | Target Audience | What's Hidden |
|-------|-----------|----------------|---------------|
| **Phase 0** | Desktop app with P2P, HR, Contracts templates | Internal audit, CFOs, operations managers | Everything beyond branch geometry, filaments, slabs, twigs, confidence, cross-section |
| **Phase 1** | + Commerce, Manufacturing, Maintenance templates | Process-heavy factories, compliance industries | Game layer, arena, spells, detection mesh, cosmic scale |
| **Phase 2** | + Web app, cross-org tree viewing, Relay Web | Collaborative enterprises, supply chains | Civilization templates, Laniakea, monster economy |
| **Phase 3** | + Education, Property templates | Schools, government offices, property registries | Full fractal scaling, voice development, sortition internals |
| **Phase 4** | + Healthcare, Emergency, Civic templates | Hospitals, emergency services, municipal governments | Arena, atomic accounting, founder key |
| **Phase 5** | + Game layer reveal, AR modules, detection mesh | Global consumer audience | Nothing — full system available |
| **Phase 6** | + Civilization templates, full globe, Laniakea LOD | Everyone | Architecture is fully visible |

**The rule:** 90% of Phase 0 users should never see spell language. 80% should never see founder key. 70% should never see monster economy. 60% should never see sortition internals. Conceptual LOD (§81.8) enforces this — features appear only when the user's context makes them relevant.

**Contract #227 — Adoption Sequence. Relay launches as a desktop accountability tool for enterprises (Phase 0). Complexity is revealed progressively through six phases. Each phase expands audience and feature visibility. Conceptual LOD (§81.8) enforces progressive disclosure. The phase order is frozen. No phase may be skipped in public marketing — you do not advertise civilization before you have adoption.**

### 88.6 Enterprise Wedge Strategy

The first paying customers are:

| Target | Why | Pitch |
|--------|-----|-------|
| Internal audit teams | They already audit — give them geometry instead of spreadsheets | "Replace your dashboard with a tree. Every number traces to a source." |
| CFO offices | They own the data — give them visibility | "See your company's health in 3 seconds, not 3 weeks." |
| Process-heavy factories | They have mass balance problems — Relay solves this natively | "Input minus output should equal zero. The tree shows you where it doesn't." |
| Compliance-heavy industries | They need audit trails — Relay IS an audit trail | "Every filament is evidence. Every cross-section is an audit." |

**Pilot structure:** One branch. One quarter. One real dataset. If the tree reveals something the spreadsheet hid, the pilot is won.

### 88.7 What Not To Do — Anti-Patterns

| Anti-Pattern | Why It Kills Adoption |
|-------------|----------------------|
| Lead with arena/combat | Sounds like a game, not a tool |
| Lead with cosmic scale | Sounds like megalomania |
| Lead with anti-bank theory | Sounds like crypto ideology |
| Lead with copyright reform | Sounds like piracy |
| Lead with civilization templates | Sounds like a cult |
| Require Git/Cursor/CLI | Eliminates 99% of target audience |
| Require blockchain wallet | Triggers crypto fatigue |
| Show the full master plan | 14,800 lines is not a pitch deck |
| Use the word "filament" in marketing | Say "record" or "entry" |
| Use the word "timebox" in marketing | Say "period" or "quarter" |
| Use the word "ontology" anywhere near a customer | Just don't |

### 88.8 Open Source Positioning

GitHub remains:
- **Transparency layer** — anyone can audit the code
- **Contribution layer** — developers submit improvements
- **Academic validation layer** — researchers verify the math

GitHub is NOT:
- The onboarding path
- The installation method
- The marketing channel

The README says: "Looking to use Relay? Download at relay.world." Then technical docs for contributors.

### 88.9 Platform Strategy — Contract #228

Relay is a layer on top of existing operating systems. It is not an OS.

| Platform | Channel | Timeline |
|----------|---------|----------|
| Windows | Desktop app (.exe) | Phase 0 |
| macOS | Desktop app (.dmg) | Phase 0 |
| Linux | Desktop app (.AppImage) | Phase 0 |
| Web | `relay.world` | Phase 2 |
| iOS | Native app | Phase 3 |
| Android | Native app | Phase 3 |
| VR/AR | Headset integration | Phase 5 |

Relay never requires proprietary hardware. Relay never requires a specific browser. Relay never requires a specific OS version beyond reasonable minimums.

**Contract #228 — Platform Strategy. Relay launches on Windows, macOS, and Linux as a desktop application. Web follows in Phase 2. Mobile follows in Phase 3. VR/AR follows in Phase 5. Relay is a software layer, not an operating system. No proprietary hardware is required. The platform-agnostic principle is frozen.**

### 88.10 The Founder Presentation Format — User Sphere Reveal — Contract #321

> *"This is what the system looks like."*

The primary video presentation for Relay follows a deliberate two-act structure designed to transform the viewer's understanding of what software can be.

**Act 1 — The Professional Entry (60-90 seconds)**

The video opens as a normal, polished software product introduction:

- Clean screen recording of a desktop application
- Professional narration explaining what Relay does in familiar terms: "Relay is a new way to organize, verify, and visualize data"
- Standard software demo conventions: UI walkthrough, feature highlights, use-case scenarios
- Footage of the globe, a personal tree, drag-and-drop file import, basic branch navigation
- The viewer thinks: "This is a nice-looking productivity/data tool"

The tone is deliberately understated. No cosmic claims. No civilization rhetoric. Just a professional software demo that a CFO, school principal, or factory manager would watch without flinching.

**Act 2 — The Reveal (transition point)**

At the transition point, the founder says something like: *"But what if I showed you what this actually looks like from the inside?"*

The screen recording dissolves. The founder appears — standing inside a **user sphere**: a transparent navigable bubble floating in the 3D Relay world. The globe is below. Trees are visible. Branches sway. The founder is a full-body 3D presence, filmed in real life (or rendered from volumetric capture), standing inside the sphere in normal clothes, speaking directly to the viewer.

**The User Sphere:**

```
UserSphere {
  occupant:         founder (volumetric video or live camera feed)
  navigation:       free flight — the sphere moves where the founder points/gestures
  transparency:     viewer sees through the sphere walls to the Relay world beyond
  interaction:      founder can reach out and touch/grab branches, filaments, pull up data
  overlays:         AR annotations appear as the founder explains concepts
  scale:            sphere scales from personal-tree level to globe level as the presentation progresses
}
```

**What the founder does from inside the sphere:**

- Flies to their own personal tree: "This is my tree. Every piece of work I've ever done is here."
- Zooms into a branch: "This branch is the Master Plan. Every section is a filament. Watch the physics — see how the branch weight changes as we scroll through time."
- Pulls back to globe view: "Every dot of light you see is someone's tree. Every tree uses the same physics."
- Flies to a municipal tree: "See this branch wilting? That means their infrastructure maintenance is behind schedule. The shape tells you before the report does."
- Enters an arena: "This is where people settle disputes. Or duel for fun. The crowd votes on the terrain."
- Demonstrates a spell cast live from inside the sphere — gestures at a branch, AR effect fires, data changes
- Ends at globe scale: "This is what software looks like when it tells the truth."

**The revelation:** The viewer realizes mid-video that this is not a mockup, not a concept render, not a CGI trailer. This is the actual system. The founder is a user, inside the system, navigating it in real time. Everything they saw in Act 1 (the "normal software demo") was the same system viewed from outside. Act 2 shows it from inside. The professional entry was the tree at LOD C0. The sphere reveal is the tree at LOD C4.

**Production requirements:**

| Component | Method |
|-----------|--------|
| Founder capture | Volumetric video (LiDAR/depth camera) or clean-keyed green screen composited into the sphere |
| Sphere rendering | Real Relay engine running live, with the founder's video feed composited as the sphere occupant |
| Navigation | Pre-scripted flight path through actual Relay data (Tree Zero, the Master Plan branch, live globe) |
| Audio | Founder's live narration recorded simultaneously — conversational, not scripted-feeling |
| Transitions | Smooth camera-to-sphere dissolve at the Act 1 → Act 2 boundary |

**Why this works:**

Act 1 gets the viewer past their skepticism threshold. They're watching a normal software demo. Their guard is down. When Act 2 hits, the scale change is visceral — the viewer's mental model of "data management tool" shatters and reforms as "I am looking at reality rendered as geometry." The founder speaking from inside the sphere makes it personal: this is not a corporation pitching software. This is one person showing you what they built, from the inside.

**Contract #321 — Founder Presentation Format (User Sphere Reveal). The primary Relay presentation follows a two-act structure: Act 1 is a professional software demo in standard screen-recording format, deliberately understated, targeting conventional enterprise/education/governance audiences. Act 2 transitions to the founder presenting from inside a user sphere — a transparent navigable bubble in the live 3D Relay world — demonstrating the same system from the inside. The founder flies through real data (personal tree, Master Plan branch, globe, arena, municipality) explaining concepts by touching and interacting with live filaments. The revelation is that Act 1 and Act 2 show the same system at different Conceptual LOD tiers (§81.8). Production uses volumetric capture or green-screen compositing into the live Relay engine. The two-act structure, the user sphere concept, and the requirement that Act 2 uses the real running system (not CGI or mockups) are frozen.**

---

## 89. Progressive Revelation & Source Document Architecture — Frozen Contracts #229–233

> *"The best place to hide a leaf is in a forest."* — G.K. Chesterton

The Master Build Plan is both Relay's proof of intentional design and its greatest spoiler. It cannot ship unredacted — any AI can extract the game layer, spell registry, treasure coordinates, and governance internals in seconds. But it also cannot be destroyed — that would violate truth permanence. The solution: tiered encryption with achievement-gated collective decryption.

### 89.1 Revelation Tiers — Contract #229

Every document, section, transcript, video, and design artifact in Relay's development corpus is classified into one of five Revelation Tiers:

| Tier | Name | What It Contains | When It Unlocks |
|------|------|-----------------|-----------------|
| **RT-0** | **Day-1 Starter Pack** | Core physics, basic templates, pricing, accessibility, first-screen tutorial. Everything a user needs to trust and operate Phase 0. | Public from genesis. Ships with desktop app. |
| **RT-1** | **Operational Discovery** | Governance mechanics, education, media, three-layer ontology, energy budget, module prerequisites. The "how it works" layer. | Automatic via Conceptual LOD C1–C2. Unlocked through natural use. |
| **RT-2** | **Civic Discovery** | Civilization templates, civic response, weather, fractal scaling, sortition internals, cross-region mechanics. The "how it governs" layer. | Automatic via Conceptual LOD C3. Unlocked through civic engagement. |
| **RT-3** | **Deep Architecture** | Anti-fraud internals, scale invariance proofs, federation architecture, adversarial hardening, equation derivations, immune detection logic. The "how it survives" layer. | Achievement-gated. Requires sustained contribution and specific milestone chains. |
| **RT-4** | **Source Vault** | The complete unredacted Master Build Plan. Raw AI transcripts. Design videos with full context. Founder decision logs. Spell registry internals. Treasure chest coordinates. Monster economy tuning data. The "how it was built" layer. | Ultimate achievement chains. Treasure chest discoveries. Collective milestone events. |

**Classification rules:**
- Every artifact receives exactly one RT classification
- Classification is performed by the founder using the AI Curation Tool (§89.5), reviewed manually
- Classification is itself a committed filament on Tree Zero — auditable, immutable
- Misclassification (content revealed too early) is a scar on the classification branch

### 89.2 Encryption Model — Contract #230

Each RT tier above RT-0 has its own AES-256-GCM encryption key set:

```
RT-0:  unencrypted (public)
RT-1:  keySet_RT1 = derivedFrom(genesisRoot, "RT1", salt_1)
RT-2:  keySet_RT2 = derivedFrom(genesisRoot, "RT2", salt_2)
RT-3:  keySet_RT3 = derivedFrom(genesisRoot, "RT3", salt_3)
RT-4:  keySet_RT4 = derivedFrom(genesisRoot, "RT4", salt_4)
```

**Storage on Tree Zero:**
- RT-0 content lives on publicly readable branches
- RT-1 through RT-4 content lives on **sealed branches** — branch geometry is visible (users can see that sealed branches exist, see their thickness and timebox structure), but filament content is encrypted
- Sealed branches render with a distinctive visual: frosted bark with a visible lock glyph. Users know something is there. They cannot read it.

**Decryption events:**
- When an RT tier unlocks, the decryption key is released to all eligible users simultaneously
- RT-1 and RT-2 unlock individually (per-user, via Conceptual LOD advancement)
- RT-3 and RT-4 unlock collectively (global milestone events — everyone sees the reveal at the same time)
- Collective unlocks are irreversible — once a tier is revealed, it stays revealed for all future users

**Contract #229 — Revelation Tiers. Every development artifact is classified into RT-0 (public), RT-1 (operational), RT-2 (civic), RT-3 (deep architecture), or RT-4 (source vault). Classification is a committed filament. Each tier above RT-0 is encrypted with a dedicated key set. Branch geometry is always visible; content is gated. RT-1/RT-2 unlock per-user via Conceptual LOD. RT-3/RT-4 unlock collectively via achievement milestones. The tier structure is frozen.**

**Contract #230 — Sealed Branch Encryption. Encrypted revelation content is stored on sealed branches of Tree Zero. Sealed branches are visually distinct (frosted bark, lock glyph). Branch geometry (thickness, timebox count, activity indicators) is visible — only filament content is encrypted. Decryption keys are released upon achievement conditions. Collective reveals are irreversible. The encryption model uses AES-256-GCM with genesis-derived key sets. The sealed branch mechanic is frozen.**

### 89.3 Achievement-Gated Revelation

Tier unlocks are triggered by specific, deterministic achievement conditions:

**RT-1 (Operational Discovery) — Per-User:**
- Triggered by Conceptual LOD reaching C1 or C2
- Conditions: first cross-tree interaction (C1), 30+ commits across 3+ branches (C2)
- Already defined in §81.8 — no new mechanic needed

**RT-2 (Civic Discovery) — Per-User:**
- Triggered by Conceptual LOD reaching C3
- Conditions: demonstrated civic engagement (votes, evidence contributions to public trees)
- Already defined in §81.8

**RT-3 (Deep Architecture) — Collective Global Milestone:**

```
RT3_unlock triggers when ALL of:
    globalActiveUsers     >= RT3_userThreshold
    globalFilamentCount   >= RT3_filamentThreshold
    globalTreeCount       >= RT3_treeThreshold
    epochsSinceGenesis    >= RT3_minEpochs
```

All thresholds are Category A parameters — community-governable after genesis. The founder sets initial values. When conditions are met, the decryption key for RT-3 is published as a filament on Tree Zero's governance branch. Every user receives the key. The deep architecture becomes public knowledge.

**RT-4 (Source Vault) — Tiered Ultimate Achievements:**

RT-4 does not unlock all at once. It is subdivided into treasure chest content, achievement chain rewards, and the final reveal:

- **Treasure chests** (§43.6) contain fragments of RT-4 content — partial transcripts, design sketches, equation derivations, philosophical exchanges. Each chest reveals one piece. Knowledge trading between users is a social mechanic.
- **Achievement chains** unlock coherent sections — e.g., completing the full governance module chain reveals the governance design history. Completing the full accounting module chain reveals the accounting design transcripts.
- **The Ultimate Reveal** — the complete unredacted Master Build Plan — unlocks when a global supermajority (85%+) of active RT-3 users vote to release it, OR when a founder-defined epoch threshold is reached (whichever comes first). This ensures the MBP is eventually public even if the vote never happens.

### 89.4 Day-1 Starter Pack Specification — Contract #231

The Day-1 Starter Pack is a standalone document (`RELAY-STARTER-PACK.md`) that:

- Contains ONLY RT-0 classified content
- Is written in accessible language — no "ontology," no "Laniakea," no "sortition," no "Merkle"
- Covers:
  - What Relay is (3D accountability system)
  - How trees work (visual model, branches, bark, rings)
  - How records work (filaments — called "entries" in public docs)
  - How to import data (CSV, Excel, drag-and-drop)
  - How templates work (P2P, HR, Contracts)
  - How pricing works (ISR, transparent, visible)
  - How governance works (you vote on settings, middle value wins)
  - How to get help (tutorials, community)
- References the full architecture only as: "The complete system specification is preserved as evidence on Tree Zero and is progressively revealed through engagement"
- Contains NO "[REDACTED]" gaps, NO "see §43 for details," NO hints that hidden content exists at specific locations
- Is self-consistent — a reader of only this document can fully understand and operate Phase 0

**Contract #231 — Day-1 Starter Pack. A standalone public specification (`RELAY-STARTER-PACK.md`) ships with the desktop app containing only RT-0 content. It is self-consistent, complete for Phase 0 operation, and contains no references to hidden content locations. Terminology uses accessible language. The starter pack is the only specification document visible to Phase 0 users. The existence of deeper layers is conveyed through sealed branch visibility, not through documentation gaps.**

### 89.5 AI Curation Tool — Contract #232

The founder uses a dedicated SCV tool to classify and distribute the development corpus:

**Inputs:**
- The complete Master Build Plan
- All AI conversation transcripts (Cursor, ChatGPT, Claude)
- All design videos, audio recordings, screen captures
- All decision logs, email threads, handwritten notes
- All code commit histories with messages

**Operations:**
1. **Auto-classify**: Propose RT tier for every section, paragraph, and artifact based on content sensitivity rules (references to spells → RT-4, references to governance internals → RT-2, references to basic physics → RT-0)
2. **Propose treasure chest content**: Select fragments that work as clues — partial equations, redacted transcripts with tantalizing gaps, design sketches without labels, philosophical exchanges that hint at deeper structure
3. **Generate Day-1 Starter Pack**: Produce the clean RT-0 document with no leakage
4. **Generate achievement maps**: Define which user behavior chains unlock which RT-3/RT-4 content
5. **Validate completeness**: Ensure RT-0 is self-consistent, ensure no RT-4 content is accidentally referenced from RT-0, ensure every artifact has a classification
6. **Validate mystery**: Ensure sealed branches are distributed across Tree Zero in a way that creates curiosity — not clustered in one obvious "secrets" area

**Constraints:**
- The curation tool runs locally on the founder's machine
- Source documents never leave the founder's device until encrypted and classified
- Classification decisions are committed as filaments — auditable, never secret
- The tool proposes; the founder decides. No automatic publication.

**Contract #232 — AI Curation Tool. The founder operates a local SCV tool that auto-classifies development artifacts into revelation tiers, proposes treasure chest content, generates the Day-1 Starter Pack, and validates completeness and mystery distribution. The tool runs locally — source documents never transmit unencrypted. Classification decisions are committed filaments. The tool proposes; the founder approves. The curation tool specification is frozen.**

### 89.6 Build History as Progressive Narrative

> **For founder archive distribution as Type 3 one-time treasure, see §98. For the Awakening Curve — how every user relives the founder's progressive realization — see §99.**

The development history — years of design, conversation, iteration, and decision — is not dumped. It is revealed as a story that users earn the right to read.

**Structure:**

| Content Type | RT Tier | Revelation Method |
|-------------|---------|-------------------|
| High-level timeline ("Year 1: Geometry") | RT-0 | Public on relay.world from day 1 |
| Design philosophy quotes | RT-0 | Public, used in marketing |
| Technical design decisions | RT-1 | Unlocked via operational engagement |
| Governance design rationale | RT-2 | Unlocked via civic engagement |
| Adversarial stress test transcripts | RT-3 | Collective global milestone |
| Raw AI conversation transcripts | RT-4 | Treasure chests + achievement chains |
| Founder decision logs | RT-4 | Ultimate achievement |
| The complete Master Build Plan | RT-4 | Global supermajority vote OR epoch threshold |
| This conversation (and all like it) | RT-4 | Treasure chest fragments, earned over time |

**The psychological design:** Users discover that Relay was built with extraordinary care. They find fragments in treasure chests. They piece together the design philosophy. They trade clues. They speculate. Eventually, the full picture is revealed — and it confirms everything they already suspected. The MBP transforms from "spoiler" to "confirmation."

### 89.7 Invariants — Contract #233

1. **All raw evidence is preserved.** Nothing is deleted. The MBP, transcripts, videos — everything is Merkle-sealed on Tree Zero. Classification controls visibility, not existence.
2. **Sealed branches are visible as geometry.** Users can see that hidden knowledge exists. Mystery is part of the design. No pretending the tree is smaller than it is.
3. **No RT-0 content references RT-4 locations.** The starter pack never says "spell details are in §43." It says nothing about spells at all.
4. **Collective reveals are permanent.** Once an RT tier unlocks, it cannot be re-sealed. Knowledge, once released, belongs to everyone.
5. **The MBP will eventually be fully public.** Either by community vote or by epoch timeout. There is no scenario where the source document is permanently hidden. Relay's truth principle demands eventual full transparency.
6. **Treasure chest content is curated, not random.** Each fragment is chosen to reward the finder with genuine insight, not arbitrary text. The founder reviews every placement.
7. **The AI Curation Tool is a helper, not an authority.** It proposes. The founder decides. Every classification is a human decision committed as evidence.

**Contract #233 — Progressive Revelation Invariants. All raw evidence is preserved and Merkle-sealed. Sealed branches are geometrically visible. RT-0 content never references RT-4 locations. Collective reveals are permanent and irreversible. The complete MBP will eventually be fully public by community vote or epoch timeout. Treasure chest content is founder-curated. AI classification is advisory only. These invariants are frozen.**

---

## 90. Airspace & Atmospheric Elevation Layers — Frozen Contracts #238–241

> *"For all things — those that are seen and those that are not — are in their places."* — Hildegard of Bingen

Relay's 3D world extends from ground level to interplanetary space. Without airspace governance, everything renders everywhere — the "Ready Player One chaos" problem. Airspace solves three problems at once: readability (no visual collision), safety and privacy (what can be seen from how far), and governance (who decides what each layer is used for).

### 90.1 Two Independent Axes

Relay airspace has two axes that must not be conflated:

**A. Physical altitude band** — where the camera is, in meters above surface. This determines scale.

**B. Render reservation** — what content is allowed to be dominant at that band. This determines priority.

Airspace is primarily B (render reservation), but anchored to A (physical altitude).

### 90.2 Canonical Band Set — Contract #238

Six atmospheric elevation layers, contiguous and non-overlapping:

| Layer | Altitude (m) | What You See | Purpose |
|-------|-------------|-------------|---------|
| **GROUND** | 0–200 | Cell/editor detail, people close-up, full bark | Work + action |
| **CANOPY** | 200–2,000 | Branch bark, sheets, local twigs, projections | Local truth work |
| **TREE** | 2,000–50,000 | Whole tree silhouette, branch health, no per-filament detail | Management view |
| **REGION** | 50,000–2,000,000 | Trunk clusters, tiles, heat/fog/storm overlays | City/country overview |
| **ORBIT** | 2,000,000–20,000,000 | Planetary fields, major trunk beacons, macro logistics | Planet overview |
| **DEEP** | >20,000,000 | Multi-body LOD, moon/planet markers, cosmic navigation | Interplanetary |

**Trees exist at all layers.** They do not live only in the lowest band. What changes is detail:

| Layer | Tree Rendering |
|-------|---------------|
| GROUND/CANOPY | Full bark, ribbons, slabs, twigs (high detail) |
| TREE | Trunk + branches, no per-filament detail (shape is the analysis) |
| REGION | Trees collapse to trunk markers + aggregated fields |
| ORBIT | Trees are signals on the globe: beacons + tiles |
| DEEP | Trees become mass/heat markers per body |

The rule: **trees are everywhere; detail is local.**

Altitude bounds are Category A parameters — community-governed. The existence of six named layers is frozen.

**Contract #238 — Airspace Layer Definition. Relay's atmosphere is divided into six contiguous, non-overlapping altitude bands: GROUND (0–200m), CANOPY (200–2,000m), TREE (2,000–50,000m), REGION (50,000–2,000,000m), ORBIT (2,000,000–20,000,000m), DEEP (>20,000,000m). Trees render at all layers with detail proportional to distance. Altitude bounds are Category A parameters. The six-band structure is frozen.**

### 90.3 Airspace Reservations — Contract #239

Each layer has a **priority budget** that determines what content gets rendering resources:

```
priorityBudget = { truth: T, lenses: L, spectacle: S }
where T + L + S = 1.0
```

**Default reservation table:**

| Layer | Truth | Lenses | Spectacle | Suppressed by Default |
|-------|-------|--------|-----------|----------------------|
| GROUND | 0.80 | 0.18 | 0.02 | Global spectacle |
| CANOPY | 0.75 | 0.22 | 0.03 | Arena spectacle |
| TREE | 0.70 | 0.25 | 0.05 | Individual filaments |
| REGION | 0.55 | 0.40 | 0.05 | Detailed bark |
| ORBIT | 0.45 | 0.50 | 0.05 | Anything personal |
| DEEP | 0.35 | 0.60 | 0.05 | Fine-grained events |

When the primitive budget is exceeded, content sheds in order: **spectacle first, lenses second, detail last.** Truth silhouettes never shed below TREE layer.

**Visibility rules per layer:**

Each layer defines toggles for every render subsystem:

```
AirspaceLayerSpec {
  layerId:          string
  name:             string
  altitudeFloorM:   number
  altitudeCeilingM: number
  safetyProfile:    "open" | "restricted" | "critical"
  
  priorityBudget: { truth, lenses, spectacle }
  
  visibilityRules: {
    presenceMode:           "INDIVIDUAL" | "QUANTIZED" | "OFF"
    presencePrecisionMeters: number
    presenceTimeBucketSec:   number
    
    filamentDetail:    "ON" | "LOD_ONLY" | "OFF"
    slabDetail:        "ON" | "SUMMARY" | "OFF"
    barkDetail:        "ON" | "SUMMARY" | "OFF"
    projectionDetail:  "ON" | "SUMMARY" | "OFF"
    
    weatherOverlays:   "ON" | "SUMMARY" | "OFF"
    arenaOverlays:     "ON" | "SUMMARY" | "OFF"
    
    allowBranchEdit:   boolean
    allowCommitActions: boolean
  }
}
```

Branch editing and commit actions are only permitted in GROUND and CANOPY. Above TREE, the world is read-only — you observe, you do not modify.

**Contract #239 — Airspace Reservations. Each altitude band has a priority budget (truth + lenses + spectacle = 1.0) that governs render resource allocation. When budgets are exceeded, content sheds in order: spectacle first, lenses second, detail last. Truth silhouettes never shed below TREE layer. Each layer defines visibility toggles for presence, filaments, slabs, bark, projections, weather, and arena. Branch editing and commit actions are restricted to GROUND and CANOPY. Priority budgets are Category A parameters. The shed order invariant is frozen.**

### 90.4 Airspace Governance — Contract #240

Airspace is meta-governed — not just another parameter — because it controls visibility and safety.

**Three governance scopes:**

| Scope | Controls | Governed By |
|-------|---------|------------|
| **Global Airspace** | Band names, default altitude bounds, default priority budgets, default visibility rules | Global Layer 3 MetaVote |
| **Regional Airspace** | May tighten safety (e.g., disable arena overlays in entire region) | Regional MetaVote |
| **Venue Airspace** | Allocate special profiles for specific locations (hospitals, schools, arenas, military zones) | Venue owner + regional approval |

**AirspaceVotePacket schema:**

```
AirspaceVotePacket {
  voteId:           "airspaceVote.<uuid>"
  scope:            "global" | "region.<id>" | "venue.<id>"
  targetLayerId:    "airspace.layer.TREE"
  proposed: {
    altitudeFloorM:    number (optional)
    altitudeCeilingM:  number (optional)
    priorityBudget:    { truth, lenses, spectacle } (optional)
    visibilityRules:   partial override (optional)
  }
  eligibilityProof: EligibilityPacketRef
  weight:           number
  timestamp:        ISO-8601
}
```

**Venue override mechanics:**

Venues inherit from global airspace and apply overrides. A hospital sets `safetyProfile: "critical"` which:
- Disables all arena/spectacle overlays at every layer
- Forces presence quantization at TREE and above
- Forces presence OFF at ORBIT and above
- Sets spectacle budget to 0.0 at all layers
- Increases truth budget proportionally

Venue overrides cannot weaken safety — only tighten it. A hospital cannot enable arena overlays that the global layer disables.

**Contract #240 — Airspace Governance. Airspace is governed at three scopes: global (MetaVote), regional (regional MetaVote), and venue (owner + regional approval). Venue overrides inherit from global and can only tighten safety, never weaken it. AirspaceVotePacket follows standard eligibility and settlement rules. The three-scope governance model is frozen.**

### 90.5 Airspace Frozen Invariants — Contract #241

These invariants hold regardless of governance votes:

1. **Truth-first.** Evidence structure cannot be shed before spectacle at any layer. The shed order (spectacle → lenses → detail) is frozen.
2. **No physics above source.** Airspace controls rendering — it never alters filament data, confidence, lifecycle, or governance weight.
3. **Presence quantization above REGION.** Above REGION layer, individual user presence is always quantized or off. No governance vote can enable individual tracking from orbit. (Aligns with §17.3 presence LOD.)
4. **No pay-to-win airspace.** Render priority cannot be purchased. No mechanism exists to buy higher truth/spectacle budget for a specific tree or branch.
5. **Contiguity.** Layers must be contiguous and non-overlapping. No gaps, no overlaps. Validator enforces.
6. **Venue safety monotonicity.** Venue overrides can only tighten safety relative to the scope they inherit from. A venue inside a restricted region cannot declare itself "open."

**Contract #241 — Airspace Frozen Invariants. Truth always sheds last. Airspace never alters data or governance. Presence is quantized or off above REGION. Airspace priority cannot be purchased. Layers are contiguous. Venue overrides only tighten safety. These invariants are frozen.**

### 90.6 Engine Integration

At every altitude change (or timebox boundary for stability):

```
1. Compute current altitude band via binary search on layer floors
2. Apply the band's visibility rules + priority budget
3. Enforce shed order (spectacle → lenses → detail)
4. Log: [AIRSPACE] layer=<name> alt=<m> truth=<T> lenses=<L> spectacle=<S> presence=<mode>
```

**HUD display:** Bottom-center panel shows: `AIRSPACE: TREE · truth 70% · lenses 25% · spectacle 5%`

When venue override applies: `VENUE: HOSPITAL (critical) · spectacle 0%`

**Refusal behavior:** If a user attempts a branch edit above CANOPY:
`[REFUSAL] reason=AIRSPACE_WRITE_DENIED layer=TREE action=branchEdit`

If the airspace config fails validation:
`[REFUSAL] reason=AIRSPACE_INVALID_SPEC` — fall back to safe defaults (truth-only, all spectacle off).

**Config files:** `config/airspace/airspace.global.v1.json` (global defaults) and `config/airspace/airspace.venue.hospital.v1.json` (hospital override example).

### 90.7 AirspaceResolvedSpec — Single Validator Output Shape — Contract #293

The §90.2–§90.6 sections define airspace layers, priority budgets, visibility rules, governance, venue overrides, and engine integration. But without a single resolved output shape that every subsystem consumes, individual subsystems will read raw airspace JSON directly, apply their own interpretation of venue overrides, and diverge.

**The resolver:**

At every altitude change (or timebox boundary), the airspace engine produces exactly one `AirspaceResolvedSpec` object. This is the ONLY airspace state that any renderer, presence system, arena overlay, projection engine, weather overlay, or SCV subsystem may read.

```
AirspaceResolvedSpec {
  resolvedAt:           ISO-8601
  cameraAltitudeM:      number
  activeLayerId:        string (e.g., "airspace.layer.TREE")
  activeLayerName:      string (e.g., "TREE")

  // Bounds (after governance + venue override resolution)
  altitudeFloorM:       number
  altitudeCeilingM:     number

  // Priority budget (after governance + venue override resolution)
  truthBudget:          number (0.0-1.0)
  lensBudget:           number (0.0-1.0)
  spectacleBudget:      number (0.0-1.0)

  // Visibility toggles (after governance + venue override resolution)
  presenceMode:         "INDIVIDUAL" | "QUANTIZED" | "OFF"
  presencePrecisionM:   number
  presenceTimeBucketS:  number
  filamentDetail:       "ON" | "LOD_ONLY" | "OFF"
  slabDetail:           "ON" | "SUMMARY" | "OFF"
  barkDetail:           "ON" | "SUMMARY" | "OFF"
  projectionDetail:     "ON" | "SUMMARY" | "OFF"
  weatherOverlays:      "ON" | "SUMMARY" | "OFF"
  arenaOverlays:        "ON" | "SUMMARY" | "OFF"
  allowBranchEdit:      boolean
  allowCommitActions:   boolean

  // Safety profile (inherited + venue tightening)
  safetyProfile:        "open" | "restricted" | "critical"
  venueOverrideRef:     null | venueId (if a venue override was applied)

  // Shed state (current frame)
  shedLevel:            "NONE" | "SPECTACLE_SHED" | "LENS_SHED" | "DETAIL_SHED"

  // Validation
  specHash:             sha256 of the resolved spec (for determinism auditing)
}
```

**Hard rules:**

1. **No subsystem reads raw airspace JSON directly.** Renderers, presence engines, arena overlays, projection engines, weather overlays, and SCV subsystems consume only `AirspaceResolvedSpec`. If a subsystem needs an airspace value, it reads it from this object. Any import of raw `airspace.*.json` in rendering code is a build-time error.

2. **The resolver applies overrides in strict order:** global defaults → regional override → venue override. Each layer can only tighten (§90.5 invariant #6). The resolver validates monotonicity and emits `[REFUSAL] reason=VENUE_SAFETY_WEAKENING` if a venue attempts to loosen a higher-scope restriction.

3. **One spec per frame.** The resolved spec is computed once per altitude transition and cached until the next transition. It is not recomputed mid-frame. All subsystems read the same cached instance.

4. **Spec hash enables audit.** The `specHash` field allows determinism verification: given the same inputs (altitude, global config, regional config, venue config), the same `AirspaceResolvedSpec` must be produced. Replay can verify this.

**Contract #293 — AirspaceResolvedSpec. All subsystems that depend on airspace state must consume a single `AirspaceResolvedSpec` object produced by the airspace resolver. No subsystem may read raw airspace configuration directly. The resolver applies global → regional → venue overrides in strict order with monotonic safety tightening. One spec per frame, cached until next altitude transition. Spec hash enables determinism auditing. This contract is frozen.**

---

## 91. Filament Color Grammar — Six-Domain Syntax Rendering — Frozen Contract #243

> *"Color is a power which directly influences the soul."* — Wassily Kandinsky

Pick up any code editor — VS Code, Cursor, IntelliJ. Keywords are one color, strings another, numbers another. You can scan a file and immediately know what you're looking at without reading a single character. That is syntax highlighting. Relay does the same thing — but the "syntax" is universal. Every filament, in every domain, on every branch, on every tree, uses the same six visual channels mapped to the same six universal domains (§0.4). A procurement manager reading an invoices branch and a developer reading a codebase branch see the same color grammar applied to different content.

### 91.1 The Six Visual Channels

Each of the six universal domains maps to exactly one visual channel on the bark surface:

| Domain | Visual Channel | What You See | Example |
|--------|---------------|-------------|---------|
| **Identity** (what) | **Hue** — the base color of the filament ribbon | Different object types have different hues. Invoices are warm amber. Contracts are cool blue. Lab results are green. The hue tells you what kind of thing this is before you read it. | Invoice = amber, Contract = blue, Lab result = green, Vote = purple |
| **Counterparty** (who) | **Angular position** (θ on bark) — where the filament sits around the branch circumference | Filaments cluster by counterparty direction. All invoices from Vendor A sit at θ=47°. All invoices from Vendor B sit at θ=192°. You can see supplier concentration as angular clustering. | Vendor A invoices cluster at one angle, Vendor B at another |
| **Time** (when) | **L-position** — where along the branch length the filament sits | Newer filaments are at the branch tip. Older filaments have sunk inward. The position IS the timestamp. | Recent events at tip, old events deep inside |
| **Magnitude** (how much) | **Color temperature** — warm for large, cool for small | A $10M contract blazes warm red-orange. A $500 office supply order is cool blue-white. You scan a branch and the expensive items jump out. | $10M = hot red, $500 = cool blue |
| **Evidence** (proof) | **Opacity/firmness** — solid for well-evidenced, translucent for unsupported | A filament with signed documents, photos, and counter-party confirmation looks solid and sharp. A filament with no evidence is ghostly, transparent, barely there. | Strong evidence = solid, no evidence = ghostly |
| **Lifecycle** (state) | **Radial position** (r) — distance from branch center | OPEN filaments sit on the bark surface (r=1.0). ACTIVE filaments are slightly inward. CLOSED filaments are deeper. ABSORBED filaments are in the inner wood. You see lifecycle as depth. | New = surface, resolved = deep, archived = core |

### 91.2 The Rendering Pipeline

The filament color grammar is computed deterministically from committed data:

```
FilamentColor {
  hue:         hash(filament.objectType) → colorWheel[0..360]
  theta:       counterpartyAngle(filament.counterpartyRef)
  l:           timePosition(filament.spawnAt, timebox.range)
  temperature: magnitude → lerp(COOL_BLUE, HOT_RED, log(magnitude) / log(maxMagnitude))
  opacity:     filament.confidence × (1 - filament.wilt)
  r:           LIFECYCLE_RADIAL[filament.lifecycleState]
}
```

No manual color assignment. No themes. No decoration. The color IS the data. If two filaments look the same, they ARE the same kind of thing with the same magnitude and evidence level.

### 91.3 Template-Level Hue Overrides

While the default hue is computed from `hash(objectType)`, templates (§21) may define explicit hue mappings for domain clarity:

```
TemplateHueMap {
  "INVOICE":        35    // amber
  "PURCHASE_ORDER": 25    // warm gold
  "CONTRACT":       210   // blue
  "LAB_RESULT":     140   // green
  "VOTE":           280   // purple
  "ALERT":          0     // red
  "CONSENT":        60    // yellow
}
```

Template hue maps are Category B constants — fixed per template version, changed only by template version bump. They never override the other five channels (those are always computed from filament data).

### 91.4 Cross-Domain Readability

The color grammar works because the six channels are perceptually orthogonal — you can distinguish all six simultaneously:

- **Hue** (what type) is a color ring — no two adjacent types share a hue
- **Temperature** (how much) is a warm-cool gradient within each hue
- **Opacity** (how certain) is transparency — readable at any hue or temperature
- **Position θ** (who) is spatial — no channel interference
- **Position L** (when) is spatial — no channel interference
- **Position r** (lifecycle) is depth — no channel interference

A colorblind user sees temperature and opacity reduced to luminance and pattern (§62 accessibility modes). The spatial channels (θ, L, r) are unaffected by color perception.

**Contract #243 — Filament Color Grammar. Every filament's visual appearance is determined by exactly six channels mapped to the six universal domains: hue from identity, angular position from counterparty, L-position from time, color temperature from magnitude, opacity from evidence/confidence, and radial position from lifecycle state. No manual color assignment exists. Template hue maps are Category B constants. The six channels are perceptually orthogonal. This rendering grammar is frozen.**

---

## 92. SCV Intelligence Architecture — API Hybrid & Cost-as-Filament — Frozen Contracts #244–246

> *"The real problem is not whether machines think but whether men do."* — B.F. Skinner
>
> *"If you can't measure it, you can't improve it."* — Peter Drucker

Every branch has an SCV — a Supply Chain Validator that checks incoming data, flags problems, and helps users navigate their tree (§16). The SCV needs intelligence. This section defines exactly where that intelligence comes from, how it is paid for, and how every cost becomes a visible filament on Relay's own tree.

### 92.1 The Intelligence Decision: Build vs Buy vs Hybrid

Building a frontier AI model from scratch requires:
- 10,000+ GPUs ($300M+ hardware)
- 50-100 ML researchers ($300K-$1M salary each)
- 2-3 years of training iterations
- $500M-$2B total over 3 years with no competitive guarantee

Relay is a coordination substrate, not an AI research lab. The correct architecture is **hybrid**: use the best available intelligence via API for complex tasks, self-host lightweight models for routine tasks, and make every invocation a filament.

### 92.2 The SCV Intelligence Stack

The SCV is not one model. It is a **router** that dispatches tasks to the appropriate intelligence tier:

| Tier | What It Handles | Source | Cost Profile |
|------|----------------|--------|-------------|
| **T0 — Deterministic** | Schema validation, format checks, lifecycle state transitions, Merkle hashing, equation computation | Local code (no AI) | Zero marginal cost |
| **T1 — Lightweight Local** | Filament classification, template matching, duplicate detection, basic NLP, evidence hash verification | Self-hosted open-weight model (8B-70B params) | Fixed infrastructure cost, near-zero per-query |
| **T2 — Frontier API** | Complex reasoning, cross-tree audit analysis, adversarial pattern detection, governance impact assessment, natural language explanation | External API (Anthropic Claude, OpenAI, or equivalent) | Per-token cost, variable |
| **T3 — Human Escalation** | Ambiguous cases, disputed evidence, governance decisions, creative judgment | Sortition jury, designated authority, or owner | Human time cost |

The routing decision is itself a deterministic function:

```
SCVRoute {
  if (task.isSchemaOnly) → T0
  if (task.requiresNLP && task.complexity < THRESHOLD_LOCAL) → T1
  if (task.requiresReasoning || task.complexity >= THRESHOLD_FRONTIER) → T2
  if (task.isAmbiguous || task.requiresAuthority) → T3
  
  THRESHOLD_LOCAL:    Category A parameter (default: 0.6)
  THRESHOLD_FRONTIER: Category A parameter (default: 0.85)
}
```

### 92.3 Cost-as-Filament: Every AI Call Is a Committed Record

Every SCV invocation that reaches T1 or T2 produces a **cost filament** on the invoking tree's `operations.ai` branch:

```
AIInvocationFilament {
  filamentId:     "F-AI-<treeId>-<uuid>"
  objectType:     "AI_INVOCATION"
  tier:           "T1_LOCAL" | "T2_FRONTIER"
  model:          "llama-3.1-70B" | "claude-opus-4.6" | "gpt-5.2" | ...
  tokensIn:       number
  tokensOut:      number
  costUSD:        number (0.00 for T1 local)
  latencyMs:      number
  purpose:        "schema_validation" | "cross_tree_audit" | "governance_analysis" | ...
  branchRef:      the branch that triggered the SCV call
  confidence:     result confidence score from the model
  evidence:       hash of the prompt + response (auditable)
}
```

This means:
- Relay HQ's own AI costs are visible on the `tree.org.relay-hq.infrastructure.ai` branch
- Any organization's AI costs are visible on their `operations.ai` branch
- The cost per SCV call is auditable, comparable, and trendable across timeboxes
- If AI costs spike without corresponding value (no confidence improvement, no flagged issues), the branch fogs — the tree tells you the money was wasted

### 92.4 Self-Hosting Economics

The crossover point between API and self-hosted depends on query volume:

| Daily SCV Queries | API Cost (est.) | Self-Host Cost (est.) | Winner |
|-------------------|-----------------|----------------------|--------|
| < 100K | $500-$2,000/day | $1,500/day (GPU amortized) | API |
| 100K - 1M | $2,000-$20,000/day | $1,500-$3,000/day | Self-host |
| 1M - 10M | $20,000-$200,000/day | $3,000-$10,000/day | Self-host |
| > 10M | $200,000+/day | $10,000-$50,000/day | Self-host |

At scale, Relay will operate a mix: self-hosted open-weight models for T1, frontier APIs for T2, with the ratio as a **Category A parameter** governed by the treasury model (§86).

### 92.5 Intelligence Sovereignty

Relay never depends on a single AI provider. The SCV router architecture guarantees:
- T0 (deterministic) works with zero external dependencies
- T1 (local) works with zero network connectivity
- T2 (frontier) can switch providers via configuration — the interface is model-agnostic
- T3 (human) works with zero AI at all

In degraded mode (§67), intelligence sheds in reverse order: T2 drops first (external API), T1 drops second (local model), T0 never drops (deterministic validation), T3 is always available (humans). Truth commits never require AI — they require evidence.

**Contract #244 — SCV Intelligence Routing. The SCV dispatches tasks across four tiers: deterministic (T0), lightweight local model (T1), frontier API (T2), and human escalation (T3). Routing thresholds are Category A parameters. T0 and T1 operate without network dependency. T2 is provider-agnostic. Degradation sheds intelligence in reverse order. Truth commits never require AI. This routing architecture is frozen.**

**Contract #245 — AI Cost-as-Filament. Every AI invocation at T1 or T2 produces a committed AIInvocationFilament recording tier, model, tokens, cost, latency, purpose, and evidence hash. AI costs are visible on the invoking tree's operations branch using standard tree physics. Cost filaments are subject to the same confidence, fog, and wilt rules as all other filaments. This transparency requirement is frozen.**

**Contract #246 — Intelligence Sovereignty. Relay's truth layer (T0 deterministic validation, append-only commits, Merkle hashing, equation computation) operates with zero AI dependency. No AI model — local or external — can modify committed filaments, alter governance weight, or bypass cryptographic guarantees. AI assists human judgment; it never substitutes for it. This sovereignty guarantee is frozen.**

**Game-layer AI routing:** Summon card AI (§43.12) and crafting validation (§43.11) route through the same four-tier system:

| Game-Layer Task | SCV Tier | Cost Model |
|----------------|----------|-----------|
| **Spell gesture validation** | T0 (deterministic zone-map lookup) | Free — no AI invocation |
| **Crafting IDE generation** (image/video/sound) | T1 or T2 (local generative model or frontier API) | Standard AIInvocationFilament on user's operations.ai branch |
| **Crafting import verification** (anti-fraud check) | T0 (hash verification against generation pipeline) | Free — deterministic |
| **Summon AI — Basic tier** | T0 (rule-based: "attack nearest") | Free — no AI invocation |
| **Summon AI — Advanced tier** | T1 (local tactical model) | Low-cost AIInvocationFilament per decision cycle |
| **Summon AI — Strategic tier** | T1 (local model with board-state evaluation) | Moderate-cost AIInvocationFilament per decision cycle |
| **Summon AI — Elite tier** | T2 (frontier API for multi-step prediction) | High-cost AIInvocationFilament per decision cycle |
| **Conversational discovery evaluation** (§104) | T1/T2 (concept alignment scoring) | Standard AIInvocationFilament |
| **Oblivion pattern matching** (§72.12.6) | T1 (local model against pattern library) | Low-cost — pattern match, not generation |
| **Oblivion ambiguous case escalation** (§72.12.6) | T2 (frontier model for boundary cases) | Standard AIInvocationFilament |

Each summon creature's AI tier determines which SCV tier processes its decisions. The summoner sees the cost: an Elite-tier summon making decisions via T2 frontier API is visibly more expensive per turn than a Basic-tier summon running on T0 deterministic rules. This creates a strategic cost-benefit tradeoff — powerful creatures cost more to operate, not just to summon. In degraded mode (§67), summon AI sheds like all other intelligence: Elite drops to Strategic, Strategic to Advanced, Advanced to Basic. Creatures become less smart but never stop functioning.

### 92.6 Learning Boundary — Type-Level Policy Separation

AI and machine learning systems generate recommendations, classifications, and predictions. These outputs must never be treated as policy, governance decisions, or truth claims. The separation is enforced at the commit-type level:

| Commit Type | Who Can Emit | What It Means |
|---|---|---|
| `POLICY_RECOMMENDATION` | SCV (T1/T2), any AI system | "The AI suggests X." Advisory only. Cannot trigger governance transitions, authority grants, or irreversible actions. |
| `POLICY_APPLIED` | Human governance (vote, motion, authority) | "The community decided X." Authoritative. Triggers state changes. |

**Schema-level enforcement:** The engine rejects any commit where the emitter is an AI system (SCV T1/T2) and the commit type is `POLICY_APPLIED`. The commit fails with `REFUSAL: LEARNING_BOUNDARY_VIOLATION`. This makes it technically impossible for an AI recommendation to mutate policy without human governance approval.

AI recommendations can inform governance. A T2 SCV might analyze traffic patterns and recommend a parameter change. That recommendation is a `POLICY_RECOMMENDATION` leaf on the governance branch. A human must then propose it as a motion (§72.11), it must be seconded, debated, and voted on. Only then does a `POLICY_APPLIED` commit execute. The chain from recommendation to policy is fully auditable — you can always trace which AI suggestion led to which human decision.

**Contract #307 — Truth Boundary Primitives. Three mechanisms enforce the boundary between truth, projection, and recommendation: (1) STABILITY_CONFIRMED is a valid lifecycle resolution — reviewed items can be formally closed as "no action needed" with 60-day reopening cooldown (§4.8). (2) Summaries, aggregations, and AI-generated synopses are projection-only — they must cite source filaments and cannot be used as evidence in governance or disputes (§82.7b). (3) AI and learning system outputs are commit-typed as POLICY_RECOMMENDATION and can never emit POLICY_APPLIED — schema-level enforcement prevents AI from mutating policy without human governance approval (§92.6). These three boundaries are frozen.**

---

## 93. Relay HQ Subsidiary Model & Operational Cost Transparency — Frozen Contracts #247–248

> *"An institution is the lengthened shadow of one man."* — Ralph Waldo Emerson

Relay HQ is Tree Zero — but Relay the organization will grow beyond a single tree. Research divisions, robotics labs, regional offices, educational programs, and specialized missions each require their own operational structure. This section defines how Relay's organizational trees work and how every cost is visible.

### 93.1 The Relay Organization Forest

Tree Zero (`tree.org.relay-hq`) is the root. Subsidiary and division trees branch from it via cross-tree links:

```
tree.org.relay-hq                    ← Tree Zero (headquarters)
├── tree.org.relay-hq.dev            ← Development (codebase, architecture)
├── tree.org.relay-hq.infrastructure ← Servers, AI, storage, CDN
├── tree.org.relay-hq.treasury       ← Revenue, expenses, ISR collection
├── tree.org.relay-hq.goals          ← Global civilization goals (§94)
│
├── tree.org.relay-robotics           ← Relay Robotics subsidiary
│   ├── research
│   ├── manufacturing
│   └── treasury
│
├── tree.org.relay-education          ← Relay Education subsidiary
│   ├── curricula
│   ├── certifications
│   └── treasury
│
├── tree.org.relay-aerospace          ← Relay Aerospace subsidiary
│   ├── design
│   ├── manufacturing
│   ├── vessels (→ companion trees: tree.vessel.epoch-001, ...)
│   └── treasury
│   (See companion document: docs/blueprints/09-EPOCH-AIRSHIP.md)
│
├── tree.org.relay-regions.<region>   ← Regional offices
│   └── treasury
│
└── tree.org.relay-<mission>         ← Future mission subsidiaries
    └── treasury
```

Each subsidiary is a full tree with identical physics. Its branches track its own operations, costs, revenue, and progress. The parent-child link is a structural cross-tree filament on Tree Zero that records: when the subsidiary was created, its mission statement, its initial budget allocation, and its reporting obligations.

### 93.2 Cost Visibility Across Subsidiaries

Every subsidiary's `treasury` branch aggregates its costs as filaments:

| Cost Category | How It Appears | What Drives Color/Shape |
|--------------|---------------|------------------------|
| **Staff** | Payroll filaments per timebox | Magnitude = total compensation. Evidence = employment contracts. |
| **Compute** | Server/GPU cost filaments | Magnitude = monthly spend. Evidence = cloud provider invoices. |
| **AI API** | AIInvocationFilaments (§92.3) | Magnitude = total API cost. Evidence = call logs. |
| **Facilities** | Lease/utility filaments | Magnitude = monthly cost. Evidence = lease agreements. |
| **Equipment** | Capital expenditure filaments | Magnitude = purchase price. Evidence = purchase orders. |
| **Legal** | Legal expense filaments | Magnitude = fees. Evidence = engagement letters. |
| **R&D** | Research cost filaments | Magnitude = allocated budget consumed. Evidence = project milestones. |

The shape of the treasury branch tells you everything:
- **Firm, thick branch** = costs well-documented, evidence strong, spending on track
- **Foggy branch** = costs not fully evidenced (missing invoices, unreconciled)
- **Wilting branch** = spending exceeding budget without corresponding output
- **Hot branch** = rapid cost acceleration — something changed
- **Twig-covered** = many small unresolved cost items

### 93.3 Mission Completion and Cost Reduction

The user's principle: *"The cost of funding does not go down unless all Relay company tree missions are complete and finalized."*

Each subsidiary has a `mission` branch with structural filaments defining its objectives. Mission completion is measured by:

```
MissionProgress {
  missionId:        "mission.<subsidiaryId>.<name>"
  objectiveCount:   number of objective filaments
  completedCount:   number with lifecycleState = CLOSED or ABSORBED
  progress:         completedCount / objectiveCount
  confidence:       weighted average confidence of completed objectives
  
  costReduction:    only triggers when progress = 1.0 AND confidence > 0.8
}
```

Until a mission is complete (100% objectives closed with high confidence), the subsidiary's operational budget does not reduce. This prevents premature cost-cutting from killing active missions. When a mission IS complete, the cost reduction follows a natural path: the branch stops growing, staff reassign, infrastructure scales down, and the treasury branch thins visibly.

**Contract #247 — Relay Subsidiary Structure. Each Relay subsidiary is a full tree with identical physics, linked to Tree Zero via structural cross-tree filaments. Every subsidiary has a treasury branch where all costs are committed as filaments with evidence. Subsidiary creation, budget allocation, and mission definition are governance commits on Tree Zero. The organizational forest structure is frozen.**

**Contract #248 — Mission-Gated Cost Reduction. Subsidiary operational budgets do not reduce until mission objectives are 100% complete with confidence above 0.8. Mission progress is computed from objective filament lifecycle states. Premature budget cuts that would leave active missions unfunded are structurally visible as wilt on the mission branch. This mission-gate principle is frozen.**

---

## 94. Civilization Goals — Locked Progression Tiers — Frozen Contracts #249–251

> *"You can't see it until you've seen it."* — Eitan Asulin
>
> *"The arc of the moral universe is long, but it bends toward justice."* — Martin Luther King Jr.

Relay is not just software. It is a civilization operating system with a mission: make everything humanity does visible, accountable, and permanent. Certain capabilities — game mechanics, advanced features, planetary-scale tools — are locked behind real-world achievement thresholds. Not arbitrary levels. Measurable, filament-backed, globally verifiable milestones. The game doesn't reward optimism. It rewards proof.

### 94.1 How Goals Work

Each civilization goal is a **structural filament** on the `goals.global` branch of Tree Zero:

```
CivilizationGoalFilament {
  filamentId:       "F-GOAL-<tierId>-<goalId>"
  objectType:       "CIVILIZATION_GOAL"
  kind:             "structural"
  tierId:           0 | 1 | 2 | 3 | 4 | 5
  goalName:         string
  metric:           string (what is measured)
  threshold:        number (target value)
  direction:        "BELOW" | "ABOVE" (is the goal to reduce or increase?)
  
  currentValue:     number (aggregated from source filaments, updated per timebox)
  confidence:       number (how many source trees contribute verified data)
  progress:         (currentValue - baseline) / (threshold - baseline)
  
  sourceQuery:      CrossTreeAggregation (which trees/branches feed this metric)
  baselineValue:    number (value at genesis or goal creation)
  baselineDate:     ISO-8601
  
  lifecycleState:   "OPEN" (in progress) | "CLOSED" (achieved) | never ABSORBED (permanent record)
}
```

The metric is NOT self-reported. It is **aggregated from bottom-up filament data** across participating trees worldwide. Starvation rate is computed from food distribution filaments, agricultural output filaments, and health outcome filaments. If the source data is foggy, the goal stays foggy. You cannot game it.

When a goal crosses its threshold with confidence above 0.8, the corresponding game mechanics unlock globally. The unlock is a **governance commit** — a permanent filament on Tree Zero.

### 94.2 Tier 0 — Foundation (Unlocked at Genesis)

Pre-conditions for Relay's existence. Met at launch.

| Goal | Metric | Threshold | Evidence Source |
|------|--------|-----------|----------------|
| Tree Zero operational | Relay HQ tree planted, all parameters set | Complete | Genesis commit |
| First 100 trees | Active entity trees with >10 filaments | 100 trees | Tree registry |
| First cross-tree link | Two trees exchange a verified TransferPacket | 1 link | Packet log |
| Camera stable | All five epistemic modes functional | Pass | Proof scripts |

**Unlocks:** Basic tree creation, filament commits, cross-tree linking, all truth-layer features.

### 94.3 Tier 1 — Visibility (Unlock: 10,000 active trees)

Basic game layer features become available when enough of the world is on Relay to make coordination meaningful.

| Goal | Metric | Threshold | Evidence Source |
|------|--------|-----------|----------------|
| Global hunger reduction | Population with insufficient food access | Below 5% (baseline ~9%) | Food distribution + health facility trees |
| Clean water access | Population with access to safe drinking water | Above 95% (baseline ~74%) | Water utility trees |
| Child mortality under 5 | Under-5 mortality rate per 1,000 live births | Below 20 (baseline ~37) | Health facility trees |
| Basic literacy | Adult literacy rate globally | Above 95% (baseline ~87%) | Education trees |
| Electricity access | Population with grid access | Above 98% (baseline ~91%) | Utility trees |

**Unlocks:** Basic achievement tokens, personal quest system, first-tier spell detection (§43), community leaderboards.

### 94.4 Tier 2 — Accountability (Unlock: Tier 1 goals at 50%+ progress)

Intermediate game mechanics. Requires proof the system is improving things, not just measuring them.

| Goal | Metric | Threshold | Evidence Source |
|------|--------|-----------|----------------|
| Weather catastrophe deaths | Annual deaths from meteorological events | Below 1,000/year (baseline ~15,000) | Emergency response + meteorological trees |
| Corruption visibility | Countries with >80% public spending filament coverage | 50+ countries (baseline ~0) | Government trees |
| Supply chain transparency | Global trade volume with mineral-to-shelf traceability | Above 25% (baseline ~0%) | Product trees (§77) |
| Medical record portability | Patients with cross-facility verified health filaments | Above 1 billion (baseline ~0) | Patient trees |
| Carbon measurement accuracy | Countries with emissions truth branches at <5% fog | 100+ countries (baseline ~0) | ESG trees (§53.6) |

**Unlocks:** Arena duels (§42), multi-resource economy (§41), monster spawning (§40), mid-tier spells, faction system.

### 94.5 Tier 3 — Coordination (Unlock: Tier 2 goals at 50%+ progress)

Advanced mechanics requiring demonstrated global coordination.

| Goal | Metric | Threshold | Evidence Source |
|------|--------|-----------|----------------|
| Global hunger | Population with insufficient food access | 0% — zero hunger | Food + agriculture + health trees |
| Preventable disease deaths | Deaths from vaccine-preventable diseases | Below statistical noise | Health facility trees globally |
| Homelessness | Homelessness rate in participating regions | Below 0.01% | Municipal + housing trees |
| Universal education | K-12 equivalent completion rate | Above 99% | Education trees |
| Justice transparency | Countries with fully filmed, filament-backed proceedings | 100+ countries | Court trees |
| Net deforestation | Annual forest cover change | 0% or negative | Environmental monitoring trees |

**Unlocks:** Full spell taxonomy (§43), advanced arena modes, crowd-driven terrain, governance theater, projection authority.

### 94.6 Tier 4 — Civilization (Unlock: Tier 3 goals at 80%+ progress)

Planetary-scale achievements.

| Goal | Metric | Threshold | Evidence Source |
|------|--------|-----------|----------------|
| Armed conflict cessation | Deaths from armed conflict | 0 for 365 consecutive days | News + government + NGO trees |
| Nuclear stockpile reduction | Active warheads (verified by treaty compliance trees) | Verifiably declining trend | International monitoring trees |
| Ocean plastic reversal | Net plastic accumulation in oceans | Negative (removal > input) | Environmental monitoring trees |
| Species extinction rate | Annual species extinctions | Below background rate (~1/million species/year) | Biodiversity monitoring trees |
| International space cooperation | Nations with shared space station trees | 10+ nations | Space agency trees |
| Global energy transition | Renewable energy share of total generation | Above 80% | Utility trees worldwide |

**Unlocks:** Full game layer, all progression tiers, planetary-scale features, deep archive exploration tools.

### 94.7 Tier 5 — Interplanetary (Unlock: Tier 4 goals at 90%+ progress)

Off-world expansion.

| Goal | Metric | Threshold | Evidence Source |
|------|--------|-----------|----------------|
| Permanent lunar presence | Active trees on Moon Relay globe | Sustained for 1 year | Lunar operations trees |
| Mars data ecosystem | Rover/orbital filament streams feeding Martian trees | Active for 6 months | Mars observation trees |
| Global extreme poverty | Population below international poverty line | 0% | National economic trees |

**Unlocks:** Lunar and Martian globe instances, off-world tree planting, interplanetary cross-body links.

### 94.8 Progression Mechanics

**Irreversibility:** Once a tier unlocks, it stays unlocked permanently. Tier achievement is a governance commit that cannot be reverted.

**Regression scars:** If an underlying metric regresses after achievement (e.g., hunger increases after hitting 0%), the goal filament develops a **scar** — visible evidence that humanity achieved something and then lost it. The scar does not re-lock the tier, but it is permanently visible.

**Progress visibility:** The `goals.global` branch on Tree Zero renders as a progression tree where each tier is a ring. Completed tiers are firm and dense. In-progress tiers glow with current heat. Future tiers are translucent outlines. Every user can fly to this branch and see exactly where humanity stands.

**No false metrics:** If source data has low confidence (few participating trees, foggy evidence), the goal's own confidence reflects this. A goal cannot be "achieved" with foggy data — confidence must exceed 0.8 for the achievement commit to fire.

**Dashboard:** A dedicated projection branch on Tree Zero provides a civilization dashboard: all goals, all tiers, current progress, projected achievement dates (based on rate of change), and the specific trees/regions contributing or lagging.

### 94.9 The Terminal Vision — Earth Returned to Nature

> *"I just think it's best if nature had its own realm entirely and we limit our interactions."* — Eitan Asulin

Beyond Tier 5, beyond interplanetary expansion, there is a vision that shapes every decision in this document. It is not a contract — it is the reason contracts exist.

**The vision:** Humans live in the sky. Earth's surface belongs to nature.

Not in orbit. Not on space stations. In the atmosphere — floating habitats like the Epoch (docs/blueprints/09-EPOCH-AIRSHIP.md), but personal and family-scale. Houses that drift above the forests, above the grasslands, above the oceans. Humans visit the surface the way guests visit a garden — carefully, respectfully, temporarily. Animals get the ground. Trees get the ground. Rivers run without dams for hydroelectric power because power comes from the sun at altitude. Cities decompose slowly into forests. Roads become animal corridors. The infrastructure that humanity built on the surface — the concrete, the asphalt, the steel, the plastic — gradually yields to root systems and rainfall.

**Why this matters for the architecture:**

Every tier of civilization goals is a step toward this outcome:

| Tier | What It Solves | How It Enables the Terminal Vision |
|------|---------------|-----------------------------------|
| T0: Foundation | Relay exists | The data infrastructure to coordinate a species-scale migration |
| T1: Visibility | Basic human needs met on the ground | Nobody can move to the sky while people are starving on the ground |
| T2: Accountability | Systems transparent, weather-safe, supply chains traced | Flight safety, resource logistics, and manufacturing transparency for sky habitats |
| T3: Coordination | Zero hunger, universal education, justice transparent | The social trust required to share sky commons without borders |
| T4: Civilization | No armed conflict, environmental restoration | The preconditions for nature reclamation — no wars, declining pollution, species recovery |
| T5: Interplanetary | Off-world expansion begins | Humanity proves it can live away from Earth's surface — the rehearsal |
| **Beyond T5** | **Atmospheric habitation** | **The return** |

**What "beyond T5" looks like as goals:**

| Goal | Metric | Threshold | Evidence Source |
|------|--------|-----------|----------------|
| Personal flight mastery | Humans with verified flight certification | Above 50% of adult population | Education + aerospace trees |
| Atmospheric habitat availability | Sky habitats available per capita | 1 per household (baseline: 0) | Relay Aerospace + manufacturing trees |
| Ground infrastructure decommission | Urban land area returned to nature per year | Net positive rewilding for 5 consecutive years | Environmental monitoring trees |
| Wildlife corridor connectivity | Continuous wildlife corridors between major ecosystems | 80% of identified corridors connected | Conservation trees |
| Surface visit protocol compliance | Human ground visits following governed interaction limits | Above 95% compliance | Civic + environmental trees |
| Border-free sky movement | Nations with unrestricted atmospheric transit agreements | All participating nations | International governance trees |
| No one left behind | Population without access to atmospheric habitation option | 0% | Housing + aerospace + civic trees |

**Design principles that protect the vision:**

1. **Voluntary, always.** No one is forced from the ground. Every ground home is the owner's sovereign property. The sky is an option, not a mandate. Migration happens because sky life is better, not because ground life is prohibited. The transition is voted on at every scale — local, regional, global.

2. **Nobody left behind.** Relay Aerospace's mission is not to build luxury airships for the wealthy. It is to drive the cost of atmospheric habitation to zero through mass manufacturing, open-source design, and mission-gated cost reduction (§93.3). The Epoch is a prototype. The goal is an Epoch for every family.

3. **Nature gets sovereignty.** When humans leave the surface, the land is not "abandoned" — it is returned. A new class of governance emerges: land stewardship, managed by humans from above, executed primarily by nature with minimal intervention. Environmental monitoring (drones, satellites, ground sensors) ensures ecosystems recover. Relay trees track the recovery as filaments — the forest growing back is visible as a living branch.

4. **No sky borders.** The atmosphere is commons. No nation owns altitude. No tourist visa is required to fly over a country. The sky is the one place where every human is free to move. Relay's airspace governance (§90) already provides safety structure without ownership — the transition from "managed airspace" to "inhabited airspace" is an extension of existing contracts.

5. **Flight is a skill, not a privilege.** Relay Education (§58) includes flight training as a civilization curriculum. Mastering the skies is a progressive skill — from personal wingsuits to paragliders to powered flight to habitat piloting. The Epoch blueprint's activity equipment (§9, wingsuits, airfoils, sails) is the training pipeline. Everyone learns to fly. Not everyone at once. But everyone eventually.

6. **Surface interaction is governed.** When humans visit the ground — for recreation, research, ceremony, agriculture transition, or maintenance — the visit follows governed protocols. How many people in this forest, for how long, doing what, with what impact. The land is nature's tree now. Humans are guests. The visit creates filaments on the visitor's tree and on the land stewardship tree. Accountability is total.

7. **The Epoch is step one.** Every vessel in the Relay Aerospace fleet (docs/blueprints/09-EPOCH-AIRSHIP.md §11) is an iteration toward personal-scale atmospheric habitation. The Epoch is a mothership. The Runner is personal-scale fast transport. The fleet template scales from expedition vessel to family home to single-person flyer. The engineering is progressive — each generation lighter, cheaper, more autonomous, more self-sufficient.

**This vision is NOT a frozen contract.** It is the founder's stated intent. The community can vote to pursue it, modify it, or reject it entirely. But it explains why Relay Aerospace exists, why flight training is in the education module, why airspace governance is border-free, why environmental monitoring is a civilization pillar, and why every tier of goals builds toward a world where humans and nature don't compete for the same ground.

The Master Plan does not promise this future. It builds the infrastructure that makes it possible. If humanity chooses to stay on the ground, Relay still works — it is a data platform for any civilization shape. But if humanity chooses the sky, Relay is ready.

**Contract #249 — Civilization Goals as Structural Filaments. Each global goal is a structural filament on Tree Zero's goals branch with tierId, metric, threshold, direction, currentValue (aggregated from source filaments), and confidence. Goals cannot be achieved with confidence below 0.8. Achievement is a permanent governance commit. This goal structure is frozen.**

**Contract #250 — Tier-Locked Game Progression. Game layer features are gated by civilization tier. Tier 0 unlocks at genesis. Subsequent tiers unlock when the prior tier's goals reach the specified progress threshold with sufficient confidence. Tier unlocks are irreversible. Metric regression produces scars, not re-locks. The tier progression model is frozen.**

**Contract #251 — Goal Metric Integrity. Goal metrics are computed from bottom-up cross-tree aggregation of committed filaments, never from self-reported values, external APIs, or manual entry. Source queries are deterministic and auditable. If source confidence is insufficient, the goal remains foggy. No administrative override can force a goal achievement. This integrity guarantee is frozen.**

---

## 95. Pricing Model — Competitive Sustainment Rate — Frozen Contracts #252–254

> *"Price is what you pay. Value is what you get."* — Warren Buffett

Relay must be affordable from day one. It competes not with other 3D platforms — it competes with spreadsheets, email, Slack, QuickBooks, and filing cabinets. If Relay costs more than the tools it replaces, adoption fails. The pricing model must generate enough revenue to fund all active missions (§93.3) while remaining competitive at every scale.

### 95.1 The Three Revenue Streams

Relay has exactly three revenue mechanisms. No advertising. No data sales. No premium tiers that gate truth features.

| Stream | What It Is | Who Pays | Rate |
|--------|-----------|----------|------|
| **ISR (Infrastructure Sustainment Rate)** | Percentage fee on economic TransferPackets only | Parties to financial transactions | 0.30% default, 1.00% constitutional cap (§86, contract #216) |
| **Resource Pricing** | Compute, storage, and render metering per timebox | Trees that consume above free-tier thresholds | Market-rate, transparent, Category A parameters |
| **Download Price** | One-time purchase for the desktop application | New users | Live gap-based price (§86, contract #234) |

### 95.2 Competitive Price Benchmarks

The pricing must undercut or match existing tools at every adoption tier:

| User Segment | Current Tools Cost | Relay Equivalent | Relay Target |
|-------------|-------------------|-----------------|-------------|
| **Individual** (personal tree) | Free (Google Drive, notes apps) | Free | $0/month — truth commits, basic tree, governance participation, education, health, civic |
| **Small team** (5-20 people) | $50-$200/month (Slack + QuickBooks + Dropbox) | Free tier + ISR on transactions | < $100/month equivalent |
| **SMB** (20-200 people) | $500-$5,000/month (ERP + CRM + compliance) | ISR + resource pricing for compute/storage | < $2,000/month equivalent |
| **Enterprise** (200+ people) | $10,000-$100,000+/month (SAP, Oracle, custom) | ISR + resource pricing + enterprise support | < $20,000/month equivalent — but with full auditability that replaces separate audit costs ($50K-$500K/year) |
| **Government / civic** | Tax-funded | Constitutionally exempt from ISR (§86, contract #218) | $0 — civic, health, education branches are free by constitutional guarantee |

### 95.3 The Free Tier (Non-Negotiable)

These features are free forever. No subscription. No trial period. No "upgrade to access." This is constitutionally guaranteed by contract #222.

| Feature | Why It's Free |
|---------|-------------|
| **Truth commits** | Relay's core function. Charging for truth defeats the purpose. |
| **Governance participation** | Voting is a right, not a premium feature. |
| **Civic branch access** | Emergency services, public records, municipal coordination. |
| **Health branch access** | Medical records, patient trees, consent management. |
| **Education branch access** | Learning, curricula, certifications. |
| **Basic tree** (3 branches, 1,000 filaments) | The first-screen contract (§81.9) requires a useful free experience. |
| **Cross-tree linking** (basic) | Relay's network effect depends on interconnection. |

### 95.4 Download Pricing: The Live Gap Model

The desktop application price is not fixed. It is computed from the treasury tree in real time (§86, contract #234):

```
downloadPrice = max(0, unfundedOperatingGap / projectedNewUsersThisTimebox)
```

- At launch (high costs, few users): price is meaningful — perhaps $20-$50
- As user base grows: denominator increases, price decreases
- At self-sustaining scale: price hits $0 and stays there
- All inputs are visible filaments on the treasury tree — anyone can verify the price

**Genesis contributors** — users who purchase before the price reaches $0 — receive a permanent non-sinking filament on Tree Zero's genesis ring (§86, contract #236). The honor is the permanent record. No governance advantage.

### 95.5 ISR Rate Stability

The ISR rate starts at 0.30% and is designed to stay low:

| Mechanism | Effect |
|-----------|--------|
| **Constitutional cap** | Cannot exceed 1.00% under any circumstance |
| **Accumulation ceiling** | If treasury exceeds 12× annual operating cost, ISR reduction vote auto-triggers. At 24×, hard circuit breaker forces reduction. |
| **Supermajority to increase** | Raising ISR requires 70% supermajority MetaVote |
| **Founder bootstrap** | ±0.20% adjustment for first 5 years only, permanently removed after |
| **0% transition** | Moving to 0% ISR requires 85% supermajority and 24-month phase-down |
| **Emergency increase** | Legal defense surcharge ≤ +0.05%, auto-expires in 12 months |

At 0.30%, the ISR is competitive with payment processor fees (Stripe: 2.9% + $0.30, PayPal: 2.99%, wire transfers: $15-$50 flat). Relay's ISR is an order of magnitude cheaper than existing financial infrastructure — and it provides full auditability, Merkle proof, and cross-tree traceability that those services cannot.

### 95.6 Revenue Sufficiency Model

The pricing model must fund all active missions. Here is the sustainability math at three scale milestones:

| Scale | Active Trees | Daily TransferPackets | Daily ISR Revenue (0.30%) | Monthly Revenue | Funds |
|-------|-------------|----------------------|--------------------------|----------------|-------|
| **Year 1** (enterprise wedge) | 1,000 | 50,000 × avg $1,000 = $50M volume | $150,000/day | ~$4.5M/month | Core team (50 people), infrastructure, API costs |
| **Year 3** (10K+ orgs) | 50,000 | 2M × avg $500 = $1B volume | $3M/day | ~$90M/month | Full operations, subsidiaries, regional offices |
| **Year 5** (mass adoption) | 1M+ | 100M × avg $200 = $20B volume | $60M/day | ~$1.8B/month | All missions, global goals infrastructure, R&D |

These are conservative estimates based on existing B2B transaction volumes. The ISR at 0.30% generates enough revenue at each scale milestone to fund the corresponding operational complexity — and the accumulation ceiling prevents excess hoarding.

### 95.7 Pricing Invariants

| Rule | Guarantee |
|------|-----------|
| Fees never alter governance weight | Paying more gives you zero additional votes |
| Fees never alter confidence | Paying does not make your filaments more credible |
| Fees never alter lifecycle | Payment status does not affect filament state |
| Free-tier truth commits are permanent | Even if a user never pays, their committed filaments persist |
| Civic/health/education: always free | Constitutional guarantee, not a marketing decision |
| No advertising, ever | Revenue comes from ISR, resources, and downloads only |
| No data sales, ever | Filaments belong to their creators. Relay never monetizes user data. |

**Contract #252 — Competitive Pricing Guarantee. Relay's pricing must remain competitive with the tools it replaces at every adoption tier. The free tier (truth commits, governance, civic, health, education, basic tree) is constitutionally permanent. No feature that existed in the free tier can be moved to a paid tier. This guarantee is frozen.**

**Contract #253 — Revenue Sufficiency Obligation. The ISR rate, resource pricing, and download price must collectively generate sufficient revenue to fund all active organizational missions (§93.3). Revenue projections are computed from treasury tree filaments and visible on the civilization dashboard. If projected revenue falls below projected mission costs for three consecutive timeboxes, an automatic treasury review vote triggers. This obligation is frozen.**

**Contract #254 — No Advertising, No Data Sales. Relay generates revenue exclusively from ISR fees, resource pricing, and application download pricing. No advertising is displayed anywhere in the system. No user data, filament content, presence data, or behavioral patterns are sold, licensed, or shared with any third party. Aggregated anonymized statistics may be published as projection branches on the system tree. This prohibition is frozen.**

---

---

## 96. Treasure Chest Taxonomy — Scarcity Gradient & Discovery Types — Frozen Contracts #255–256

> *"Not all who wander are lost — but some find what no one else ever will."* — J.R.R. Tolkien (adapted)

Treasure chests were introduced in §43.6 as hidden locations containing knowledge — spell clues, architectural fragments, development history. But not all chests are equal. The scarcity of what you find determines its meaning. A clue that ten thousand people already know is useful. A fragment that only you will ever hold is something else entirely.

Relay defines exactly four chest types. Each controls a different dimension of scarcity: who can open it, how many times, and what happens to the chest afterward.

### 96.1 The Four Chest Types

| Type | Name | Who Can Open | How Many Times | What Happens After | Rarity |
|------|------|-------------|----------------|-------------------|--------|
| **0** | **Open Chest** | Anyone who finds it | Unlimited | Chest remains. Content identical for all openers. | Common |
| **1** | **Personal Chest** | One specific user (bound to tree coordinates) | Once (for that user) | Chest disappears for that user; invisible to others from the start. | Uncommon |
| **2** | **Regenerating Chest** | Anyone who finds it | Multiple, but content rotates per opener | Each opener receives a different fragment from a finite pool. When pool exhausted, chest goes dormant (visually frosted, lock glyph, no interaction). | Rare |
| **3** | **One-Time Chest** | The first person to find and open it | Once, ever | Chest is consumed — permanently removed from the world. A **legendary branch** (§97) spawns on the finder's tree. | Legendary |

**Type 0 — Open Chest.** The workhorse of discovery. Scattered across geographic coordinates, branch locations, and root archive depths. Opening reveals a clue — a partial spell trigger, a riddle, a lore fragment. The content is identical for everyone. Knowledge trading (§43.6) applies fully. These chests teach the game layer to new users and reward exploration without creating exclusivity. GPS-verified location chests and deep-root archaeological chests are typically Type 0.

**Type 1 — Personal Chest.** Bound to a specific user's tree topology — their profession, their geographic history, their engagement pattern. A shepherd's tree might reveal a chest about pastoral data mapping that no urban user would ever encounter. A marine biologist might find one about ocean temperature filaments. Personal chests reward depth of engagement in a specific domain. The content becomes part of the finder's tree as committed filaments. No one else ever sees the chest — it exists only in the intersection of location and identity.

**Type 2 — Regenerating Chest.** Same location, different content each time. The first person to open it receives Fragment A. The second receives Fragment B. The fifteenth receives Fragment O. When the pool is exhausted, the chest freezes — visually dormant, a monument to completed discovery. Regenerating chests create a natural community around a location: "What fragment did you get?" becomes a social mechanic. Knowledge trading between openers assembles a larger picture. The pool size is a sealed parameter per chest — users don't know how many fragments exist until the chest freezes.

**Type 3 — One-Time Chest.** The rarest discovery in Relay. One person. One opening. One chance. The chest is consumed upon opening — it ceases to exist in the coordinate system. The finder receives the content as a **legendary branch** on their personal tree (§97). The content is the most significant material in Relay's archive: founder design transcripts, philosophical exchanges, raw equation derivations, video recordings of pivotal decisions. Type 3 chests are the Ready Player One moments — once found, they're gone. The finder can describe what they found, share their understanding, teach from it — but the original artifact lives only on their tree, forever.

**Chest rewards beyond knowledge:** Treasure chests contain more than lore and spell clues. Chest content can include:
- **Crafting tier eligibility (§43.11.3):** Rare, Epic, and Legendary crafting tiers require specific treasure discoveries as prerequisites. Opening a qualifying chest commits a `CRAFTING_ELIGIBILITY` filament to the finder's crafting branch, unlocking the ability to finalize at that rarity tier.
- **Summon registry entries (§43.12.4):** Discovery-unlocked summon creatures are mapped to specific chest types or chest contents. Opening the chest commits a `SUMMON_UNLOCK` filament, adding the creature to the finder's available summon registry. These discovery summons are often the most powerful — rewarding exploration over collection.
- **Crafting token rewards:** Some chests contain crafting tokens (§41.10) as material rewards alongside knowledge content.

The chest type determines the reward profile: Type 0 (Open) chests grant common crafting eligibility and base knowledge. Type 1 (Personal) chests may unlock domain-specific summons or crafting templates matched to the finder's expertise. Type 2 (Regenerating) chests distribute different rewards from a pool — some openers get crafting eligibility, others get summon unlocks, others get lore. Type 3 (One-Time) chests grant unique summon creatures and Legendary crafting eligibility that no other source provides.

### 96.2 Chest Placement Rules

All chests follow the placement principles established in §43.6 and §89:

- Chests are placed by the founder (append-only — never removed except by Type 3 consumption)
- Placement uses the AI Curation Tool (§89.5) for classification, encryption, and geographic distribution
- Each chest has a committed filament on Tree Zero's game branch recording its type, location hash, content hash, and RT classification — but NOT the content itself or the plaintext location
- GPS-verified chests require physical presence at the coordinates
- Branch-location chests require navigation to specific tree depths
- Root-strata chests require archaeological exploration of historical data layers

### 96.3 Sharing Mechanics & Attention Economy

Opening a chest is a filament commit on the finder's tree. What happens next depends on what the finder does with the knowledge:

**Sharing creates engagement.** When a finder describes chest content — in conversation, in a published filament, in a teaching session — those descriptions are leaf packets (§82.2) on the finder's tree. If they attract attention (replies, votes, citations), the leaves promote to filaments. The finder's branch grows. Attention is not an abstract currency — it is engagement mass on the finder's tree, computed by the same physics that govern every other branch.

**Citation creates counterparty links.** When another user references what a chest opener shared, the citation creates a counterparty filament linking back to the original sharer. The opener becomes a permanent source node in the knowledge graph. For Type 0 and Type 2 chests, multiple people share overlapping knowledge — the first to publish earns the citation advantage. For Type 3, the finder is the only possible original source.

**Type-specific sharing rules:**

| Type | What Can Be Shared | Original Artifact Location |
|------|-------------------|---------------------------|
| **0 (Open)** | Everything — content is identical for all | Replicated on every opener's tree |
| **1 (Personal)** | The knowledge, in the finder's words | Finder's tree only |
| **2 (Regenerating)** | Each fragment, by its respective finder | Each finder's tree (different fragments) |
| **3 (One-Time)** | Descriptions, interpretations, lessons learned — never the original artifact | Finder's legendary branch only (§97) |

**The attention loop:** Find chest → learn something → share the knowledge → attract engagement → engagement promotes to filaments → tree grows → growth makes you visible → visibility attracts more engagement. This is how attention becomes a resource: not as a token or score, but as the physical mass of your tree. A user who opens many chests and shares generously has a tree that visibly reflects that generosity — thicker branches, more counterparty links, higher confidence on knowledge-sharing filaments.

### 96.4 Invariants

1. **Chests provide knowledge, never power** (§43.6). No chest type grants game-layer resources (Power, AT, EC) directly. Knowledge enables — it doesn't empower.
2. **Type 3 consumption is irreversible.** Once opened, the chest is gone from the coordinate system. No restoration, no duplication, no founder override.
3. **Chest type is immutable.** A Type 2 cannot be reclassified to Type 3 after placement. Classification is a committed filament.
4. **Sharing is voluntary.** No mechanic forces a finder to share. Hoarding knowledge is a valid strategy — but it means no engagement, no citations, no tree growth from that discovery. The physics incentivize sharing without mandating it.
5. **Pool exhaustion is permanent.** A regenerating chest that runs out of fragments stays dormant forever. It becomes a historical marker — evidence that a community completed a discovery cycle.

**Contract #255 — Treasure Chest Type Taxonomy. Relay defines exactly four chest types: Type 0 (Open — unlimited, identical content), Type 1 (Personal — bound to one user's tree topology), Type 2 (Regenerating — rotating content from finite pool), and Type 3 (One-Time — single opening, consumed, spawns legendary branch). Chest type is assigned at placement and is immutable. Type 3 consumption is irreversible. No chest type grants game-layer resources directly. This taxonomy is frozen.**

**Contract #256 — Chest Sharing & Attention Mechanics. Opening a chest is a filament commit. Sharing chest knowledge generates leaf packets on the sharer's tree. Engagement with shared knowledge follows standard promotion mechanics (§82.4). Citations create counterparty links to the original finder. Type 3 original artifacts live exclusively on the finder's legendary branch — descriptions can be shared, originals cannot. Attention is engagement mass, not a separate token. The sharing mechanics are frozen.**

---

## 97. Legendary Branch — Unique Tree Geometry from Discovery — Frozen Contracts #257–258

> *"There is a crack in everything. That's how the light gets in."* — Leonard Cohen

Most branches on a Relay tree are generated from templates — accounting branches look like accounting branches, HR branches look like HR branches. The geometry follows the template's structural filament definitions (§78.4). A legendary branch follows no template. It is a one-of-a-kind structural element that appears on a user's tree only when they open a Type 3 one-time chest (§96.1). It is proof — visible, permanent, unmistakable — that this person found something no one else ever will.

### 97.1 Spawning Mechanics

When a user opens a Type 3 chest:

1. The chest content is decrypted using the finder's session key + the chest's RT-4 key fragment
2. A new **structural filament** (kind: `structural`, per §81.1) is committed to the finder's tree
3. This structural filament defines a new branch with geometry parameters derived from the chest content hash — not from any template
4. The content filaments (transcript fragment, video clip, design sketch, equation derivation, philosophical exchange) are committed as children of this structural filament
5. The chest's coordinate entry on Tree Zero's game branch is updated: `status: consumed`, `finderRef: <finder's tree>`, `consumedAt: <timestamp>`
6. The legendary branch appears on the finder's tree immediately — growing outward from the trunk at an angle and position determined by the content hash

### 97.2 Visual Distinctiveness

Legendary branches are visually unmistakable. Their geometry is derived from the content hash, producing characteristics that no template can replicate:

| Property | Template Branch | Legendary Branch |
|----------|----------------|-----------------|
| **Bark texture** | Uniform per template type | Unique — derived from content hash seed |
| **Glow signature** | Standard activity glow | Persistent warm glow at low intensity, even when dormant |
| **Branch angle** | Template-defined grid positions | Unique angle — not aligned to any template grid |
| **Growth pattern** | Incremental via filament commits | Fully formed at spawn — all content is present from the moment of discovery |
| **Slab rendering** | Time-sequential rings | Single genesis slab containing the entire artifact, sealed at creation |

The legendary branch does not grow over time. It arrives complete. This is the visual signature of discovery: a branch that appeared whole, out of nowhere, at a unique angle, glowing faintly — clearly not part of the tree's regular structure. Other users who visit this tree will see it immediately and know: this person found something.

### 97.3 Rarity & Scarcity

The number of legendary branches in the entire Relay ecosystem is bounded by the number of Type 3 chests placed by the founder. This is a finite, non-renewable quantity:

- The founder places N Type 3 chests (N is a sealed parameter — users don't know the total)
- Each opening consumes one chest and creates one legendary branch
- At most N legendary branches will ever exist across all users globally
- Most users will never have a legendary branch
- Some users may have more than one (if they find multiple Type 3 chests)
- The total number of unopened Type 3 chests is not published — users can only observe that chests are being found (consumption events are public filaments on Tree Zero)

### 97.4 Immutability Rules

A legendary branch, once spawned, is subject to stronger immutability than ordinary branches:

| Rule | Ordinary Branch | Legendary Branch |
|------|----------------|-----------------|
| **Transfer** | Ownership follows tree ownership | Cannot be transferred, period. Tree ownership transfer does not move legendary branches — they remain on the original tree. |
| **Fork** | Can be forked to child trees | Cannot be forked. The branch exists on exactly one tree. |
| **Duplicate** | Content can be copied via export | Original artifact content cannot be exported as raw data. Descriptions, screenshots, and annotations are allowed. |
| **Wilt** | Wilts if evidence degrades | Cannot wilt. Evidence is sealed at creation — the chest itself is the evidence chain. Confidence is permanently 1.0. |
| **Delete** | Correction filaments can supersede | Cannot be deleted or superseded. The legendary branch is permanent. |
| **Heartwood** | Sinks inward over time | Sinks like all committed truth — eventually entering the deepest heartwood strata, but always retrievable and always glowing. |

### 97.5 Cross-Tree Viewing

Other users can see a legendary branch on someone else's tree, subject to standard disclosure tier rules (§8.5):

- **Tier 0 (Private):** The branch geometry is visible (users can see that a legendary branch exists — the unique angle and glow are apparent), but content filaments are encrypted.
- **Tier 1 (Shape):** Geometry visible, content shape visible (users can see the type of content — video, text, sketch — but not the actual content).
- **Tier 2 (Public):** Full content visible. Other users can read the transcript, watch the video, study the equation — but only as a read-only cross-tree projection. The originals stay on the finder's tree.

The finder chooses the disclosure tier. Many will choose Tier 2 — sharing is how attention flows. But the choice is theirs.

**Contract #257 — Legendary Branch Definition. A legendary branch is a structural filament with unique hash-derived geometry that spawns on a user's tree exclusively upon opening a Type 3 one-time chest (§96.1). Geometry is derived from the content hash — not from any template. The branch appears fully formed at spawn. Visual properties (bark texture, glow, angle, slab structure) are deterministically unique. The number of legendary branches globally is bounded by the finite number of Type 3 chests. The legendary branch definition is frozen.**

**Contract #258 — Legendary Branch Immutability. Legendary branches cannot be transferred, forked, duplicated (as raw data), wilted, deleted, or superseded. Confidence is permanently 1.0. The branch sinks into heartwood over time but remains retrievable and visually distinct. Tree ownership transfer does not move legendary branches. Cross-tree viewing follows standard disclosure tiers. The immutability rules are frozen.**

---

## 98. Founder Archive Distribution — History as Type 3 Treasure — Frozen Contracts #259–260

> *"I am putting my whole story into the world, one piece at a time, and trusting that the people who find it will understand what it means."* — Eitan Asulin

The Genesis Record (§80) establishes Tree Zero and imports the full development archive. The Progressive Revelation system (§89) classifies and encrypts that archive into tiers. But the founder's personal archive — the conversations, videos, handwritten notes, design sketches, philosophical exchanges, raw AI transcripts, and pivotal decision recordings captured during the creation of Relay — is not revealed through collective milestone unlocks or Conceptual LOD progression. It is scattered across the world as Type 3 one-time treasure chests.

Every piece of the founder's journey becomes a unique, unrepeatable discovery for one person.

### 98.1 What the Archive Contains

The founder archive encompasses everything produced during Relay's design and construction:

| Content Type | Examples | Format |
|-------------|---------|--------|
| **AI transcripts** | Conversations with Claude, ChatGPT, Cursor — the actual dialogues that designed the system | Text with timestamps, model identifiers, and prompt/response structure |
| **Design videos** | Screen recordings of architectural breakthroughs, whiteboard sessions, first successful renders | Video with embedded metadata |
| **Audio recordings** | Voice notes, verbal design reasoning, moments of realization spoken aloud | Audio with transcription filament |
| **Handwritten notes** | Sketches, equation drafts, margin notes, napkin diagrams | Scanned image with OCR filament |
| **Decision logs** | Why specific paths were chosen, what alternatives were rejected, the reasoning chain | Structured text with pros/cons and confidence |
| **Philosophical exchanges** | Conversations about what truth means, why accountability matters, what a tree represents | Full dialogue with context |
| **Equation derivations** | The mathematical work behind gravity, confidence, wilt, energy budget, photosynthesis | Step-by-step derivation with annotations |
| **Prototype artifacts** | Early screenshots, failed experiments, first working filaments, evolution of the visual language | Images, videos, code snippets |

### 98.2 Distribution as Type 3 Chests

Every artifact in the founder archive is distributed as a Type 3 one-time chest. The distribution follows these principles:

**Fragmentation.** Large artifacts are broken into meaningful fragments. A two-hour design conversation becomes twenty fragments, each containing a coherent exchange — a question, a realization, a debate, a conclusion. Each fragment stands alone as a discovery. Together, they tell a larger story — but no single person will hold them all.

**Geographic placement.** Chest locations are thematically linked to their content:
- A conversation about agricultural data is placed in farming regions
- A realization about weather systems is placed near meteorological stations
- A debate about urban governance is placed in city centers
- A philosophical exchange about truth is placed at a university
- A mathematical derivation is placed near a research institution
- Some placements are deeply personal — a conversation that happened at a specific cafe is placed at that cafe's coordinates

**Temporal scattering.** Not all chests are available at genesis. Some activate at future epoch thresholds — discoveries waiting for the world to be ready. A chest about interplanetary data might activate only when Mars observation trees exist (§94.7). The activation schedule is sealed.

**No collection completeness.** The archive is deliberately too large and too scattered for any individual or coordinated group to collect in full. The founder's story is meant to be encountered in fragments, discussed, compared, and pieced together across generations of users. The complete picture emerges collectively, never individually — mirroring how the system itself was built.

### 98.3 The Founder's Trust

This distribution is an irreversible act. Once the founder places the archive as Type 3 chests:

- The founder no longer controls who finds each fragment
- The founder cannot retrieve a placed chest
- The founder cannot see who will find what
- The original artifacts on Tree Zero's sealed branches remain (§89.2), but the Type 3 chest versions are the only way those specific fragments enter individual trees as legendary branches

The founder trusts that the people who find these fragments will value them — not as collectibles, but as genuine insight into how the system was designed and why. The archive is not memorabilia. It is evidence. Each fragment is a real moment in the creation of something real.

### 98.4 Interaction with Progressive Revelation (§89)

The founder archive distribution complements but does not replace the RT tier system:

| Mechanism | What It Reveals | To Whom | When |
|-----------|----------------|---------|------|
| **RT-1/RT-2 (per-user)** | Operational and civic architecture | Individual users via Conceptual LOD | Through natural engagement |
| **RT-3 (collective)** | Deep architecture | All users simultaneously | Global milestone threshold |
| **RT-4 treasure fragments** | Design history, transcripts, videos | Individual finders via Type 3 chests | When found — one person, one time |
| **RT-4 ultimate reveal** | The complete Master Build Plan | All users | Supermajority vote or epoch timeout |

The Type 3 founder chests are a subset of RT-4 content — specifically, the personal, intimate fragments that are most meaningful as individual discoveries. The broader RT-4 architectural documents (the MBP itself, the complete specification) are revealed through collective mechanisms. The founder's personal journey is revealed through individual ones.

### 98.5 The Sealed Count

The total number of founder Type 3 chests is a sealed Category A parameter:

- The count is committed as an encrypted filament on Tree Zero
- Users cannot see the total
- Users can observe consumption events (each Type 3 opening is a public filament on Tree Zero's game branch)
- Users can count how many have been found — but not how many remain
- When the last founder Type 3 chest is opened, a special filament fires on Tree Zero: `founderArchive.distribution.complete = true`
- This completion event is itself a discovery — the user community will know when every fragment has been found, but not before

**Contract #259 — Founder Archive Distribution. All documentation, video, audio, AI transcripts, design sketches, handwritten notes, equation derivations, and philosophical exchanges from Relay's founding are distributed exclusively as Type 3 one-time treasure chests. Distribution uses the AI Curation Tool (§89.5). Artifacts are fragmented into coherent standalone pieces. Geographic placement is thematically linked to content. Temporal activation schedules are sealed. The total chest count is a sealed parameter. No individual can collect the complete archive. This distribution principle is frozen.**

**Contract #260 — Founder Chest Placement Principle. Founder Type 3 chests are placed at coordinates that reflect the thematic content of the artifact — conversations about cities in cities, realizations about farming in agricultural regions, mathematical work near research institutions. Some placements are personally meaningful to the founder. Placement decisions are committed filaments on Tree Zero (location hashes, not plaintext coordinates). Placement is irreversible — the founder cannot retrieve placed chests. The placement principle is frozen.**

---

## 99. The Awakening Curve — Progressive Understanding Through Use — Frozen Contracts #261–262

> *"The world is a lot more simple than it seems."* — Eitan Asulin
>
> *"I want everyone to be able to go through the same experience I did when you start to realize what mapping on spreadsheets and global data actually means. The slow progression and independent understanding step by step is key to seeing how all this will happen and getting on board."* — Eitan Asulin

This section describes Relay's deepest design principle — one that is not a feature, not a mechanic, and not a contract that can be implemented in code. It is the reason the system exists: every person who uses Relay will, at their own pace, in their own domain, through their own experience, arrive at the same understanding the founder arrived at. That structured, trustworthy data mapped onto reality at global scale reveals how everything connects — and that seeing this changes what you believe is possible.

### 99.1 The Founder's Journey

The founder did not start with a vision of civilization-scale truth mapping. He started with spreadsheets. Then realized those spreadsheets could be visual. Then realized the visuals could encode trust. Then realized trust could be verified across entities. Then realized verified trust across all entities would reveal the actual state of the world. Then realized that the actual state of the world — visible, accountable, unmistakable — would change what humanity chooses to do.

Each realization followed the last. None could have been skipped. The progression took years — conversation by conversation, equation by equation, section by section. The Master Build Plan itself is the fossil record of this journey: §0 begins with a neighborhood tree. By §94, the system is measuring whether humanity has ended hunger.

The Awakening Curve is the principle that this journey is not unique to the founder. It is built into the structure of Relay itself.

### 99.2 The Curve

Relay is not designed to be understood all at once. It is designed so that using it naturally creates a progression of insight. The curve has no fixed timeline — it unfolds differently for every user — but the stages are consistent because they follow from the physics:

| Stage | What the User Realizes | Why It Happens | Relay Mechanic |
|-------|----------------------|----------------|----------------|
| **Personal Utility** | "This is a better way to organize my data" | First tree, first branch, first filaments. The 3D structure is intuitive. | First-screen contract (§81.9), basic tree |
| **Interoperability** | "My neighbor's tree works exactly like mine" | First cross-tree link. Seeing someone else's branch and recognizing the same structure. | Cross-tree linking (§7), disclosure tiers (§8.5) |
| **Supply Chain** | "You could trace a product from mineral to shelf" | Encountering a product tree (§77) or seeing how counterparty links chain across entities. | Product supply chain (§77), counterparty filaments |
| **Accountability** | "You could see where every dollar goes" | Viewing a government or organization tree where spending is visible as branch geometry. | Treasury transparency (§86), civic branches |
| **Civilization Metrics** | "You could see whether we're actually solving our problems" | Visiting Tree Zero's goals branch (§94). Seeing the civilization dashboard. Realizing the metrics are real. | Civilization goals (§94), global aggregation |
| **The Realization** | "One structure. One truth. Every tree on Earth works the same way. The shape tells you everything." | The moment the user sees that Relay's uniformity is not a limitation but the point. The same physics that organize their personal files also measure global hunger. | The entire system |

### 99.3 Why the Curve Cannot Be Accelerated

The understanding must be earned through use because each stage depends on the visceral experience of the previous one:

- You cannot understand interoperability until you've built your own tree and internalized what a branch means
- You cannot grasp supply chain traceability until you've experienced cross-tree links on something that matters to you
- You cannot feel the weight of accountability until you've seen your own data rendered as geometry and understood that the shape cannot lie
- You cannot process civilization-scale metrics until you've experienced accountability at a smaller scale and realized it scales

No tutorial, no video, no marketing pitch, no documentation can substitute for this progression. Telling someone "Relay maps all data onto 3D trees and can measure global hunger" sounds like science fiction. Living through the progression — starting with your own files and ending at the civilization dashboard — makes it obvious.

This is why Relay's onboarding (§73) starts with personal utility and never mentions civilization goals. This is why the Conceptual LOD system (§81.8) gates complexity by engagement. This is why the education module (§58) offers role-based starting paths — each path begins in the user's own domain and lets the broader implications emerge naturally.

### 99.4 The Awakening Curve and Treasure Chests

Treasure chests (§96) are breadcrumbs along the Awakening Curve. They reward users who are exploring — who are curious, who are going deeper — with fragments that confirm and extend their developing understanding:

- **Early in the curve:** Type 0 chests teach game mechanics and reward exploration habit
- **Mid-curve:** Type 2 regenerating chests create community around shared discovery, mirroring the interoperability realization
- **Deep in the curve:** Type 1 personal chests reward domain expertise, confirming that the system sees and values the user's specific engagement
- **At the edge:** Type 3 one-time chests deliver the founder's own journey fragments — pieces of the same progression, experienced by someone else, placed in the world for the finder to recognize and relate to

The deepest chest content is not valuable because it is rare. It is valuable because by the time a user finds it, they have enough context to understand what they're reading. A founder transcript about deriving the confidence equation is meaningless to a day-1 user. To a user who has built their own tree, linked to others, seen accountability in action, and visited the civilization dashboard — that same transcript is a confirmation of everything they've come to understand.

**Game-layer progression parallels the curve.** The Awakening Curve is a truth-layer insight progression, but the game layer has its own parallel trajectory that reinforces and illustrates each stage:

- **Stage 1 (Personal Utility):** User discovers basic spell casting, crafts their first Common-tier graphic, uses the free Crafting IDE to experiment. The game layer makes the tree feel alive and personal.
- **Stage 2 (Interoperability):** User enters their first duel, sees another user's crafted spell effects, encounters summon creatures for the first time. The realization that other people's trees interact with yours through combat and spectacle mirrors the truth-layer discovery that trees connect.
- **Stage 3 (Supply Chain):** User begins collecting diverse summons, assembles a combat loadout, discovers that treasure chests in different geographic locations unlock different capabilities. The realization that game-layer resources flow through the same tree physics as real-world resources.
- **Stage 4 (Accountability):** User participates in arena governance, votes on weapon balance, sees how community voting shapes the combat meta. The realization that game-layer rules are governed by the same parametric system as truth-layer policy.
- **Stage 5 (Civilization Metrics):** User sees civilization goals (§94) gating game mechanics — Tier 2 achievements unlock arena duels, Tier 3 unlocks advanced arena modes. The realization that real-world progress unlocks game possibilities, not the other way around.
- **Stage 6 (Realization):** The game layer and the truth layer are the same system. Crafting mastery feeds attention which feeds the tree which feeds governance weight. Summoned AI creatures use the same SCV intelligence that manages your business. The arena and the boardroom run on identical physics. There is no separate "game." There is one tree.

The game layer does not replace or shortcut the Awakening Curve. It provides a parallel experiential track that makes each truth-layer insight viscerally felt rather than intellectually understood.

### 99.5 The Founder's Guarantee

The Awakening Curve is not a monetization strategy. It does not gate features behind understanding. It does not slow users down to increase engagement metrics. It is a recognition that some truths can only be understood sequentially, and that the sequence itself is the most valuable thing Relay offers.

Every feature that exists at Tier 0 (§94.2) is available from day one. The free tier (§95.3) includes everything needed to reach every stage of the curve. The curve does not require payment, does not require game layer participation, does not require social connection. A single user with a single tree, exploring honestly, will arrive at the realization on their own.

The system is designed so that the shape of the data teaches you what the data means.

### 99.6 Invariants

1. **No stage can be skipped.** The Awakening Curve is sequential because each insight depends on experiencing the previous one. There is no "skip to civilization metrics" button.
2. **No stage can be purchased.** Money does not accelerate understanding. Premium features do not exist on the curve.
3. **No stage can be forced.** The system does not push users through the curve. If someone uses Relay only for personal files for ten years, that is valid. The curve is available, not mandatory.
4. **No stage can be faked.** Conceptual LOD (§81.8) advances only through demonstrated engagement, not through self-declaration or payment.
5. **The curve is infinite.** The six stages described above are the founder's observed pattern. Future stages may emerge as the system grows — interplanetary data, AI-tree integration, temporal archaeology. The curve has no ceiling because understanding has no ceiling.
6. **The curve is the product.** Relay's real output is not a 3D visualization, not an accounting system, not a governance platform, not a game. It is the progressive understanding that all of these are the same thing.

**Contract #261 — The Awakening Curve. Relay is designed so that sustained use naturally produces a progressive understanding of what structured global data means — from personal utility through interoperability, supply chain traceability, accountability, civilization metrics, to the realization that one universal structure reveals the state of everything. This progression mirrors the founder's own journey and is emergent from engagement, not taught or gated. The Awakening Curve is recognized as Relay's deepest design principle. This principle is frozen.**

**Contract #262 — Non-Acceleration Guarantee. No stage of the Awakening Curve can be skipped, purchased, forced, or faked. The free tier provides everything needed to traverse the full curve. Conceptual LOD advancement requires demonstrated engagement. The curve is available to every user but mandatory for none. Understanding is earned through use. This guarantee is frozen.**

---

---

## 100. The Substrate — Global Knowledge Bedrock & Activation Mechanics — Frozen Contracts #263–266

> *"We stand on the shoulders of giants."* — Isaac Newton (attributed by Bernard of Chartres)
>
> *"The knowledge exists. It's just not in Relay yet."* — Eitan Asulin

Humanity already knows an enormous amount. Best medical practices, agricultural science, legal codes, engineering standards, educational curricula, physical constants, historical records — all of it lives scattered across the 2D internet: on websites, in PDFs, behind paywalls, in government databases with terrible interfaces, in academic journals nobody reads. This knowledge has no geographic identity, no evidence chain, no confidence score, and no connection to the trees that need it.

The Substrate is how Relay absorbs what humanity already knows without putting it on any tree — because no tree owns it. The Substrate is the geological bedrock beneath all trees. It is the common ground.

### 100.1 What the Substrate Is

Below every tree's root system (§1.3) is a shared layer that belongs to no entity. It is the knowledge commons — the structured, attributed, confidence-scored index of what the 2D internet already contains, organized into Relay's filament format and waiting for real users to engage with it.

**Geological metaphor extended:**

| Depth Layer | What It Contains | Ownership | Visual |
|------------|-----------------|-----------|--------|
| **Canopy** | Active branches, live filaments, engagement | Per-tree | Organic — bark, leaves, sap glow |
| **Trunk** | Core structure, identity | Per-tree | Dense wood grain |
| **Root zone** | Per-tree historical archive (§1.3) | Per-tree | Organic root structures, soil tones |
| **Substrate** | Shared human knowledge — reference filaments | Nobody. Commons. | Mineral — crystal veins, geological formations, different glow spectrum |

The Substrate is not a tree. It has no trunk, no branches, no owner, no governance. It is a layer — rendered as geological bedrock with crystalline structures organized by knowledge domain. When a user flies underground in FPS mode (§50) past their tree's roots, the visual transitions from organic (soil, roots) to mineral (crystal veins, glowing formations). This is the boundary between personal history and collective knowledge.

### 100.2 Reference Filaments

The Substrate is populated with **reference filaments** — a subtype of filament designed to index external knowledge without claiming it:

```
ReferenceFilament {
  filamentId:       "F-REF-<domain>-<uuid>"
  objectType:       "REFERENCE"
  domain:           "health" | "education" | "agriculture" | "law" | "finance" |
                    "engineering" | "science" | "infrastructure" | "environment" | ...
  sourceURL:        original web location (preserved even if link dies)
  sourceAuthority:  publishing entity ("WHO", "MIT", "USDA", "Nature", ...)
  authorityTier:    PEER_REVIEWED | GOVERNMENT | INSTITUTIONAL | JOURNALISTIC |
                    COMMUNITY_WIKI | INDIVIDUAL
  attribution:      full citation in standard format
  deferredClaim:    "@<original-author>" — resolves when they join Relay (§79.4)
  summary:          AI-generated structured summary (factual extraction, not creative reproduction)
  summaryHash:      hash of the summary content
  sourceHash:       hash of the source content at crawl time
  confidence:       computed from authorityTier (PEER_REVIEWED=0.8, GOVERNMENT=0.7,
                    INSTITUTIONAL=0.6, JOURNALISTIC=0.5, COMMUNITY_WIKI=0.4, INDIVIDUAL=0.3)
  lastVerified:     timestamp of last link/content verification check
  supersededBy:     null | filamentRef (populated when primary source joins Relay)
  license:          "PUBLIC_DOMAIN" | "CC-BY" | "CC-BY-SA" | "FAIR_USE_SUMMARY" |
                    "GOVERNMENT_PUBLIC" | ...
  activatedBy:      null | userRef (populated on first activation)
  activatedAt:      null | timestamp
  activationCount:  0 (how many living filaments link down to this reference)
}
```

**What reference filaments are NOT:**
- They are not copies of copyrighted content. They are structured summaries with attribution and links.
- They are not truth claims. Their confidence reflects source authority, not verified ground truth.
- They are not permanent claims of knowledge. They exist to be superseded by real committed data.

**Legal compliance:**
- Crawling respects robots.txt and terms of service
- Content is summarized under fair use — factual extraction, not creative reproduction
- License tracked per filament — public domain, Creative Commons, government publications, fair use summaries
- The AI Curation Tool (§89.5) enforces the fair use boundary during classification

### 100.3 Substrate Population

The founder, assisted by the SCV curation pipeline, populates the Substrate before genesis. The pipeline:

1. **Source identification.** For each civilization domain (§76 pillars), identify authoritative sources: international bodies (WHO, FAO, UNESCO), government agencies (USDA, NHS, NIST), academic institutions, peer-reviewed journals, established educational platforms, legal code databases.

2. **Crawl and classify.** The SCV pipeline crawls identified sources, extracts structured facts, classifies by domain, and assigns authority tiers. Raw content is never stored — only structured summaries with source hashes and links.

3. **Attribute and cite.** Every reference filament carries full attribution to its original creator. Attribution uses the deferred claim mechanic (§79.4) — the original author is named even though they don't have a Relay tree yet.

4. **Organize by domain.** Reference filaments are organized into geological formations by knowledge domain. Health references cluster in one mineral vein. Agricultural references in another. The domain structure mirrors the Civilization Template Library (§76).

5. **Score by authority.** Confidence is assigned from the authority tier system. A WHO clinical guideline starts at 0.8. A personal blog post starts at 0.3. These scores are the starting hypothesis — real-world data from Relay users will eventually confirm, refine, or challenge them.

**Phased population:**

| Phase | Scope | Estimated Reference Filaments | Cost |
|-------|-------|------------------------------|------|
| **Genesis** | Core domains for Phase 0 templates (business, health, education) | ~500K | ~$50K–$100K |
| **Year 1** | All 13 civilization pillars at depth | ~5M | ~$500K–$1M |
| **Year 2+** | Continuous expansion, multi-language, new domains | ~50M+ | Funded by ISR revenue |

Genesis cost is a line item on Tree Zero's infrastructure branch — visible, auditable, funded from initial capital.

### 100.4 Activation — From Bedrock to Living Tree

A reference filament in the Substrate is inert until a real user engages with it. Activation is the moment knowledge passes from the commons into the living world.

**How activation works:**

1. A user commits a filament on their tree that intersects with a Substrate reference — same topic, same domain, related content.
2. The SCV detects the intersection and offers a cross-reference link: "Related reference exists in the Substrate. Link?"
3. If the user confirms, two things happen:
   - A **citation link** forms between the user's living filament and the Substrate reference. The user's filament gains a citation chain reaching down into the bedrock.
   - The Substrate reference's `activatedBy` field is set to this user, and `activationCount` increments. This user becomes the **geographic anchor** — the first person in Relay's 3D world to engage with this topic at this location.

4. The reference filament does NOT move. It stays in the Substrate. It's still there for everyone. Activation doesn't lock others out — it creates a bridge between one person's tree and the shared bedrock.

**What geographic anchoring means:**

The user who activates a reference is not claiming authorship. The original 2D creator retains attribution (deferred, claimable later). The activating user is claiming *presence* — "I am here, in this place, and this knowledge matters to me." Their tree is now the first living instance of this topic at this location.

Subsequent users who engage with the same topic in the same region see the first user's filament as a starting point. If the first user's engagement is shallow, the second user who posts deeper content naturally attracts more engagement, more citations, and effectively becomes the local authority. The geographic anchor is a timestamp, not a throne.

### 100.5 The 2D-to-3D Attribution Bridge

Original creators of 2D internet content retain attribution through the deferred claim mechanic (§79.4):

| Scenario | Attribution State | Resolution |
|----------|------------------|------------|
| **Living author, joins Relay** | Deferred `@Dr. Smith, MIT`. Dr. Smith creates a tree and claims the attribution. | Deferred reference resolves to real counterparty link to Dr. Smith's tree. |
| **Living author, never joins** | Deferred `@Dr. Smith, MIT`. Stays deferred indefinitely. | Attribution persists as ghost-label. No expiration. |
| **Deceased author** | Deferred `@Marie Curie`. Never claimable personally. | Attribution is permanent, factual, governance-protected. Estate or scholarly community can claim stewardship (not ownership). |
| **Institutional author** | Deferred `@WHO`. WHO joins Relay. | WHO's tree becomes the primary source. Reference filament's `supersededBy` points to WHO's living tree. |
| **Disputed authorship** | Two claimants for same attribution. | Governance resolution — evidence-based community vote (§72), sortition (§46) for contested cases. Publication records, timestamps, and institutional records form the evidence chain. |

**Supersession:** When the actual source joins Relay and commits their knowledge as primary filaments on their own tree, the Substrate reference is superseded:
- `supersededBy` points to the primary source's tree
- The reference filament develops a visual indicator — a crack or mineral-to-organic transition showing that bedrock has been replaced by living wood
- Citation links from activated users redirect to the primary source
- The reference is never deleted — it becomes geological history, evidence that this knowledge existed before the primary source arrived

### 100.6 Anti-Gaming: Activation Rate Limits

**The risk:** A user could bulk-activate thousands of Substrate references — posting minimal engagement on every topic to become the geographic anchor for everything, artificially inflating their tree.

**Existing physics that already limit this:**

1. **Confidence requires evidence** (§9). A filament that says "I agree with this WHO guideline" with zero evidence has low confidence. Low confidence = fog. A foggy tree is visibly untrustworthy.

2. **Engagement mass requires actual engagement** (§83.1). Activating a reference is a commit. But if nobody responds, the filament is a dead leaf. No engagement = no photosynthesis = no growth.

3. **Immune detection** (§83.4, §84). Rapid-fire commits with low semantic delta and high scaffold percentage trigger anti-fraud detection. The SCV flags it. Fog, wilt, scar.

4. **Wilt from neglect** (§3, §30). Activate 1,000 references and never follow up? All 1,000 branches wilt. Your tree looks diseased. Nobody engages with a wilted tree.

5. **Attention is earned, not claimed** (§96.3). Being the geographic anchor means nothing if your engagement is shallow. The next person who posts genuine content on the same topic attracts the citations.

**One explicit additional limit:**

Despite the emergent protections, one explicit rate limit prevents bulk land-grabs:

```
activationRateLimit {
  maxActivationsPerTimebox:  computed from treeMaturiy
  baseRate:                  5 activations per timebox (new trees)
  scalingFactor:             +1 per 100 committed filaments with confidence > 0.6
  absoluteCeiling:           50 activations per timebox (no tree exceeds this)
  cooldownOnFlag:            if immune detection triggers, rate drops to 1 for 3 timeboxes
}
```

- **New users** (fresh tree, few commits): 5 activations per timebox. Enough to start engaging with references in their domain. Not enough to bulk-claim.
- **Active users** (mature tree, hundreds of confident filaments): Rate scales up. Demonstrated engagement earns the right to activate more. But never more than 50 per timebox.
- **Flagged users** (immune detection triggered): Rate drops to 1 activation per timebox for 3 timeboxes. Gaming attempt is punished with cooling.

All rate parameters are **Category A** — community-governable via parametric governance (§11). The community can tighten or loosen as gaming patterns emerge.

### 100.7 Substrate Rendering

When a user navigates underground past the root zone:

| Depth | Visual | Content |
|-------|--------|---------|
| **Root boundary** | Organic-to-mineral transition — soil gives way to crystal | Per-tree archive ends, commons begin |
| **Shallow Substrate** | Bright crystal veins, organized by domain | Recent web content, active references with many activations |
| **Mid Substrate** | Denser formations, dimmer glow | Established knowledge, institutional publications, standards |
| **Deep Substrate** | Dense mineral core, steady glow | Fundamental knowledge — physical constants, mathematical proofs, historical records |

**Visual cues:**
- **Activated references** glow brighter than dormant ones — you can see which knowledge veins are alive
- **Deferred attributions** render as ghost-labels — translucent names hovering near their references, waiting to solidify when the real person claims them
- **Superseded references** show mineral-to-organic transitions — cracks where living wood from a real tree has grown down through the crystal, replacing it
- **Domain formations** are color-coded by the filament color grammar (§91) — health veins are one hue, agriculture another, law another

### 100.8 Invariants

1. **The Substrate is commons.** No entity owns it. No governance can restrict access to it. Every user can navigate the Substrate from any tree's root zone.
2. **Reference filaments are never truth.** Their maximum confidence is capped by authority tier. Only primary committed data from the actual source can reach full confidence.
3. **Activation does not lock.** Multiple users can activate the same reference. The first activator gets the geographic anchor timestamp, but all subsequent activators get their own citation links.
4. **Supersession is graceful.** When a primary source joins, the reference redirects. It is never deleted. The geological record shows what came before.
5. **The Substrate shrinks over time.** As more primary sources join Relay and commit their own data, more references are superseded. The goal is a world where the Substrate is mostly superseded — where living trees have replaced bedrock with real committed truth.
6. **Attribution is permanent.** Deferred claims never expire. The original 2D creator is always cited, whether they join Relay or not.
7. **Rate limits are community-governed.** All activation rate parameters are Category A. The community adjusts as gaming patterns emerge.
8. **Legal compliance is non-negotiable.** Reference filaments respect source licensing, robots.txt, fair use boundaries. No copyrighted content is reproduced — only structured factual summaries with attribution and links.

**Contract #263 — The Substrate. Below every tree's root system lies a shared geological knowledge layer — the Substrate — containing reference filaments that index humanity's existing knowledge from the 2D internet. The Substrate belongs to no entity. It is rendered as mineral/crystalline formations visually distinct from organic tree roots. Reference filaments contain structured summaries with full attribution, source hashes, authority-tier confidence scores, and deferred claims for original creators. The Substrate is the knowledge commons. This layer definition is frozen.**

**Contract #264 — Reference Filament Schema. Reference filaments are a distinct subtype: objectType REFERENCE, with sourceURL, sourceAuthority, authorityTier, attribution, deferredClaim, summary, summaryHash, sourceHash, confidence (capped by authority tier), lastVerified, supersededBy, activatedBy, activationCount, and license fields. Reference filaments are never truth claims — their confidence ceiling is below primary committed data. They exist to be superseded by real sources. The schema is frozen.**

**Contract #265 — Activation & Geographic Anchoring. A Substrate reference filament activates when a real user commits a living filament that intersects its topic and confirms the cross-reference link. The activating user becomes the geographic anchor — the first person in Relay's 3D world to engage with this topic at this location. Activation does not lock the reference — multiple users can activate the same reference. The geographic anchor is a timestamp, not ownership. Subsequent users with deeper engagement naturally attract more citations. When the original source joins Relay, the reference is superseded and citation links redirect. The activation mechanic is frozen.**

**Contract #266 — Substrate Anti-Gaming Rate Limits. Substrate activation is rate-limited per user per timebox: base rate of 5 for new trees, scaling with tree maturity (committed filaments with confidence above 0.6), absolute ceiling of 50 per timebox, cooldown to 1 for 3 timeboxes upon immune detection trigger. Existing physics (confidence requirements, engagement mass, immune detection, wilt from neglect) provide additional emergent protection. All rate parameters are Category A — community-governable. The rate limit structure is frozen.**

---

## 101. SCV Physical Extension — Drone & Robotics Evidence Architecture — Frozen Contracts #267–269

> *"The machine does not isolate man from the great problems of nature but plunges him more deeply into them."* — Antoine de Saint-Exupéry

The SCV (Supply Chain Validator) is defined as an AI agent on every branch (§16, §92). It checks data, flags problems, assists users, and routes through intelligence tiers (T0 deterministic through T3 human escalation). But the SCV has a fundamental limitation: it cannot gather evidence on its own. When confidence drops because visual evidence is missing, the SCV can only ask a human to go look.

A drone — or any physical device that can move, observe, and report — removes this limitation. The SCV becomes an agent that can act in the physical world.

### 101.1 The Principle

The SCV's intelligence tiers (§92.2) extend from digital to physical:

| Tier | Digital SCV (Current) | Physical Extension |
|------|----------------------|-------------------|
| **T0 — Deterministic** | Schema checks, threshold triggers | Sensor reads (battery, GPS, altitude, basic telemetry) |
| **T1 — Local Model** | Lightweight classification, pattern detection | On-device classification (crop health, structural damage, livestock count, environmental conditions) |
| **T2 — Frontier API** | Complex reasoning, cross-domain analysis | Cloud analysis of device footage (disease identification, yield prediction, damage assessment) |
| **T3 — Human Escalation** | Ask the user, sortition, authority chain | Human takes manual control of the device, or physically visits the location |

The physical device does not think. The SCV thinks. The device is an actuator — it flies, drives, floats, or holds position, gathering evidence under SCV direction. If the device can't handle the situation (T1 classification fails, conditions too dangerous, legal restriction), the SCV escalates — same degradation path it always uses.

### 101.2 The Evidence Loop

Today's evidence loop has a human bottleneck:

```
SCV detects evidence gap → flags human → human travels to location →
human gathers evidence → human commits filament → confidence restores
```

With physical extension, the loop closes automatically for routine evidence gathering:

```
SCV detects evidence gap → dispatches mission to device's companion tree →
device travels to location → device gathers evidence (video, thermal, multispectral) →
device SCV classifies on-device (T1) → raw data microsharded (§66) →
classified signals committed as filaments → branch SCV validates evidence →
confidence restores → human reviews summary (not raw footage)
```

The human is still in the loop — they review results, authorize non-routine actions, and handle escalations. But the evidence-gathering step is automated for cases where the SCV already knows what to look for and a device can go look.

### 101.3 Device as Companion Tree

Every physical device running Relay software gets a **companion tree** (§17.4 pattern extended from animals to equipment):

```
tree.device.<owner-tree>.<device-id>
├── telemetry           ← SapPackets: GPS, altitude, battery, heading, speed (ms TTL)
├── maintenance         ← Filaments: flight hours, part replacements, calibration records
├── missions            ← Branch per mission: start/end, waypoints, evidence commits, status
├── evidence            ← Committed filaments: video hashes, thermal captures, classifications
└── compliance          ← Registration, operator license, airspace authorizations
```

**Telemetry is sap** (§82.3). Live GPS, altitude, battery, heading — these are SapPackets. Overwritable, millisecond TTL, never persisted unless materiality triggers a checkpoint (low battery warning, GPS anomaly, collision event, geofence breach).

**Missions are filaments.** A user or the branch SCV commits a mission filament to the device's tree:

```
MissionFilament {
  filamentId:       "F-MISSION-<device-tree>-<uuid>"
  objectType:       "DEVICE_MISSION"
  missionType:      "PATROL" | "SURVEY" | "INSPECT" | "HOVER_OBSERVE" | "DELIVER" | ...
  dispatchedBy:     branchRef (the SCV or user that requested evidence)
  coordinates:      [...] (waypoints or area boundary)
  altitude:         target altitude in meters
  duration:         maximum mission time
  evidenceCapture:  "CONTINUOUS_VIDEO" | "INTERVAL_PHOTO" | "THERMAL" | "MULTISPECTRAL" | ...
  returnCondition:  "LOW_BATTERY" | "MISSION_COMPLETE" | "WEATHER_ABORT" | "RECALL"
  priority:         0-10 (determines scheduling order)
  airspaceAuth:     reference to compliance filament authorizing this flight
}
```

**Scheduled missions are scheduled filaments** (§5b). A recurring patrol is a scheduled filament at a future L position. When the time arrives, the filament transitions SCHEDULED to OPEN, the device launches, and the mission executes. Identical to how a meeting works — the branch tip IS the calendar.

### 101.4 Cross-Tree Evidence Flow

The critical mechanic: a device gathers evidence for *other* trees, not just its own.

A farmer's drone surveys crop fields. The video evidence flows to the *farm tree's* agriculture branch, not just the drone's mission log. The evidence chain:

```
Device camera → on-device T1 classification → signal metadata + evidence hash →
commit to device's mission branch → cross-tree evidence link to target branch →
target branch SCV validates evidence quality → confidence on target branch updates
```

**Examples:**

| Owner | Device | Target Branch | Evidence Type | Result |
|-------|--------|--------------|---------------|--------|
| Farmer | Agricultural drone | Farm tree → crop health | Daily aerial photos, thermal, NDVI | Branch confidence stays high; growth trends visible in slab thickness |
| Municipality | Infrastructure drone | City tree → bridges/roads | Structural inspection photos, crack detection | Maintenance branches get evidence; wilt prevented |
| Environmental agency | Marine sensor | Ocean tree → water quality | Temperature, pH, dissolved oxygen | Environmental monitoring branch with continuous automated evidence |
| Warehouse operator | Ground robot | Logistics tree → inventory | Shelf scans, count verification | Inventory branch confidence maintained without manual counting |

### 101.5 Relay Robotics Mission Progression

Relay Robotics (§93.1, `tree.org.relay-robotics`) follows a software-first progression:

| Phase | What Relay Robotics Delivers | How It Works |
|-------|------------------------------|-------------|
| **Phase 0 — Protocol** | Open SDK and evidence protocol specification. Any drone manufacturer can integrate Relay telemetry and evidence commits. | Open source. Revenue: ISR on evidence transactions. |
| **Phase 1 — Software** | Relay Drone Software — installable on existing commercial hardware (DJI, Skydio, Parrot, Autel). Mission planning, automated patrol, evidence commits, fleet management. | Software distribution. Revenue: ISR on device tree operations. |
| **Phase 2 — Reference Hardware** | A Relay-native drone optimized for evidence capture: 360 cameras, LiDAR, thermal imaging, extended flight time, native Relay communication chip. | Hardware sales + software. Revenue: device sales + ISR. |
| **Phase 3 — Fleet Infrastructure** | Autonomous fleet management for municipalities, farms, logistics hubs, environmental monitoring networks. Drones as permanent evidence infrastructure. | Service contracts. Revenue: operational ISR + resource pricing. |

Phase 0 is the priority — define the protocol so the existing drone ecosystem can integrate. Phase 2 (native hardware) only makes sense after the protocol is proven and adoption demand is demonstrated. Building hardware before software protocol exists is backwards.

### 101.6 Not Just Drones

The SCV physical extension principle applies to any device that can observe and report:

| Device Type | Evidence Domain | Companion Tree Template |
|-------------|----------------|------------------------|
| **Aerial drone** | Agriculture, infrastructure, environmental, security | `DEVICE.UAV` |
| **Ground robot** | Warehouse, manufacturing, indoor facility inspection | `DEVICE.GROUND` |
| **Underwater vehicle** | Ocean monitoring, pipeline inspection, marine biology | `DEVICE.MARINE` |
| **Fixed sensor array** | Bridge strain, pipeline pressure, air quality, traffic flow | `DEVICE.SENSOR` |
| **Satellite feed** | Large-scale environmental, weather, deforestation, urban growth | `DEVICE.SATELLITE` |

Every device type uses the same companion tree structure, the same mission filament schema, the same cross-tree evidence flow. The SCV on the target branch doesn't care whether the evidence came from a $200 consumer drone or a $2M satellite — it validates the evidence quality the same way.

### 101.7 Invariants

1. **Detection is local-first** (contract #49). All camera-based classification runs on the device. Raw video frames never leave the device unless explicitly committed as evidence via microsharding (§66). The SCV validates classified signals, not raw imagery.
2. **The device is an actuator, not an authority.** The device gathers evidence. The branch SCV validates it. The human reviews and authorizes. The device never commits filaments that bypass SCV validation.
3. **Airspace compliance is mandatory.** Every mission filament requires a reference to a compliance filament authorizing the flight in the relevant airspace (§90). No compliance authorization = no mission dispatch.
4. **The device tree is governed like any tree.** Disclosure tiers (§8.5), parametric governance (§11), immune detection (§84) — all apply. A drone tree that exhibits anomalous behavior triggers the same immune response as any other tree.
5. **Software before hardware.** Relay Robotics' Phase 0 (protocol) and Phase 1 (software on existing devices) must be operational before Phase 2 (native hardware). The protocol defines the contract; hardware is one implementation.
6. **Physical extension is optional.** An SCV without physical devices works exactly as it does today — flagging evidence gaps for human resolution. Physical extension enhances the evidence loop; it does not change the SCV's fundamental architecture.

**Contract #267 — SCV Physical Extension Principle. The SCV intelligence tier model (T0–T3) extends to physical devices: T0 for deterministic sensor reads, T1 for on-device classification, T2 for cloud-based analysis, T3 for human escalation and manual control. Physical devices are actuators commanded by the SCV — they gather evidence, they do not make truth claims. The evidence loop (gap detection → mission dispatch → evidence gathering → SCV validation → filament commit) automates routine evidence collection while keeping humans in the loop for review and authorization. This extension principle is frozen.**

**Contract #268 — Device Companion Tree Schema. Every physical device running Relay software operates as a companion tree with branches for telemetry (sap), maintenance (filaments), missions (filaments with MissionFilament schema), evidence (committed captures), and compliance (registrations and authorizations). Telemetry is sap-class (millisecond TTL, checkpointed only on materiality). Missions are standard filaments supporting scheduling (§5b). Cross-tree evidence links carry device-gathered evidence to target branches for SCV validation. The companion tree schema is frozen.**

**Contract #269 — Relay Robotics Progression Model. Relay Robotics follows a four-phase progression: Phase 0 (open protocol and SDK), Phase 1 (software on existing commercial hardware), Phase 2 (Relay-native reference hardware), Phase 3 (fleet infrastructure services). Software protocol must be operational before native hardware development begins. The progression applies to all device types — aerial, ground, marine, sensor, and satellite. Each phase is a mission on the Relay Robotics subsidiary tree with evidence-backed completion criteria. The progression model is frozen.**

### 101.8 IoT Device Ingestion Protocol — Sensors, PLCs, and Smart Infrastructure

§101.1-101.7 specifies how drones, robots, and mobile devices operate as SCV-commanded evidence gatherers. But the industrial and civic world is full of stationary devices that also produce evidence: factory floor PLCs, environmental sensors, weather stations, smart meters, traffic cameras, building management systems, agricultural soil monitors, and medical telemetry devices.

These devices do not need companion trees (they are not autonomous agents). They need an **ingestion protocol** — a standardized interface for feeding sensor data into the Relay tree as sap, with optional checkpoint to filament.

```
IoTIngestionRegistration {
  deviceId:           string,
  deviceType:         enum { SENSOR, PLC, METER, CAMERA, MONITOR,
                             WEATHER_STATION, MEDICAL_TELEMETRY, OTHER },
  ownerTreeRef:       treeRef (the tree that owns this device),
  targetBranch:       branchRef (where data flows),
  dataSchema:         objectType (template-defined schema for this device type),
  attestationFrequency: number (seconds between heartbeat attestations),
  ingestionMode:      enum { SAP_ONLY, SAP_WITH_CHECKPOINT, DIRECT_FILAMENT },
  retentionPolicy:    enum { TTL_ONLY, CHECKPOINT_ON_THRESHOLD, CHECKPOINT_ON_SCHEDULE },
  calibrationRef:     filamentRef | null (last calibration evidence)
}
```

**Ingestion modes:**

- **SAP_ONLY**: Device data streams as SapPackets with standard TTL. No persistence unless a checkpoint trigger fires. Suitable for high-frequency telemetry (temperature readings every second, vibration monitoring).
- **SAP_WITH_CHECKPOINT**: Data streams as sap but checkpoints to filament on materiality (threshold breach, anomaly detection, schedule). Suitable for environmental monitoring, utility metering.
- **DIRECT_FILAMENT**: Every reading becomes a committed filament. Suitable for low-frequency, high-importance data (daily soil tests, monthly emissions readings, medical lab results). Rate-limited to prevent storage abuse.

All ingested data follows the same physics as any other filament or sap. Confidence depends on calibration evidence. Fog increases if the device misses attestation heartbeats. The SCV on the target branch validates ingested data against expected ranges and flags anomalies. The device is an input source — never an authority.

**Contract #309 — IoT Device Ingestion Protocol. Stationary sensors, PLCs, meters, cameras, monitors, and telemetry devices feed data into Relay via a standardized ingestion registration with three modes: SAP_ONLY (high-frequency, TTL-governed), SAP_WITH_CHECKPOINT (streams with materiality-triggered persistence), and DIRECT_FILAMENT (low-frequency committed readings). All ingested data obeys standard tree physics — confidence from calibration, fog from missed attestations, SCV anomaly validation. Devices are input sources, never authorities. The ingestion protocol extends §101 to stationary infrastructure without requiring companion trees.**

---

---

## 102. Search Architecture & Filter Governance — Frozen Contracts #270–273

> *"The important thing is not to stop questioning. Curiosity has its own reason for existing."* — Albert Einstein

Search in Relay is not keyword matching against unstructured text. Every filament already carries six universal domains (Identity, Counterparty, Time, Magnitude, Evidence, Lifecycle), a template type, a branch address, and a confidence score. Searching is structured filtering across known dimensions. The data is pre-organized by tree physics — search is the act of asking the physics a question.

### 102.1 Search as SCV Function

There is no separate search engine. Search IS the SCV (§16, §92). The SCV on the branch you're searching already knows the schema, knows the template, knows the data. When you type a query, the SCV processes it. When you apply filters, the SCV narrows the results.

| Search Complexity | SCV Tier | Example | AI Required |
|-------------------|----------|---------|-------------|
| **Exact filter** | T0 — Deterministic | "All invoices over $10,000 from Q3" | No. Structured query against committed filaments. |
| **Pattern match** | T0 — Deterministic | "All filaments on this branch with confidence below 0.5" | No. Threshold comparison. |
| **Semantic match** | T1 — Local model | "Best agricultural practice for maize in my climate zone" | Yes — needs context understanding, Substrate reference lookup. |
| **Cross-tree discovery** | T1/T2 | "Who else in East Africa is tracking similar crop yields?" | Yes — needs graph traversal, similarity scoring, privacy-respecting aggregation. |
| **Natural language** | T2 — Frontier API | "Why is my branch wilting?" | Yes — needs diagnostic reasoning across multiple signals. |

Simple searches are fast and free (T0). Complex searches route through intelligence tiers exactly like any other SCV operation. The same routing logic, the same cost-as-filament transparency (§92.3), the same degradation path.

### 102.2 The Search Query Model

A search query is a set of constraints across the six universal domains plus template-specific fields:

```
SearchQuery {
  scope:          "BRANCH" | "TREE" | "REGION" | "GLOBAL" | "SUBSTRATE"
  scopeRef:       branchId | treeId | regionBounds | null
  filters: [
    { domain: "IDENTITY",     field: "objectType",      op: "IN",  values: ["INVOICE", "PO"] },
    { domain: "TIME",         field: "spawnAt",          op: "RANGE", values: ["2025-07-01", "2025-09-30"] },
    { domain: "MAGNITUDE",    field: "amount",           op: "GT",  values: [10000] },
    { domain: "EVIDENCE",     field: "confidence",       op: "GT",  values: [0.7] },
    { domain: "LIFECYCLE",    field: "lifecycleState",   op: "IN",  values: ["COMMITTED", "ABSORBED"] },
    { domain: "COUNTERPARTY", field: "counterpartyRef",  op: "EQ",  values: ["tree.org.supplier-x"] }
  ]
  sortBy:         "magnitude" | "time" | "confidence" | "relevance"
  sortDirection:  "ASC" | "DESC"
  limit:          50
  naturalLanguage: null | "free text query for T1/T2 processing"
}
```

When `naturalLanguage` is provided, the SCV at T1/T2 translates it into structured filters before execution. The user sees both: their original question and the structured query the SCV derived. If the SCV misinterpreted, the user can correct the filters directly. Transparency — the search shows you what it's doing.

**Game-layer search:** The same query model covers game-layer objects. Game-layer scopes extend the scope enum:

```
scope: "BRANCH" | "TREE" | "REGION" | "GLOBAL" | "SUBSTRATE" |
       "SPELL_LIBRARY" | "SUMMON_REGISTRY" | "CRAFTING_CATALOG" | "ARENA_HISTORY" |
       "OBLIVION"
```

Example game-layer searches:
- `{ scope: "SPELL_LIBRARY", filters: [{ domain: "IDENTITY", field: "objectType", op: "IN", values: ["SPELL_FIRE", "SPELL_ICE"] }] }` — "Show me all fire and ice spells I've discovered"
- `{ scope: "SUMMON_REGISTRY", filters: [{ domain: "MAGNITUDE", field: "power", op: "GT", values: [5] }] }` — "What summon creatures have power above 5?"
- `{ scope: "CRAFTING_CATALOG", filters: [{ domain: "LIFECYCLE", field: "status", op: "EQ", values: ["FINALIZED"] }], sortBy: "time", sortDirection: "DESC" }` — "My most recent finalized graphics"

**Oblivion scope (§72.12):** The `OBLIVION` scope is available only to users who have deliberately lowered their filter below the oblivion floor. Default search across all other scopes automatically excludes oblivion-classified results. Oblivion-scope queries are auditable — the search itself is committed as a filament on the user's tree.
- `{ scope: "ARENA_HISTORY", naturalLanguage: "My best duel performances this month" }` — T1/T2 translates to time-filtered arena match records sorted by outcome

Game-layer filters appear in filter governance (§102.3) and follow the same two-stage meta-vote: the community votes on which game-layer filters are prominent by default and which are advanced.

### 102.3 Filter Governance — Two-Stage Meta-Vote

Available filters come from template definitions — every field in a template is a potential filter. But which filters appear by default? Which are prominent? Which are hidden behind "Advanced"? This is a governance question resolved by the existing meta-vote model (§72):

**Stage 1 — What filters should be available?**

1. Any user in a template community can PROPOSE a default filter set: "Health search should default to: date range, diagnosis code, confidence, region"
2. The community votes on which proposals should be on the ballot (Layer 1 — meta-vote on which options deserve consideration)
3. Surviving proposals advance to the final vote

**Stage 2 — What is the filter priority ordering?**

1. Each surviving filter set goes to a weighted-median vote (Layer 0)
2. The winning configuration becomes the default search panel for that template
3. Individual filters within the winning set are ranked by vote weight — highest-voted filter appears first

**Governance scope:**

| Parameter | Scope | Governance Level |
|-----------|-------|-----------------|
| **Universal filters** (confidence, time, lifecycle) | Global | Category A — always available, ordering community-governed |
| **Template filters** (diagnosis, crop type, invoice amount) | Per template | Category B — template community governs |
| **Personal filter presets** | Per user | No governance — you configure your own saved filters |

**Silence-stability applies** (§81.3). If nobody votes on filter ordering for 12+ epochs, the existing configuration becomes harder to change (supermajority required). Default filter sets stabilize over time unless the community actively wants change.

### 102.4 Search Visualization — The Search Lens

Search results render as a **lens** (§81.5) — a read-only overlay that highlights matching content and fades everything else:

**Highlighting:**
- Matching filaments intensify: glow increases, opacity goes to full, color sharpens to the filament color grammar (§91)
- Matching branches develop a bright spine — a visible thread connecting all results on that branch
- Match count renders as a small badge at branch junction points

**Fading:**
- Non-matching filaments drop to 10-20% opacity — still visible as structure (the tree shape is preserved) but content is ghosted
- Non-matching branches become thin ghost outlines — you can see they exist but they're not the focus
- The overall effect: the tree remains navigable, but your results are the loudest visual element

**Cross-tree results:**
- If the search scope is REGION or GLOBAL, matching filaments on other trees render as glowing points at their geographic locations
- Glowing trace lines connect your current position to those results — flight paths you can follow
- Clicking a trace line flies you to that tree's result, applying the same search lens on arrival

**Dismissal:**
- Dismissing the search restores full rendering instantly. No data was modified. The lens is purely visual.
- Search history is a leaf packet on the user's tree — it falls/composts unless the user saves it as a named lens (promoting it to a filament)

### 102.5 Search as Training Data — Native Intelligence Path

Every search interaction generates structured behavioral data:

| Signal | Data Type | What It Teaches |
|--------|-----------|----------------|
| **Query submitted** | Leaf packet | What people search for, in what domain, at what time |
| **Filters applied** | Leaf packet | Which dimensions matter most to users in each domain |
| **Results clicked** | Leaf packet | Which results are actually useful (engagement = relevance signal) |
| **Navigation after search** | Sap checkpoint | Where users go after finding results — what action follows discovery |
| **Query refinement** | Leaf packet | How users correct or narrow initial searches — what the SCV got wrong |
| **Filter set votes** | Filament | Community consensus on what matters |

This is **massive structured training data** — not messy web clickstream data, but structured queries against structured results with structured outcomes. The training signal is already in Relay's native format.

**The progression toward native search intelligence:**

| Phase | Search Intelligence | Training Source |
|-------|-------------------|----------------|
| **Launch** | T0 structured queries + T2 frontier API for natural language | No training needed — structured queries work without AI |
| **6 months** | T1 local model starts learning common query patterns per domain | Aggregated search leaf/sap data from early users |
| **Year 1** | T1 predicts what you're searching before you finish typing. Suggests filters you haven't applied. Learns your personal search habits. | Millions of search interactions across thousands of trees |
| **Year 2+** | T1 handles most queries that previously needed T2. Frontier API calls drop. Cost decreases. Intelligence stays on-device. | The tree graph itself — every filament, template, engagement pattern, search interaction |

The tree structure is a pre-organized knowledge graph. Features don't need to be extracted from raw text — they're already structured by the physics. Training a search model on Relay data is orders of magnitude more efficient than training on unstructured web data.

**This is the path to intelligence sovereignty (§92.5).** Not by building a general-purpose LLM — by training a specialized model on the richest structured dataset ever assembled: the Relay tree graph, annotated by billions of human search interactions.

### 102.6 Invariants

1. **Search is a lens** (§81.5). It never modifies data. Dismissing restores full rendering. Search is read-only by constitutional rule.
2. **Search is an SCV function.** No separate search engine. The SCV processes queries using the same intelligence tiers it uses for everything else.
3. **Filter governance follows meta-vote** (§72). Filter sets are community-governed. Universal filters are Category A. Template filters are Category B. Personal presets are ungoverned.
4. **Search telemetry is leaf/sap class.** Query data is ephemeral by default. Users opt into saving search history. The system never retains individual search data beyond TTL without explicit consent.
5. **Training data is aggregated and anonymized.** Individual search patterns are private. T1 model training uses aggregated patterns only — never individual user queries. This is the same privacy boundary as all sap data (§82.3).
6. **Complex searches are cost-transparent.** T1/T2 search queries produce AIInvocationFilaments (§92.3) — users see the cost of their search intelligence the same way they see the cost of any SCV operation.

**Contract #270 — Search as SCV Function. Search in Relay is processed by the SCV using the standard intelligence tier routing (T0–T3). T0 handles structured queries deterministically. T1/T2 handle natural language and cross-tree discovery. There is no separate search engine. Search queries are sets of constraints across the six universal domains plus template-specific fields. Natural language queries are translated to structured filters by the SCV with full transparency. This architecture is frozen.**

**Contract #271 — Filter Governance via Meta-Vote. Default search filter sets for each template are governed by the two-stage meta-vote model (§72): Stage 1 votes on which filter proposals deserve consideration, Stage 2 votes on the winning configuration and priority ordering via weighted median. Universal filters (confidence, time, lifecycle) are Category A. Template-specific filters are Category B. Personal filter presets are ungoverned. Silence-stability (§81.3) applies to filter configurations. The filter governance model is frozen.**

**Contract #272 — Search Lens Rendering. Search results render as a read-only lens overlay: matching filaments intensify (full opacity, enhanced glow), non-matching filaments fade (10-20% opacity), matching branches develop bright spines, cross-tree results render as glowing trace lines navigable by click. Dismissing the search restores full rendering instantly. No data is modified. The search lens model is frozen.**

**Contract #273 — Search Telemetry & Native Intelligence Training. Search interactions generate leaf/sap-class telemetry (queries, filter selections, result clicks, navigation paths, query refinements). Individual search data is private and ephemeral. Aggregated anonymized patterns train T1 local models for improved search prediction over time. T1/T2 search costs produce AIInvocationFilaments for transparency. The training pathway from structured search data to native search intelligence is recognized as the primary path to intelligence sovereignty (§92.5). The telemetry and training model is frozen.**

---

## 103. The SphereCore — Semantic Bedrock & Universal Language Structure — Frozen Contracts #274–277

> *"In the beginning was the Word."* — John 1:1
>
> *"The limits of my language mean the limits of my world."* — Ludwig Wittgenstein

The Substrate (§100) contains knowledge — facts, references, best practices from the 2D internet. But what organizes the knowledge? What makes the category "health" mean the same thing in every language? What makes the word "water" in English point to the same reality as "ماء" in Arabic, "水" in Mandarin, "agua" in Spanish, and "maji" in Swahili?

Below the Substrate, at the geometric center of the Earth, is the deepest layer in Relay: the **SphereCore**. A small, dense sphere of points, each point representing a fundamental concept — a meaning without language. Not the word "water" — the *concept* of water. Not the word "justice" — the *concept* of justice. These are the irreducible semantic anchors that give everything above them structure.

### 103.1 The Five-Layer Depth Model

The full depth model from surface to center:

| Layer | Name | What It Contains | Visual | Ownership |
|-------|------|-----------------|--------|-----------|
| **Canopy** | Living trees | Active branches, filaments, engagement | Organic — bark, leaves, sap | Per-entity |
| **Roots** | Per-tree archive | Historical data, heartwood (§1.3) | Organic — root structures, soil | Per-tree |
| **Substrate** | Knowledge bedrock (§100) | Reference filaments from 2D internet | Mineral — crystal veins, geological formations | Commons |
| **SphereCore** | Semantic bedrock | Universal concepts, language roots, category anchors | Geometric — glowing point sphere | Universal |
| **Planetary Core** | Cross-body links | Shared universal concepts between celestial instances | Geometric — pulse connections to other globes | Interplanetary |

Each layer transition has a distinct visual shift:
- Organic → Mineral (roots to Substrate): soil gives way to crystal
- Mineral → Geometric (Substrate to SphereCore): crystal formations thin out, space opens, a dense glowing sphere appears at the center
- The SphereCore is the densest, most information-rich object in the system — and the smallest

### 103.2 Semantic Anchors

Each point on the SphereCore surface is a **semantic anchor** — a concept that exists independent of any language:

```
SemanticAnchor {
  anchorId:         "SA-<concept-hash>"
  conceptCluster:   "SUBSTANCE" | "ACTION" | "QUALITY" | "RELATION" | "STRUCTURE" |
                    "QUANTITY" | "TIME_CONCEPT" | "SPACE_CONCEPT" | "SOCIAL" | "ABSTRACT"
  position:         {theta, phi} on SphereCore surface
  neighbors:        [anchorId, ...] — semantically adjacent concepts
  activationCount:  number of living filaments tracing to this anchor across all trees
  radialConnections: [
    { languageCode: "en", word: "water", confidence: 0.99, regionRef: ... },
    { languageCode: "ar", word: "ماء", confidence: 0.99, regionRef: ... },
    { languageCode: "zh", word: "水", confidence: 0.99, regionRef: ... },
    { languageCode: "es", word: "agua", confidence: 0.99, regionRef: ... },
    { languageCode: "sw", word: "maji", confidence: 0.98, regionRef: ... },
    ...
  ]
  isUniversal:      true | false (universal = exists in all SphereCores across bodies)
}
```

**Anchor proximity:** Points that are semantically related cluster near each other on the SphereCore surface. Water is near food, food is near agriculture, agriculture is near land, land is near property, property is near law. The SphereCore's surface topology IS the concept map of human understanding. Navigation along the surface is navigation through meaning.

**Game-layer vocabulary:** SphereCore anchors are not limited to real-world concepts. Game-layer terminology occupies its own cluster on the SphereCore surface:

- **Element anchors:** FIRE, WATER, ICE, WIND, EARTH, LIGHT, SMOKE — each a semantic anchor with radial connections to every language (火, نار, fuego, etc.). These anchors serve double duty: they are real-world substance concepts AND game-layer element types. The same anchor, different context.
- **Combat concept anchors:** ATTACK, DEFEND, SUMMON, CHARGE, DODGE, BLOCK, CAST — universal combat concepts that the gesture/spell system references. Spell names in different locales trace to these anchors.
- **Creature type anchors:** DRAGON, ELEMENTAL, SPIRIT, CONSTRUCT, BEAST — creature categories for summon cards (§43.12). Each has language-specific names across all locales.
- **Crafting concept anchors:** TEXTURE, PARTICLE, GLOW, TRAIL, PULSE, RHYTHM — visual and audio effect concepts that the Crafting IDE (§43.11) uses as semantic labels.

Game-layer anchors cluster in a distinct region of the SphereCore surface, adjacent to but separate from real-world concept clusters. This means game-layer search (§102), UI translation (§62.8), and spell/creature naming all flow through the same SphereCore translation pipeline — a Japanese user sees Japanese spell names, a Hebrew user sees Hebrew creature types, all tracing to the same language-independent anchors.

**Anchor density:** Fundamental concepts (water, time, number, family) are large, bright points. Highly specialized concepts (quantum chromodynamics, arbitrage pricing theory) are smaller, dimmer points with fewer radial connections. The SphereCore's visual density tells you how fundamental a concept is to human civilization.

### 103.3 Radial Connections — Language as Geography

Each language's connection to a semantic anchor is a **radial thread** extending from the SphereCore surface outward through the Substrate and root zones to the surface where that language is spoken:

```
SphereCore (center) → radial thread → Substrate layer → root zone → surface trees
```

The radial threads are the **language trees** — not separate tree structures but pathways from meaning to expression. Every word in every language is a path from a region on the Earth's surface down to a semantic anchor at the core.

**How this handles regional differences:**

| Phenomenon | SphereCore Representation |
|-----------|--------------------------|
| **Direct translation** ("water" = "agua" = "水") | Multiple radial threads from different regions converge on the same anchor. High confidence on all connections. |
| **Regional meaning difference** ("football" US vs UK) | The word "football" has two radial threads from different regions pointing to TWO DIFFERENT anchors — one near "American football" cluster, one near "association football" cluster. The geometry makes the difference visible. |
| **Untranslatable concept** (Portuguese "saudade", Danish "hygge") | One radial thread from one region to a unique anchor that has no threads from other regions. The anchor exists — the concept is real — but only one language has a direct word for it. Other languages can navigate to the concept via semantic neighbors. |
| **New word coined** | A new radial thread is created from a region to an existing anchor (new slang for an old concept) or to a new anchor (genuinely new concept). New anchors start dim and grow as more languages/regions create connections. |
| **Obsolete word** | The radial thread dims as usage decreases. The anchor remains — concepts don't die — but the linguistic pathway sinks inward, becoming archaeological. |

### 103.4 The Category Foundation

The first categories that give Relay structure — the template types, the civilization pillars (§76), the domain labels — are SphereCore anchors. They are not arbitrary labels chosen by the founder. They are semantic anchors at the deepest layer, and everything above them inherits meaning from these core points:

| Category Level | Source | Example |
|---------------|--------|---------|
| **Civilization pillars** (§76) | Primary SphereCore anchors in the SOCIAL and STRUCTURE clusters | HEALTH, EDUCATION, LAW, COMMERCE, AGRICULTURE |
| **Template types** (§21) | Secondary anchors derived from pillar combinations | INVOICE (COMMERCE + QUANTITY + TIME), MEDICAL_RECORD (HEALTH + TIME + SUBSTANCE) |
| **Branch types** | Tertiary anchors specialized by domain | ACCOUNTS_PAYABLE (COMMERCE + QUANTITY + RELATION + TIME) |
| **Filament object types** | Terminal anchors — the most specific concepts | PURCHASE_ORDER, PRESCRIPTION, CROP_YIELD_REPORT |

When a new template is proposed, it must trace its category to existing SphereCore anchors. If it can't — if the concept is genuinely new — a new anchor is created. Anchor creation is a governance event, voted by the community that uses the relevant domain.

### 103.5 Search and the SphereCore

Search (§102) uses the SphereCore for semantic resolution:

When a user searches "water quality in East Africa," the SCV resolves the query by:
1. **"water"** → traces to SphereCore anchor for WATER (substance)
2. **"quality"** → traces to SphereCore anchor for QUALITY (attribute), combined with WATER → narrows to WATER_QUALITY
3. **"East Africa"** → geographic scope filter (not a SphereCore concept — it's a surface region)
4. The structured query becomes: `scope: REGION(East Africa), filters: [objectType IN concepts linked to WATER_QUALITY anchor]`

This is how search works in any language. A user searching "جودة المياه في شرق أفريقيا" (same query in Arabic) follows the Arabic radial threads to the same SphereCore anchors and produces the same structured query. The language doesn't matter — the meaning does.

### 103.6 Planetary Cores — Cross-Body Semantics

Each celestial body with a Relay instance has its own SphereCore:

**Earth's SphereCore:** Contains all human concepts — universal (physics, math, logic) plus Earth-specific (terrestrial biology, human culture, geography).

**Lunar SphereCore** (when Tier 5 unlocks, §94.7): Inherits universal concepts from Earth. Adds Moon-specific concepts: lunar regolith types, low-gravity engineering, radiation shielding categories, communication delay protocols. The Lunar core starts small — mostly mirrored universals — and grows as lunar civilization develops its own vocabulary.

**Mars SphereCore** (when Mars Relay launches): Same inheritance pattern. Mars-specific concepts: terraforming terminology, atmospheric chemistry categories, inter-body logistics. Connected to Earth and Moon via cross-core links.

**Cross-core links:** Universal concepts (physics, math, logic, basic substances) exist as synchronized anchors in all SphereCores. When a concept is added to one core and classified as universal, it propagates to all others. Non-universal concepts (cultural, geographic, biome-specific) stay local.

```
Earth SphereCore ←→ universal anchors ←→ Lunar SphereCore
                 ←→ universal anchors ←→ Mars SphereCore
```

The cross-core connection renders as a pulse — a visible energy transfer between planetary centers when universal concepts are referenced. From deep underground on Earth, looking toward the SphereCore, you can see faint pulse lines extending toward the Moon and Mars — evidence that meaning extends beyond this planet.

### 103.7 Population and Governance

**Initial population:** The founder, assisted by the SCV curation pipeline (similar to Substrate population, §100.3), seeds the SphereCore with fundamental concepts drawn from established linguistics, ontology research, and universal human categories. The initial anchor set covers:
- Physical substances (~500 anchors: water, iron, carbon, oxygen, soil, ...)
- Actions (~1,000 anchors: move, create, destroy, trade, grow, teach, heal, ...)
- Qualities (~500 anchors: hot, cold, large, small, fast, slow, healthy, sick, ...)
- Relations (~300 anchors: parent, child, owner, partner, neighbor, enemy, ...)
- Structures (~200 anchors: house, road, bridge, market, hospital, school, ...)
- Quantities (~100 anchors: numbers, measurements, ratios, ...)
- Time concepts (~100 anchors: past, future, season, cycle, deadline, ...)
- Space concepts (~200 anchors: near, far, above, below, inside, outside, ...)
- Social concepts (~500 anchors: family, law, trade, governance, education, ...)
- Abstract concepts (~500 anchors: truth, justice, beauty, freedom, knowledge, ...)

Total genesis anchors: ~4,000. This is the seed. It grows as humanity's vocabulary grows.

**Language connections** are seeded from established multilingual dictionaries and ontologies (WordNet, Wiktionary, UNESCO thesauri). Initial connections cover the ~20 most-spoken languages. Additional languages are added by their speaking communities — a governance proposal to add radial connections for a new language follows the standard meta-vote process (§72).

**New anchor creation** is a governance event:
- Any user can propose a new semantic anchor by demonstrating that an existing concept cannot be adequately represented by existing anchors or their combinations
- The relevant domain community votes on whether the anchor is genuinely new or can be decomposed into existing anchors
- Accepted anchors are committed as structural filaments on Tree Zero's semantic branch
- The bar is high — most "new concepts" are combinations of existing anchors. Genuinely new anchors are rare, representing actual expansion of human understanding.

**Radial connection disputes** (two regions claiming different meanings for the same word) are resolved by allowing both connections. The word has two threads, to two different anchors. The geometry makes the ambiguity visible rather than hiding it.

### 103.8 Invariants

1. **The SphereCore is universal.** Every Relay instance (Earth, Moon, Mars, future bodies) has a SphereCore. Universal concepts are synchronized across all cores.
2. **Semantic anchors are language-independent.** An anchor represents a concept, not a word. Words are regional connections to anchors.
3. **Multiple connections are normal.** A word can connect to multiple anchors (polysemy). An anchor can have connections from all languages (translation). The geometry handles both without conflict.
4. **Concepts don't die.** Anchors are never deleted. Obsolete concepts dim (reduced activation) but remain. The SphereCore is an accumulating record of human meaning.
5. **Categories trace to anchors.** Every template type, every civilization pillar, every domain label traces its meaning to SphereCore anchors. If it can't trace, it has no meaning in the system.
6. **New anchors require governance.** Anchor creation is a community-voted governance event. The bar is high. Most new concepts are compositions of existing anchors.
7. **Translation is navigation.** Moving from one language's radial thread to the core anchor and outward along another language's thread gives concept-level translation. Translation confidence reflects connection confidence.
8. **The SphereCore is the smallest and deepest object.** It renders at the geometric center of the globe. Its information density is the highest in the system. It is the foundation that gives everything above it meaning.
9. **Glyphs are animated, not illustrated.** Anchor visuals use motion to convey meaning without cultural dependence. Animation over illustration. Maximum two visual elements per elemental glyph.

### 103.9 Anchor Visual Language — Frozen Contract #289

Semantic anchors must be visible without words. The visual language builds in four layers from physical to abstract, using animation and spatial composition instead of illustration or cultural iconography.

**Layer 1 — Elemental Glyphs (Physical Concepts)**

The ~500 most fundamental physical concepts have unique minimal animations — tiny animated essences, not icons:

| Concept | Visual | Why It's Universal |
|---------|--------|-------------------|
| **Water** | A small fluid droplet that shimmers — surface tension visible | Every human has seen water behave this way |
| **Fire** | A flicker — a dancing point of warm light | Fire looks the same everywhere |
| **Stone/Earth** | A dense, still grain with visible weight | Heaviness reads in any culture |
| **Wind/Air** | A particle trail that curves and disperses | Movement without a body |
| **Light** | A ray — a line that brightens what it touches | Light is light |
| **Plant** | A single upward curve — growth from a point | The simplest abstraction of growing |
| **Animal** | A dot that moves with intention — starts, stops, turns | Self-directed motion distinguishes animal from plant |
| **Body/Person** | Two connected dots — head and center of mass | Minimal human form. Not gendered, not cultural. |
| **Sound** | Concentric ripples expanding from a point | What a splash and a shout look like |
| **Heat** | A vibrating point — faster vibration = more heat | Temperature IS molecular vibration |
| **Cold** | A still point with crystalline edges | Stillness and geometry |

**Complexity rule:** Maximum two visual elements per elemental glyph. Water is ONE droplet. Fire is ONE flicker. Person is TWO dots. If a glyph needs more than two elements, it is too complex for Layer 1.

**Layer 2 — Composite Glyphs (Complex Concepts)**

More complex concepts are visually composed from elemental glyphs — spatial arrangements where the interaction tells the story:

| Concept | Composition | Visual |
|---------|------------|--------|
| **Agriculture** | Earth + Water + Plant | A grain with a droplet feeding an upward curve |
| **Medicine** | Body + Substance + Action(repair) | Body-dots with a particle entering and the body stabilizing |
| **Trade** | Person + Person + Object(exchange) | Two body-dots with a particle passing between them |
| **Building** | Stone + Stone + Structure(stack) | Grains arranged in a stable weight-bearing configuration |
| **Music** | Sound + Pattern + Time | Ripples with rhythmic spacing, pulsing in sequence |
| **Food** | Plant/Animal + Body(absorb) | Growth curve or motion dot being absorbed into body-dots |

**Complexity rule:** Composites never exceed three elemental glyphs. Agriculture = earth + water + plant (three). If a concept needs four or more elements, it is not fundamental enough for the SphereCore — it belongs in the Substrate as a reference or in templates as a category.

**Layer 3 — Relational Patterns (Abstract Concepts)**

Abstract concepts render as dynamic patterns between neighboring anchors:

| Concept | Pattern |
|---------|---------|
| **Balance/Justice** | Two connected anchors in equilibrium — equidistant from a fulcrum, gently oscillating but always returning to center |
| **Truth** | Maximum stillness and brightness — no oscillation, no fog, full confidence. The brightest, most stable point. |
| **Freedom** | An unbound orbital — a particle that moves freely, unpredictably, within a region |
| **Knowledge** | High radial connection density — threads reaching in many directions, touching everything |
| **Time** | A spiral — motion that progresses without repeating. The only glyph that moves forward. Always forward. |
| **Death** | Inward collapse — a point sinking toward the SphereCore center. Gravity winning. Dimming. Not gone — sunk. |
| **Love** | Two body-glyphs with synchronized oscillation — not touching, moving in resonance |

**Layer 4 — Positional Identity (The Deepest Abstractions)**

Some concepts are so abstract that even relational patterns cannot capture them — existence, beauty, consciousness, infinity. These anchors have no individual visual signature. Their meaning comes entirely from their **neighborhood on the SphereCore surface**:

- "Existence" is surrounded by: time, matter, consciousness, space, causality. Its meaning IS its neighborhood.
- "Beauty" sits between: pattern, perception, emotion, harmony. Navigate to it and the surrounding anchors define it.
- The anchor itself is just a glowing point. Its identity is its context. The shape tells you the meaning.

This is the purest expression of Relay's philosophy applied to the deepest layer: the position IS the definition.

### 103.10 SphereCore LOD Rendering

The SphereCore unfolds with distance:

| Distance | What You See |
|----------|-------------|
| **Far** | A dense glowing sphere — the SphereCore looks like a small star at the Earth's center |
| **Approaching** | Individual points become visible — thousands of tiny lights on the sphere surface |
| **Close** | Points resolve into glyphs — water shimmers, fire dances, body-dots move |
| **Very close** | Radial threads become visible — language connections extending outward, color-coded by region |
| **Surface** | Full detail — glyph animations, neighboring anchors, composite relationships, relational patterns |

The SphereCore is beautiful at every distance but meaningful only up close. Like everything in Relay — LOD governs what you see. Zoom in and the meaning reveals itself.

**Contract #289 — Anchor Visual Language. SphereCore semantic anchors are rendered using a four-layer visual language: Layer 1 elemental glyphs (minimal animations, max two elements, ~500 physical concepts), Layer 2 composite glyphs (spatial arrangements of max three elemental glyphs), Layer 3 relational patterns (dynamic equilibria between neighboring anchors for abstract concepts), Layer 4 positional identity (anchors defined purely by neighborhood context). Animation over illustration. No cultural iconography. No text labels. LOD rendering from distant glow to surface-level glyph detail. The visual language is frozen.**

**Contract #274 — The SphereCore. At the geometric center of every Relay globe instance lies a SphereCore — a dense sphere of semantic anchors representing fundamental concepts independent of any language. Each anchor is a meaning-without-words. The SphereCore is the deepest layer in Relay's five-layer depth model (Canopy → Roots → Substrate → SphereCore → Planetary Core). It gives categories, templates, and domain labels their meaning. The SphereCore definition is frozen.**

**Contract #275 — Semantic Anchors & Radial Connections. Semantic anchors are positioned on the SphereCore surface with proximity reflecting semantic relatedness. Each anchor has radial connections — language-specific threads extending outward to the regions where those words are spoken. Multiple languages connect to the same anchor (translation). One word can connect to multiple anchors (polysemy). Regional meaning differences produce separate threads to separate anchors. Connections are confidence-scored. The anchor and connection model is frozen.**

**Contract #276 — SphereCore Governance. Initial SphereCore anchors (~4,000) are seeded by the founder from established linguistic and ontological sources. New anchor creation requires community governance — proposal plus domain vote. Language connections are seeded from multilingual dictionaries and extended by speaking communities via meta-vote (§72). Concepts are never deleted. Anchor creation bar is high — most concepts decompose into existing anchors. The governance model is frozen.**

**Contract #277 — Planetary Core & Cross-Body Semantics. Each celestial body with a Relay instance has its own SphereCore. Universal concepts (physics, math, logic, basic substances) are synchronized across all SphereCores via cross-core links. Non-universal concepts (cultural, geographic, biome-specific) remain local to their body's core. New bodies inherit universal anchors from the parent core and add their own. Cross-core connections render as visible pulse lines between planetary centers. The interplanetary semantic model is frozen.**

---

---

## 104. Conversational Discovery — Understanding as Treasure Trigger — Frozen Contracts #278–280

> *"The answer you seek is never given. It is recognized."* — Eitan Asulin

Treasure chests (§96) can be discovered geographically — walk to the coordinates, open the chest. But some of the most significant discoveries in Relay are not found by walking. They are found by thinking. When a user, in natural conversation with their SCV, demonstrates genuine understanding of a concept — connecting ideas, reasoning from their own data to broader principles, articulating insights in their own words — the system recognizes it. A chest reveals. Not because the user was searching for treasure, but because their understanding qualified them.

### 104.1 The Mechanic

A user is talking to their SCV — working, not treasure hunting. Asking questions about their data. Reasoning about branch shapes. Wondering why confidence differs between their tree and their neighbor's. In the course of natural multi-turn conversation, they articulate a conceptual alignment: they connect ideas that the chest's trigger requires.

The SCV evaluates the conversation against the chest's discovery trigger. If the alignment is genuine — coherent reasoning, supported by tree evidence, building progressively across multiple turns — the chest reveals.

**What the user experiences:** Something in their tree glows that wasn't glowing before. A sealed branch cracks open. A new path appears in their root zone. The SCV says: "You found something." The content inside rewards the insight — often a fragment of the founder's original moment of that same realization, confirming what the user independently figured out.

### 104.2 The Discovery Trigger

Each chest can have a conversational discovery trigger alongside (or instead of) a geographic trigger:

```
DiscoveryTrigger {
  triggerType:        "GEOGRAPHIC" | "CONVERSATIONAL" | "BOTH"

  geographic: {
    coordinates:      {lat, lon, alt} | null
    gpsRequired:      true | false
  }

  conversational: {
    requiredAnchors:      [anchorId, ...]   // SphereCore concepts the user must connect
    minimumConnections:   number             // anchor-to-anchor links they must articulate
    coherenceThreshold:   0.0-1.0           // T1/T2 evaluated reasoning quality
    noveltyRequirement:   true | false      // must phrase in own words, not parrot
  }

  treeRequirements: {
    minFilamentsInDomain:   number          // committed filaments in the relevant domain
    minConfidenceAverage:   0.0-1.0         // average confidence on those filaments
    minConceptualLOD:       "C0"-"C4"       // minimum Conceptual LOD level
    prerequisiteChests:     [chestId, ...]  // chests already found
    minTreeAge:             number          // minimum timeboxes since tree creation
  }

  antiGaming: {
    requireProgressiveConversation: true    // single message cannot trigger
    minConversationTurns:           5       // minimum turns of reasoning
    recentEngagementRequired:       true    // must have committed in last N timeboxes
    keywordStuffingDetection:       true    // SCV flags vocabulary dumps
  }
}
```

### 104.3 Five-Signal Evaluation

The SCV evaluates conversational triggers across five signals, all of which must pass:

| Signal | What It Measures | Gaming Defense |
|--------|-----------------|----------------|
| **Semantic coherence** | Does the conversation show logical progression? Did the user build from premise to conclusion? | T1/T2 model distinguishes reasoning chains from keyword lists. |
| **Tree evidence** | Does the user's tree show engagement in the relevant domain? Committed filaments? Confident branches? | Empty trees cannot trigger conversational discovery regardless of what the user says. |
| **Conceptual LOD alignment** | Is the user's demonstrated understanding consistent with their tree maturity? | C1 users claiming C4 insights are flagged unless the tree supports the leap. |
| **Conversational trajectory** | Did the user arrive at the insight over multiple turns? Did they wrestle with the idea? Change their mind? Ask intermediate questions? | Single-message trigger attempts fail. Copy-pasted trigger phrases fail. Genuine reasoning has texture. |
| **Prerequisite chain** | Has the user already discovered the prerequisite chests or achieved the required milestones? | Deep discoveries require a foundation of earlier ones. |

### 104.4 Chest Type Compatibility

| Chest Type | Geographic Trigger | Conversational Trigger | Typical Use |
|-----------|-------------------|----------------------|-------------|
| **Type 0 (Open)** | Common | Yes — introductory insights | Early Awakening Curve stages |
| **Type 1 (Personal)** | Rare | Primary method — domain expertise in conversation | Domain-specific "aha" moments |
| **Type 2 (Regenerating)** | Common | Yes — different reasoning paths yield different fragments | Community knowledge building |
| **Type 3 (One-Time)** | Some physically placed | Yes — deepest insights unlock rarest chests | Founder archive fragments matching the user's own realization |

Type 3 chests with conversational triggers are the most powerful. These are moments where a user's independent reasoning reaches the same conclusion the founder reached during design. The chest contains the founder's original moment of that realization — placed not at GPS coordinates but at a conceptual coordinate in understanding space.

### 104.5 Invariants

1. **Understanding cannot be faked.** The five-signal evaluation requires tree evidence, progressive conversation, and semantic coherence. Keyword stuffing, parroting, and single-message attempts are detected and rejected.
2. **Triggers are secret.** The specific SphereCore anchors, connection counts, and coherence thresholds for each chest are sealed. Users cannot reverse-engineer triggers from publicly shared discoveries because each evaluation includes the user's personal tree state.
3. **The SCV is the evaluator.** Conversational discovery uses the same intelligence tiers as all SCV operations (§92). T0 handles prerequisite checks. T1/T2 evaluate semantic coherence and novelty. Evaluation cost produces AIInvocationFilaments (§92.3).
4. **Discovery is private until shared.** The moment of discovery is between the user and their SCV. Whether to share is the user's choice.

**Contract #278 — Conversational Discovery Mechanic. Treasure chests may include conversational discovery triggers evaluated by the SCV during natural user interaction. Triggers specify required SphereCore concept connections (§103), coherence thresholds, tree prerequisites, and anti-gaming constraints. Evaluation uses five signals: semantic coherence, tree evidence, Conceptual LOD alignment, conversational trajectory, and prerequisite chain. All five must pass. The conversational discovery mechanic is frozen.**

**Contract #279 — Five-Signal Anti-Gaming. Conversational discovery requires: (1) T1/T2-evaluated semantic coherence distinguishing reasoning from keyword stuffing, (2) tree evidence of domain engagement, (3) Conceptual LOD consistency, (4) multi-turn progressive conversation (minimum 5 turns), (5) prerequisite chest/milestone completion. Single-message attempts, copy-pasted phrases, and empty-tree conversations cannot trigger discovery. The anti-gaming model is frozen.**

**Contract #280 — Trigger Secrecy. Conversational discovery triggers (required anchors, connection counts, coherence thresholds) are sealed parameters. Evaluation includes the user's personal tree state, making triggers non-transferable between users. Trigger specifications are never published. The secrecy model is frozen.**

---

## 105. Device Mesh & Physical Immersion — Frozen Contracts #281–284

> *"Any sufficiently advanced technology is indistinguishable from magic."* — Arthur C. Clarke

Relay renders on one screen. But one screen is a window. Multiple screens are a room. Enough screens are a world. The Device Mesh is the protocol by which an arbitrary collection of physical screens, speakers, and sensors form a single unified Relay rendering surface — not through special hardware, but through sap-level coordination of existing devices.

### 105.1 Mesh Formation

Any device running Relay can join a mesh. The process:

1. **Discovery.** Devices in the same proximity channel (§29) detect each other via Bluetooth LE, WiFi, or ultrasonic ping.
2. **Registration.** A brief calibration — each device's camera sees its neighbors' screens displaying a Relay handshake pattern. This establishes relative position, angle, and scale to sub-centimeter accuracy. Manual override available for arrangements cameras cannot resolve.
3. **Session creation.** A MeshSession structural filament links all participating device companion trees (§101):

```
MeshSession {
  sessionId:       "MESH-<initiator>-<uuid>"
  initiator:       deviceTreeRef
  participants:    [{ deviceRef, position: {x,y,z}, orientation: {pitch,yaw,roll},
                     screenSize: {w,h}, capabilities: ["DISPLAY","SPEAKER","CAMERA","INPUT"] }]
  topology:        "FLAT" | "CURVED" | "SPHERICAL" | "FREEFORM"
  syncClock:       networkTimeOffset per device
  masterViewport:  combined virtual viewport from all device positions
  contentSource:   branchRef | treeRef | projectionRef
  audioZones:      [{ speakerRefs, spatialMix, latencyOffsets }]
}
```

4. **Synchronization.** Frame sync via `FrameSyncPacket` — sap with sub-millisecond precision pulsing across the mesh every frame. All devices render the same world state at the same moment.

### 105.2 Distributed Rendering

The Relay renderer computes a **master viewport** — a single continuous view of the 3D world spanning all screens:

- Each device receives its **frustum slice** — the portion of the master viewport corresponding to its physical position and angle
- Each device renders its slice locally using its own GPU
- Seams between devices are computed from spatial registration and overlap-compensated
- The result: trees, branches, filaments, the globe appear to extend seamlessly across all screens

**Topology modes:**

| Mode | Physical Arrangement | Rendering Approach |
|------|---------------------|-------------------|
| **FLAT** | Screens side by side (extended desktop, phone grid, TV wall) | Planar viewport subdivision |
| **CURVED** | Screens in an arc (semicircle of tablets, curved TV wall) | Cylindrical projection with per-device frustum correction |
| **SPHERICAL** | Screens surrounding the viewer (immersion bubble) | Spherical projection — VR without the headset |
| **FREEFORM** | Arbitrary positions (speakers across a room, screens on different walls) | Per-device independent frustum with shared world state |

### 105.3 Cross-Device Interaction

When a user drags content toward the edge of one screen, the mesh knows which device is adjacent:

```
DragHandoff {
  contentRef:    filamentId | branchRef | projectionRef
  sourceDevice:  deviceTreeRef
  targetDevice:  deviceTreeRef
  exitPosition:  {x, y} on source screen edge
  entryPosition: {x, y} on target screen edge
  velocity:      pixels per second
}
```

The element exits one screen and enters the next — continuous motion across physical device boundaries. Works for filaments, branches, projections, game objects, UI elements. The mesh treats all screens as one surface.

### 105.4 Audio Mesh

Speakers in a mesh synchronize with sub-millisecond precision:

- Each speaker publishes its clock offset as sap
- The mesh coordinator computes per-speaker latency compensation
- Audio buffers are aligned so all speakers produce sound at the same physical moment
- Spatial audio adjusts per listener position — the mix changes as you move through the speaker array
- The listener's phone (if in the mesh) reports their position; the nearest speakers carry the primary channel

### 105.5 Sensor Integration

Devices contribute more than screens and speakers:

| Sensor | Contribution | Example |
|--------|-------------|---------|
| **Accelerometer/Gyroscope** | Device orientation, movement, tilt angle | Physics objects that roll between phones based on tilt |
| **GPS** | Outdoor positioning for large-scale meshes | Festival-scale device coordination |
| **Camera** | Head tracking, gesture detection, spatial registration | Viewport shifts when the user moves in a spherical mesh |
| **Microphone** | Audio response detection (with consent) | Crowd laughter, cheering, audience energy measurement |
| **Haptic motor** | Synchronized vibration across devices | A bass hit that you feel across every phone in the mesh |

### 105.6 The Immersion Spectrum

The device mesh enables a spectrum from casual to total immersion:

| Level | Devices | Experience |
|-------|---------|-----------|
| **Companion** | 1 phone + 1 TV | Phone is controller/detail view, TV is main display |
| **Extended** | 2-3 monitors | Traditional extended desktop but for 3D tree navigation |
| **Collaborative** | 5-20 phones on a table | Shared workspace, collaborative tree editing, group exploration |
| **Surround** | 10-50 screens around viewer | Panoramic immersion, the world wraps around you |
| **Arena** | 2-50 devices around duelists + spectator devices | Arena combat: duelists' spell effects and summon creatures render across the mesh, spectators see unified battlefield from their angle |
| **Venue** | Hundreds of devices + venue speakers + displays | Full event immersion — dance floor, concert, conference |

**Arena mesh (§42, §43.12):** When a duel or arena match occurs in a physical venue, the device mesh becomes the battlefield. Summoned creatures (§43.12) render across device boundaries — a dragon summon that moves from one duelist's side to the other visually crosses from one set of screens to another via `DragHandoff` (§105.3). Crafted spell effects (§43.11) render on every mesh participant's device simultaneously. The CrowdAggregate sap (§106) from spectator devices feeds back to both duelists as crowd confidence. The arena mesh is the integration point where device mesh (rendering), live performance (audience feedback), crafted graphics (visual language), and summon cards (AI creatures) all converge on a single physical event.

### 105.7 Invariants

1. **Any device can join.** No proprietary hardware required. Any screen that runs Relay participates.
2. **Mesh is temporary.** MeshSession filaments have a lifecycle. When the event ends, the mesh dissolves. Devices return to independent operation.
3. **Privacy is per-device.** Joining a mesh does not share your tree data. Only the agreed content source renders across the mesh. Your personal tree, messages, and private branches remain on your device.
4. **Rendering is local.** Each device renders its own slice. No device streams its screen to another. Content references are shared; pixels are not.
5. **Graceful degradation.** If a device disconnects, the mesh recomputes without it. Remaining devices fill the gap or leave a dark zone. No cascade failure.

**Contract #281 — Device Mesh Protocol. An arbitrary number of Relay-running devices can form a temporary mesh via proximity discovery, camera-based spatial registration, and sap-level frame synchronization. The mesh creates a MeshSession structural filament linking all participant device trees. Topology modes: FLAT, CURVED, SPHERICAL, FREEFORM. Any device can join. No proprietary hardware required. The mesh protocol is frozen.**

**Contract #282 — Distributed Viewport Rendering. The mesh computes a master viewport spanning all screens. Each device renders its frustum slice locally. Frame sync uses sub-millisecond sap packets. Cross-device content handoff enables continuous drag across physical device boundaries. Seam compensation is computed from spatial registration data. The distributed rendering model is frozen.**

**Contract #283 — Audio Mesh Synchronization. Speakers in a mesh synchronize with sub-millisecond precision via clock-offset sap and per-speaker latency compensation. Spatial audio adjusts per listener position. The mesh coordinator routes audio channels based on speaker positions and listener proximity. The audio mesh model is frozen.**

**Contract #284 — Mesh Privacy & Degradation. Joining a mesh does not share personal tree data — only the agreed content source renders across devices. Rendering is local per device (no screen streaming). Disconnection triggers graceful recomputation — no cascade failure. Mesh sessions are temporary with defined lifecycles. The privacy and degradation model is frozen.**

---

## 106. Live Performance Loop — Crowd Metrics as Creative Input — Frozen Contracts #285–287

> *"The audience is not the enemy of the art. They are the other half of it."* — Eitan Asulin

In a Relay-connected venue, the audience is not passive. Every device in the proximity channel publishes engagement sap — movement intensity, attention state, presence duration, explicit reactions. These signals aggregate into a living branch on the performer's event tree. The performer reads the branch. The branch's shape, heat, and color tell them how the crowd is responding — in real time, quantified, not guessed.

### 106.1 Audience Engagement Sap

Every audience member's device publishes signals — local-first, aggregated before transmission, never individually identifying:

| Signal | Source | Privacy |
|--------|--------|---------|
| **Movement intensity** | Accelerometer | On-device computation. Only aggregate intensity class transmitted. |
| **Attention state** | Screen orientation | Binary: engaged or not. No screen content shared. |
| **Presence duration** | Proximity channel entry/exit | Aggregate only: "85% still present." |
| **Explicit reaction** | Tap patterns, reaction buttons | Intentional user signal. |
| **Biometric response** | Smartwatch (double opt-in) | Never individual. Only aggregate: "crowd avg heart rate +15%." |
| **Audio response** | Microphone (venue consent) | On-device classification. Signal type + intensity only. Never raw audio. |

### 106.2 The Crowd Aggregate

Individual signals aggregate into a CrowdAggregate sap structure:

```
CrowdAggregate {
  eventRef:        branchRef
  crowdSize:       number
  energyLevel:     0.0-1.0
  attentionRate:   0.0-1.0
  retentionRate:   0.0-1.0
  sentimentVector: { positive, negative, neutral }
  peakDetected:    boolean
  valleyDetected:  boolean
  biometricPulse:  null | { avgHeartRateDelta }
  audioResponse:   null | { laughterIntensity, cheerIntensity, silenceDepth }
  explicitVotes:   { option: count, ... }
}
```

This renders as the **audience branch** on the performer's event tree. The performer sees crowd energy as branch thickness, sentiment as color temperature, attention as opacity, retention as branch length. Peaks glow. Valleys fog.

### 106.3 Domain Applications

**Music (DJ / Band / AI-Generated):**
- DJ reads crowd branch on mixer display — energy, retention, response to BPM changes
- Band's SCV suggests between songs: "Energy peaked during uptempo. Retention dropped during the ballad."
- AI-generated music: crowd aggregate sap feeds directly into the generation algorithm. Energy rising → BPM increases, percussion intensifies. Valley detected → introduce a break. The crowd IS the composer.

**Theatre — Live Branching Narrative:**
- Aggregate sentiment at scene boundaries determines which scripted branch plays next
- High positive → triumphant version. High tension → suspenseful version. Low energy → provocative version.
- Each audience experiences a unique performance. The event branch records which path and why.

**Stand-Up Comedy — Per-Joke Analytics:**
- Each joke is a filament with crowd response: laughter onset, duration, intensity, silence depth
- Over hundreds of shows, the comedian's tree reveals which material works where, optimal set order, growth over time
- SCV set advisor suggests order based on venue type, demographics, and historical response

**Sports — Crowd Energy as Game Data:**
- Aggregate crowd energy visible to coaches as a live branch
- Crowd reaction to referee calls is quantified data (informative, not binding)
- Broadcasters use attention spikes to guide camera choices and replay timing
- Venue operations: season-long engagement data optimizes scheduling, configuration, pricing

**Film Screenings:**
- Per-scene attention rate, biometric tension, laughter timing, departure rate
- Different cuts A/B tested with quantified audience response
- Scene-level engagement committed as filaments on the film's product tree (§77)

### 106.4 The Feedback Democracy

The crowd is always voting, whether or not there's a ballot:

| Vote Type | Signal | Binding? |
|-----------|--------|----------|
| **Presence vote** | Staying vs leaving | Strongest signal — voting with your feet |
| **Energy vote** | Movement, dancing, stillness | Physical engagement |
| **Attention vote** | Screen up vs pocket | Conscious focus |
| **Biometric vote** | Heart rate, skin response | Unconscious — the body doesn't lie |
| **Explicit vote** | Buttons, gestures, shouts | Intentional expression |

All are valid. None are individually identifying. All aggregate into the branch the performer reads. The performer who reads the branch well gives the crowd what it collectively wants — and the crowd's response creates the next signal. **The loop is the performance.**

### 106.5 Invariants

1. **Aggregate only.** Individual audience signals are never transmitted or stored. Only aggregate metrics flow to the performer. Privacy is non-negotiable.
2. **Biometric is double opt-in.** Smartwatch data requires explicit device-level consent AND event-level consent. Default is off.
3. **Metrics are advisory.** No metric forces a performer to change their performance. The data is available. The human decides.
4. **Events are committed.** The full event — tracks, jokes, scenes, crowd aggregates per timebox — is committed as filaments on the event branch. Permanent record of what happened and how the crowd responded.
5. **AI generation is bounded.** AI-generated content (music, visuals) using crowd metrics follows the same bounded-creativity rules as all Relay AI — it composes existing mechanics, never invents new physics.
6. **Arena combat is a performance domain.** Duels (§42) and arena matches (§68) with spectators are live performances. The CrowdAggregate model applies identically: spectator engagement generates sap, sap aggregates into audience metrics on the event branch, duelists read the branch and respond (charging attacks amplified by crowd confidence, §43.10.12). Crafted spell graphics (§43.11) are the visual spectacle that draws the crowd — artistic mastery IS performance mastery. A duelist with stunning crafted effects draws a larger audience than one with default graphics, generating more engagement sap, more attention income, and more crafting resource flow. The live performance loop and the crafting economy's attention cycle (§43.11.3b) are the same mechanism operating on the same sap layer.

**Contract #285 — Audience Engagement Sap. Audience devices in a Relay-connected venue publish engagement signals (movement, attention, presence, reaction, optional biometric, optional audio response) as sap — aggregated before transmission, never individually identifying. CrowdAggregate renders as a live audience branch on the performer's event tree. All signals are local-first computed. The engagement sap model is frozen.**

**Contract #286 — Performer Feedback Loop. CrowdAggregate metrics are available to performers in real time as branch physics (thickness = energy, color = sentiment, opacity = attention, length = retention). Metrics are advisory — no metric forces performance changes. AI-generated content can use aggregate metrics as input. Per-domain applications (music, theatre, comedy, sports, film) follow the same aggregate model with domain-specific filament schemas. The feedback loop is frozen.**

**Contract #287 — Performance Event Record. Live events are committed as filaments on the event branch: performer actions, crowd aggregates per timebox, set structure, audience branching decisions (theatre), per-joke response (comedy), per-scene engagement (film). The event record enables longitudinal analysis across performances. All crowd data in the record is aggregate only. The event record model is frozen.**

---

## 107. Relay Launch Event — Genesis Party Protocol — Frozen Contract #288

> *"This is where it starts. Not in a boardroom. On a dance floor."* — Eitan Asulin

The first public Relay event is not a conference talk, not a demo day, not a pitch meeting. It is a party. A Relay launch party where every attendee downloads the app, joins a device mesh, and experiences what the system can do — not by watching, but by participating. The party is the proof. The crowd is the first mesh. The music is the first crowd-generated content. The games are the first multi-device physics demonstrations. The event itself becomes the first committed social event on Tree Zero.

### 107.1 The Sequence

**Phase 1 — Arrival & Download (0:00–0:15)**

A single projector displays a QR code. Large. Unmissable. The URL leads to the Relay app download — lightweight, installs in under 60 seconds. While phones download:

- The projector plays the **Genesis Film** — a 90-second cinematic introduction (§88): "Every event is a filament. Every filament is on a tree. Every tree tells you the truth about what's inside it. This is Relay." The film ends with: "Your phone is ready. Open it."

- As each phone completes installation and opens Relay, it automatically joins the venue's proximity channel. A counter on the projector shows connected devices climbing: 12... 47... 103... 200+. The room watches itself connect.

### 107.2 The Demo (0:15–0:25)

Ten minutes maximum. The founder walks through three demonstrations on the projector, with everyone's phones as companion devices:

**Demo 1 — "The Tree Is Real" (3 min)**
The projector shows a live Relay globe. The founder creates a tree — the venue's tree — in real time. Adds a branch: "Tonight." Adds a filament: "This party." The crowd sees it appear on the globe on the projector and on their phones simultaneously. The founder drags a photo from their phone to the projector — it crosses device boundaries visually. The filament now has evidence. "That's all Relay is. Events on a tree. The shape tells you the truth."

**Demo 2 — "Your Phone Is Part of This" (3 min)**
The founder triggers the first mesh. All phones in the room join. The projector shows the mesh forming — device icons appearing in spatial positions, the room's layout reconstructing itself from phone positions. Then: the Relay globe renders across every phone. The person near the left wall sees the left side of the globe. The person near the right wall sees the right side. The person in the center sees straight ahead. The room IS the viewport. People start moving their phones and watching the perspective shift. Gasps.

**Demo 3 — "This Is Just the Start" (4 min)**
Quick montage on the projector: the tree structure applied to a company (accounting branches, HR, sales), a hospital (patient records, procedures), a farm (crops, weather, livestock), a city (infrastructure, transit, services). Same physics everywhere. Then: "The game layer is hidden in this system. Discover it." Cut to black.

### 107.3 The Party (0:25–end)

The demo ends. The lights change. The party begins. Every phone is now a mesh participant. The venue's speakers are audio mesh nodes. The projector continues as the primary display. Every person in the room is an audience member publishing engagement sap.

**Game 1 — The Dreidel (Physics Mesh Demo)**

A 3D dreidel appears on the projector — spinning. Then it drops onto the nearest phone's screen. The phone's accelerometer controls the dreidel's tilt. Tilt the phone left, the dreidel slides left. If it reaches the edge — it transfers to the adjacent phone. The dreidel is now shared physics object crossing device boundaries in real time.

Rules:
- The dreidel spins. Gravity pulls it toward whichever phone is tilted lowest.
- If it falls off a phone's edge, it appears on the nearest neighbor's screen.
- Each phone's gyroscope contributes to the physics — the dreidel responds to the aggregate tilt of all connected devices.
- Objective: keep the dreidel spinning as long as possible by collaboratively balancing across all phones. A timer runs on the projector. The crowd cooperates to beat the clock.

The dreidel's spin decay rate is tied to the CrowdAggregate energy level — if people are dancing/moving, the dreidel spins faster. Stillness slows it. The crowd discovers that their collective movement keeps the game alive.

**Game 2 — The Wave (Synchronized Display Demo)**

A visual wave of color ripples across every phone in the room — left to right, based on spatial position. Each phone lights up in sequence, creating a wave visible across the entire crowd of held-up phones. The wave speed responds to crowd energy — more movement, faster wave. The color responds to collective sentiment — positive sentiment warms the colors, negative cools them.

Then: the crowd controls the wave. A slider on each phone lets you vote on wave color. The wave becomes the crowd's collective color choice — weighted median of all votes. People see their vote influence the wave in real time. First taste of parametric governance (§11).

**Game 3 — The Collective Instrument (Music Generation Demo)**

The projector shows a set of large graphic sliders — attribute controls:

| Slider | What It Controls | Range |
|--------|-----------------|-------|
| **BPM** | Tempo | 80–160 |
| **Bass depth** | Low frequency intensity | 0–100% |
| **Melody complexity** | Number of simultaneous melodic lines | 1–5 |
| **Rhythm density** | Hits per bar | 4–32 |
| **Atmosphere** | Reverb/space/ambient texture | Dry → Cathedral |
| **Energy** | Overall intensity and layering | Chill → Maximal |

Every phone shows the same sliders. Every person votes on every slider by dragging. The displayed value is the **weighted median** of all votes — real-time parametric governance of music generation. The AI music engine (using crowd aggregate as additional input) produces a track that updates live as votes shift.

The room makes music together. 200 people, each with a vote on six parameters, producing a track that no individual composed but everyone shaped. The track is committed as a filament on the venue tree — "Genesis Party Track 1, composed by 247 participants, February [date], [venue]."

**Game 4 — The Constellation (Social Discovery Demo)**

Each phone displays a single glowing point — a star. The projector shows the room from above, with every star at its phone's position. Stars that are near each other cluster. The crowd sees itself as a constellation.

Then: each person's star color shifts based on a simple question displayed on their phone — "What domain matters most to you?" Options: Health, Education, Business, Environment, Art, Technology. Stars recolor. The constellation reveals the room's composition — clusters of shared interest become visible.

People with the same color near each other discover each other. People with rare colors stand out. No names, no profiles — just a visual map of shared interest rendered across 200+ phones. First taste of how Relay makes patterns visible without exposing individual identity.

### 107.4 The Commit

At the end of the night, the venue tree's event branch is committed:

- Attendance count (from proximity channel)
- Mesh formation data (device count, topology)
- Game results (dreidel survival time, wave parameters, music track, constellation distribution)
- Crowd aggregate timeline (energy curve across the night)
- The generated music track as a committed filament with 247 co-creators

Every attendee who opts in gets a genesis event filament on their personal tree — proof they were at the first Relay party. This is the social equivalent of the genesis contributor filament (§86, contract #236) — not a governance advantage, not a premium feature. A permanent record that says: "I was there when it started."

### 107.5 What the Party Proves

| Principle | How the Party Demonstrates It |
|-----------|------------------------------|
| **Device mesh works** | 200+ phones forming a unified rendering surface in minutes |
| **Cross-device physics** | The dreidel crossing phone boundaries via accelerometer data |
| **Crowd metrics are real** | Wave speed and dreidel spin responding to collective movement |
| **Parametric governance works** | Music sliders producing a track from weighted-median votes |
| **The tree is the data** | The entire event committed as filaments on the venue tree |
| **Relay is fun** | People had a good time while experiencing every core mechanic |

The party is not a marketing event. It is a proof script. Every game demonstrates a frozen contract. Every interaction validates a design principle. And the attendees don't know they're proving anything — they're just having fun.

**Contract #288 — Genesis Party Protocol. The first public Relay event follows a defined sequence: QR download + Genesis Film (15 min), three-demo walkthrough (10 min), party phase with four games demonstrating device mesh (Dreidel), synchronized display (Wave), crowd-governed music generation (Collective Instrument), and social pattern discovery (Constellation). The event is committed as filaments on Tree Zero's event branch. Attendees receive genesis event filaments (opt-in). The party is both celebration and proof script. The genesis party protocol is frozen.**

---

**Contract #314 — Cross-Module Integration Invariant. Every concept in Relay applies universally — no module is exempt from system-wide physics. Specifically: (1) The three-layer ontology (§82) classifies ALL data types including game-layer objects — crafting drafts are LEAF, summon combat state is SAP, finalized graphics and treasure markers are FILAMENT (wood), CrowdAggregate is SAP. (2) The energy budget (§83) applies to ALL branches — crafting branches grow through photosynthesis (crowd attention), arena branches run hot with adversarial engagement, legendary branches override wilt/confidence as immutable properties, and Tree Health Pool = Σ vitality across branches × combat scaling factor. (3) Governance safety primitives (cooling windows §19.5, soft divergence §19.4) apply to ALL governance contexts — council motions, parental governance transitions, summon registry additions, and jury proceedings. (4) Protected Participation Profiles (§63.7) propagate to council roles, Sybil defense, jury service, and UI rendering. (5) The immune detection trigger (§83.5) fires identically on child safety branches. (6) The Procedural Governance Template (§72.11) applies to sortition juries (§46) as well as councils. (7) Search (§102) covers game-layer scopes (SPELL_LIBRARY, SUMMON_REGISTRY, CRAFTING_CATALOG, ARENA_HISTORY). (8) SphereCore (§103) includes game-layer vocabulary anchors (elements, combat concepts, creature types, crafting concepts). (9) Live Performance (§106) treats arena combat as a performance domain with CrowdAggregate feedback. (10) Device Mesh (§105) supports arena combat rendering across device boundaries. (11) Treasure chests (§96) grant crafting tier eligibility and summon registry unlocks. (12) The Awakening Curve (§99) has a game-layer parallel track. (13) Crafting token economics close through a 70/30 infrastructure/burn split. (14) Summon AI routes through the four-tier SCV system (§92) with cost-as-filament transparency. No subsystem operates outside the universal physics. The cross-module integration invariant is frozen.**

---

### Acknowledgment

Relay is dedicated to the people who build, maintain, teach, repair, and create — and to those who came before us, whose work formed the foundation we stand on.

To every person who ever organized information on a spreadsheet and wished it could mean more. To every parent who looked at a government report and couldn't tell if it was real. To every child who will grow up in a world where data has shape, where truth has weight, and where the tree remembers.

To my brother, who showed me that state matters. To the AI systems that helped me think through 314 contracts and never once told me an idea was too big. To the martial artists, musicians, and shepherds who will use this system in ways I never imagined.

To the future: may you never lose your state.

— Eitan Asulin, Founder

---

*End of Relay Master Build Plan. The tree IS the data. Time sinks everything. Truth persists. Reality becomes the game.*
